@ROUT atlas_atmctr.h
#ifndef ATLAS_ATMCTR_H
   #define ATLAS_ATMCTR_H
   #include "atlas_tprim.h"
/* 
 * atmctr data structure has two variants.  The mutex version is of size
 * 2*SAFELS + sizeof(lock).  _new returns a SAFELS-aligned address, and the
 * data structure from this point is: [<cnt><off>][lock].
 * 
 * For systems where we have true atomic ctrs, the lock is ommitted, so size
 * 2*SAFELS.
 *
 * If <off> is nonzero it is the bytes to add to ac to get to the 
 * original malloc-returned ptr (used only in _free).
 */
   #if defined(ATL_GAS_x8632) || defined(ATL_GAS_x8664) || \
       defined(ATL_GAS_ARM64) || defined(ATL_GAS_WOW64)
      #define ATL_ATM_ASM 1  /* I've got assembly atomic ops */
   #else
      #define ATL_ATM_ASM 0  /* I do not have assembly atomic ops */
   #endif

void *ATL_atmctr_new(long cnt);
void  ATL_atmctr_free(void *ac);

/* All these functions return prior value */
long ATL_atmctr_set(void *ac, long val);
long ATL_atmctr_dec(void *ac);
long ATL_atmctr_add(void *ac, unsigned long val);

@skip long ATL_atmctr_get(void *ac); /* perform unsafe read */
#define ATL_atmctr_get(ac_) (*((volatile long*)(ac_)))
#endif
@ROUT ATL_atmctr_new
#include "atlas_atmctr.h"
void *ATL_atmctr_new(long cnt)
{
   void *vp, *lck;
   long *lp;
   #if ATL_ATM_ASM
      vp = malloc(ATL_SAFELS+ATL_SAFELS);
   #else
      vp = malloc(ATL_SAFELS+ATL_SAFELS+sizeof(ATL_lock_t));
   #endif
   ATL_assert(vp);
   lp = ATL_AlignSafeLS(vp);
   lp[0] = cnt;
   lp[1] = ((size_t)vp) - ((size_t)lp); /* will be negative or 0 */
   #if !ATL_ATM_ASM
      lck = ATL_IncBySafeLS(lp);
      ATL_lock_init(lck);
   #endif
   return(lp);
}
@ROUT ATL_atmctr_free
#include "atlas_atmctr.h"
void  ATL_atmctr_free(void *ac)
{
   long *lp=ac, off=lp[1];
   #if !ATL_ATM_ASM
      ATL_lock_destroy(ATL_IncBySafeLS(ac));
   #endif
   ac = ATL_AddBytesPtr(ac, lp[1]);
   free(ac);
}
@ROUT ATL_atmctr_set_mut
#include "atlas_atmctr.h"
#if !ATL_ATM_ASM
long ATL_atmctr_set(void *ac, long val)
{  /* RETURNS: old value of count */
   void *lck=ATL_IncBySafeLS(ac);
   long ret, *lp=ac;
   ATL_lock(lck);
   ret = *lp;
   *lp = val;
   ATL_unlock(lck);
   return(ret);
}
#endif
@ROUT ATL_atmctr_dec_mut
#include "atlas_atmctr.h"
#if !ATL_ATM_ASM
long ATL_atmctr_dec(void *ac)
{  /* RETURNS: old value of count */
   void *lck=ATL_IncBySafeLS(ac);
   long ret, *lp=ac;
   ATL_lock(lck);
   ret = *lp;
   if (ret > 0)
      *lp = ret-1;
   ATL_unlock(lck);
   return(ret);
}
#endif
@ROUT ATL_atmctr_add_mut
#include "atlas_atmctr.h"
#if !ATL_ATM_ASM
long ATL_atmctr_add(void *ac, unsigned long val)
{  /* RETURNS: old value of count */
   void *lck=ATL_IncBySafeLS(ac);
   long ret, *lp=ac;
   ATL_lock(lck);
   ret = *lp;
   *lp = ret + val;
   ATL_unlock(lck);
   return(ret);
}
#endif
@ROUT ATL_atmctr_dec_asm
   @define rt @dec@
@ROUT ATL_atmctr_add_asm
   @define rt @add@
@ROUT ATL_atmctr_set_asm
   @define rt @set@
@ROUT ATL_atmctr_dec_asm ATL_atmctr_add_asm ATL_atmctr_set_asm
#include "atlas_asm.h"
#include "atlas_asm.h"
#define ROUT ATL_asmdecor(ATL_atmctr_@(rt))
#ifdef ATL_GAS_x8664
@ROUT ATL_atmctr_dec_asm
   /* rax                     rdi  */
   /* int ATL_atmctr_dec(void *vp) */
@ROUT ATL_atmctr_add.S ATL_atmctr_set.S
   /* rax                     rdi                rsi  */
   /* int ATL_atmctr_@(rt)(void *vp, unsigned long val) */
@ROUT ATL_atmctr_dec_asm ATL_atmctr_add_asm ATL_atmctr_set.S
   .text
   ALIGN32
   .global ROUT
   ROUT:
      movq (%rdi), %rax       /* read cnt from memory */
      mov  %rax, %rcx         /* rcx = cnt */
@ROUT ATL_atmctr_dec_asm
      sub  $1, %rcx           /* rcx = cnt-1 */
      jl ZERO_RET             /* return 0 if count already below 1 */
@ROUT ATL_atmctr_add_asm
      add %rsi, %rcx          /* rcx = val+cnt */
@ROUT ATL_atmctr_set_asm
      mov %rsi, %rcx          /* rcx = val */
@ROUT ATL_atmctr_dec_asm ATL_atmctr_add_asm
      lock                    /* make cmpxchg atomic */
      cmpxchg %rcx, (%rdi)    /* st newcnt if mem still == oldcnt in rax */
      je DONE                 /* ZF set if cmpxchg wrote to mem */
   jmp ROUT                   /* ZF=0 means cmpxch failed, try again */
   ZERO_RET:
      xor %rax, %rax
   DONE:
   ret
#elif defined(ATL_GAS_WOW64)
@ROUT ATL_atmctr_dec_asm
   /* rax                      rcx  */
   /* int ATL_atmctr_@(rt)(void *vp) */
@ROUT ATL_atmctr_add_asm ATL_atmctr_set_asm
   /* rax                      rcx                rdx  */
   /* int ATL_atmctr_@(rt)(void *vp, unsigned long val) */
@ROUT ATL_atmctr_dec_asm ATL_atmctr_add_asm ATL_atmctr_set_asm
   .text
   ALIGN32
   .global ROUT
   ROUT:
      movq (%rcx), %rax       /* read cnt from memory */
@ROUT ATL_atmctr_dec_asm
      mov  %rax, %r8          /* r8 = cnt */
      subl $1, %r8            /* r8 = cnt-1 */
      jl ZERO_RET             /* return 0 if count already below 1 */
@ROUT ATL_atmctr_dec_asm ATL_atmctr_add_asm
      add %rdx, %r8           /* r8 = val+cnt */
@ROUT ATL_atmctr_dec_asm ATL_atmctr_add_asm
      lock                    /* make cmpxchg atomic */
      cmpxchg %r8, (%rcx)     /* st newcnt if mem still == oldcnt in rax */
      je DONE                 /* ZF set if cmpxchg wrote to mem */
   jmp ROUT                   /* ZF=0 means cmpxch failed, try again */
@ROUT ATL_atmctr_add_asm
   ZERO_RET:
      xor %rax, %rax
@ROUT ATL_atmctr_dec_asm ATL_atmctr_add_asm ATL_atmctr_set_asm
   DONE:
   ret
#elif defined(ATL_GAS_x8632)
@ROUT ATL_atmctr_dec_asm
   /* eax                    4(%esp)  */
   /* int ATL_DecAtomicCount(void *vp) */
   .text
   .global ROUT
   ROUT:
   movl 4(%esp), %edx
   ATOMIC_LOOP:
      movl (%edx), %eax       /* read cnt from memory */
      movl %eax, %ecx         /* ecx = cnt */
      subl $1, %ecx           /* ecx = cnt-1 */
      jl ZERO_RET             /* return 0 if count already below 1 */
      lock                    /* make cmpxchg atomic */
      cmpxchg %ecx, (%edx)    /* put cnt-1 in mem if mem still == cnt in eax */
      je DONE                 /* ZF set if cmpxchg wrote to mem */
   jmp ATOMIC_LOOP            /* ZF=0 means cmpxch failed, try again */

   ZERO_RET:
      xor %eax, %eax
@ROUT ATL_atmctr_add_asm ATL_atmctr_set_asm
   /* eax                  4(%esp)  8(%esp)  */
   /* int ATL_atmctr_@(rt)(void *vp, int val) */
   .text
   .global ROUT
   ROUT:
   push %esi
   movl 4+4(%esp), %edx       /* edx = ac */
   movl 4+8(%esp), %esi       /* esi = val */
   ATOMIC_LOOP:
      movl (%edx), %eax       /* read cnt from memory */
      movl %eax, %ecx         /* ecx = cnt */
@ROUT ATL_atmctr_add_asm `      add %esi, %ecx          /* ecx = cnt + val */`
@ROUT ATL_atmctr_set_asm `      mov %esi, %ecx          /* ecx = val */`
      lock                    /* make cmpxchg atomic */
      cmpxchg %ecx, (%edx)    /* st newcnt if mem still == oldcnt in eax */
      je DONE                 /* ZF set if cmpxchg wrote to mem */
   jmp ATOMIC_LOOP            /* ZF=0 means cmpxch failed, try again */
   pop %esi

@ROUT ATL_atmctr_dec_asm ATL_atmctr_add_asm
   DONE:
   ret
#elif defined(ATL_GAS_ARM64)
@ROUT ATL_atmctr_dec_asm
/* x0                        x0
/* long ATL_atmctr_dec(void *ac) */
@ROUT ATL_atmctr_add_asm ATL_atmctr_set_asm
/* x0                         x0                 x1 */
/* long ATL_atmctr_@(rt)(void *ac, unsigned long val) */
@ROUT ATL_atmctr_dec_asm ATL_atmctr_add_asm ATL_atmctr_set_asm
   .global Mjoin(PATL,atmcnt_@(rt))
   Mjoin(PATL,atmcnt_@(rt)):
   mov x3, x0            /* x3 = address of ctr */
@ROUT ATL_atmctr_set `   mov x2, x1            /* x2 = val */`
   ATOMIC_LOOP:
      ldxr x0, [x3]      /* exclusive read of cnt into return reg (x0) */
@ROUT ATL_atmctr_dec_asm
      subs x2, x0, 1     /* dec cnt, set cond codes */
      b.lt   ZERO_RET    /* return 0 if count already below 1 */
@ROUT ATL_atmctr_add_asm
      add x2, x0, x1     /* x2 = cnt + val */
@ROUT ATL_atmctr_dec_asm ATL_atmctr_add_asm ATL_atmctr_set_asm
      stxr w4, x2, [x3]  /* excl store newval, w4 0 on exclusive success */
   cbnz w4, ATOMIC_LOOP  /* if (w4 != 0) try again */
   ret
@ROUT ATL_atmctr_dec_asm
   ZERO_RET:
      eor w0, w0, w0
@ROUT ATL_atmctr_dec_asm ATL_atmctr_add_asm ATL_atmctr_set_asm
   ret
#endif
