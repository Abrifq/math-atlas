@ROUT ATL_trsmK_L
#include "atlas_misc.h"
#define RTYPE register TYPE

#if defined(ATL_SSE3) && defined(DREAL) && 0
   #define NRHS 3
   #include <xmmintrin.h>
/*
 * Subtract off x0...x3 contribution to all remaining equations using a
 * rank-4 update with mu=4, nu=3, ku=4.  This version is for 16 regs.
 * nu is the # of RHS, ku is the number of equations solved, and mu is 
 * unrolled only to enable software pipelinine of load/use.
 * Loop order is MKN, so that B is kept completely in registers, and
 * C and A are streamed in (and out, for C) from cache during the operation.
 */
static inline void ATL_rk4(ATL_CINT M, const TYPE *A, ATL_CINT lda, 
                           TYPE *pB0, ATL_CINT ldb, TYPE *C, ATL_CINT ldc) 
{ 
   const TYPE *pA0 = A, *pA1 = A+lda, 
              *pA2 = A+((lda)<<1), *pA3=pA1+((lda)<<1); 
   TYPE *pC0 = C, *pC1 = C+ldc, *pC2 = C+((ldc)<<1);
   const int MM = M; 
   int i; 
   register __m128d rB00, rB01, rB02, rB03; 
   register __m128d rB20, rB21, rB22, rB23;
   register __m128d rC00, rC01, rC02, rC03;
   register __m128d rC20, rC21, rC22, rC23;
   register __m128d rA0, rA1;
 
   rB00 = _mm_load_pd(pB0);
   rB20 = _mm_load_pd(pB0+2);
   rB01 = _mm_load_pd(pB0+ldb);
   rB21 = _mm_load_pd(pB0+ldb+2);
   rB02 = _mm_load_pd(pB0+2*ldb);
   rB22 = _mm_load_pd(pB0+2*ldb+2);
   rB03 = _mm_load_pd(pB0+3*ldb);
   rB23 = _mm_load_pd(pB0+3*ldb+2);

   rC00 = _mm_load_pd(pC0);
   rC01 = _mm_load_pd(pC1);
   rC02 = _mm_load_pd(pC2);
   rA0  = _mm_load_pd(pA0);  /* A1, A0 */
   for (i=0; i < MM; i += 4, pA0 += 4, pA1 += 4, pA2 += 4, pA3 += 4,
        pC0 += 4, pC1 += 4, pC2 += 4)
   {
      register __m128d rB;

      rB = _mm_unpacklo_pd(rB00, rB00);
      rB = _mm_mul_pd(rB, rA0);
      rC00 = _mm_sub_pd(rC00, rB); rA1 = _mm_load_pd(pA1);
      rB = _mm_unpacklo_pd(rB01, rB01);
      rB = _mm_mul_pd(rB, rA0);
      rC01 = _mm_sub_pd(rC01, rB); rC20 =_mm_load_pd(pC0+2);
      rB = _mm_unpacklo_pd(rB02, rB02);
      rB = _mm_mul_pd(rB, rA0);
      rC02 = _mm_sub_pd(rC02, rB); rC21 =_mm_load_pd(pC1+2);

      rB = _mm_unpackhi_pd(rB00, rB00);
      rB = _mm_mul_pd(rB, rA1);
      rC00 = _mm_sub_pd(rC00, rB); rC22 =_mm_load_pd(pC2+2);
      rB = _mm_unpackhi_pd(rB01, rB01);
      rB = _mm_mul_pd(rB, rA1);
      rC01 = _mm_sub_pd(rC01, rB); rA0 = _mm_load_pd(pA2);
      rB = _mm_unpackhi_pd(rB02, rB02);
      rB = _mm_mul_pd(rB, rA1);
      rC02 = _mm_sub_pd(rC02, rB); rA1 = _mm_load_pd(pA3);

      rB = _mm_unpacklo_pd(rB20, rB20);
      rB = _mm_mul_pd(rB, rA0);
      rC20 = _mm_sub_pd(rC20, rB); _mm_store_pd(pC0, rC00);
      rB = _mm_unpacklo_pd(rB21, rB21);
      rB = _mm_mul_pd(rB, rA0);
      rC21 = _mm_sub_pd(rC21, rB); _mm_store_pd(pC1, rC01);
      rB = _mm_unpacklo_pd(rB22, rB22);
      rB = _mm_mul_pd(rB, rA0);
      rC22 = _mm_sub_pd(rC22, rB); _mm_store_pd(pC2, rC02);

      rB = _mm_unpackhi_pd(rB20, rB20);
      rB = _mm_mul_pd(rB, rA1);
      rC20 = _mm_sub_pd(rC20, rB); _mm_store_pd(pC0+2, rC20);
      rB = _mm_unpackhi_pd(rB21, rB21);
      rB = _mm_mul_pd(rB, rA1);
      rC21 = _mm_sub_pd(rC21, rB); _mm_store_pd(pC1+2, rC21);
      rB = _mm_unpackhi_pd(rB22, rB22);
      rB = _mm_mul_pd(rB, rA1);
      rC22 = _mm_sub_pd(rC22, rB); _mm_store_pd(pC2+2, rC22);
   }
}
#else
   #define NRHS 4
/*
 * Subtract off x0...x3 contribution to all remaining equations using a
 * rank-4 update with mu=2, nu=4, ku=4.  This version is for 32 scalar
 * registers, and assumes the scalar registers rB00..rB33 are live on entry.
 * nu is the # of RHS, ku is the number of equations solved, and mu is 
 * unrolled only to enable software pipelinine of load/use.
 * Loop order is MKN, so that B is kept completely in registers, and
 * C and A are streamed in (and out, for C) from cache during the operation.
 */
#define ATL_rk4(M_, A_, lda_, C_, ldc_) \
{ \
   const TYPE *pA0 = A_, *pA1 = A_+lda_, \
              *pA2 = A_+((lda_)<<1), *pA3=pA1+((lda_)<<1); \
   TYPE *pC0 = C_, *pC1 = C_+ldc_, \
               *pC2 = C_+((ldc_)<<1), *pC3=pC1+((ldc_)<<1); \
   register TYPE rC00= *pC0, rC01= *pC1, rC02 = *pC2, rC03 = *pC3; \
   register TYPE rc00, rc01, rc02, rc03; \
   register TYPE rA0 = *pA0, rA1; \
   const int MM = M_ - 2; \
   int i; \
 \
   for (i=0; i < MM; i += 2, pA0 += 2, pA1 += 2, pA2 += 2, pA3 += 2, \
        pC0 += 2, pC1 += 2, pC2 += 2, pC3 += 2) \
   { \
      rC00 -= rA0 * rB00; rA1 = *pA1; \
      rC01 -= rA0 * rB01; rc00 = pC0[1]; \
      rC02 -= rA0 * rB02; rc01 = pC1[1]; \
      rC03 -= rA0 * rB03; rc02 = pC2[1]; \
 \
      rC00 -= rA1 * rB10; rA0 = *pA2; \
      rC01 -= rA1 * rB11; rc03 = pC3[1]; \
      rC02 -= rA1 * rB12;  \
      rC03 -= rA1 * rB13;  \
       \
      rC00 -= rA0 * rB20; rA1 = *pA3; \
      rC01 -= rA0 * rB21; \
      rC02 -= rA0 * rB22;  \
      rC03 -= rA0 * rB23; rA0 = pA0[1]; \
       \
      rC00 -= rA1 * rB30; *pC0 = rC00; \
      rC01 -= rA1 * rB31; *pC1 = rC01; \
      rC02 -= rA1 * rB32; *pC2 = rC02; \
      rC03 -= rA1 * rB33; *pC3 = rC03; \
       \
      rc00 -= rA0 * rB00; rA1 = pA1[1]; \
      rc01 -= rA0 * rB01; rC00 = pC0[2]; \
      rc02 -= rA0 * rB02; rC01 = pC1[2]; \
      rc03 -= rA0 * rB03; rC02 = pC2[2]; \
       \
      rc00 -= rA1 * rB10; rA0 = pA2[1]; \
      rc01 -= rA1 * rB11; rC03 = pC3[2]; \
      rc02 -= rA1 * rB12; \
      rc03 -= rA1 * rB13;  \
       \
      rc00 -= rA0 * rB20; rA1 = pA3[1]; \
      rc01 -= rA0 * rB21; \
      rc02 -= rA0 * rB22;  \
      rc03 -= rA0 * rB23; rA0 = pA0[2]; \
       \
      rc00 -= rA1 * rB30; pC0[1] = rc00; \
      rc01 -= rA1 * rB31; pC1[1] = rc01; \
      rc02 -= rA1 * rB32; pC2[1] = rc02; \
      rc03 -= rA1 * rB33; pC3[1] = rc03; \
   } \
/* \
 *  Drain the C fetch/store pipe \
 */ \
   rC00 -= rA0 * rB00; rA1 = *pA1; \
   rC01 -= rA0 * rB01; rc00 = pC0[1]; \
   rC02 -= rA0 * rB02; rc01 = pC1[1]; \
   rC03 -= rA0 * rB03; rc02 = pC2[1]; \
 \
   rC00 -= rA1 * rB10; rA0 = *pA2; \
   rC01 -= rA1 * rB11; rc03 = pC3[1]; \
   rC02 -= rA1 * rB12;  \
   rC03 -= rA1 * rB13;  \
    \
   rC00 -= rA0 * rB20; rA1 = *pA3; \
   rC01 -= rA0 * rB21; \
   rC02 -= rA0 * rB22;  \
   rC03 -= rA0 * rB23; rA0 = pA0[1]; \
    \
   rC00 -= rA1 * rB30; *pC0 = rC00; \
   rC01 -= rA1 * rB31; *pC1 = rC01; \
   rC02 -= rA1 * rB32; *pC2 = rC02; \
   rC03 -= rA1 * rB33; *pC3 = rC03; \
    \
   rc00 -= rA0 * rB00; rA1 = pA1[1]; \
   rc01 -= rA0 * rB01; \
   rc02 -= rA0 * rB02; \
   rc03 -= rA0 * rB03; \
    \
   rc00 -= rA1 * rB10; rA0 = pA2[1]; \
   rc01 -= rA1 * rB11; \
   rc02 -= rA1 * rB12; \
   rc03 -= rA1 * rB13; \
    \
   rc00 -= rA0 * rB20; rA1 = pA3[1]; \
   rc01 -= rA0 * rB21; \
   rc02 -= rA0 * rB22; \
   rc03 -= rA0 * rB23; \
    \
   rc00 -= rA1 * rB30; pC0[1] = rc00; \
   rc01 -= rA1 * rB31; pC1[1] = rc01; \
   rc02 -= rA1 * rB32; pC2[1] = rc02; \
   rc03 -= rA1 * rB33; pC3[1] = rc03; \
}
#endif

void Mjoin(PATL,trsmLLNk)
(
   const int M,   /* size of triangular matrix A, M%4 = 0 (mat padded) */
   const int N,   /* number of RHS in B */
   const SCALAR alpha,  /* scale factor for B */
   const TYPE *A, /* MxM lower matrix A, diag has inverse of original diag */
   TYPE *B,       /* on input, B, on output X, of A x = b */
   const int ldb, /* leading dim of B */
   TYPE *W        /* Mx4 workspace with good alignment */
)
{
   int j;
   #define lda M
/*
 * Loop over RHS, 4 RHS at a time
 */
   for (j=0; j < N; j += 4, B += (ldb<<2))
   {
      const int nb = Mmin(NRHS, N-j);
      int k, i;
      TYPE *w = W, *b = B;
      const TYPE *a;
/*
 *    Copy NRHS RHS to aligned workspace and scale if necessary, alpha cannot be
 *    zero, because this is handled as a special case at top
 */
      for (k=0; k < nb; k++)
      {
         if (alpha != 1.0)
         {
            for (i=0; i < M; i++)
               w[i] = alpha * b[i];
         }
         else
         {
            for (i=0; i < M; i++)
               w[i] = b[i];
         }
         w += M;
         b += ldb;
      }
      for (; k < NRHS; k++, w += M)
         for (i=0; i < M; i++)
             w[i] = ATL_rzero;
/*
 *    Completely solve these RHSs by looping over entire triangular matrix
 */
      b = B;
      w = W;
      a = A;
      for (k=0; k < M; k += 4, b += 4, w += 4, a += (lda+1)<<2)
      {
         RTYPE rB00 = *w, rB10=w[1], rB20=w[2], rB30=w[3];
         RTYPE rB01=w[M], rB11=w[M+1], rB21=w[M+2], rB31=w[M+3];
         RTYPE rB02=w[2*M],rB12=w[2*M+1],rB22=w[2*M+2],rB32=w[2*M+3];
         RTYPE rB03=w[3*M],rB13=w[3*M+1],rB23=w[3*M+2],rB33=w[3*M+3];
/*
 *       Solve M=4 NRHS=4 TRSM symbolically
 */
         {
            const RTYPE L00=(*a), L10=a[1], L20=a[2], L30=a[3];
            const RTYPE L11=a[lda+1], L21=a[lda+2], L31=a[lda+3];
            const RTYPE L22=a[2*lda+2], L32=a[2*lda+3];
            const RTYPE L33=a[3*lda+3];
/*
 *          x0 = b0 / L00
 */
            rB00 *= L00;
            rB01 *= L00;
            rB02 *= L00;
            rB03 *= L00;
/*
 *          x1 = (b1 - L10 * x0) / L11
 */
            rB10 = (rB10 - L10*rB00) * L11; 
            rB11 = (rB11 - L10*rB01) * L11;
            rB12 = (rB12 - L10*rB02) * L11;
            rB13 = (rB13 - L10*rB03) * L11;
/*
 *          x2 = (b2 - L20*x0 - L21*x1) / L22
 */
            rB20 = (rB20 - L20*rB00 - L21*rB10) * L22;
            rB21 = (rB21 - L20*rB01 - L21*rB11) * L22;
            rB22 = (rB22 - L20*rB02 - L21*rB12) * L22;
            rB23 = (rB23 - L20*rB03 - L21*rB13) * L22;
/*
 *          x3 = (b3 - L30*x0 - L31*x1 - L32*x2) / L33
 */
            rB30 = (rB30 - L30*rB00 - L31*rB10 - L32*rB20) * L33;
            rB31 = (rB31 - L30*rB01 - L31*rB11 - L32*rB21) * L33;
            rB32 = (rB32 - L30*rB02 - L31*rB12 - L32*rB22) * L33;
            rB33 = (rB33 - L30*rB03 - L31*rB13 - L32*rB23) * L33;
         }  /* complete 4x4 solve block */
/*
 *       Write solved 4x4 block out to original workspace (final answer)
 */
         *b = rB00;
         b[1] = rB10;
         b[2] = rB20;
         b[3] = rB30;
         b[ldb] = rB01;
         b[ldb+1] = rB11;
         b[ldb+2] = rB21;
         b[ldb+3] = rB31;
         b[ldb+ldb] = rB02;
         b[ldb+ldb+1] = rB12;
         b[ldb+ldb+2] = rB22;
         b[ldb+ldb+3] = rB32;
         b[(ldb<<1)+ldb] = rB03;
         b[(ldb<<1)+ldb+1] = rB13;
         b[(ldb<<1)+ldb+2] = rB23;
         b[(ldb<<1)+ldb+3] = rB33;
/*
 *       Subtract off x0-x4 contribution from rest of B using rank-4 update
 */
         ATL_rk4(M-k-4, a+4, lda, w+4, M);
      }     /* end k-loop that loops through L */
   }        /* end j-loop over RHS */
   #undef lda
}           /* end routine */

void Mjoin(PATL,trsmDR)
(
   enum ATLAS_SIDE Side,
   enum ATLAS_UPLO Uplo,
   enum ATLAS_TRANS TA,
   enum ATLAS_DIAG Diag,
   const int M,   /* size of triangular matrix A, M%4 = 0 (mat padded) */
   const int N,   /* number of RHS in B */
   const SCALAR alpha,  /* scale factor for B */
   const TYPE *A, /* MxM lower matrix A, diag has inverse of original diag */
   const int lda,
   TYPE *B,       /* on input, B, on output X, of A x = b */
   const int ldb  /* leading dim of B */
)
{
   void *vp;
   TYPE *a, *w;
   int M4 = ((M+3)>>2)<<2;
   vp = malloc(sizeof(TYPE)*(M4*M4+4*M4)+2*ATL_Cachelen);
   ATL_assert(vp);
   ATL_assert(TA == AtlasNoTrans && Side == AtlasLeft && Uplo == AtlasLower);
   ATL_assert(M4 == M);

   a = ATL_AlignPtr(vp);
   w = a + M4*M4;
   w = ATL_AlignPtr(w);
   if (Uplo == AtlasLower)
   {
      int j, i;
      TYPE *ap=a;
/*
 *    Copy original L to aligned workspace, invert diagonal elts, pad wt I
 */
      for (j=0; j < M; j++, ap += M4, A += lda)
      {
         for (i=0; i < j; i++)
            ap[i] = ATL_rzero;
         ap[j] = (Diag == AtlasNonUnit) ? 1.0 / A[j] : ATL_rone;
         for (i=j+1; i < M; i++)
            ap[i] = A[i];
         for (; i < M4; i++)
            ap[i] = ATL_rzero;
      }
      for (; j < M4; j++, ap += M4)
      {
         for (i=0; i < M4; i++)
            ap[i] = ATL_rzero;
         ap[j] = ATL_rone;
      }
      Mjoin(PATL,trsmLLNk)(M, N, alpha, a, B, ldb, w);
   }
   free(vp);
}
