@ROUT storage.idx scopy.idx dcopy.idx ccopy.idx zcopy.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
@ROUT storage.idx
# This file indexes the user-supplied storage schemes, and has the following
# format:
# The file has the following format (default values in []):
# ID=<id> FLAG=<bitfield> BLKSZF='iexp' EXTELTF='iexp'
# ID must be a unique >100 number identifying the storage scheme.  A copy
#    routine with a matching STGID must be found for both copy directions
#    in the appropriate [s,c,d,z]blkcpy.idx types.  The storage IDs that
#    are so far in use by ATLAS itself (<100) are:
#      0: access major storage as used in generator, details in struct
#      1: access major (unvectorized or m-vec) storage for A or B
#      2: access major (unvectorized or m-vec) storage for C
#      3: K-vectorized access major storage for A or B
#      4: K-vectorized access major storage for C
#      5: block major (ATLAS 3.10 or older code gen support)
# 'iexp': must contain in '' a valid ANSI C integer expression which computes
#         the indicated storage using only constants and the key-specific
#         variables.
# BLKSZF [((M+mu-1)/mu)*((N+nu-1)/nu)*mu*nu]
#        must contain in '' a valid ANSI C integer expression which computes
#        iexp computes the number of elements to store one block using this
#        storage pattern.  ATLAS assumes real & imag components stored 
#        separately, so complex size should be half of total size.
#        The only variables that can be used will be chosen by the search after
#        tuning and passed to a function with the following prototype:
#           int getsz(int M, int N, int mu, int nu, int vlen);
#        to allow ATLAS to allocate storage for an individual block. j
#        The expression may use the following variables, in addition
#        to any constants (these args themselved might be constants for some
#        storage formats):
#          M : number of rows chosen for block factor
#          N : number of cols chosen for block factor
#         mu : unroll&jam chosen for M dim
#         nu : unroll&jam chosen for N dim
#       vlen : length of vectorization employed
# EXTELTF: [4*mu*nu]
#          how many elements must be allocated past the end of allocated
#          block memory so that advanced loads don't seg fault.  This number
#          should be small.  The generated size function will have prototype:
#            int getsz(int mu, int nu, int vlen);
#
@ROUT scopy.idx dcopy.idx ccopy.idx zcopy.idx
# This file indexes the user-supplied copy routines for the storage schemes
# indexed in storage.ids, and has the following format (non-mandatory
# keys show the default in []):
# ID=<id> STGID=<stgid> CBLK=[0,1] TOBLK=[0,1] TRANS=[0,1] CONJ=[0,1] \
#    MU=<mu> NU=<nu> VLEN=<vlen> ROUT='rt' AUTH='name' \
#    COMP='gcc' CFLAGS='flags' ALPHA=lst BETA=lst
# ID: Mandatory.  Unique (in this file only) int >= 0.  
# STGID: Mandatory.  Number >0 matching and ID in storage.idx.  Predefined:
#    0: access major, scope TOBLKCBLK,VLEN,KVEC to determine what type
#    X: user defined type
# TOBLK: Mandatory. 
#         0: copies from STGID block storage to column-major
#         1: copies from column-major to STGID block storage
# MU/NU: [0] unrolling along rows/cols
# TRANS: [n] Needed only for A/B storage, indicates transpose being done:
#    N: cols of matrix stored contiguously, rows strided (col-major)
#    T: rows of matrix stored contiguously, cols strided (row-major)
# ALPHA: mandatory.  What alpha cases handled by kern.  For A/B, full list
#        is 1,N,X, for C it is 0,1,N,X.
# BETA: mandatory for C ignored for A/B.  Full list is 0,1,N,X.
#
# NOTE: for a storage format to be used by ATLAS, enough copy funcs must
#       be supplied for use, and the number required varies by whether the
#       format is for GEMM's A/B or C matrix:
#       A&B: TOBLK=1 and for real TRANS=N&T, cplx TRANS=N&T&C&H
#            TOBLK=0 must be present for testing & custom uses.
#       C  : TOBLK=0 required. TOBLK=1 needed for testing & custom uses.
#
@ROUT scopy.idx 
   @define TP @ REAL=1 SINGLE=1@
@ROUT ccopy.idx 
   @define TP @ SINGLE=1@
@ROUT scopy.idx ccopy.idx 
@define VL @8@
@ROUT dcopy.idx
   @define TP @ REAL=1@
@ROUT zcopy.idx 
   @define TP @@
@ROUT dcopy.idx zcopy.idx 
@define VL @4@
@ROUT scopy.idx dcopy.idx
ID=1 STGID=0 CBLK=1 TOBLK=0 MU=3 NU=3 KVEC=@(VL) VLEN=@(VL) SYRK=1@(TP) \
     ALPHA=1,N,X BETA=0,N,1,X ROUT='ATL_skblk2C3x3.c' AUTH='R. Clint Whaley'
ID=2 STGID=0 TOBLK=1 MU=1 NU=4 VLEN=4 ALPHA=1,N,X@(TP) \
     ROUT='ATL_cpAN2blk4_avx2.c' AUTH='R. Clint Whaley'
ID=2 STGID=0 TOBLK=1 MU=1 NU=12 VLEN=4 ALPHA=1,N,X@(TP) \
     ROUT='ATL_cpAN2blk12_avx2.c' AUTH='R. Clint Whaley'
@ROUT cptst.c
/* 
 * This is a sanity check that takes a known-good copy implementation in
 * CPK_GOOD, and one to test in CPK_TEST.  It then applies these routines
 * on duplicate matrices, and looks for errors greater than expected due to
 * fp arithmetic.  This version specialized for col-major to blk copies.
 */
void cpyblksN(const int mb, const int nb, const size_t M, const size_t N, 
              SCALAR alpha, TYPE *A, size_t lda, TYPE *B, size_ldb, TYPE *wrk)
/*
 * B <-- alpha*A; A&B both MxN, copy by blocks
 */
{
   const size_t nmblks=M/mb, Mb=nmblks*mb, mr=M-Mb;
   const size_t nnblks=N/nb, Nb=nnblks*nb, nr=N-Nb;
   size_t i, j;
   const int NB=nb SHIFT;
   #ifdef TCPLX
      TYPE ralpha[2];
   #else
      TYPE ralpha = ATL_rone / alpha;
   #endif
   #ifdef TCPLX
      Mjoin(PATL,cplxinvert)(1, alpha, 1, ralpha, 1);
   #endif

   for (j=0; j < Nb; j += nb, A += lda*NB, B += ldb*NB)
   {
      for (i=0; i < Mb; i += mb)
      {
         mycpyN(mb, nb, alpha, A+(i SHIFT), lda, wrk);
         myrcpyN(mb, nb, ralpha, B+(i SHIFT), ldb, wrk);
      }
   }
}
int cntErr(int verb, int M, int N, TYPE *A, size_t lda, TYPE *E, size_t lde, 
           TYPE tol)
{
   int j, nerr=0;
   for (j=0; j < N; j++, A += lda SHIFT, E += lde SHIFT)
   {
      for (i=0; i < M; i++)
      {
         diff = A[i] - E[i];
         if (diff > tol)
         {
            
         }
      }
   }
}

int main(int nargs, char **args)
{
   int mb=28, nb=36, lda, m=27, n=33, N=nb+4;
   int lda=mb+55;
   size_t szA, szW, csz, lda=mb+55, lda2, i;
   #ifdef TCPLX
      TYPE alpha[2]={ATL_rone, ATL_rzero}, beta[2]={ATL_rone, ATL_rzero};
   #else
      TYPE alpha=ATL_rone, beta=ATL_rone;
   #endif
   TYPE *A, *G, *T;
   char *cp;

   lda2 = lda SHIFT:
   sz = N*lda2;
   A = malloc(sz*sizeof(TYPE))
   assert(A);
   for (i=0; i < sz; i++)
      A[i] = i;
   szW = mb * nb;
   csz = 2*(szW SHIFT)*sizeof(TYPE) + 3*ATL_Cachelen;
   cp = malloc(2*csz);
   assert(cp);
   cp = (char*)w;
   for (i=0; i < 2*csz; i++)
      cp[i] = 0xFF;
   T = ATL_AlignPtr(cp) + ATL_Cachelen;
   G = (TYPE*) (((char)T) + csz);

}
@ROUT cpysearch
#include "atlas_cpparse.h"
#include "atlas_cptesttime.h"
#include "atlas_mmparse.h"
#include "atlas_mmtesttime.h"
#include "atlas_mmgen.h"

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
@skip   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -i <cpyin.CPS>: (stdin) list of copy to search\n");
   fprintf(stderr, "   -o <cpyout.CPS>: (stdout) fastest copy kernels\n");
@skip   fprintf(stderr, "   -v <verb> : set verbosity (1)\n");
   exit(ierr ? ierr : -1);
}

ATL_cpnode_t *GetFlags(int nargs, char **args, int *VERB, char **FOUT)
/*
 * RETURNS: list of all kerns/blk factors to tune copies for
 */
{
   ATL_cpnode_t *cb=NULL, *cp;
   int i;

   *VERB = 0;
   *FOUT = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'i':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        cb = ReadCPFile(args[i]);
        assert(cb);
        break;
      case 'o':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *FOUT = args[i];
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (!cb)
      cb = ReadCPFile(NULL);
   return(cb);
}

unsigned long GetRep(unsigned long reps, unsigned int mb, unsigned int nb)
{
   double ratio;
   unsigned long nrep;
   ratio = 16.0 / (((double)mb)*nb);
   nrep = reps*ratio;
   nrep = (nrep > 0) ? nrep : 1;
   return(nrep);
}

ATL_cpnode_t *GetWorkingKerns(char pre, int verb, ATL_cpnode_t *cb)
/*
 * Right now, just reads in all kerns.  Later, should eliminate kerns that
 * won't work with any cb.
 */
{
   ATL_cpnode_t *hb=NULL;
   int DOTEST=0;
@skip   hb = ReadCPFileWithPath(pre, "res", "cpywork_a1b0.sum");
   if (!hb)
   {
      hb = ReadCPFileWithPath(pre, "CPYCASES", "copy.idx");
      #if 0
      if (flag&(1<<CPF_CBLK))
         DOTEST = (CopyGetAlphaI(flag) == 1 && CopyGetBetaI(flag) == 0);
      else
         DOTEST = CopyGetAlphaI(flag) == 1;
      #endif
   }

@skip   hb = CopyApplyTypeScal2Hand(hb, flag);
   PrefixStrAllNodes(hb, GetOffset(&hb->next, hb), GetOffset(&hb->rout, hb),
                     "CPYCASES/");
   if (DOTEST)
   {
      hb = KillFailingCPNodes(pre, hb);
      WriteCPFileWithPath(pre, "res", "cpywrk_a1b0.sum", hb);
   }
@skip   hb = KillCPNodesByFlag(flag, 1<<CPF_CBLK, hb); /* kill wrong-mat kerns */
   return(hb);
}

ATL_cpnode_t *DoHandTimings
   (char pre, int verb, unsigned long rep4, ATL_cpnode_t *cb)
{
   ATL_cpnode_t *hb, *cp, *hp, *HB=NULL;
   unsigned long nrep;


   hb = GetWorkingKerns(pre, verb, cb);
   if (!hb)
   {
      printf("NO USER-SUPPLIED COPY ROUTINES!\n");
      return(NULL);
   }
   printf("FINDING BEST HAND-TUNED COPY:\n");
   for (cp=cb; cp; cp=cp->next)
   {
      double mf;
      ATL_cpnode_t *np=NULL;
      const unsigned int mb=cp->mb, nb=cp->nb, flag=cp->flag;
      int ialp, ibet=0;

      nrep = GetRep(rep4, mb, nb);
      ialp = CopyGetAlphaI(flag);
      if (flag & (1<<CPF_CBLK))
         ibet = CopyGetBetaI(flag);
/*
 *    Try any hand-tuned cases that work
 */
      hp = FindEquivCopy_ab(hb, cp);
      if (hp)
      {
         printf("   TIMINGS B=(%d,%d), U=(%d,%d) TA=%c, reps=%lu:\n", 
                cp->mb, cp->nb, cp->mu, cp->nu, 
                (cp->flag&(1<<CPF_TRANS))?'T':'N', nrep);
         printf("      ID=%6d VL=%2d: mf=%.0f\n", 0, cp->vlen, cp->mflop[0]);
         do
         {
            double mf;

            mf = TimeCPKernel(verb, 0, hp, mb, nb, ialp, ibet, nrep, -1);
            printf("      ID=%6d VL=%2d: mf=%.0f\n", hp->ID, hp->vlen, mf);
            if (mf > cp->mflop[0])
            {
               if (np)
                  KillCPNode(np);
               np = CloneCPNode(hp);
               np->mflop[0] = mf;
               np->mb = mb;
               np->nb = nb;
               np->flag = CopyEncodeScal(flag, ialp, ibet);
            }
            hp = hp->next;
         }
         while( (hp = FindEquivCopy_ab(hp, cp)) );
         printf("   DONE\n");
      }
      if (!np)
         np = CloneCPNode(cp);
      np->next = HB;
      HB = np;
   }
   if (hb)
      KillAllCPNodes(hb);
   return(ReverseCPQ(HB));
}

void DoGenTimings(char pre, int verb, unsigned long rep4, ATL_cpnode_t *cb)
{
   ATL_cpnode_t *cp;
   char *fnam;

@skip   fnam = GetCpySumNam(flag, 'g');
   printf("FINDING BEST GENERATED COPY:\n");
   for (cp=cb; cp; cp = cp->next)
   {
      double mf, mfB;
      unsigned long nrep;
      int ialp, ibet=0, flag=cp->flag;
      ialp = CopyGetAlphaI(flag);
      if (flag & (1<<CPF_CBLK))
         ibet = CopyGetBetaI(flag);

      nrep = GetRep(rep4, cp->mb, cp->nb);
      printf("   TIMINGS B=(%d,%d), U=(%d,%d), TA=%c, reps=%lu:\n", 
             cp->mb, cp->nb, cp->mu, cp->nu, (cp->flag&(1<<CPF_TRANS))?'T':'N',
             nrep);
      cp->vlen = 1;
      if (!cp->rout)
         cp->rout = DupString("ATL_tmp.c");
      if (cp->genstr)
         free(cp->genstr);
      cp->genstr = GetCopyGenStr(cp);
      mfB = TimeCPKernel(verb, 0, cp, cp->mb, cp->nb, ialp, ibet, nrep, -1);
      printf("      ID=     0 VL= 1: mf=%.0f\n", mfB);
      cp->mflop[0] = mfB;
/*
 *    See if we can use vectorized generator.
 *    Present vector generator only supports SSE/AVX for real GEMM C copy
 */
      #if defined(ATL_AVX) || defined(ATL_SSE2) || defined(ATL_SSE)
         if (!(cp->flag & CPF_ALLKERN) && (pre == 's' || pre == 'd') &&
             (cp->flag&(1<<CPF_CBLK)))
         {
            char *gens;
            int VL0=cp->vlen, VL = (pre == 's') ? 4 : 2;

         #if defined(ATL_SSE2) || defined(ATL_SSE1)
            #if defined(ATL_SSE2)
            if (cp->mu % VL == 0 && (pre == 'd' || pre == 's') && 
                !(cp->flag&CPF_ALLKERN))
            #else
            if (cp->mu % VL == 0 && pre == 's' && !(cp->flag&CPF_ALLKERN))
            #endif
            {
               gens = cp->genstr;
               cp->vlen = VL;
               cp->genstr = GetCopyGenStr(cp);
               mf = TimeCPKernel(verb, 0, cp, cp->mb, cp->nb, ialp, ibet, 
                                 nrep, -1);
               printf("      ID=     0 VL=%2d: mf=%.0f\n", VL, mf);
               if (mf > mfB)
               {
                  free(gens);
                  cp->mflop[0] = mfB = mf;
               }
               else
               {
                  free(cp->genstr);
                  cp->genstr = gens;
                  cp->vlen = VL0;
               }
            } /* end SSE if */
         #endif
         #ifdef ATL_AVX
            VL0 = cp->vlen;
            VL <<= 1;
            if (cp->mu % VL == 0)
            {
               gens = cp->genstr;
               cp->vlen = VL;
               cp->genstr = GetCopyGenStr(cp);
               mf = TimeCPKernel(verb, 0, cp, cp->mb, cp->nb, ialp, ibet, 
                                 nrep, -1);
               printf("      ID=     0 VL=%2d: mf=%.0f\n", VL, mf);
               if (mf > mfB)
               {
                  free(gens);
                  cp->mflop[0] = mfB = mf;
               }
               else
               {
                  free(cp->genstr);
                  cp->genstr = gens;
                  cp->vlen = VL0;
               }
            } /* end AVX if */
         #endif
         }    /* end if over trying old vec-basefile */
      #endif  /* end #if on Intel SSE/AVX */
   }
   printf("DONE GENERATED COPY SEARCH\n");
@skip   WriteCPFileWithPath(pre, "res", fnam, cb);
@skip   printf("DONE, output in: res/%c%s\n", pre, fnam);
}

void DoTimings
   (char *fnam, char pre, int verb, unsigned long rep4, ATL_cpnode_t *cb)
{
   ATL_cpnode_t *cp, *fb;

   cp = TimeCPFile(pre, fnam, 0, verb, 0);
   if (cp)
   {
      KillAllCPNodes(cp);
      return;
   }
   DoGenTimings(pre, verb, rep4, cb);
   fb = DoHandTimings(pre, verb, rep4, cb);
   if (!fb)
      fb = cb;
   for (cp=fb; cp; cp=cp->next)
   {
      if (cp->flag & (1L<<CPF_SYRK))
         cp->mflop[0] = 2e-6 / cp->mflop[0]; /* time per elt */
      else
         cp->mflop[0] = 1e-6 / cp->mflop[0]; /* time per elt */
   }
   WriteCPFile(fnam, fb);
   if (fb != cb)
      KillAllCPNodes(fb);
   printf("DONE, OUTPUT IN: %s.\n", fnam);
}

unsigned long GetReps4x4(int verb, double res)
/*
 * Find how many repititions to do for 4x4 copy to get timing interval to
 * around res seconds
 */
{
   ATL_cpnode_t *cp;
   double tim, mf;
   unsigned long nrep = 32;
   FILE *fp;

   fp = fopen("res/ncprep4x4.txt", "r");
   if (fp)
   {
      fscanf(fp, " %lu", &nrep);
      fclose(fp);
      return(nrep);
   }
   cp = GetCPNode();
   cp->mu = 4; 
   cp->nu = 1;
   cp->flag = (1<<CPF_BE0)|(1<<CPF_AL1)|(1<<CPF_CBLK)|
              (1<<CPF_SINGLE)|(1<<CPF_REAL);
   cp->rout = DupString("ATL_tmp.c");
   cp->genstr = GetCopyGenStr(cp);

   printf("FINDING NREP:\n");
   do
   {
      nrep += nrep;
      mf = TimeCPKernel(verb, 1, cp, 4, 4, 1, 0, nrep, -1);
      tim = (mf / 16e6) * nrep;
      printf("   NREP=%16lu, tim=%e\n", nrep, tim);
   }
   while (tim < res && nrep < 100000);
   printf("DONE.\n");
   KillCPNode(cp);
   fp = fopen("res/ncprep4x4.txt", "w");
   fprintf(fp, "%lu", nrep);
   fclose(fp);
   return(nrep);
}

int main(int nargs, char **args)
/*
 * For now read geAMMRES.sum, later add rkAMMRES.sum & SYRK.
 * Will use this info to find unique lists of AB & C copiers.
 * -> Later must extend for A & B using possibly different copiers.
 * It then finds the fastest working copy routine for each case, 
 * trying each of following:
 * (1) Codes generated from atlas-mmkg.base (all standard formats)
 * (2) atlas-mmg.base (vector ops, but only mu%vlen Cblk formats)
 * (3) User-contributed cases
 */
{
   ATL_cpnode_t *cb, *cp, *cb0;
   char *fout;
   unsigned long nrep;
   char pre;
   int verb, minSz, ialp, ibet=0;
   unsigned int flag;

   cb = GetFlags(nargs, args, &verb, &fout);
   pre = CopyGetPre(cb->flag);
   nrep = GetReps4x4(verb, 0.10);
   DoTimings(fout, pre, verb, nrep, cb);

   KillAllCPNodes(cb);
   return(0);
}
@ROUT cpygen
#include "atlas_cpparse.h"
#include "atlas_mmgen.h"
void GenMake(ATL_cpnode_t *cb, char *path)
{
   FILE *fp;
   ATL_cpnode_t *cp;
   int len, CPLX;
   char *fnam;
   char pre;
   char UPR;
   char dcomp[7] = {'$','(', 'D', 'K', 'C',')', '\0'};
   char dflag[12] = {'$','(','D','K','C', 'F','L','A','G','S', ')', '\0'};
@skip   char *getd="fgrep 'BLDdir =' Make.inc | sed -e 's/   BLDdir = //'";

   if (!cb)
      return;
   pre = CopyGetPre(cb->flag);
   CPLX = pre == 'c' || pre == 'z';
   len = strlen(path) + 10;  /* /Makefile */
   fnam = malloc(len);
   assert(fnam);
   sprintf(fnam, "%s/Makefile", path);
   assert(!Sys2File("fgrep 'BLDdir =' Make.inc", fnam));
   fp = fopen(fnam, "a");
   assert(fp);
   free(fnam);
   fprintf(fp, "include $(BLDdir)/Make.inc\n");

   UPR = (pre == 'c' || pre == 's') ? 'S' : 'D';
   dflag[2] = dcomp[2] = UPR;
   fprintf(fp, "\n   objs =");
   for (cp=cb; cp; cp = cp->next)
   {
      fprintf(fp, " \\\n          %s.o", cp->rout);
      if (CPLX && !(cp->flag&(1<<CPF_CBLK)))  /* Need conjugate target? */
      {
         ConjCopyName(cp);
         fprintf(fp, " \\\n          %s.o", cp->rout);
         UnConjCopyName(cp);
      }
   }      
   PrintMakeTargs(fp, pre);
/*
 * Print compilation rules 
 */
   for (cp=cb; cp; cp = cp->next)
   {
      char ch = (cp->flag&(1<<CPF_ASM)) ? 'S' : 'c';
      if (cp->comp || cp->cflags)
      {
         fprintf(fp, "%s.o : %s.%c\n", cp->rout, cp->rout, ch);
         fprintf(fp, "\t%s $(CDEFS) %s -c %s.%c", cp->comp ? cp->comp:dcomp, 
                 cp->cflags ? cp->cflags : dflag, cp->rout, ch);
      }
      if (CPLX && !(cp->flag&(1<<CPF_CBLK)))  /* Need conjugate target? */
      {
         ConjCopyName(cp);
         fprintf(fp, "%s.o :", cp->rout);
         UnConjCopyName(cp);
         fprintf(fp, " %s.%c\n", cp->rout, ch);
         fprintf(fp, "\t%s $(CDEFS) %s -DConj_=1 -c %s.%c\\\n", 
                 cp->comp ? cp->comp:dcomp, cp->cflags ? cp->cflags:dflag,
                 cp->rout, ch);
         ConjCopyName(cp);
         fprintf(fp, "           -o %s.o\n", cp->rout);
         UnConjCopyName(cp);
      }
   }
/*
 * Print default rules
 */
   fprintf(fp, ".S.o:\n");
   fprintf(fp, "\t%s $(CDEFS) %s -c $*.S\n", dcomp, dflag);
   fprintf(fp, ".s.o:\n");
   fprintf(fp, "\t%s $(CDEFS) %s -c $*.s\n", dcomp, dflag);
   fprintf(fp, ".c.o:\n");
   fprintf(fp, "\t%s $(CDEFS) %s -c $*.c\n", dcomp, dflag);

   fclose(fp);
}

void GenCopy(ATL_cpnode_t *cb, char *path)
{
   ATL_cpnode_t *cp;
   char *sp, *typs, *untyp;
   int len, plen;
   char pre;

   if (!cb)
      return;

   plen = strlen(path);
   pre = CopyGetPre(cb->flag);
   untyp = "#ifdef SCALAR\n   #undef SCALAR\n#endif\n"
           "#ifdef TYPE\n   #undef TYPE\n#endif\n"
           "#ifdef SREAL\n   #undef SREAL\n#endif\n"
           "#ifdef DREAL\n   #undef DREAL\n#endif\n"
           "#ifdef SCPLX\n   #undef SCPLX\n#endif\n"
           "#ifdef DCPLX\n   #undef DCPLX\n#endif\n";
   if (pre == 'z')
      typs = "#define DCPLX 1\n#define TYPE double\n#define SCALAR TYPE*\n";
   else if (pre == 'c')
      typs = "#define SCPLX 1\n#define TYPE float\n#define SCALAR TYPE*\n";
   else if (pre == 'd')
      typs = "#define DREAL 1\n#define TYPE double\n#define SCALAR TYPE\n";
   else if (pre == 's')
      typs = "#define SREAL 1\n#define TYPE float\n#define SCALAR TYPE\n";

   for (cp=cb; cp; cp = cp->next)
   {
      char *nam, *fnam=NULL, *rt=cp->rout;
      char calp, cbet=0, fe = 'c';
      FILE *fp;

      calp = CopyGetAlphaC(cp->flag);
      if (cp->flag&(1<<CPF_CBLK))
         cbet = CopyGetBetaC(cp->flag);
      nam = GetCopyName(cp, 0);
      if (cp->ID)
      {
         char *onam;
         assert(rt);
         for (onam=rt; *onam; onam++);
         fe = onam[-1];
         if (fe != 'c' && fe != 'S' && fe != 's')
            fe = 'c';
         
         len = 10 + strlen(rt);
         cp->rout = malloc(len);
         assert(cp->rout);
         if (strncmp(rt, "CPYCASES/", 9))
            sprintf(cp->rout, "CPYCASES/%s", rt);
         else
            strcpy(cp->rout, rt);
      }
      else
      {
         char *gens=cp->genstr;
         cp->rout = "ATL_tmp.c";
         cp->genstr = GetCopyGenStr(cp);
         MMDoGenString(0, cp->genstr);
         free(cp->genstr);
         cp->genstr = gens;
      }
      if (rt)
         free(rt);
      if (fe == 's' || fe == 'S')
         cp->flag |= 1L<<CPF_ASM;
      len = strlen(path) + 1 + strlen(nam) + 2 + 1;
      fnam = malloc(len);
      sprintf(fnam, "%s/%s.%c", path, nam, fe);
      fp = fopen(fnam, "w");
      assert(fp);
      fprintf(fp, untyp);
      fprintf(fp, typs);
      if (cp->flag&(1<<CPF_CBLK))
         fprintf(fp, "#define ATL_MU %u\n#define ATL_NU %u\n", cp->mu, cp->nu);
      else
         fprintf(fp, "#define ATL_NU %u\n", cp->nu);
      fprintf(fp, "#define ATL_USERCPMM %s\n", nam);
      if (!(cp->flag&(1<<CPF_REAL)) && !(cp->flag&(1<<CPF_CBLK)))
      {  /* if complex A/B copy, need conj_! */
         char *rt = cp->rout;
         cp->rout = nam;
         fprintf(fp, "#ifdef Conj_\n   #undef ATL_USERCPMM\n");
         ConjCopyName(cp);
         fprintf(fp, "   #define ATL_USERCPMM %s\n#endif\n", nam);
         UnConjCopyName(cp);
         cp->rout = rt;
      }
      fprintf(fp, "\n");
      fclose(fp);
      len = 10 + strlen(cp->rout) + strlen(fnam);
      sp = malloc(len);
      assert(sp);
      sprintf(sp, "cat %s >> %s", cp->rout, fnam);
      free(fnam);
      if (system(sp))
      {
         fprintf(stderr, "ERROR IN CMD: '%s'\n", sp);
         assert(0);
      }
      free(sp);
      if (cp->ID)
         free(cp->rout);
      cp->rout = nam;
   }
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -i cpyout.sum: repeat for multiple\n");
   fprintf(stderr, "   -o <output path>\n");
@skip   fprintf(stderr, "   -v <verb> : set verbosity (1)\n");
   exit(ierr ? ierr : -1);
}

ATL_cpnode_t *GetFlags(int nargs, char **args, char **OUTD)
{
   ATL_cpnode_t *cb=NULL, *cp;
   char *outd=NULL;
   int i;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'i':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        if (!cb)
           cb = ReadCPFile(args[i]);
        else
        {
           cp = ATL_LastCPNode(cb);
           cp->next = ReadCPFile(args[i]);
        }
        break;
      case 'o':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        outd = DupString(args[i]);
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (!cb)
      cb = ReadCPFile(NULL);
   if (!outd)
      outd = DupString("tmp/");
   *OUTD = outd;
   return(cb);
}

int main(int nargs, char **args)
{
   ATL_cpnode_t *cb;
   char *outd;

   cb = GetFlags(nargs, args, &outd);
   assert(cb);
   GenCopy(cb, outd);   /* sets info for Protos&Make! */
   GenMake(cb, outd);
   free(outd);
   KillAllCPNodes(cb);
   return(0);
}
@ROUT cphgen
@beginskip
// NOTE: GenProto is view-specific, so don't put that here.
static int flag2PrIdx(int flag)
/*
 * Translates C matrix: a1b0:0, a1b1:1 a1bN:2, a1bX:3, aN, aX (aXbX=11)
 * A matrix: a1N:12 a1T:13, aNN:14 aNT:15,aXN:16 aXT:17.
 * so 18 choices, * 2 for TOBLK.
 */
{
   int i;
   if (flag & (1<<CPF_CBLK))
   {
      if (flag & (1<<CPF_AL1))
         i = 0;
      else 
         i = (flag & (1<<CPF_ALN)) ? 4 : 8;
      if (flag & (1<<CPF_BE1))
         i++;
      else if (flag & (1<<CPF_BEN))
         i += 2;
      else if (flag & (1<<CPF_BEX))
         i += 3;
   }
   else
   {
      if (flag & (1<<CPF_AL1))
         i = 0;
      else 
         i = (flag & (1<<CPF_ALN)) ? 2 : 4;
      if (flag & (1<<CPF_TRANS))
         i++;
      i += 12;
   }
   if (flag & (1<<CPF_TOBLK))
      i += 18;
   return(i);
}

@endskip
#include "atlas_mmgen.h"
void PrintProtos(FILE *fp, ATL_cpnode_t *cb)
{
   ATL_cpnode_t *cp;
   int i;
   char *args;

   if (!cb)
      return;
   cb = CloneCPQueue(cb);
   cb = CopyNoRep(cb, 24*24);
   if (cb->flag & (1<<CPF_CBLK))
   {
      if (cb->flag & (1<<CPF_TOBLK)) /* copy from C into blk */
      {
         if (cb->flag & (1<<CPF_REAL))
            args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,"
                   "const SCALAR, TYPE *";
         else
            args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,"
                   "const SCALAR, TYPE*,TYPE*";
      }
      else /* copy from block into C */
      {
         if (cb->flag & (1<<CPF_REAL))
            args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,"
                   "const SCALAR,TYPE*,ATL_CSZT";
         else
            args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const TYPE*,"
                   "const SCALAR,TYPE*,ATL_CSZT";
      }
   }
   else if (cb->flag & (1<<CPF_TOBLK)) /* A2blk */
   {
      if (cb->flag & (1<<CPF_REAL))
         args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*";
      else
         args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,"
                "TYPE*,TYPE*";
   }
   else /* blk2A */
   {
      if (cb->flag & (1<<CPF_REAL))
         args = "ATL_CSZT,ATL_CSZT,const SCALAR, const TYPE*,ATL_CSZT,TYPE*";
      else
         args = "ATL_CSZT,ATL_CSZT,const SCALAR, const TYPE*,ATL_CSZT,"
                "TYPE*,TYPE*";
   }
   for (cp=cb; cp; cp = cp->next)
      fprintf(fp, "void %s\n   (%s);\n", cp->rout, args);
@skip   fprintf(fp, "\n#endif\n");
   KillAllCPNodes(cb);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   fprintf(stderr, 
      "This program generates copy header files for lists of kernels.\n"
      "It will generate seperate header file for each alpha/beta combo.\n");
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -p [d,s,c,z]\n");
   fprintf(stderr, "   -o /path : specify directory to generate into\n");
   fprintf(stderr,
   "   -V [C,A]a=1,N,X Cb=0,1,N,X [A,C]d=I,F <name> mmview.sum:\n");
   fprintf(stderr, 
"      Any of the = args may be ommitted, which means all values are set.\n"
"      <name> and <mmview> must appear in that order.\n"
"      A/Cd=[I,F]: copy Into or From col-major (I,F means both directions).\n"
"      A/Ca/b give the list of needed alpha/beta for that matrix copy.\n"
"      <name> is a unique string that will be used in all header files.\n"
"      mmview.sum: list of amm kerns demanding the copies.\n");
   exit(ierr ? ierr : -1);
}

ATL_view_t *GetFlags(int nargs, char **args, char *PRE, char **PTH)
{
   ATL_view_t *vb=NULL;
   char *pth=NULL, *nm=NULL;
   int i;
   char pre='d', dir='I';

   for (i=1; i < nargs; i++)
   {
      ATL_view_t *vp;
      char *nam;
      int k, flag=0;

      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'p':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         pre = tolower(args[i][0]);
         assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
         break;
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         pth = DupString(args[i]);
         break;
      case 'V': /* -V C/Aa=1,N,X Cb=0,1,N,X C/Ad=I,F <name> mmview.sum */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         flag = 0;
         for (k=0; k < 5; k++)
         {
            char mt, wt;
            int st;
            mt = args[i][0];
            if (mt != 'C' && mt != 'A')
               break;
            wt = args[i][1];
            if (wt != 'a' && wt != 'b' && wt != 'd')
               break;
            if (args[i][2] != '=')
               break;
            if (wt == 'b')
            {
               assert(mt == 'C');
               flag |= CPV_ScalStr2bits(args[i]+3, CPV_BE1C);
            }
            else if (wt == 'a')
               flag |= CPV_ScalStr2bits(args[i]+3, (mt=='C')?CPV_AL1C:CPV_AL1A);
            else if (wt == 'd')
               flag |= CPV_DirStr2bits(args[i]+3,(mt=='C')?CPV_C2BLK:CPV_A2BLK);
            else
               PrintUsage(args[0], i-1, NULL);
            if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
         }
         nam = DupString(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         vp = ATL_NewView(flag, nam, DupString(args[i]));
         vp->next = vb;
         vb = vp;
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   assert(vb);
   if (!pth)
      pth = DupString("tmp");
   *PRE = pre;
   *PTH = pth;
   return(vb);
}

void GenHead
(
   char pre,        /* s,d,c,z */
   char mtx,        /* C,A,B */
   char dir,        /* 'F': FromC, i.e. C2blk, 'I': blk2C */
   char calp,       /* 1,N,X */
   char cbet,       /* C:0,1,N,X or A:T,N */
   char *nm,        /* view name */
   char *pnam,      /* name with path */
   char *nam,       /* name without path */
   ATL_cpnode_t *cb /* queue of copies to produce header for */
)
{
   ATL_cpnode_t *cp;
   FILE *fpp, *fpd;
   char *sp, *arrnm;
   int i, flag, N;

   assert(cb);
   sp = strstr(nam, "ZZZZ");
   assert(sp);
   sp[0] = 'p';
   sp[1] = 'e';
   sp[2] = 'r';
   sp[3] = 'f';
   fpp = fopen(pnam, "w");
   assert(fpp);
   PrintBegIfdef(fpp, nam);
   sp[0] = 'd';
   sp[1] = 'e';
   sp[2] = 'c';
   sp[3] = 'l';
   fpd = fopen(pnam, "w");
   assert(fpd);
   PrintBegIfdef(fpd, nam);
   sp[0] = 'Z';
   sp[1] = 'Z';
   sp[2] = 'Z';
   sp[3] = 'Z';

   fprintf(fpd, "\n#include \"atlas_amm.h\"\n");
   fprintf(fpd, "/*\n * Prototypes\n */\n");
   PrintProtos(fpd, cb);
   fprintf(fpd, "/*\n * Index array\n */\n");
   N = ATL_CountNumberOfCPNodes(cb);
   if (mtx == 'C')
   {
      fprintf(fpd, "static const %s_t ATL_AMM_%s_a%c_b%c[%d] =\n{\n",
              (dir=='F')?"cmat2ablk":"ablk2cmat", (dir=='F')?"BLK2C":"C2BLK",
              calp, cbet, N);
      fprintf(fpp, "static const float ATL_AMM_%sTIME_a%cb%c[%d] = \n{\n",
              (dir=='F')?"C2BLK":"BLK2C", calp, cbet, N);
   }
   else /* A or B */
   {
      char *bn;
      if (dir == 'F')
      {
         if (cbet == 'N')
            bn = (mtx == 'A') ? "AN2BLK" : "BN2BLK";
         else if (cbet == 'C')
            bn = (mtx == 'A') ? "AC2BLK" : "BC2BLK";
         else if (cbet == 'H')
            bn = (mtx == 'A') ? "AH2BLK" : "BH2BLK";
         else
            bn = (mtx == 'A') ? "AT2BLK" : "BT2BLK";
         fprintf(fpd,"static const cm2am_t ATL_AMM_%s_a%c[%d] =\n{\n",
                 bn, calp, N);
      }
      else
      {
         if (cbet == 'N')
            bn = (mtx == 'A') ? "BLK2AN" : "BLK2BN";
         else if (cbet == 'C')
            bn = (mtx == 'A') ? "BLK2AC" : "BLK2BC";
         else if (cbet == 'H')
            bn = (mtx == 'A') ? "BLK2AH" : "BLK2BH";
         else
            bn = (mtx == 'A') ? "BLK2AT" : "BLK2BT";
         if (mtx == 'A')
            bn = (cbet == 'N') ? "BLK2AN" : "BLK2AT";
         else
            bn = (cbet == 'N') ? "BLK2BN" : "BLK2BT";
         fprintf(fpd,"static const am2cm_t ATL_AMM_%s_a%c[%d] =\n{\n",
                 bn, calp, N);
      }
      fprintf(fpp, "static const float ATL_AMM_%stime_a%c[%d] = \n{\n",
              bn, calp, N);
   }
   for (i=0,cp=cb; cp; i++, cp = cp->next)
   {
      fprintf(fpd, "/* IDX=%3d */ %s%c\n", i, cp->rout, cp->next?',':' ');
      fprintf(fpp, "/* IDX=%3d */ %e%c\n", i, cp->mflop[0], cp->next?',':' ');
   }
   fprintf(fpd, "};\n\n");
   fprintf(fpp, "};\n\n");

   fprintf(fpp, "#endif  /* end ifdef guard */\n");
   fprintf(fpd, "#endif  /* end ifdef guard */\n");
   fclose(fpp);
   fclose(fpd);
}

void GenAllCHeadDir(char pre, char *path, ATL_view_t *vp, ATL_mmnode_t *mb,
                    ATL_cpnode_t *CB)
{
   int tlen, nlen, plen, ia, ib, d;
   char *nam, *tnam;
         /* atlas_<pre><nm>_[Into,From]Cxxxx_aXbX.h */
   char iscls[4]={1, -1, 2, 0};
   char cscls[4]={'1', 'N', 'X', '0'};

   plen = strlen(path) + 1;
   nlen = strlen(vp->nam);
   tlen = plen + 6 + 1 + nlen + 1 + 4 + 13 + 1;
   tnam = malloc(tlen*sizeof(char));
   assert(tnam);
   nam = tnam + plen;

   d = sprintf(tnam, "%s/atlas_%c%s_FromCZZZZ_aXbX.h", path, pre, vp->nam);
   assert(d < tlen);
   for (d=0; d < 2; d++)
   {
      const char dir = d ? 'I' : 'F';
      if (!(vp->flag &(1<<(CPV_C2BLK+d))))
         continue;
      if (d)
      {
         char *sp;
         sp = strstr(tnam, "FromC");
         sp[0] = 'I';
         sp[1] = 'n';
         sp[2] = 't';
         sp[3] = 'o';
      }
      for (ib=0; ib < 4; ib++)
      {
         const char cbet=cscls[ib];

         if (!(vp->flag &(1<<(CPV_BE1C+ib))))
            continue;
         nam[nlen+21] = cbet;
         for (ia=0; ia < 3; ia++)
         {
            ATL_cpnode_t *cb, *cp;
            const char calp=cscls[ia];
            int flag;

            if (!(vp->flag &(1<<(CPV_AL1C+ia))))
               continue;
            nam[nlen+19] = calp;
            flag = CopyEncode(pre, d?'F':'I', 'C', 'N');
            flag = CopyEncodeScal(flag, iscls[ia], iscls[ib]);
            cb = MMGetCopiesFromList(flag, mb, CB);
            for (cp=cb; cp; cp = cp->next)
            {
               if (cp->rout)
                  free(cp->rout);
               cp->rout = GetCopyName(cp,0);
            }
            GenHead(pre, 'C', dir, calp, cbet, vp->nam, tnam, nam, cb);
            KillAllCPNodes(cb);
         }
      }
   }
   free(tnam);
}

void GenAllAHeadDir(char pre, char *path, ATL_view_t *vp, ATL_mmnode_t *mb,
                    ATL_cpnode_t *CB)
{
   int tlen, nlen, plen, ia, it, d;
   const int nta = (pre == 'c' || pre == 'z') ? 4 : 2;
   char *nam, *tnam;
         /* atlas_<pre><nm>_[Into,From]A[T,N]xxxx_aX.h */
   char iscls[3]={1, -1, 2};
   char cscls[3]={'1', 'N', 'X'};
   char ctas[4] = {'N', 'T', 'C', 'H'};

   plen = strlen(path) + 1;
   nlen = strlen(vp->nam);
   tlen = plen + 6 + 1 + nlen + 1 + 4 + 12 + 1;
   tnam = malloc(tlen*sizeof(char));
   assert(tnam);
   nam = tnam + plen;

   d = sprintf(tnam, "%s/atlas_%c%s_FromANZZZZ_aX.h", path, pre, vp->nam);
   assert(d < tlen);
   for (d=0; d < 2; d++)
   {
      const char dir = d ? 'I' : 'F';
      if (!(vp->flag &(1<<(CPV_A2BLK+d))))
         continue;
      if (d)
      {
         char *sp;
         sp = strstr(tnam, "FromA");
         sp[0] = 'I';
         sp[1] = 'n';
         sp[2] = 't';
         sp[3] = 'o';
      }
      for (it=0; it < nta; it++)
      {
         const char cta = ctas[it];

         nam[nlen+13] = cta;
         for (ia=0; ia < 3; ia++)
         {
            ATL_cpnode_t *cb, *cp;
            const char calp=cscls[ia];
            int flag;

            if (!(vp->flag &(1<<(CPV_AL1A+ia))))
               continue;
            nam[nlen+20] = calp;
            flag = CopyEncode(pre, d?'F':'I', 'A', 'N');
            flag = CopyEncodeScal(flag, iscls[ia], 0);
            cb = MMGetCopiesFromList(flag, mb, CB);
            nam[nlen+12] = 'A';
            CopyFixTransByMtx('A', cta, cb);
            GenHead(pre, 'A', dir, calp, cta, vp->nam, tnam, nam, cb);
            KillAllCPNodes(cb);
            cb = MMGetCopiesFromList(flag & ~(1<<(CPF_ABLK)), mb, CB);
            nam[nlen+12] = 'B';
            CopyFixTransByMtx('B', cta, cb);
            GenHead(pre, 'B', dir, calp, cta, vp->nam, tnam, nam, cb);
            KillAllCPNodes(cb);
         }
      }
   }
   free(tnam);
}

int main(int nargs, char **args)
{
   ATL_view_t *vb, *vp;
   char *path, *nm;
   char pre, dir;
   ATL_cpnode_t *cb;

   vb = GetFlags(nargs, args, &pre, &path);
   cb = ReadCPFileWithPath(pre, "res", "cpyPERF.CPS");
   for (vp=vb; vp; vp = vp->next)
   {
      ATL_mmnode_t *mb;
      mb = ReadMMFile(vp->fnam);
      GenAllCHeadDir(pre, path, vp, mb, cb);
      GenAllAHeadDir(pre, path, vp, mb, cb);
      KillAllMMNodes(mb);
   }

   KillAllViews(vb);
   KillAllCPNodes(cb);
   free(path);
   return(0);
}
@ROUT cpydrv
#include "atlas_mmgen.h"
#define uint unsigned int

ATL_cpnode_t **SplitList(char pre, ATL_cpnode_t *cb, int *NLIST, uint **FLAGS)
/*
 * Splits cb according to GetCopyMatches, returns number of non-NULL lists
 * in *NLIST, and the non-NULL flag values in FLGS.
 * RETURNS: *NLIST-length array of lists
 */
{
@skip   char fn[32]={'c','p','y','P','E','R','F','_'};
@skip   char *sp;
   int ik; /* loop over kernels, which can be incoherent */
   int nlist=0, nalloc;
   int *flags;
   ATL_cpnode_t **lists;

   nalloc = 8;
   lists = malloc(nalloc*sizeof(ATL_cpnode_t *));
   flags = malloc(nalloc*sizeof(int));
   assert(lists && flags);

   CopyApplyBlasRules(cb);
   for (ik=CPF_SYRK-1; ik <= CPF_TRSM; ik++)
   {
      int ic; /* CBLK unset or set */
      for (ic=0; ic < 2; ic++)
      {
         const int B0=(ic)?CPF_BE1:0, BN=(ic)?CPF_BE0:1;
         int id; /* TOBLK unset or set */
         for (id=0; id < 2; id++)
         {
            int ia;
            for (ia=CPF_AL1; ia <= CPF_ALX; ia++)
            {
               int ib;

               for (ib=B0; ib <= BN; ib++)
               {
                  const int HN = (ic || pre == 'd' || pre == 's') ? 0 : 1;
                  int ih;
                  for (ih=0; ih <= HN; ih++)
                  {
                     ATL_cpnode_t *bp;
                     int flag;
                     flag = (id<<CPF_TOBLK)|(ic<<CPF_CBLK)|(1<<ia);
                     flag |= (ik >= CPF_SYRK) ? (1<<ik) : 0;
                     if (ic)
                        flag |= 1<<ib;
                     else
                        flag |= (ib<<CPF_TRANS)|(ih<<CPF_CONJ);
                     bp = GetCopyMatches(cb, flag);
                     if (bp)
                     {
                        if (nlist == nalloc)
                        {
                           nalloc = nlist + 4;
                           lists = realloc(lists,nalloc*sizeof(ATL_cpnode_t *));
                           flags = realloc(flags,nalloc*sizeof(int));
                        }
                        lists[nlist] = bp;
                        flags[nlist++] = flag;
                     }
                  }
               }
            }
         }
      }
   }
   *NLIST = nlist;
   *FLAGS = flags;
   return(lists);
}

unsigned int CountRegion(int N, ATL_cpnode_t **cbs)
{
   const uint mask=(CPF_ALLKERN|(1<<CPF_CBLK)), flag=(cbs[0]->flag)&mask;
   uint i;

   for (i=1; i < N; i++)
      if (flag != ((cbs[i]->flag)&mask))
         return(i);
   return(N);
}

uint *CountMoveShared(const uint N,  ATL_cpnode_t **cbs)
{
   uint *cnts;
   ATL_cpnode_t *cp=cbs[0];
   uint i, ioff, nxtoff;

   cnts = malloc(N*sizeof(uint));
   assert(cnts);
   ioff = GetOffset(&cp->flag, cp);
   nxtoff = GetOffset(&cp->next, cp);
   for (i=0; i < N; i++)
   {
      uint j;
/*
 *    Mark all files duplicated between i and remaining lists
 */
      for (j=i+1; j < N; j++)
         CopyMarkDup_noscal(cbs[i], cbs[j]);
/*
 *    Move all duplicated entries to beginning of list
 */
      cbs[i] = CopySortMarkedFirst(cbs[i]);
      cnts[i] = CountListMaskALL(cbs[i], (1<<CPF_TMP), nxtoff, ioff);
   }
   return(cnts);
}

void SortByCount(uint N, uint *nshar,  ATL_cpnode_t **cbs, uint *flgs)
{
   uint i;
   for (i=0; i < N; i++)
      printf("nshar= %u (of %u)\n", nshar[i], ATL_CountNumberOfCPNodes(cbs[i]));
}

void CohereLists(const uint N, ATL_cpnode_t **cbs, uint *flgs)
/*
 * cbs already sorted in precedence: kernel, mtx (C/A).
 * The indices of a given kernel must match in all kern,mtx lists, despite
 * the fact that views may make it so these lists contain different numbers
 * and types of cp funcs.  The idea that shared funcs between kern,mtx lists
 * share the same index regardless of file length means that the lists COHERE.
 *
 * Therefore, to make the files within a given region cohere, we figure out
 * how many files are in the region, and then within this region we sort
 * the lists from least number of shared files to most.
 * Each list is sorted so all shared files come first, and then the files
 * with least number of shared kernels dictate where all longer lists locate
 * their corresponding files.
 */
{
   int n, i=0;
   do
   {
      unsigned int *nshar;

      n = CountRegion(N-i, cbs);
      nshar = CountMoveShared(n, cbs);
      SortByCount(n, nshar, cbs, flgs);

      cbs += n;
      flgs += n;
      i += n;
      free(nshar);
   }
   while (i < N);
}
void CreateMasterIdx(char pre)
{
   ATL_cpnode_t *cb, **cbs;
   FILE *fp;
   unsigned int *flgs;
   unsigned int N, i;
   const unsigned int msk=~((1<<CPF_MVEC)|(1<<CPF_NVEC)|(1<<CPF_ASM)|
      (1<<CPF_TMP));
   char fn[32]={'r','e','s','/',pre,'m','a','s','t','e','r','.','C','P','I',0};

   cb = ReadCPFileWithPath(pre, "res", "cpyPERF.CPS");
   assert(cb);
   cbs = SplitList(pre, cb, &N, &flgs);
   KillAllCPNodes(cb);
   CohereLists(N, cbs, flgs);
/*
 * Write out master list of used copy kernels
 */
   fp = fopen(fn, "w");
   assert(fp);
   fprintf(fp, "%u\n", N);
   for (i=0; i < N; i++)
   {
      char *sp;
      unsigned int flag;
      cb = cbs[i];
      flag = cb->flag & msk;
      sp = CopyFlag2Str(flag);
      fprintf(fp, "%x '%s'\n", flag, sp);
   }
   fclose(fp);

   for (i=0; i < N; i++)
      KillAllCPNodes(cbs[i]);
   free(cbs);
   free(flgs);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   fprintf(stderr, 
"This program is a driver for searching & generating all copy kernels.\n"
"Output file of cumulative views: res/<pre>full.CPS, used for xcpygen.\n"
"Delete this file if you get kerns you don't need in a prior search.\n"
"You can either invoke this driver routine multiple times, or repeat\n"
"the -V flag.\n");

   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr,"USAGE: %s [flags:\n", name);
   fprintf(stderr,"   -p [d,s,c,z]\n");
   fprintf(stderr,"   -z <minsz>: (24*24) demand mb*nb>minsz\n");
   fprintf(stderr, "   -o /path : specify directory to generate into\n");
   fprintf(stderr,
   "   -V [C,A]a=1,N,X Cb=0,1,N,X [A,C]d=I,F <name> mmview.sum:\n");
   fprintf(stderr, 
"      Any of the = args may be ommitted, which means all values are set.\n"
"      <name> and <mmview> must appear in that order.\n"
"      A/Cd=[I,F]: copy Into or From col-major (I,F means both directions).\n"
"      A/Ca/b give the list of needed alpha/beta for that matrix copy.\n"
"      <name> is a unique string that will be used in all header files.\n"
"      mmview.sum: list of amm kerns demanding the copies.\n");
   exit(ierr ? ierr : -1);
}

ATL_view_t *GetFlags
   (int nargs, char **args, char *PRE, char **PTH, int *MINSZ)
{
   ATL_view_t *vb=NULL, *vp;
   char *pth=NULL;
   int i, minSz=24*24;
   char pre='d';

   for (i=1; i < nargs; i++)
   {
      char *nam;
      int k, flag;
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'p':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         pre = tolower(args[i][0]);
         assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
         break;
      case 'z':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         minSz = atoi(args[i]);
         break;
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         pth = DupString(args[i]);
         break;
      case 'V': /* -V C/Aa=1,N,X Cb=0,1,N,X C/Ad=I,F <name> mmview.sum */
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         flag = 0;
         for (k=0; k < 5; k++)
         {
            char mt, wt;
            int st;
            mt = args[i][0];
            if (mt != 'C' && mt != 'A')
               break;
            wt = args[i][1];
            if (wt != 'a' && wt != 'b' && wt != 'd')
               break;
            if (args[i][2] != '=')
               break;
            if (wt == 'b')
            {
               assert(mt == 'C');
               flag |= CPV_ScalStr2bits(args[i]+3, CPV_BE1C);
            }
            else if (wt == 'a')
               flag |= CPV_ScalStr2bits(args[i]+3, (mt=='C')?CPV_AL1C:CPV_AL1A);
            else if (wt == 'd')
               flag |= CPV_DirStr2bits(args[i]+3,(mt=='C')?CPV_C2BLK:CPV_A2BLK);
            else
               PrintUsage(args[0], i-1, NULL);
            if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
         }
         nam = DupString(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         vp = ATL_NewView(flag, nam, DupString(args[i]));
         vp->next = vb;
         vb = vp;
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   assert(vb);
   if (!pth)
      pth = DupString("tmp");
   *PTH = pth;
   *PRE = pre;
   *MINSZ = minSz;
   return(vb);
}

ATL_cpnode_t *GetAllCopy(char pre, ATL_view_t *vb, int minSz)
{
   int d;

   ATL_cpnode_t *cb=NULL, *cbC=NULL, *cp;
   for (d=0; d < 2; d++)  /* 0: M2BLK, 1: BLK2M */
   {
      int a;
      for (a=0; a < 3; a++) /* 0:alp=1, 1:alp=-1, 2:alp=X */
      {
         ATL_view_t *vp;
         for (vp=vb; vp; vp = vp->next) /* scope all input views */
         {
            const int vflg=vp->flag;
            int flg;
            int b;

            flg = (d) ? 0 : (1<<CPF_TOBLK);
            flg |= 1<<(CPF_AL1+a);
            if (pre == 'd')
               flg |= (1<<CPF_REAL);
            else if (pre == 's')
               flg |= (1<<CPF_REAL) | (1<<CPF_SINGLE);
            else if (pre == 'c')
               flg |= (1<<CPF_SINGLE);
/*
 *          Add copies A needs from all views (TRANS added later) 
 */
            if ((vflg&(1<<(CPV_A2BLK+d))) && (vflg&(1<<(CPV_AL1A+a))))
            {
               ATL_mmnode_t *mb;
               ATL_cpnode_t *bb;
               mb = ReadMMFile(vp->fnam);
               assert(mb);
               bb = GetAllCopyNodesFromMM(flg, mb);
               if (bb)
               {
                  cp = ATL_LastCPNode(bb);
                  cp->next = cb;
                  cb = bb;
                  bb = GetAllCopyNodesFromMM(flg|(1<<CPF_ABLK), mb);
                  cp = ATL_LastCPNode(bb);
                  cp->next = cb;
                  cb = bb;
               }
               KillAllMMNodes(mb);
            }

            if (!(vflg&(1<<(CPV_AL1C+a))))
               continue;
            if (!(vflg&(1<<(CPV_C2BLK+d))))
               continue;
            flg |= 1<<CPF_CBLK;
            for (b=0; b < 4; b++) /* 0:beta=1, 1:beta=N, 2:beta=X, 3:beta=0 */
            {
               flg &= ~CPF_ALLBET;
               flg |= 1<<(CPF_BE1+b);
               if (vflg & (1<<(CPV_BE1C+b)))
               {
                  ATL_mmnode_t *mb;
                  ATL_cpnode_t *bb;
                  mb = ReadMMFile(vp->fnam);
                  assert(mb);
                  bb = GetAllCopyNodesFromMM(flg, mb);
                  if (bb)
                  {
                     cp = ATL_LastCPNode(bb);
                     cp->next = cbC;
                     cbC = bb;
                  }
                  KillAllMMNodes(mb);
               }
            }
         }  /* end search thru views */
      }
   }
/*
 * Having added all copies from views that matched, get rid of dups
 */
   if (cb)
   {
      ATL_cpnode_t *b, *last;
      cb = CopyNoRep(cb, minSz);
      last = b = CloneCPQueue(cb);
      for (cp=b; cp; cp = cp->next)
      {
         cp->flag |= 1<<CPF_TRANS;
         last = cp;
      }
      last->next = cb;
      cb = b;
   }
   cbC = CopyNoRep(cbC, minSz);
   if (cb)
   {
      cp = ATL_LastCPNode(cb);
      cp->next = cbC;
   }
   else
      cb = cbC;
   for (cp=cb; cp; cp = cp->next)
   {
      if (!cp->ID && cp->rout)  /* generated filenames should be */
      {                         /* regenerated & set to ouput name */
         free(cp->rout);
         cp->rout = NULL;
      }
   }
   WriteCPFileWithPath(pre, "res", "cpylst.CPS", cb);
   return(cb);
}

void DoSearch(char pre)
{
   char *ln;
   ln = DupString("./xcpysearch -i res/Xcpylst.CPS -o res/XcpyPERF.CPS");
   ln[20] = ln[39] = pre;
   assert(!Sys2File(ln, "stdout"));
   free(ln);
}

void DoGen(char pre, char *path)
{
   char *ln;
   ln = NewMergedString("./xcpygen -i res/XcpyPERF.CPS -o ", path);
   ln[17] = pre;
   assert(!Sys2File(ln, NULL));
   free(ln);
}

void DoGenH(char pre, char *path, ATL_view_t *vb)
{
   ATL_view_t *vp;
   int plen;

   plen=strlen(path);
   for (vp=vb; vp; vp = vp->next)
   {
      char *ln, *sp, *va;
      int len, d;

      va = View2Args(vp);
      len = 20 + strlen(va) + plen;
      ln = malloc(len*sizeof(char));
      assert(ln);
      d = sprintf(ln, "./xcphgen -p %c %s -o %s", pre, va, path);
      assert(d < len);
      assert(!Sys2File(ln, NULL));
      free(va);
      free(ln);
   }
}

/*
 * xcpydrv -Vs -o cpylst.CPS | xcpysearch -o cpyPERF.CPS | xcpygen/xcphgen
 */
int main(int nargs, char **args)
{
   ATL_view_t *vb=NULL, *vp;  /* view base & ptr */
   ATL_cpnode_t *cb=NULL, *op;   /* cpsearch output files */
   char *path, *ln;
   int minSz;
   char pre;

   vb = GetFlags(nargs, args, &pre, &path, &minSz);
   cb = GetAllCopy(pre, vb, minSz);
   KillAllCPNodes(cb);
   DoSearch(pre);
   CreateMasterIdx(pre);
   DoGen(pre, path);
   DoGenH(pre, path, vb);
   KillAllViews(vb);
   free(path);
   return(0);
}
