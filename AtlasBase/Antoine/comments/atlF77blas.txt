@skip
@skip Comments of the ATLAS F77 interface                              AP00
@skip
@skip Last modification : 03/24/00
@skip
@skip      C      V                      D                             V12345678
@skip
@define BLAS_PAPERS            @@(ATLAS_F77_SRC_COMMENT) rout=papers@
@skip
@rout papers
@extract @(FURTHER_DETAILS)
*
*  For further information on the Level 1 BLAS specification, see:
*
*  ``A Proposal for Standard Linear Algebra Subprograms''  by R. Hanson,
*  F. Krogh and C. Lawson, ACM SIGNUM Newsl., 8(16), 1973,
*
*  ``Basic Linear Algebra Subprograms for Fortran Usage''  by C. Lawson,
*  R. Hanson, D. Kincaid and F. Krogh,  ACM Transactions on Mathematical
*  Software, 5(3) pp 308-323, 1979.        
*
*  For further information on the Level 2 BLAS specification, see:
*
*  ``An  Extended Set of  FORTRAN  Basic Linear Algebra Subprograms'' by
*  J. Dongarra,  J. Du Croz,  S. Hammarling and R. Hanson,  ACM Transac-
*  tions on Mathematical Software, 14(1) pp 1-17, 1988.
*
*  ``Algorithm 656: An extended Set of Basic Linear Algebra Subprograms:
*  Model Implementation and Test Programs''  by J. Dongarra, J. Du Croz,
*  S. Hammarling and R. Hanson,  ACM  Transactions on Mathematical Soft-
*  ware, 14(1) pp 18-32, 1988.
*
*  For further information on the Level 3 BLAS specification, see:
*
*  ``A Set of Level 3 Basic Linear Algebra Subprograms'' by J. Dongarra,
*  J. Du Croz, I. Duff and S. Hammarling, ACM Transactions on Mathemati-
*  cal Software, 16(1), pp 1-17, 1990.
@skip
@skip
@rout lsame
@extract @(PURPOSE)
*
*  @(rname) returns .TRUE. if CA is the same letter as CB regardless of ca-
*  se. 
*
@extract @(NOTES)
*
*  This routine is identical to the LSAME function provided in LAPACK.
*
@extract @(ARGUMENTS)
*
*  CA, CB  (input)                       CHARACTER*1
*          CA and CB specify the single characters to be compared.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout xerbla
@extract @(PURPOSE)
* 
*  @(rname) is an error handler for the  BLAS  routines. It is called by a
*  BLAS routine if an input parameter has an invalid value. A message is
*  printed.  Installers  may consider modifying this routine in order to 
*  call system-specific exception-handling facilities.
*
@extract @(ARGUMENTS)
*
*  SRNAME  (input)                       CHARACTER*6
*          The name of the routine which called @(rname).
*
*  INFO    (input)                       INTEGER
*          The  position  of the invalid parameter in the parameter list
*          of the calling routine.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout dcabs1
@extract @(PURPOSE)
*
*  @(rname) returns |real( z )| + |imag( z )|  where z is a double complex
*  number.
*
@extract @(ARGUMENTS)
*
*  Z       (input)                       COMPLEX*16
*          On entry, the complex number z.
*
@extract @(LINE)
@skip
@skip
@rout rotg
@extract @(PURPOSE)
*
*  @(rname)  constructs a Givens plane rotation. Given the scalars a and b,
*  this routine computes the following quantities:
*
@type real dble
*     sigma = sgn(a) if |a| > |b|, sgn(b) otherwise;
*     r     = sigma * sqrt( a^2 + b^2 );
*     c     = a / r if r <> 0, 1 otherwise;
*     s     = b / r if r <> 0, 0 otherwise.
*
*  The numbers c, s and r then satisfy the matrix equation:
*
*     [ c  s ] [ a ]    [ r ]
*     [ -s c ] [ b ] =  [ 0 ].
*
*  The introduction of  sigma  is not essential  to the computation of a
*  Givens rotation matrix, but it permits later stable reconstruction of
*  c and s from just one stored number.  For  this purpose, this routine
*  also computes 
*
*          s        if |a| > |b|,
*     z =  1 / c    if |b| >= |a| and c <> 0,
*          1        if c = 0. 
*
*  This subroutine returns r overwriting a, and z overwriting b, as well
*  as returning c and s. If one later wishes to reconstruct c and s from
*  z, it can be done as follows:
*
*     if  z  = 1,    set c = 0             and s = 1,
*     if |z| < 1,    set c = sqrt(1 - z^2) and s = z,
*     if |z| > 1,    set c = 1 / z         and s = sqrt(1 - c^2).
@type cplx zplx
*  if |a| = 0, then c = 0, s = 1, and r = b; 
*  and otherwise:
*     norm = sqrt( |a|^2 + |b|^2 );
*     c    = |a| / norm;
*     s    = a * conjg( b ) / ( |a| * norm );
*     r    = a / ( |a| * norm );
@type real dble cplx zplx
*
@extract @(ARGUMENTS)
*
*  A       (input/output)                @(type_comm)
*          On entry, A specifies the scalar a. On exit, A is overwritten
*          by the scalar r defined above.
*
@type real dble
*  B       (input/output)                @(type_comm)
*          On entry, B specifies the scalar b. On exit, B is overwritten
*          by the scalar z defined above.
@type cplx zplx
*  B       (input)                       @(type_comm)
*          On entry, B  specifies the scalar b. Unchanged on exit.
@type real dble cplx zplx
*
*  C       (output)                      @(utyp_comm)
*          On exit, C  specifies the scalar c defined above.
*
*  S       (output)                      @(type_comm)
*          On exit, S  specifies the scalar s defined above.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout rotmg
@extract @(PURPOSE)
*
*  @(rname) constructs the modified-Givens plane rotation.  The input sca-
*  lars d1, d2, x1 and y1 define a 2-vector [a1 a2]' such that
*
*     [ a1 ]   [ d1^{1/2}  0      ] [ x1 ]
*     [ a2 ] = [   0     d2^{1/2} ] [ y1 ].
*
*  This subroutine determines the modified Givens rotation matrix H that
*  transforms y1 and thus a2 to zero. A representation of this matrix is
*  stored in the output array PARAM.
* 
@extract @(ARGUMENTS)
*
*  D1      (input/output)                @(type_comm)
*          On entry, D1 specifies the scalar d1.
*
*  D2      (input/output)                @(type_comm)
*          On entry, D2 specifies the scalar d2.
*
*  X1      (input/output)                @(type_comm)
*          On entry, X1 specifies the scalar x1.
*
*  Y1      (input)                       @(type_comm)
*          On entry, Y1 specifies the scalar y1. Unchanged on exit.
*
*  PARAM   (output)                      @(type_comm) array
*          On entry, PARAM is an array of dimension at least 5. On exit,
*          the entries of this array have the following meaning:
*
*          if PARAM( 1 ) = 1,
*             h_12 = 1, h_21 = -1, PARAM( 2 ) = h_11, PARAM( 5 ) = h_22,
*             and the other entries of PARAM are left unchanged; 
*          else if PARAM( 1 ) = 0,
*             h_11 = 1, h_22 =  1, PARAM( 3 ) = h_21, PARAM( 4 ) = h_12,
*             and the other entries of PARAM are left unchanged; 
*          else if PARAM( 1 ) = -1, (case of re-scaling)
*             PARAM( 2 ) = h_11, PARAM( 3 ) = h_21,
*             PARAM( 4 ) = h_12, PARAM( 5 ) = h_22;
*          else if PARAM( 1 ) = -2,
*             H = I, and the other entries of PARAM are left unchanged;
*          end if
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout nrm2
@extract @(PURPOSE)
*
*  @(rname) returns the 2-norm of an n-vector x.
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the length of the vector x. N  must  be
*          at least zero. Unchanged on exit.
*
*  X       (input)                       @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) )  that  contains the vector x.
*          Unchanged on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout asum
@extract @(PURPOSE)
*
*  @6l@(rname)  returns the sum of absolute values of the entries of a vector
*  x.
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the length of the vector x. N  must  be
*          at least zero. Unchanged on exit.
*
*  X       (input)                       @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) )  that  contains the vector x.
*          Unchanged on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE) 
@skip
@skip
@rout amax
@extract @(PURPOSE)
*
*  @(rname) returns the index in an n-vector x of the first element having
*  maximum absolute value.
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the length of the vector x. N  must  be
*          at least zero. Unchanged on exit.
*
*  X       (input)                       @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) )  that  contains the vector x.
*          Unchanged on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout scal
@extract @(PURPOSE)
*
*  @(rname) performs the following operation:
*
*     x := alpha * x,
*
@type real dble cplx zplx
*  where alpha is a scalar and x is an n-vector.
@type chex zhex
*  where alpha is a real scalar and x is an n-vector.
@type real dble cplx zplx chex zhex
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the length of the vector x. N  must  be
*          at least zero. Unchanged on exit.
*
@type real dble cplx zplx
*  ALPHA   (input)                       @(type_comm)
@type chex zhex
*  ALPHA   (input)                       @(utyp_comm)
@type real dble cplx zplx chex zhex
*          On entry, ALPHA specifies the scalar alpha.   When  ALPHA  is
*          supplied as zero, then the entries of the incremented array X
*          need not be set on input. Unchanged on exit.
*
*  X       (input/output)                @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) )  that  contains the vector x.
*          On exit, the entries of the incremented array X are mutiplied
*          by alpha.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout axpy
@extract @(PURPOSE)
*
*  @(rname) performs the following operation:
*
*     y := y + alpha * x,
*
*  where alpha is a scalar and x and y are two n-vectors. 
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the length of the vector x. N  must  be
*          at least zero. Unchanged on exit.
*
*  ALPHA   (input)                       @(type_comm)
*          On entry, ALPHA specifies the scalar alpha.   When  ALPHA  is
*          supplied as zero, then the entries of the incremented array X
*          need not be set on input. Unchanged on exit.
*
*  X       (input)                       @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) )  that  contains the vector x.
*          Unchanged on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
*  Y       (input/output)                @(type_comm) array
*          On entry,  Y  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCY ) )  that  contains the vector y.
*          On exit, the entries of the incremented array  Y  are updated
*          with the scaled entries of the incremented array  X.
*
*  INCY    (input)                       INTEGER
*          On entry, INCY specifies the increment for the elements of Y.
*          INCY must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout copy
@extract @(PURPOSE)
*
*  @(rname) copies the entries of an n-vector x into an n-vector y.
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the length of the vector x. N  must  be
*          at least zero. Unchanged on exit.
*
*  X       (input)                       @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) )  that  contains the vector x.
*          Unchanged on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
*  Y       (input/output)                @(type_comm) array
*          On entry,  Y  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCY ) )  that  contains the vector y.
*          On exit, the entries of the incremented array  X  are  copied
*          into the entries of the incremented array  Y.
*
*  INCY    (input)                       INTEGER
*          On entry, INCY specifies the increment for the elements of Y.
*          INCY must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout swap
@extract @(PURPOSE)
*
*  @(rname) swaps the entries of two n-vectors x and y.
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the length of the vector x. N  must  be
*          at least zero. Unchanged on exit.
*
*  X       (input/output)                @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) )  that  contains the vector x.
*          On exit, the entries of the incremented array  X  are swapped
*          with the entries of the incremented array  Y.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
*  Y       (input/output)                @(type_comm) array
*          On entry,  Y  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCY ) )  that  contains the vector y.
*          On exit, the entries of the incremented array  Y  are swapped
*          with the entries of the incremented array  X.
*
*  INCY    (input)                       INTEGER
*          On entry, INCY specifies the increment for the elements of Y.
*          INCY must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout rot
@extract @(PURPOSE)
*
*  @5l@(rname) applies  a  plane  rotation to the two n-vectors x and y.  This
*  routine computes:
*
*     [ x_i ]   [ c  s ] [ x_i ]
*     [ y_i ] = [ -s c ] [ y_i ]    for all i = 1 .. n.
*
*  If n <= 0 or if c = 1 and s = 0, this subroutine returns immediately.
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the length of the vector x. N  must  be
*          at least zero. Unchanged on exit.
*
*  X       (input/output)                @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) )  that  contains the vector x.
*          On exit, the entries of the incremented array  X  are rotated
*          with the entries of the incremented array  Y.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
*  Y       (input/output)                @(type_comm) array
*          On entry,  Y  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCY ) )  that  contains the vector y.
*          On exit, the entries of the incremented array  Y  are rotated
*          with the entries of the incremented array  X.
*
*  INCY    (input)                       INTEGER
*          On entry, INCY specifies the increment for the elements of Y.
*          INCY must not be zero. Unchanged on exit.
*
*  C       (input)                       @(utyp_comm)
*          On entry, C specifies the scalar c definiting the plane rota-
*          tion. Unchanged on exit.
*
*  S       (input)                       @(type_comm)
*          On entry, S specifies the scalar s definiting the plane rota-
*          tion. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout rotm
@extract @(PURPOSE)
*
*  @(rname) applies the modified-Givens rotation  H  stored in PARAM to the
*  two n-vectors x and y as follows:
*
*     [ x_i ]   [ h_11 h_12 ] [ x_i ]
*     [ y_i ] = [ h_21 h_22 ] [ y_i ]    for all i = 1 .. n.
*
*  If n <= 0 or if H is the identity matrix, this subroutine returns im-
*  mediately.
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the length of the vector x. N  must  be
*          at least zero. Unchanged on exit.
*
*  X       (input/output)                @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) )  that  contains the vector x.
*          On exit, the entries of the incremented array  X  are rotated
*          with the entries of the incremented array  Y.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
*  Y       (input/output)                @(type_comm) array
*          On entry,  Y  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCY ) )  that  contains the vector y.
*          On exit, the entries of the incremented array  Y  are rotated
*          with the entries of the incremented array  X.
*
*  INCY    (input)                       INTEGER
*          On entry, INCY specifies the increment for the elements of Y.
*          INCY must not be zero. Unchanged on exit.
*
*  PARAM   (input)                       @(type_comm) array
*          On entry, PARAM is an array of dimension at least 5 that con-
*          tains the matrix  H as encoded by the routine _ROTMG. Unchan-
*          ged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout dot
@extract @(PURPOSE)
*
@type real dble cplx zplx
*  @(rname) returns the dot product x^T * y of two n-vectors x and y.
@type chex zhex
*  @(rname) returns the dot product x^H * y of two n-vectors x and y.
@type real dble cplx zplx chex zhex
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the length of the vector x. N  must  be
*          at least zero. Unchanged on exit.
*
*  X       (input)                       @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) )  that  contains the vector x.
*          Unchanged on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
*  Y       (input)                       @(type_comm) array
*          On entry,  Y  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCY ) )  that  contains the vector y.
*          Unchanged on exit.
*
*  INCY    (input)                       INTEGER
*          On entry, INCY specifies the increment for the elements of Y.
*          INCY must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout dsdot
@extract @(PURPOSE)
*
*  @(rname)  returns the  dot product x^T * y of two n-vectors x and y. The
*  result is internally computed using double precision arithmetic.
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the length of the vector x. N  must  be
*          at least zero. Unchanged on exit.
*
*  X       (input)                       REAL array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) )  that  contains the vector x.
*          Unchanged on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
*  Y       (input)                       REAL array
*          On entry,  Y  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCY ) )  that  contains the vector y.
*          Unchanged on exit.
*
*  INCY    (input)                       INTEGER
*          On entry, INCY specifies the increment for the elements of Y.
*          INCY must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout sdsdot
@extract @(PURPOSE)
*
*  @(rname)  returns the dot product b + x^T * y of two n-vectors x and y.
*  The result  is internally computed  using double precision arithmetic
*  and casted to a single precision scalar just before being returned.
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the length of the vector x. N  must  be
*          at least zero. Unchanged on exit.
*
*  B       (input)                       REAL
*          On entry, B specifies the scalar b. Unchanged on exit.
*
*  X       (input)                       REAL array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) )  that  contains the vector x.
*          Unchanged on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
*  Y       (input)                       REAL array
*          On entry,  Y  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCY ) )  that  contains the vector y.
*          Unchanged on exit.
*
*  INCY    (input)                       INTEGER
*          On entry, INCY specifies the increment for the elements of Y.
*          INCY must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout gemv gbmv
@extract @(PURPOSE)
*
*  @(rname) performs one of the matrix-vector operations
*
@type real dble
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
@type cplx zplx
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   or
*
*     y := alpha*conjg( A' )*x + beta*y,
@type real dble cplx zplx
*
@rout gemv
*  where  alpha and beta are scalars, x and y are vectors and  A is an m
*  by n matrix.
@rout gbmv
*  where  alpha and beta are scalars, x and y are vectors and  A is an m
*  by n band matrix, with kl sub-diagonals and ku super-diagonals.
@rout gemv gbmv
*
@extract @(ARGUMENTS)
*
@extract @(TRANS_COMMENT)
*
*             TRANS = 'N' or 'n',    y := alpha*A *x + beta*y,
*
*             TRANS = 'T' or 't',    y := alpha*A'*x + beta*y,
*
@type real dble
*             TRANS = 'C' or 'c',    y := alpha*A'*x + beta*y.
@type cplx zplx
*             TRANS = 'C' or 'c',    y := alpha*conjg( A' )*x + beta*y.
@type real dble cplx zplx
*
*          Unchanged on exit.
*
*  M       (input)                       INTEGER
*          On entry,  M  specifies the number of rows of  the matrix  A.
*          M must be at least zero. Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N  specifies the number of columns of the matrix A.
*          N  must be at least zero. Unchanged on exit.
@rout gbmv
*
*  KL      (input)                       INTEGER
*          On entry, KL specifies the number of sub-diagonals of the ma-
*          trix A. KL must satisfy  0 .le. KL. Unchanged on exit.
*  
*  KU      (input)                       INTEGER
*          On entry, KU specifies the number of  super-diagonals of  the
*          matrix A. KU must satisfy  0 .le. KU. Unchanged on exit.
@rout gemv gbmv
*
*  ALPHA   (input)                       @(type_comm)
*          On entry, ALPHA specifies the scalar alpha.   When  ALPHA  is
*          supplied as zero then  A and X  need not be set on input. Un-
*          changed on exit.
*
@rout gemv
*  A       (input)                       @(type_comm) array
*          On entry,  A  is an array of DIMENSION ( LDA, n ). Before en-
*          try, the leading m by n part of the array  A must contain the
*          matrix coefficients. Unchanged on exit.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in the calling (sub) program. LDA must be at least  max(1,m).
*          Unchanged on exit.
@rout gbmv
*  A       (input)                       @(type_comm) array
*          On entry,  A  is an array of DIMENSION ( LDA, n ). Before en-
*          try, the leading (kl+ku+1) by n part of the array A must con-
*          tain the matrix of coefficients, supplied column  by  column,
*          with the leading diagonal of the matrix in row (ku+1)  of the
*          array, the first super-diagonal starting at position 2 in row
*          ku,  the  first  sub-diagonal  starting  at position 1 in row
*          (ku+2), and so on. Elements in the array  A  that do not cor-
*          respond to elements in the band matrix (such as the top  left
*          ku by ku triangle) are not referenced.
*          The  following  program  segment  will transfer a band matrix
*          from conventional full matrix storage to band storage:
*
*                 DO 20, J = 1, N
*                    K = KU + 1 - J
*                    DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
*                       A( K + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Unchanged on exit.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in the calling (sub) program. LDA must be at least (kl+ku+1).
*          Unchanged on exit.
@rout gemv gbmv
*
*  X       (input)                       @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) ) when  TRANS = 'N' or 'n'  and 
*          at  least ( 1 + ( m - 1 ) * abs( INCX ) )  otherwise.  Before 
*          entry, the incremented array X must contain the vector x. Un-
*          changed on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
*  BETA    (input)                       @(type_comm)
*          On entry,  BETA  specifies the scalar  beta.   When  BETA  is
*          supplied as zero then Y  need not be set on input.  Unchanged
*          on exit. 
*
*  Y       (input/output)                @(type_comm) array
*          On entry,  Y  is an incremented array of dimension  at  least
*          ( 1 + ( m - 1 ) * abs( INCY ) ) when  TRANS = 'N' or 'n'  and
*          at  least ( 1 + ( n - 1 ) * abs( INCY ) )  otherwise.  Before
*          entry with BETA non-zero, the incremented array  Y  must con-
*          tain the vector y. On exit,  Y  is overwritten by the updated
*          vector y.
*
*  INCY    (input)                       INTEGER
*          On entry, INCY specifies the increment for the elements of Y.
*          INCY must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout symv sbmv spmv
@extract @(PURPOSE)
*
*  @(rname) performs the matrix-vector operation
*
*     y := alpha*A*x + beta*y,
*
@rout symv
*  where alpha and beta are scalars, x and y are n-element vectors and A
*  is an n by n @(syhe_comm) matrix.
@rout sbmv
*  where alpha and beta are scalars, x and y are n-element vectors and A
*  is an n by n @(syhe_comm) band matrix, with k super-diagonals.
@rout spmv
*  where alpha and beta are scalars, x and y are n-element vectors and A
*  is an n by n @(syhe_comm) matrix, supplied in packed form.
@rout symv sbmv spmv
*
@extract @(ARGUMENTS)
*
@rout symv
@extract @(UPLO_SY_COMMENT) "A"
@rout sbmv
@extract @(UPLO_SB_COMMENT) "A"
@rout spmv
@extract @(UPLO_SP_COMMENT) "A"
@rout symv sbmv spmv
*
*  N       (input)                       INTEGER
*          On entry, N specifies the order of the matrix A. N must be at
*          least zero. Unchanged on exit.
@rout sbmv
*
*  K       (input)                       INTEGER
*          On entry, K  specifies  the number of  super-diagonals of the
*          matrix A. K must satisfy 0 .le. K. Unchanged on exit. 
@rout symv sbmv spmv
*
*  ALPHA   (input)                       @(type_comm)
*          On entry, ALPHA specifies the scalar alpha.   When  ALPHA  is
*          supplied as zero then  A and X  need not be set on input. Un-
*          changed on exit.
*
@rout symv
*  A       (input)                       @(type_comm) array
*          On entry,  A  is an array of DIMENSION ( LDA, n ). Before en-
*          try with  UPLO = 'U' or 'u', the  leading n by n upper trian-
*          gular part of the array  A  must contain the upper triangular
*          part of the @(syhe_comm) matrix and the  strictly lower triangu-
*          lar part of A is not referenced.
*          Before entry with UPLO = 'L' or 'l', the leading n by n lower
*          triangular part of the array A  must contain the lower trian-
*          gular  part  of the @(syhe_comm) matrix and  the strictly  upper
@type real dble cplx zplx
*          triangular part of A is not referenced. Unchanged on exit.
@type chex zhex
*          triangular part of A is not referenced.
*          Note that the  imaginary parts  of the local entries  corres-
*          ponding to the diagonal elements of A need not be set and as-
*          sumed to be zero. Unchanged on exit.
@type real dble cplx zplx chex zhex
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in the calling (sub) program. LDA must be at least  max(1,n).
*          Unchanged on exit.
@rout sbmv
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of DIMENSION ( LDA, n ). Before entry
*          with UPLO = 'U' or 'u',  the leading (k + 1) by n part of the
*          array  A  must  contain the upper triangular band part of the
*          @(syhe_comm) matrix, supplied column by column, with the leading
*          diagonal of the matrix in row (k + 1) of the array, the first
*          super-diagonal  starting at position 2 in row k,  and  so on.
*          The  top left k by k  triangle of the array A is not referen-
*          ced.  The following program  segment  will transfer the upper
*          triangular part of a @(syhe_comm) band  matrix from conventional
*          full matrix storage to band storage:
*
*                DO 20, J = 1, N
*                   M = K + 1 - J
*                   DO 10, I = MAX( 1, J - K ), J
*                      A( M + I, J ) = matrix( I, J )
*             10    CONTINUE
*             20 CONTINUE
*
*          Before entry with  UPLO = 'L' or 'l', the leading (k+1)  by n
*          part of  the array A must contain the lower  triangular  band
*          part of the @(syhe_comm) matrix, supplied column by column, with
*          the leading diagonal of the matrix in row 1 of the array, the
*          first sub-diagonal starting at position  1  in row  2, and so
*          on.  The bottom right  k by k  triangle of the array A is not
*          referenced.  The  following program segment will transfer the
*          lower triangular part of a @(syhe_comm) band matrix from conven-
*          tional full matrix storage to band storage:
*
*                DO 20, J = 1, N
*                   M = 1 - J
*                   DO 10, I = J, MIN( N, J + K )
*                      A( M + I, J ) = matrix( I, J )
*             10    CONTINUE
*             20 CONTINUE
*
@type real dble cplx zplx
*          Unchanged on exit.
@type chex zhex
*          Note that the  imaginary parts  of the local entries  corres-
*          ponding to the diagonal elements of A need not be set and as-
*          sumed to be zero. Unchanged on exit.
@type real dble cplx zplx chex zhex
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in the calling (sub) program. LDA must be at least k + 1. Un-
*          changed on exit.
@rout spmv
*  A       (input)                       @(type_comm) array
*          On entry,  A  is an array of DIMENSION ( ( n*( n + 1 ) )/2 ).
*          Before entry with UPLO = 'U' or 'u', the array A must contain
*          the upper triangular  part of the @(syhe_comm) matrix packed se-
*          quentially, column by column, so that A( 1 ) contains a(1,1),
*          A( 2 ) and A( 3 ) contain a(1,2) and a(2,2) respectively, and
*          so on.
*          Before entry with UPLO = 'L' or 'l', the array A must contain
*          the lower triangular  part of the @(syhe_comm) matrix packed se-
*          quentially, column by column, so that A( 1 ) contains a(1,1),
*          A( 2 ) and A( 3 ) contain a(2,1) and a(3,1) respectively, and
@type real dble cplx zplx
*          so on. Unchanged on exit.
@type chex zhex
*          so on.
*          Note that the  imaginary parts  of the local entries  corres-
*          ponding to the diagonal elements of A need not be set and as-
*          sumed to be zero. Unchanged on exit.
@type real dble cplx zplx chex zhex
@rout symv sbmv spmv
*
*  X       (input)                       @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) ).  Before entry, the incremen-
*          ted array X must contain the vector x. Unchanged on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
*  BETA    (input)                       @(type_comm)
*          On entry,  BETA  specifies the scalar  beta.   When  BETA  is
*          supplied as zero then Y  need not be set on input.  Unchanged
*          on exit.
*
*  Y       (input/output)                @(type_comm) array
*          On entry,  Y  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCY ) ).  Before entry with BETA non-
*          zero, the incremented array  Y  must contain the vector y. On
*          exit, Y is overwritten by the updated vector y.
*
*  INCY    (input)                       INTEGER
*          On entry, INCY specifies the increment for the elements of Y.
*          INCY must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout trmv tbmv tpmv
@extract @(PURPOSE)
*
*  @(rname) performs one of the matrix-vector operations
*
@type real dble
*     x := A*x,   or   x := A'*x,
@type cplx zplx
*     x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,
@type real dble cplx zplx
*
@rout trmv
*  where x is an n-element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular matrix.
@rout tbmv
*  where x is an n-element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular band matrix, with ( k + 1 ) diagonals.
@rout tpmv
*  where x is an n-element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular matrix, supplied in packed form.
@rout trmv tbmv tpmv
*
@extract @(ARGUMENTS)
*
@extract @(UPLO_TR_COMMENT) "A"
*
@extract @(TRANS_COMMENT)
*
*             TRANS = 'N' or 'n'   x := A *x,
*
*             TRANS = 'T' or 't'   x := A'*x,
*
@type real dble
*             TRANS = 'C' or 'c'   x := A'*x.
@type cplx zplx
*             TRANS = 'C' or 'c'   x := conjg( A' )*x.
@type real dble cplx zplx
*
*          Unchanged on exit.
*
@extract @(DIAG_COMMENT) "A"
*
*  N       (input)                       INTEGER
*          On entry, N specifies the order of the matrix A. N must be at
*          least zero. Unchanged on exit.
*
@rout tbmv
*  K       (input)                       INTEGER
*          On entry  with UPLO = 'U' or 'u',  K  specifies the number of
*          super-diagonals of the matrix A. On entry  with UPLO = 'L' or
*          'l', K specifies the number of sub-diagonals of the matrix A.
*          K must satisfy  0 .le. K. Unchanged on exit.
*
@rout trmv
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of dimension ( LDA, n ). Before entry
*          with  UPLO = 'U' or 'u',  the leading n by n upper triangular
*          part of the array A must contain the upper triangular  matrix
*          and the strictly lower triangular part of  A  is not referen-
*          ced. Before entry with UPLO = 'L' or 'l', the leading  n by n
*          lower triangular part of the array  A  must contain the lower
*          triangular matrix and the strictly upper triangular part of A
*          is not referenced.
*          Note that when  DIAG = 'U' or 'u', the diagonal elements of A
*          are not referenced  either,  but are assumed to be unity. Un-
*          changed on exit.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in the calling (sub) program. LDA must be at least  max(1,n).
*          Unchanged on exit. 
@rout tbmv
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of dimension ( LDA, n ). Before entry
*          with UPLO = 'U' or 'u', the leading (k + 1) by n part of  the
*          array  A  must  contain the upper triangular band part of the
*          matrix of coefficients,  supplied  column by column, with the 
*          leading diagonal of the matrix in row ( k + 1 ) of the array,
*          the first super-diagonal starting at position 2 in row k, and
*          so on. The top left k by k triangle of the array A is not re-
*          ferenced.  The following program segment will transfer an up-
*          per  triangular  band  matrix  from  conventional full matrix 
*          storage to band storage:
*
*                DO 20, J = 1, N
*                   M = K + 1 - J
*                   DO 10, I = MAX( 1, J - K ), J
*                      A( M + I, J ) = matrix( I, J )
*             10    CONTINUE
*             20 CONTINUE
*
*          Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) by
*          n part of the array A must contain the lower triangular  band
*          part  of  the  matrix of coefficients, supplied column by co-
*          lumn, with the leading diagonal of the matrix in row 1 of the
*          array,  the  first sub-diagonal starting at position 1 in row
*          2, and so on. The bottom right k by k triangle of the array A
*          is not referenced.  The following program segment will trans-
*          fer a lower triangular band matrix from conventional full ma-
*          trix storage to band storage:
*
*                DO 20, J = 1, N
*                   M = 1 - J
*                   DO 10, I = J, MIN( N, J + K )
*                      A( M + I, J ) = matrix( I, J )
*             10    CONTINUE
*             20 CONTINUE
*
*          Note that when DIAG = 'U' or 'u' the elements of the array  A
*          corresponding to the diagonal elements of the matrix are  not
*          referenced, but are assumed to be unity. Unchanged on exit.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in the calling (sub) program. LDA must be at least ( k + 1 ).
*          Unchanged on exit. 
@rout tpmv
*  A       (input)                       @(type_comm) array
*          On entry, A  is an array of  DIMENSION ( ( n*( n + 1 ) )/2 ).
*          Before entry with UPLO = 'U' or 'u', the array A must contain
*          the  upper  triangular  matrix packed sequentially, column by
*          column,  so that A( 1 ) contains a( 1, 1 ), A( 2 ) and A( 3 )
*          contain a( 1, 2 ) and a( 2, 2 )  respectively, and so on. Be-
*          fore entry with UPLO = 'L' or 'l', the array  A  must contain
*          the  lower  triangular  matrix packed sequentially, column by
*          column,  so that A( 1 ) contains a( 1, 1 ), A( 2 ) and A( 3 )
*          contain a( 2, 1 ) and a( 3, 1 ) respectively, and so on. Note
*          that when  DIAG = 'U' or 'u', the diagonal elements of  A are
*          not referenced,  but are  assumed to be unity.  Unchanged  on
*          exit.
@rout trmv tbmv tpmv
*
*  X       (input/output)                @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) ).  Before entry, the incremen-
*          ted array X must contain the vector x. On exit, X is overwri-
*          tten with the tranformed vector x.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout trsv tbsv tpsv
@extract @(PURPOSE)
*
*  @(rname) solves one of the systems of equations
*
@type real dble
*     A*x = b,   or   A'*x = b,
@type cplx zplx
*     A*x = b,   or   A'*x = b,   or   conjg( A' )*x = b,
@type real dble cplx zplx
*
@rout trsv
*  where b and x are n-element vectors and  A is an n by n unit, or non-
*  unit, upper or lower triangular matrix.
@rout tbsv
*  where b and x are n-element vectors and  A is an n by n unit, or non-
*  unit, upper or lower triangular band matrix, with (k+1) diagonals.
@rout tpsv
*  where b and x are n-element vectors and  A is an n by n unit, or non-
*  unit, upper or lower triangular matrix, supplied in packed form.
@rout trsv tbsv tpsv
*
*  No test for  singularity  or  near-singularity  is included  in  this
*  routine. Such tests must be performed before calling this routine.
*
@extract @(ARGUMENTS)
*
@extract @(UPLO_TR_COMMENT) "A"
*
*  TRANS   (input)                       CHARACTER*1.
*          On entry,  TRANS specifies the equations to be solved as fol-
*          lows:
*
*             TRANS = 'N' or 'n'   A *x = b,
*
*             TRANS = 'T' or 't'   A'*x = b,
*
@type real dble
*             TRANS = 'T' or 't'   A'*x = b.
@type cplx zplx
*             TRANS = 'C' or 'c'   conjg( A' )*x = b.
@type real dble cplx zplx
*
*          Unchanged on exit.
*
@extract @(DIAG_COMMENT) "A"
*                                                                               
*  N       (input)                       INTEGER
*          On entry, N specifies the order of the matrix A. N must be at
*          least zero. Unchanged on exit.
*
@rout tbsv
*  K       (input)                       INTEGER
*          On entry  with UPLO = 'U' or 'u',  K  specifies the number of
*          super-diagonals of the matrix A. On entry  with UPLO = 'L' or
*          'l', K specifies the number of sub-diagonals of the matrix A.
*          K must satisfy  0 .le. K. Unchanged on exit.
*
@rout trsv
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of dimension ( LDA, n ). Before entry
*          with  UPLO = 'U' or 'u',  the leading n by n upper triangular
*          part of the array A must contain the upper triangular  matrix
*          and the strictly lower triangular part of  A  is not referen-
*          ced. Before entry with UPLO = 'L' or 'l', the leading  n by n
*          lower triangular part of the array  A  must contain the lower
*          triangular matrix and the strictly upper triangular part of A
*          is not referenced.
*          Note that when  DIAG = 'U' or 'u', the diagonal elements of A
*          are not referenced  either,  but are assumed to be unity. Un-
*          changed on exit.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in the calling (sub) program. LDA must be at least  max(1,n).
*          Unchanged on exit. 
@rout tbsv
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of dimension ( LDA, n ). Before entry
*          with UPLO = 'U' or 'u', the leading (k + 1) by n part of  the
*          array  A  must  contain the upper triangular band part of the
*          matrix of coefficients,  supplied  column by column, with the 
*          leading diagonal of the matrix in row ( k + 1 ) of the array,
*          the first super-diagonal starting at position 2 in row k, and
*          so on. The top left k by k triangle of the array A is not re-
*          ferenced.  The following program segment will transfer an up-
*          per  triangular  band  matrix  from  conventional full matrix 
*          storage to band storage:
*
*                DO 20, J = 1, N
*                   M = K + 1 - J
*                   DO 10, I = MAX( 1, J - K ), J
*                      A( M + I, J ) = matrix( I, J )
*             10    CONTINUE
*             20 CONTINUE
*
*          Before entry with UPLO = 'L' or 'l', the leading ( k + 1 ) by
*          n part of the array A must contain the lower triangular  band
*          part  of  the  matrix of coefficients, supplied column by co-
*          lumn, with the leading diagonal of the matrix in row 1 of the
*          array,  the  first sub-diagonal starting at position 1 in row
*          2, and so on. The bottom right k by k triangle of the array A
*          is not referenced.  The following program segment will trans-
*          fer a lower triangular band matrix from conventional full ma-
*          trix storage to band storage:
*
*                DO 20, J = 1, N
*                   M = 1 - J
*                   DO 10, I = J, MIN( N, J + K )
*                      A( M + I, J ) = matrix( I, J )
*             10    CONTINUE
*             20 CONTINUE
*
*          Note that when DIAG = 'U' or 'u' the elements of the array  A
*          corresponding to the diagonal elements of the matrix are  not
*          referenced, but are assumed to be unity. Unchanged on exit.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in the calling (sub) program. LDA must be at least ( k + 1 ).
*          Unchanged on exit. 
@rout tpsv
*  A       (input)                       @(type_comm) array
*          On entry, A  is an array of  DIMENSION ( ( n*( n + 1 ) )/2 ).
*          Before entry with UPLO = 'U' or 'u', the array A must contain
*          the  upper  triangular  matrix packed sequentially, column by
*          column,  so that A( 1 ) contains a( 1, 1 ), A( 2 ) and A( 3 )
*          contain a( 1, 2 ) and a( 2, 2 )  respectively, and so on. Be-
*          fore entry with UPLO = 'L' or 'l', the array  A  must contain
*          the  lower  triangular  matrix packed sequentially, column by
*          column,  so that A( 1 ) contains a( 1, 1 ), A( 2 ) and A( 3 )
*          contain a( 2, 1 ) and a( 3, 1 ) respectively, and so on. Note
*          that when  DIAG = 'U' or 'u', the diagonal elements of  A are
*          not referenced,  but are  assumed to be unity.  Unchanged  on
*          exit.
@rout trsv tbsv tpsv
*
*  X       (input/output)                @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) ).  Before entry, the incremen-
*          ted array X must contain the n element right-hand side vector
*          b. On exit, X is overwritten with the solution vector x.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout ger
@extract @(PURPOSE)
*
*  @(rname) performs the rank 1 operation
*
@type real dble cplx zplx
*     A := alpha*x*y' + A,
@type chex zhex
*     A := alpha*x*conjg( y' ) + A,
@type real dble cplx zplx chex zhex
*
*  where alpha is a scalar,  x is an m-element vector, y is an n-element
*  vector and A is an m by n matrix.
*
@extract @(ARGUMENTS)
*
*  M       (input)                       INTEGER
*          On entry,  M  specifies the number of rows of  the matrix  A.
*          M must be at least zero. Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N  specifies the number of columns of the matrix A.
*          N  must be at least zero. Unchanged on exit.
*
*  ALPHA   (input)                       @(type_comm)
*          On entry, ALPHA specifies the scalar alpha.   When  ALPHA  is
*          supplied as zero then the arrays X and Y need not be set on 
*          input. Unchanged on exit.
*
*  X       (input)                       @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( m - 1 ) * abs( INCX ) ).  Before entry, the incremen-
*          ted array X must contain the vector x. Unchanged on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
*  Y       (input)                       @(type_comm) array
*          On entry,  Y  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCY ) ).  Before entry, the incremen-
*          ted array Y must contain the vector y. Unchanged on exit.
*
*  INCY    (input)                       INTEGER
*          On entry, INCY specifies the increment for the elements of Y.
*          INCY must not be zero. Unchanged on exit.
*
*  A       (input/output)                @(type_comm) array
*          On entry,  A  is an array of DIMENSION ( LDA, n ). Before en-
*          try, the leading m by n part of the array  A must contain the
*          matrix coefficients. On exit, A is overwritten by the updated
*          matrix.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in the calling (sub) program. LDA must be at least  max(1,m).
*          Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout syr spr
@extract @(PURPOSE)
*
*  @(rname) performs the @(syhe_comm) rank 1 operation
*
@type real dble cplx zplx
*     A := alpha*x*x' + A,
@type chex zhex
*     A := alpha*x*conjg( x' ) + A,
@type real dble cplx zplx chex zhex
*
@rout syr
@type real dble cplx zplx
*  where  alpha is a scalar, x is an n-element vector and A is an n by n
*  @(syhe_comm) matrix.
@type chex zhex
*  where  alpha is a real scalar, x is an n-element vector and A is an n
*  by n @(syhe_comm) matrix.
@type real dble cplx zplx chex zhex
@rout spr
@type real dble cplx zplx
*  where  alpha is a scalar, x is an n-element vector and A is an n by n
*  @(syhe_comm) matrix, supplied in packed form.
@type chex zhex
*  where  alpha is a real scalar, x is an n-element vector and A is an n
*  by n @(syhe_comm) matrix, supplied in packed form.
@type real dble cplx zplx chex zhex
@rout syr spr
*
@extract @(ARGUMENTS)
*
@rout syr
@extract @(UPLO_SY_COMMENT) "A"
@rout spr
@extract @(UPLO_SP_COMMENT) "A"
@rout syr spr
*
*  N       (input)                       INTEGER
*          On entry, N specifies the order of the matrix A. N must be at
*          least zero. Unchanged on exit.
*
@type real dble cplx zplx
*  ALPHA   (input)                       @(type_comm)
@type chex zhex
*  ALPHA   (input)                       @(utyp_comm)
@type real dble cplx zplx chex zhex
*          On entry, ALPHA specifies the scalar alpha.   When  ALPHA  is
*          supplied as  zero then  the array X need not be set on input.
*          Unchanged on exit.
*
*  X       (input)                       @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) ).  Before entry, the incremen-
*          ted array X must contain the vector x. Unchanged on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
@rout syr
*  A       (input/output)                @(type_comm) array
*          On entry,  A  is an array of DIMENSION ( LDA, n ). Before en-
*          try with  UPLO = 'U' or 'u', the  leading n by n upper trian-
*          gular part of the array  A  must contain the upper triangular
*          part of the @(syhe_comm) matrix and the  strictly lower triangu-
*          lar part of  A is not referenced. On exit, the upper triangu-
*          lar part of the array  A is overwritten by the upper triangu-
*          lar part of the updated matrix.  Before entry with UPLO = 'L'
*          or 'l', the leading n by n lower triangular part of the array
*          A  must  contain the lower triangular  part  of the @(syhe_comm)
*          matrix  and  the  strictly  upper triangular part of A is not
*          referenced.
@type chex zhex
*          Note that  the  imaginary parts of the diagonal elements need
*          not be set, they are assumed to be zero, and on exit they are
*          set to zero. 
@type real dble cplx zplx chex zhex
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in the calling (sub) program. LDA must be at least  max(1,n).
*          Unchanged on exit.
@rout spr
*  A       (input/output)                @(type_comm) array
*          On entry,  A  is an  array  of DIMENSION ( ( n*(n + 1) )/2 ).
*          Before  entry  with  UPLO = 'U' or 'u', the array A must con-
*          tain the upper triangular part of the @(syhe_comm) matrix packed
*          sequentially, column by column, so that A(1) contains a(1,1),
*          A( 2 ) and A( 3 ) contain a(1,2) and a(2,2) respectively, and
*          so on. On exit, the array  A is overwritten by the upper tri-
*          angular part of the updated matrix.
*          Before entry with UPLO = 'L' or 'l', the array A must contain
*          the lower triangular part of the @(syhe_comm) matrix  packed se-
*          quentially, column by column, so that A( 1 ) contains a(1,1),
*          A( 2 ) and A( 3 ) contain a(2,1) and a(3,1) respectively, and
*          so on. On exit, the array  A is overwritten by the lower tri-
*          angular part of the updated matrix.
@type chex zhex
*          Note that the imaginary parts of the  diagonal elements  need
*          not be set, they are assumed to be zero, and on exit they are
*          set to zero.
@type real dble cplx zplx chex zhex
@rout syr spr
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout syr2 spr2
@extract @(PURPOSE)
*
*  @(rname) performs the @(syhe_comm) rank 2 operation
*
@type real dble cplx zplx
*     A := alpha*x*y' + alpha*y*x' + A,
@type chex zhex
*     A := alpha*x*conjg( y' ) + conjg( alpha )*y*conjg( x' ) + A,
@type real dble cplx zplx chex zhex
*
@rout syr2
*  where  alpha is a scalar, x and y are n-element vectors and A is an n
*  by n @(syhe_comm) matrix.
@rout spr2
*  where  alpha is a scalar, x and y are n-element vectors and A is an n
*  by n @(syhe_comm) matrix, supplied in packed form.
@rout syr2 spr2
*
@extract @(ARGUMENTS)
*
@rout syr2
@extract @(UPLO_SY_COMMENT) "A"
@rout spr2
@extract @(UPLO_SP_COMMENT) "A"
@rout syr2 spr2
*
*  N       (input)                       INTEGER
*          On entry, N specifies the order of the matrix A. N must be at
*          least zero. Unchanged on exit.
*
*  ALPHA   (input)                       @(type_comm)
*          On entry, ALPHA specifies the scalar alpha.   When  ALPHA  is
*          supplied as  zero then  the arrays X and Y need not be set on 
*          input. Unchanged on exit.
*
*  X       (input)                       @(type_comm) array
*          On entry,  X  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCX ) ).  Before entry, the incremen-
*          ted array X must contain the vector x. Unchanged on exit.
*
*  INCX    (input)                       INTEGER
*          On entry, INCX specifies the increment for the elements of X.
*          INCX must not be zero. Unchanged on exit.
*
*  Y       (input)                       @(type_comm) array
*          On entry,  Y  is an incremented array of dimension  at  least
*          ( 1 + ( n - 1 ) * abs( INCY ) ).  Before entry, the incremen-
*          ted array Y must contain the vector y. Unchanged on exit.
*
*  INCY    (input)                       INTEGER
*          On entry, INCY specifies the increment for the elements of Y.
*          INCY must not be zero. Unchanged on exit.
*
@rout syr2
*  A       (input/output)                @(type_comm) array
*          On entry,  A  is an array of DIMENSION ( LDA, n ). Before en-
*          try with  UPLO = 'U' or 'u', the  leading n by n upper trian-
*          gular part of the array  A  must contain the upper triangular
*          part of the @(syhe_comm) matrix and the  strictly lower triangu-
*          lar part of  A is not referenced. On exit, the upper triangu-
*          lar part of the array  A is overwritten by the upper triangu-
*          lar part of the updated matrix.  Before entry with UPLO = 'L'
*          or 'l', the leading n by n lower triangular part of the array
*          A  must  contain the lower triangular  part  of the @(syhe_comm)
*          matrix  and  the  strictly  upper triangular part of A is not
*          referenced.
@type chex zhex
*          Note that  the  imaginary parts of the diagonal elements need
*          not be set, they are assumed to be zero, and on exit they are
*          set to zero.
@type real dble cplx zplx chex zhex
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in the calling (sub) program. LDA must be at least  max(1,n).
*          Unchanged on exit.
@rout spr2
*  A       (input/output)                @(type_comm) array
*          On entry,  A  is an  array  of DIMENSION ( ( n*(n + 1) )/2 ).
*          Before  entry  with  UPLO = 'U' or 'u', the array A must con-
*          tain the upper triangular part of the @(syhe_comm) matrix packed
*          sequentially, column by column, so that A(1) contains a(1,1),
*          A( 2 ) and A( 3 ) contain a(1,2) and a(2,2) respectively, and
*          so on. On exit, the array  A is overwritten by the upper tri-
*          angular part of the updated matrix.
*          Before entry with UPLO = 'L' or 'l', the array A must contain
*          the lower triangular part of the @(syhe_comm) matrix  packed se-
*          quentially, column by column, so that A( 1 ) contains a(1,1),
*          A( 2 ) and A( 3 ) contain a(2,1) and a(3,1) respectively, and
*          so on. On exit, the array  A is overwritten by the lower tri-
*          angular part of the updated matrix.
@type chex zhex
*          Note that the imaginary parts of the  diagonal elements  need
*          not be set, they are assumed to be zero, and on exit they are
*          set to zero.
@type real dble cplx zplx chex zhex
@rout syr2 spr2
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout gemm
@extract @(PURPOSE)
*
*  @(rname)  performs one of the matrix-matrix operations
*
*     C := alpha * op( A ) * op( B ) + beta * C,
*
*  where op( X ) is one of
*
@type real dble
*     op( X ) = X   or   op( X ) = X'.
@type cplx zplx
*     op( X ) = X   or   op( X ) = X'   or   op( X ) = conjg( X' ).
@type real dble cplx zplx
*
*  Alpha and beta are scalars, and A, B and C are matrices, with op( A )
*  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
*
@extract @(ARGUMENTS)
*
@extract @(TRANSX_COMMENT) "A"
*
@extract @(TRANSX_COMMENT) "B"
*
*  M       (input)                       INTEGER
*          On entry,  M  specifies  the  number  of rows  of the  matrix
*          op( A )  and  of the  matrix  C.  M  must  be at least  zero.
*          Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry,  N  specifies  the number  of columns of the matrix
*          op( B )  and the number of columns of the matrix C. N must be
*          at least zero. Unchanged on exit.
*
*  K       (input)                       INTEGER
*          On entry,  K  specifies  the  number of columns of the matrix
*          op( A ) and the number of rows  of the matrix op( B ). K must
*          be at least  zero. Unchanged on exit.
*
*  ALPHA   (input)                       @(type_comm)
*          On entry, ALPHA specifies the scalar alpha.   When  ALPHA  is
*          supplied  as  zero  then the elements of the matrices A and B
*          need not be set on input. Unchanged on exit.
*
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of DIMENSION ( LDA, ka ), where ka is
*          k  when  TRANSA = 'N' or 'n',  and  is  m  otherwise.  Before 
*          entry with  TRANSA = 'N' or 'n',  the leading  m by k part of
*          the array  A must contain the matrix A, otherwise the leading
*          k by m  part of the array  A  must contain the matrix  A. Un-
*          changed on exit.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in the  calling (sub) program. When  TRANSA = 'N' or 'n' then
*          LDA  must be at least  max( 1, m ), otherwise  LDA must be at
*          least  max( 1, k ). Unchanged on exit.
*
*  B       (input)                       @(type_comm) array
*          On entry, B is an array of DIMENSION ( LDB, kb ), where kb is
*          n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.   Before
*          entry with  TRANSB = 'N' or 'n',  the leading  k by n part of
*          the array  B must contain the matrix B, otherwise the leading
*          n by k part of the array B must contain the matrix B. Unchan-
*          ged on exit.
*
*  LDB     (input)                       INTEGER
*          On entry, LDB  specifies the first dimension of B as declared
*          in the  calling (sub) program. When  TRANSB = 'N' or 'n' then
*          LDB  must be at least  max( 1, k ), otherwise  LDB must be at
*          least  max( 1, n ). Unchanged on exit.
*
*  BETA    (input)                       @(type_comm)
*          On entry,  BETA  specifies the scalar  beta.   When  BETA  is
*          supplied  as  zero  then  the  elements of the matrix C  need
*          not be set on input. Unchanged on exit.
*
*  C       (input/output)                @(type_comm) array
*          On entry,  C  is  an  array of  DIMENSION ( LDC, n ).  Before
*          entry, the leading  m by n  part of the array  C must contain
*          the matrix C,  except when beta is zero, in which case C need
*          not be set on entry. On exit, the array  C  is overwritten by
*          the  m by n  matrix ( alpha*op( A )*op( B ) + beta*C ).
*
*  LDC     (input)                       INTEGER
*          On entry, LDC  specifies the first dimension of C as declared
*          in  the   calling  (sub)  program.   LDC  must  be  at  least
*          max( 1, m ). Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout symm
@extract @(PURPOSE)
*
*  @(rname)  performs one of the matrix-matrix operations
*
*     C := alpha * A * B + beta * C,
*
*  or
*
*     C := alpha * B * A + beta * C,
*
*  where alpha and beta are scalars,  A is a @(syhe_comm) matrix and B and
*  C are m by n matrices.
*
@extract @(ARGUMENTS)
*
*  SIDE    (input)                       CHARACTER*1
*          On entry,  SIDE  specifies  whether the  @(syhe_comm)  matrix  A 
*          appears  on  the left or right in the operation as follows:
*
*             SIDE = 'L' or 'l'    C := alpha * A * B + beta * C,
*
*             SIDE = 'R' or 'r'    C := alpha * B * A + beta * C.
*
*          Unchanged on exit.
*
@extract @(UPLO_SY_COMMENT) "A"
*
*  M       (input)                       INTEGER
*          On entry,  M  specifies  the number  of rows of the matrix C.
*          M  must be at least zero. Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N  specifies the number of columns of the matrix C.
*          N must be at least zero. Unchanged on exit.
*
*  ALPHA   (input)                       @(type_comm)
*          On entry, ALPHA specifies the scalar alpha.   When  ALPHA  is
*          supplied  as  zero  then the elements of the matrices A and B
*          need not be set on input.
*
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of DIMENSION ( LDA, ka ), where ka is
*          m  when  SIDE = 'L' or 'l'  and is  n otherwise.
*          Before  entry  with  SIDE = 'L' or 'l',  the  m by m  part of
*          the  array  A  must contain the  @(syhe_comm) matrix,  such that
*          when  UPLO = 'U'  or 'u', the leading m by m upper triangular
*          part  of the array  A  must contain the upper triangular part
*          of the  @(syhe_comm)  matrix and the  strictly  lower triangular
*          part of  A  is not  referenced,  and when  UPLO = 'L' or 'l',
*          the leading  m by m  lower  triangular part  of the  array  A
*          must  contain  the  lower  triangular part  of the  @(syhe_comm)
*          matrix and the  strictly  upper triangular part of  A  is not
*          referenced.
*          Before  entry  with  SIDE = 'R' or 'r',  the  n by n  part of
*          the  array  A  must contain the  @(syhe_comm) matrix,  such that
*          when  UPLO = 'U' or 'u', the  leading n by n upper triangular
*          part of the array  A  must  contain the upper triangular part
*          of the  @(syhe_comm) matrix  and the  strictly  lower triangular
*          part of  A  is not  referenced,  and when  UPLO = 'L' or 'l',
*          the leading  n by n  lower  triangular part  of the  array  A
*          must  contain  the  lower  triangular part  of the  @(syhe_comm)
*          matrix and the  strictly  upper triangular part of  A  is not
@type real dble cplx zplx
*          referenced. Unchanged on exit.
@type chex zhex
*          referenced.
*          Note that the imaginary parts of the local entries correspon-
*          ding to the diagonal  elements of A need not be set and assu-
*          med to be zero. Unchanged on exit.
@type real dble cplx zplx chex zhex
*
*  LDA     (input)                       INTEGER
*          On entry,  LDA specifies the first dimension of A as declared
*          in the  calling (sub) program.  When  SIDE = 'L' or 'l'  then
*          LDA  must be at least  max( 1, m ), otherwise  LDA must be at
*          least  max( 1, n ). Unchanged on exit.
*
*  B       (input)                       @(type_comm) array
*          On entry, B is an array of DIMENSION (LDB, n).  Before entry,
*          the  leading  m by n  part of  the array  B  must contain the
*          matrix B. Unchanged on exit.
*
*  LDB     (input)                       INTEGER
*          On entry, LDB specifies  the first dimension of B as declared
*          in  the  calling  (sub)  program.   LDB  must  be   at  least
*          max( 1, m ). Unchanged on exit.
*
*  BETA    (input)                       @(type_comm)
*          On entry,  BETA  specifies the scalar  beta.   When  BETA  is
*          supplied  as  zero  then  the  elements of the matrix C  need
*          not be set on input. Unchanged on exit.
*
*  C       (input/output)                @(type_comm) array
*          On entry, C is an array of DIMENSION (LDC, n).  Before entry,
*          the leading  m by n  part of the array C must contain the ma-
*          trix C, except when beta is zero, in which case C need not be
*          set on entry. On exit, the array C is overwritten by the m by
*          n updated matrix.
*
*  LDC     (input)                       INTEGER
*          On entry,  LDC specifies the first dimension of C as declared
*          in   the  calling  (sub)  program.   LDC  must  be  at  least
*          max( 1, m ). Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout syrk
@extract @(PURPOSE)
*
*  @(rname)  performs one of the @(syhe_comm) rank k operations
*
@type real dble cplx zplx
*     C := alpha * A * A' + beta * C,
@type chex zhex
*     C := alpha * A * conjg( A' ) + beta * C,
@type real dble cplx zplx chex zhex
*
*  or
*
@type real dble cplx zplx
*     C := alpha * A' * A + beta * C,
@type chex zhex
*     C := alpha * conjg( A' ) * A + beta * C,
@type real dble cplx zplx chex zhex
*
@type real dble cplx zplx
*  where alpha and beta are scalars, C is an n by n @(syhe_comm) matrix and
*  A is an  n by k  matrix in the first case and a  k by n matrix in the
*  second case.
@type chex zhex
*  where alpha and beta are  real  scalars, C is an n by n @(syhe_comm) ma-
*  trix and  A is an n by k matrix in the first case and a k by n matrix
*  in the second case.
@type real dble cplx zplx chex zhex
*
@extract @(ARGUMENTS)
*
@extract @(UPLO_SY_COMMENT) "C"
*
@extract @(TRANS_COMMENT)
*
@type real dble
*             TRANS = 'N' or 'n'  C := alpha * A * A' + beta * C,
*
*             TRANS = 'T' or 't'  C := alpha * A' * A + beta * C,
*
*             TRANS = 'C' or 'c'  C := alpha * A' * A + beta * C.
@type cplx zplx
*             TRANS = 'N' or 'n'  C := alpha * A * A' + beta * C,
*
*             TRANS = 'T' or 't'  C := alpha * A' * A + beta * C.
@type chex zhex
*             TRANS = 'N' or 'n'  C := alpha * A*conjg( A )' + beta * C,
*
*             TRANS = 'C' or 'c'  C := alpha * conjg( A )'*A + beta * C.
@type real dble cplx zplx chex zhex
*
*          Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N specifies the order of the matrix C. N must be at
*          least zero. Unchanged on exit.
*
*  K       (input)                       INTEGER
*          On entry, with TRANS = 'N' or 'n',  K specifies the number of
@type real dble
*          columns of the matrix  A,  and with TRANS = 'T' or 't' or 'C'
*          or 'c',  K  specifies  the  number of rows of the  matrix  A. 
*          K must be at least zero. Unchanged on exit.
@type cplx zplx
*          columns of the matrix A, and with TRANS = 'T' or 't', K  spe-
*          cifies  the  number of rows of the  matrix  A.  K  must be at
*          least zero. Unchanged on exit.
@type chex zhex
*          columns of the matrix A, and with TRANS = 'C' or 'c', K  spe-
*          cifies  the  number of rows of the  matrix  A.  K  must be at
*          least zero. Unchanged on exit.
@type real dble cplx zplx chex zhex
*
@type real dble cplx zplx
*  ALPHA   (input)                       @(type_comm)
@type chex zhex
*  ALPHA   (input)                       @(utyp_comm)
@type real dble cplx zplx chex zhex
*          On entry, ALPHA specifies the scalar alpha.   When  ALPHA  is
*          supplied as zero  then  the  entries of the matrix A need not
*          be set on input. Unchanged on exit.
*
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of DIMENSION ( LDA, ka ), where ka is
*          k  when  TRANS = 'N' or 'n', and is n otherwise. Before entry
*          with TRANS = 'N' or 'n', the leading n by k part of the array
*          A must contain the matrix A,  otherwise  the  leading  k by n
*          part of the array A must contain the matrix A.  Unchanged  on
*          exit.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in  the   calling  (sub)  program.   When  TRANS = 'N' or 'n'
*          then  LDA  must be at least  max( 1, n ), otherwise  LDA must
*          be at least  max( 1, k ). Unchanged on exit.
*
@type real dble cplx zplx
*  BETA    (input)                       @(type_comm)
@type chex zhex
*  BETA    (input)                       @(utyp_comm)
@type real dble cplx zplx chex zhex
*          On entry,  BETA  specifies the scalar  beta.   When  BETA  is
*          supplied as zero  then  the  entries of the matrix C need not
*          be set on input. Unchanged on exit.
*
*  C       (input/output)                @(type_comm) array
*          On entry, C is an array of DIMENSION ( LDC, n ). Before entry
*          with  UPLO = 'U' or 'u',  the leading n by n upper triangular
*          part of the array C must contain the upper triangular part of
*          the  @(syhe_comm) matrix  and the strictly lower triangular part
*          of C is not referenced. On exit, the upper triangular part of
*          the array  C  is  overwritten by the upper triangular part of
*          the updated matrix. Before entry with  UPLO = 'L' or 'l', the
*          leading n by n lower triangular part of the array C must con-
*          tain the lower triangular part of the  @(syhe_comm)  matrix  and
*          the strictly upper triangular part of C is not referenced. On
*          exit, the lower triangular part of the array C is overwritten
*          by the lower triangular part of the updated matrix.
@type chex zhex
*          Note  that  the imaginary parts of the diagonal elements of C
*          need not  be  set,  they are assumed to be zero,  and on exit
*          they are set to zero.
@type real dble cplx zplx chex zhex
*
*  LDC     (input)                       INTEGER
*          On entry,  LDC specifies the first dimension of C as declared
*          in   the  calling  (sub)  program.   LDC  must  be  at  least
*          max( 1, n ). Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout syr2k
@extract @(PURPOSE)
*
*  @(rname)  performs one of the @(syhe_comm) rank 2k operations
*
@type real dble cplx zplx
*     C := alpha * A * B' + alpha * B * A' + beta * C,
@type chex zhex
*     C := alpha * A * conjg( B )' + conjg( alpha ) * B * conjg( A )' +
*          beta * C,
@type real dble cplx zplx chex zhex
*
*  or
*
@type real dble cplx zplx
*     C := alpha * A' * B + alpha * B' * A + beta * C,
@type chex zhex
*     C := alpha * conjg( A' ) * B + conjg( alpha ) * conjg( B' ) * A +
*          beta * C,
@type real dble cplx zplx chex zhex
*
@type real dble cplx zplx
*  where alpha and beta are scalars, C is an n by n @(syhe_comm) matrix and
*  A and B are n by k matrices in the first case and k by n  matrices in
*  the second case.
@type chex zhex
*  where  alpha  and  beta are scalars with  beta  real,  C is an n by n
*  @(syhe_comm) matrix and  A  and  B are n by k matrices in the first case
*  and k by n matrices in the second case.
@type real dble cplx zplx chex zhex
*
@extract @(ARGUMENTS)
*
@extract @(UPLO_SY_COMMENT) "C"
*
@extract @(TRANS_COMMENT)
*
@type real dble
*             TRANS = 'N' or 'n'  C := alpha*A*B' + alpha*B*A' + beta*C,
*
*             TRANS = 'T' or 't'  C := alpha*B'*A + alpha*A'*B + beta*C,
*
*             TRANS = 'C' or 'c'  C := alpha*B'*A + alpha*A'*B + beta*C.
@type cplx zplx
*             TRANS = 'N' or 'n'  C := alpha*A*B' + alpha*B*A' + beta*C,
*
*             TRANS = 'T' or 't'  C := alpha*B'*A + alpha*A'*B + beta*C.
@type chex zhex
*             TRANS = 'N' or 'n'
*             C := alpha*A*conjg( B' ) + conjg( alpha )*B*conjg( A' ) +
*                  beta*C,
*
*             TRANS = 'C' or 'c'
*             C := alpha*conjg( A' )*B + conjg( alpha )*conjg( B' )*A +
*                  beta*C.
@type real dble cplx zplx chex zhex
*
*          Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N specifies the order of the matrix C. N must be at
*          least zero. Unchanged on exit.
*
*  K       (input)                       INTEGER
*          On entry, with TRANS = 'N' or 'n',  K specifies the number of
@type real dble
*          columns of the matrices A and B, and with  TRANS = 'T' or 't'
*          or 'C' or 'c', K specifies the number of rows of the matrices
*          A and B. K must be at least zero. Unchanged on exit.
@type cplx zplx
*          columns of the matrices A and B, and with TRANS = 'T' or 't',
*          K  specifies  the  number  of  rows  of the matrices A and B.
*          K must be at least zero. Unchanged on exit.
@type chex zhex
*          columns of the matrices A and B, and with TRANS = 'C' or 'c',
*          K  specifies  the  number  of  rows  of the matrices A and B.
*          K  must be at least zero. Unchanged on exit.
@type real dble cplx zplx chex zhex
*
*  ALPHA   (input)                       @(type_comm)
*          On entry, ALPHA specifies the scalar alpha.   When  ALPHA  is
*          supplied  as  zero  then  the entries of the matrices A and B
*          need not be set on input. Unchanged on exit.
*
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of DIMENSION ( LDA, ka ), where ka is
*          k  when  TRANS = 'N' or 'n', and is n otherwise. Before entry
*          with TRANS = 'N' or 'n', the leading n by k part of the array
*          A must contain the matrix A,  otherwise  the  leading  k by n
*          part of the array A must contain the matrix A.  Unchanged  on
*          exit.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the first dimension of A as declared
*          in  the   calling  (sub)  program.   When  TRANS = 'N' or 'n'
*          then  LDA  must be at least  max( 1, n ), otherwise  LDA must
*          be at least  max( 1, k ). Unchanged on exit.
*
*  B       (input)                       @(type_comm) array
*          On entry, B is an array of DIMENSION ( LDB, kb ), where kb is
*          k  when  TRANS = 'N' or 'n', and is n otherwise. Before entry
*          with TRANS = 'N' or 'n', the leading n by k part of the array
*          B must contain the matrix B,  otherwise  the  leading  k by n
*          part of the array B must contain the matrix  B.  Unchanged on
*          exit.
*
*  LDB     (input)                       INTEGER
*          On entry, LDB  specifies the first dimension of B as declared
*          in  the   calling  (sub)  program.   When  TRANS = 'N' or 'n'
*          then  LDB  must be at least  max( 1, n ), otherwise  LDB must
*          be at least  max( 1, k ). Unchanged on exit.
*
@type real dble cplx zplx
*  BETA    (input)                       @(type_comm)
@type chex zhex
*  BETA    (input)                       @(utyp_comm)
@type real dble cplx zplx chex zhex
*          On entry,  BETA  specifies the scalar  beta.   When  BETA  is
*          supplied as zero  then  the  entries of the matrix C need not
*          be set on input. Unchanged on exit.
*
*  C       (input/output)                @(type_comm) array
*          On entry, C is an array of DIMENSION ( LDC, n ). Before entry
*          with  UPLO = 'U' or 'u',  the leading n by n upper triangular
*          part of the array C must contain the upper triangular part of
*          the  @(syhe_comm) matrix  and the strictly lower triangular part
*          of C is not referenced. On exit, the upper triangular part of
*          the array  C  is  overwritten by the upper triangular part of
*          the updated matrix. Before entry with  UPLO = 'L' or 'l', the
*          leading n by n lower triangular part of the array C must con-
*          tain the lower triangular part of the  @(syhe_comm)  matrix  and
*          the strictly upper triangular part of C is not referenced. On
*          exit, the lower triangular part of the array C is overwritten
*          by the lower triangular part of the updated matrix.
@type chex zhex
*          Note  that  the imaginary parts of the diagonal elements of C
*          need not  be  set,  they are assumed to be zero,  and on exit
*          they are set to zero.
@type real dble cplx zplx chex zhex
*
*  LDC     (input)                       INTEGER
*          On entry,  LDC specifies the first dimension of C as declared
*          in   the  calling  (sub)  program.   LDC  must  be  at  least
*          max( 1, n ). Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout trmm
@extract @(PURPOSE)
*
*  @(rname)  performs one of the matrix-matrix operations
*
*     B := alpha * op( A ) * B,   or    B := alpha * B * op( A ),
*
*  where alpha is a scalar, B is an m by n matrix, A is a unit,  or non-
*  unit, upper or lower triangular matrix and op( X ) is one of 
*
@type real dble 
*     op( X ) = X   or   op( X ) = X'.
@type cplx zplx
*     op( X ) = X   or   op( X ) = X'   or   op( X ) = conjg( X' ).
@type real dble cplx zplx
*
@extract @(ARGUMENTS)
*
*  SIDE    (input)                       CHARACTER*1
*          On entry,  SIDE  specifies whether  op( A ) multiplies B from
*          the left or right as follows:
*
*             SIDE = 'L' or 'l'  B := alpha * op( A )* B,
*
*             SIDE = 'R' or 'r'  B := alpha * B * op( A ).
*
*          Unchanged on exit.
*
@extract @(UPLO_TR_COMMENT) "A"
*
@extract @(TRANSX_COMMENT) "A"
*
@extract @(DIAG_COMMENT) "A"
*
*  M       (input)                       INTEGER
*          On entry,  M  specifies the number of rows of  the  matrix B.
*          M  must be at least zero. Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N  specifies the number of columns of the matrix B.
*          N  must be at least zero. Unchanged on exit.
*
*  ALPHA   (input)                       @(type_comm)
*          On entry,  ALPHA  specifies  the scalar  alpha. When ALPHA is
*          supplied as zero then the elements of the matrix B need   not
*          be set on input. Unchanged on exit.
*
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of DIMENSION ( LDA, k ), where k is m
*          when  SIDE = 'L' or 'l'  and  is  n  when  SIDE = 'R' or 'r'.
*          Before  entry  with  UPLO = 'U' or 'u',  the  leading  k by k
*          upper  triangular part of the array  A must contain the upper
*          triangular  matrix  and the strictly lower triangular part of
*          A  is  not  referenced. Before entry with  UPLO = 'L' or 'l',
*          the leading k by k lower triangular part of the array  A must
*          contain  the  lower  triangular matrix and the strictly upper
*          triangular part of A is not referenced.
*          Note  that when  DIAG = 'U' or 'u',  the diagonal elements of
*          A  are  not referenced either,  but are assumed to be  unity.
*          Unchanged on exit.
*
*  LDA     (input)                       INTEGER
*          On entry,  LDA specifies the first dimension of A as declared
*          in the  calling (sub) program.  When  SIDE = 'L' or 'l'  then
*          LDA  must  be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
*          then LDA must be at least max( 1, n ). Unchanged on exit.
*
*  B       (input/output)                @(type_comm) array
*          On entry, B is an array of DIMENSION (LDB, n).  Before entry,
*          the leading  m by n  part of the array B must contain the ma-
*          trix B, except when beta is zero, in which case B need not be
*          set on entry. On exit, the array B is overwritten by the m by
*          n updated matrix.
*
*  LDB     (input)                       INTEGER
*          On entry,  LDB specifies the first dimension of B as declared
*          in   the  calling  (sub)  program.   LDB  must  be  at  least
*          max( 1, m ). Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout trsm
@extract @(PURPOSE)
*
*  @(rname)  solves one of the matrix equations
*
*     op( A ) * X = alpha * B,   or  X * op( A ) = alpha * B,
*
*  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
*  non-unit, upper or lower triangular matrix and op( A ) is one of
*
@type real dble
*     op( A ) = A   or   op( A ) = A'.
@type cplx zplx
*     op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ).
@type real dble cplx zplx
*
*  The matrix X is overwritten on B.
*
@extract @(ARGUMENTS)
*
*  SIDE    (input)                       CHARACTER*1
*          On entry, SIDE  specifies whether op( A ) appears on the left
*          or right of X as follows:
*
*             SIDE = 'L' or 'l'   op( A ) * X = alpha * B,
*
*             SIDE = 'R' or 'r'   X * op( A ) = alpha * B.
*
*          Unchanged on exit.
*
@extract @(UPLO_TR_COMMENT) "A"
*
@extract @(TRANSX_COMMENT) "A"
*
@extract @(DIAG_COMMENT) "A"
*
*  M       (input)                       INTEGER
*          On entry,  M  specifies the number of rows of  the  matrix B.
*          M  must be at least zero. Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N  specifies the number of columns of the matrix B.
*          N  must be at least zero. Unchanged on exit.
*
*  ALPHA   (input)                       @(type_comm)
*          On entry,  ALPHA  specifies  the scalar  alpha. When ALPHA is
*          supplied as zero then the elements of the matrix B need   not
*          be set on input. Unchanged on exit.
*
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of DIMENSION ( LDA, k ), where k is m
*          when  SIDE = 'L' or 'l'  and  is  n  when  SIDE = 'R' or 'r'.
*          Before  entry  with  UPLO = 'U' or 'u',  the  leading  k by k
*          upper  triangular part of the array  A must contain the upper
*          triangular  matrix  and the strictly lower triangular part of
*          A  is  not  referenced. Before entry with  UPLO = 'L' or 'l',
*          the leading k by k lower triangular part of the array  A must
*          contain  the  lower  triangular matrix and the strictly upper
*          triangular part of A is not referenced.
*          Note  that when  DIAG = 'U' or 'u',  the diagonal elements of
*          A  are  not referenced either,  but are assumed to be  unity.
*          Unchanged on exit.
*
*  LDA     (input)                       INTEGER
*          On entry,  LDA specifies the first dimension of A as declared
*          in the  calling (sub) program.  When  SIDE = 'L' or 'l'  then
*          LDA  must  be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
*          then LDA must be at least max( 1, n ). Unchanged on exit.
*
*  B       (input/output)                @(type_comm) array
*          On entry, B is an array of DIMENSION (LDB, n).  Before entry,
*          the leading  m by n  part of the array B must contain the ma-
*          trix B, except when beta is zero, in which case B need not be
*          set on entry. On exit, the array B is overwritten by the m by
*          n solution matrix.
*
*  LDB     (input)                       INTEGER
*          On entry,  LDB specifies the first dimension of B as declared
*          in   the  calling  (sub)  program.   LDB  must  be  at  least
*          max( 1, m ). Unchanged on exit.
*
@extract @(BLAS_PAPERS)
*
@extract @(LINE)
@skip
@skip
@rout !
@skip
@skip
@undef BLAS_PAPERS
@skip
@skip
