@skip ==================================================================
@skip ATLAS / BLAS reference implementation                         AP00
@skip Last modification : 05/28/00
@skip ==================================================================
@skip File layout:
@skip
@skip rf1_inc,  rf2_inc,  rf3_inc,
@skip rotg,     rotmg,    nrm2,     asum,     amax,     scal,
@skip axpy,     copy,     swap,     rot,      rotm,     dot,
@skip dsdot,    sdsdot,   gbmv,     gbmvN,    gbmvC,    gbmvT,
@skip gbmvH,    gpmv,     gpmvLN,   gpmvLC,   gpmvLT,   gpmvLH,
@skip gpmvUN,   gpmvUC,   gpmvUT,   gpmvUH,   gemv,     gemvN,
@skip gemvC,    gemvT,    gemvH,    gpr,      ger,      sbmv,
@skip spmv,     symv,     sbmvL,    spmvL,    symvL,    sbmvU,
@skip spmvU,    symvU,    spr,      syr,      sprL,     syrL,
@skip sprU,     syrU,     spr2,     syr2,     spr2L,    syr2L,
@skip spr2U,    syr2U,    tbmv,     tbsv,     tpmv,     tpsv,
@skip trmv,     trsv,     tbmvLNN,  tbsvLNN,  tpmvLNN,  tpsvLNN,
@skip trmvLNN,  trsvLNN,  tbmvLNU,  tbsvLNU,  tpmvLNU,  tpsvLNU,
@skip trmvLNU,  trsvLNU,  tbmvLCN,  tbsvLCN,  tpmvLCN,  tpsvLCN,
@skip trmvLCN,  trsvLCN,  tbmvLCU,  tbsvLCU,  tpmvLCU,  tpsvLCU,
@skip trmvLCU,  trsvLCU,  tbmvLTN,  tbsvLTN,  tpmvLTN,  tpsvLTN,
@skip trmvLTN,  trsvLTN,  tbmvLTU,  tbsvLTU,  tpmvLTU,  tpsvLTU,
@skip trmvLTU,  trsvLTU,  tbmvLHN,  tbsvLHN,  tpmvLHN,  tpsvLHN,
@skip trmvLHN,  trsvLHN,  tbmvLHU,  tbsvLHU,  tpmvLHU,  tpsvLHU,
@skip trmvLHU,  trsvLHU,  tbmvUNN,  tbsvUNN,  tpmvUNN,  tpsvUNN,
@skip trmvUNN,  trsvUNN,  tbmvUNU,  tbsvUNU,  tpmvUNU,  tpsvUNU,
@skip trmvUNU,  trsvUNU,  tbmvUCN,  tbsvUCN,  tpmvUCN,  tpsvUCN,
@skip trmvUCN,  trsvUCN,  tbmvUCU,  tbsvUCU,  tpmvUCU,  tpsvUCU,
@skip trmvUCU,  trsvUCU,  tbmvUTN,  tbsvUTN,  tpmvUTN,  tpsvUTN,
@skip trmvUTN,  trsvUTN,  tbmvUTU,  tbsvUTU,  tpmvUTU,  tpsvUTU,
@skip trmvUTU,  trsvUTU,  tbmvUHN,  tbsvUHN,  tpmvUHN,  tpsvUHN,
@skip trmvUHN,  trsvUHN,  tbmvUHU,  tbsvUHU,  tpmvUHU,  tpsvUHU,
@skip trmvUHU,  trsvUHU,  gemm,     gemmNN,   gemmTN,   gemmCN,
@skip gemmTN,   gemmCN,   gemmNT,   gemmNC,   gemmTT,   gemmTC,
@skip gemmCT,   gemmCC,   symm,     symmLL,   symmLU,   symmRL,
@skip symmRU,   syrk,     syr2k,    syrkLN,   syrkLT,   syrkUN,
@skip syrkUT,   syr2kLN,  syr2kLT,  syr2kUN,  syr2kUT,  trmm,
@skip trsm,     trmmLLNN, trmmLLNU, trsmLLNN, trsmLLNU, trmmLLTN,
@skip trmmLLTU, trsmLLTN, trsmLLTU, trmmLLCN, trmmLLCU, trsmLLCN,
@skip trsmLLCU, trmmLUNN, trmmLUNU, trsmLUNN, trsmLUNU, trmmLUTN,
@skip trmmLUTU, trsmLUTN, trsmLUTU, trmmLUCN, trmmLUCU, trsmLUCN,
@skip trsmLUCU, trmmRLNN, trmmRLNU, trsmRLNN, trsmRLNU, trmmRLTN,
@skip trmmRLTU, trsmRLTN, trsmRLTU, trmmRLCN, trmmRLCU, trsmRLCN,
@skip trsmRLCU, trmmRUNN, trmmRUNU, trsmRUNN, trsmRUNU, trmmRUTN,
@skip trmmRUTU, trsmRUTN, trsmRUTU, trmmRUCN, trmmRUCU, trsmRUCN,
@skip trsmRUCU, Make.l1ref,         Make.l2ref,         Make.l3ref,
@skip atlas_refalias1.h,  atlas_refalias2.h,  atlas_refalias3.h,
@skip atlas_reflevel1.h,  atlas_reflevel2.h,  atlas_reflvl2.h,
@skip atlas_reflevel3.h,  atlas_reflvl3.h,    atlas_refmisc.h.
@skip ==================================================================
@skip Global define statements
@skip
@extract -addkeys -b @(BASEdir)include/atlas.inc lan=C
@skip ==================================================================
@skip Specific define statements
@skip
@define abs    @M@(upr)abs@
@define div    @M@(upr)div@
@define iso    @M@(upr)one@
@define isz    @M@(upr)zero@
@define scl    @M@(upr)scl@
@skip
@define RF1_INCLUDE @-addkeys -b @(srcdir)/atlrefblas.base rout=rf1_inc@
@define RF2_INCLUDE @-addkeys -b @(srcdir)/atlrefblas.base rout=rf2_inc@
@define RF3_INCLUDE @-addkeys -b @(srcdir)/atlrefblas.base rout=rf3_inc@
@skip ==================================================================
@skip
@rout rf1_inc
@extract @(INCLUDE)
#include "atlas_refmisc.h"
#include "atlas_reflevel1.h"
@skip
@skip ==================================================================
@skip
@rout rf2_inc
@extract @(INCLUDE)
#include "atlas_refmisc.h"
#include "atlas_reflvl2.h"
#include "atlas_reflevel2.h"
@skip
@skip ==================================================================
@skip
@rout rf3_inc
@extract @(INCLUDE)
#include "atlas_refmisc.h"
#include "atlas_reflvl3.h"
#include "atlas_reflevel3.h"
@skip
@skip ==================================================================
@skip
@rout rotg
@define rname @ATL_@(pre)refrotg@
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)

void @(rname)
(
@type real dble
   @(type_decl) * A,
   @(type_decl) * B,
   @(type_decl) * C,
   @(type_decl) * S
@type cplx zplx
   @(utyp_decl) * A,
   @(cst_utyp_decl) * B,
   @(utyp_decl) * C,
   @(utyp_decl) * S
@type real dble cplx zplx
)
{
@extract @(ATLAS_REF_COMMENT)
@type real dble
@extract @(LOCAL_VARIABLE)
   @(reg_type_decl) absa, absb, roe, scale, r, tmpa, tmpb, z;
@extract @(EXECUTABLE_STATEMENT)
   absa = @(abs)( *A ); absb = @(abs)( *B );
   roe  = ( absa > absb ? (*A) :  (*B) ); scale = absa + absb;

   if( scale != ATL_@(upr)ZERO )
   {
      tmpa = (*A) / scale; tmpb = (*B) / scale;
      if( roe < ATL_@(upr)ZERO )
      { r = - scale * sqrt( ( tmpa * tmpa ) + ( tmpb * tmpb ) ); }
      else
      { r =   scale * sqrt( ( tmpa * tmpa ) + ( tmpb * tmpb ) ); }
      *C = (*A) / r; *S = (*B) / r; z =  ATL_@(upr)ONE;
      if(   absa >  absb ) { z = *S; }
      if( ( absb >= absa ) && ( (*C) != ATL_@(upr)ZERO ) )
      { z = ATL_@(upr)ONE / (*C); }
   }
   else { *C = ATL_@(upr)ONE; *S = r = z = ATL_@(upr)ZERO; }

   *A = r; *B = z;
@type cplx zplx
@extract @(LOCAL_VARIABLE)
   @(reg_utyp_decl) absa, absb, ia, ialpha, ib, norm,
                              ra, ralpha, rb, scale, tmp, w, z;
@extract @(EXECUTABLE_STATEMENT)
   ra = @(abs)( *A   ); ia = @(abs)( A[1] );
   w  = Mmax( ra, ia ); z  = Mmin( ra, ia );
   if( z == ATL_@(upr)ZERO ) { absa = w; }
   else { tmp  = z / w; absa = w * sqrt( ATL_@(upr)ONE + ( tmp * tmp ) ); }

   if( absa == ATL_@(upr)ZERO )
   {
      *C     = ATL_@(upr)ZERO;
      Mset( ATL_@(upr)ONE, ATL_@(upr)ZERO, *S, S[1] );
      Mset( *B, B[1], *A, A[1] );
   }
   else
   {
      rb     = @(abs)( *B   ); ib     = @(abs)( B[1] );
      w      = Mmax( rb, ib ); z      = Mmin( rb, ib );
      if( z == ATL_@(upr)ZERO ) { absb = w; }
      else { tmp  = z / w; absb = w * sqrt( ATL_@(upr)ONE + ( tmp * tmp ) ); }

      scale  = absa + absb;
      Mset( *A / scale, A[1] / scale, ra, ia );
      Mset( *B / scale, B[1] / scale, rb, ib );
      norm   = scale * sqrt( ( ra * ra ) + ( ia * ia ) +
                             ( rb * rb ) + ( ib * ib ) );
      Mset( *A / absa, A[1] / absa, ralpha, ialpha );
      *C     = absa / norm;
      Mmul( ralpha, ialpha, *B, -B[1], *S, S[1] );
      Mset( *S  / norm, S[1] / norm, *S, S[1] );
      Mset( ralpha * norm, ialpha * norm, *A, A[1] );
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout rotmg
@define rname @ATL_@(pre)refrotmg@
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)

#define   GAM           4096.0
#define   GAMSQ         16777216.0

void @(rname)
(
   @(type_decl) * D1,
   @(type_decl) * D2,
   @(type_decl) * X1,
   @(cst_type_decl) Y1,
   @(type_decl) * PARAM
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
   @(sta_cst_type_decl) gam   = GAM,   rgam   = ATL_@(upr)ONE / GAM;
   @(sta_cst_type_decl) gamsq = GAMSQ, rgamsq = ATL_@(upr)ONE / GAMSQ;
   @(type_decl) d1 = (*D1), d2 = (*D2), flag, h11, h12, h21, h22,
                              p1, p2, q1, q2, tmp, u, x1 = (*X1);
@extract @(EXECUTABLE_STATEMENT)
   h11 = h12 = h21 = h22 = ATL_@(upr)ZERO;

   if( d1 < ATL_@(upr)ZERO )
   {
       PARAM[0] = ATL_@(upr)NONE;
       PARAM[1] = PARAM[2] = PARAM[3] = PARAM[4] = ATL_@(upr)ZERO;
       *D1 = *D2 = *X1 = ATL_@(upr)ZERO;
       return;
   }
 
   if( ( p2 = d2 * Y1 ) == ATL_@(upr)ZERO )
   { PARAM[0] = ATL_@(upr)NTWO; return; }
 
   p1 = d1 * x1; q2 = p2 * Y1; q1 = p1 * x1;
 
   if( @(abs)( q1 ) > @(abs)( q2 ) )
   {
      h21 = - Y1 / x1; h12 = p2 / p1; u = ATL_@(upr)ONE - h12 * h21;

      if( u <= ATL_@(upr)ZERO )
      {
         PARAM[0] = ATL_@(upr)NONE;
         PARAM[1] = PARAM[2] = PARAM[3] = PARAM[4] = ATL_@(upr)ZERO;
         *D1 = *D2 = *X1 = ATL_@(upr)ZERO;
         return;
      }
      flag = ATL_@(upr)ZERO; d1 /= u; d2 /= u; x1 *= u;
   }
   else
   {
      if( q2 < ATL_@(upr)ZERO )
      {
         PARAM[0] = ATL_@(upr)NONE;
         PARAM[1] = PARAM[2] = PARAM[3] = PARAM[4] = ATL_@(upr)ZERO;
         *D1 = *D2 = *X1 = ATL_@(upr)ZERO;
         return;
      }
      flag = ATL_@(upr)ONE;
      h11  = p1 / p2; h22  = x1 / Y1;
      u    = ATL_@(upr)ONE + h11 * h22; tmp  = d2 / u;
      d2   = d1 / u; d1   = tmp; x1 = Y1 * u;
   }

   if( d1 <= rgamsq )
   {
      if( d1 != ATL_@(upr)ZERO )                      /* scale d1 up */
      {
         if(      flag == ATL_@(upr)ZERO )
         { h11  = ATL_@(upr)ONE;  h22  = ATL_@(upr)ONE; flag = ATL_@(upr)NONE; }
         else if( flag >  ATL_@(upr)ZERO )
         { h21  = ATL_@(upr)NONE; h12  = ATL_@(upr)ONE; flag = ATL_@(upr)NONE; }
 
         do
         {
            d1 *= gamsq; x1 *= rgam; h11 *= rgam; h12 *= rgam;
         } while( d1 <= rgamsq );
      }
   }
   else if( d1 >= gamsq )                            /* scale d1 down */
   {
      if(      flag == ATL_@(upr)ZERO )
      { h11  = ATL_@(upr)ONE;  h22  = ATL_@(upr)ONE; flag = ATL_@(upr)NONE; }
      else if( flag > ATL_@(upr)ZERO )
      { h21  = ATL_@(upr)NONE; h12  = ATL_@(upr)ONE; flag = ATL_@(upr)NONE; }
 
      do
      {
         d1 *= rgamsq; x1 *= gam; h11 *= gam; h12 *= gam;
      } while( d1 >= gamsq );
   }

   if( ( tmp = @(abs)( d2 ) ) <= rgamsq )
   {
      if( d2 != ATL_@(upr)ZERO )                      /* scale d2 up */
      {
         if(      flag == ATL_@(upr)ZERO )
         { h11  = ATL_@(upr)ONE;  h22  = ATL_@(upr)ONE; flag = ATL_@(upr)NONE; }
         else if( flag > ATL_@(upr)ZERO )
         { h21  = ATL_@(upr)NONE; h12  = ATL_@(upr)ONE; flag = ATL_@(upr)NONE;
         }
 
         if( d2 > ATL_@(upr)ZERO )
         {
            do
            {
               d2 *= gamsq; h21 *= rgam; h22 *= rgam;
            } while( d2 <=  rgamsq );
         }
         else
         {
            do
            {
               d2 *= gamsq; h21 *= rgam; h22 *= rgam;
            } while( d2 >= -rgamsq );
         }
      }
   }
   else if( tmp >= gamsq )                         /* scale d2 down */
   {
      if(      flag == ATL_@(upr)ZERO )
      { h11  = ATL_@(upr)ONE;  h22  = ATL_@(upr)ONE; flag = ATL_@(upr)NONE; }
      else if( flag >  ATL_@(upr)ZERO )
      { h21  = ATL_@(upr)NONE; h12  = ATL_@(upr)ONE; flag = ATL_@(upr)NONE; }
 
      if( d2 > ATL_@(upr)ZERO )
      {
         do
         {
            d2 *= rgamsq; h21 *= gam; h22 *= gam;
         } while( d2 >= gamsq );
      }
      else
      {
         do
         {
            d2 *= rgamsq; h21 *= gam; h22 *= gam;
         } while( d2 <= -gamsq );
      }
   }

   *D1 = d1; *D2 = d2; *X1 = x1;
 
   PARAM[0] = flag;
   if(      flag <  ATL_@(upr)ZERO )
   { PARAM[1] = h11; PARAM[2] = h21; PARAM[3] = h12; PARAM[4] = h22; }
   else if( flag == ATL_@(upr)ZERO )
   {                 PARAM[2] = h21; PARAM[3] = h12;                 }
   else
   { PARAM[1] = h11;                                 PARAM[4] = h22; }
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout nrm2
@type real dble 
@define rname @ATL_@(pre)refnrm2@
@type cplx zplx
@define rname @ATL_@(upr)@(pre)refnrm2@
@type real dble cplx zplx
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)

@type real dble 
@(type) @(rname)
(
   const int                  N,
   @(cst_type_decl) * X,
   const int                  INCX
)
@type cplx zplx
@(type) @(rname)
(
   const int                  N,
   @(cst_utyp_decl) * X,
   const int                  INCX
)
@type real dble cplx zplx
{
@extract @(ATLAS_REF_COMMENT)
@type real dble 
@extract @(LOCAL_VARIABLE)
   @(reg_type_decl) absxi, scale = ATL_@(upr)ZERO,
                              ssq = ATL_@(upr)ONE, temp, x0, x1, x2, x3, x4,
                              x5, x6, x7;
   @(type_decl) * StX = (@(type) *)(X) + N * INCX;
   register int               i;
   int                        n = (int)(N), nu;
   const int                  incX2 = 2 * INCX, incX3 = 3 * INCX,
                              incX4 = 4 * INCX, incX5 = 5 * INCX,
                              incX6 = 6 * INCX, incX7 = 7 * INCX,
                              incX8 = 8 * INCX;
@extract @(EXECUTABLE_STATEMENT)
   if(    ( N  < 1 ) || ( INCX < 1 ) ) return( ATL_@(upr)ZERO );
   else if( N == 1 )                   return( @(abs)( *X ) );

@skip CHANGE MADE BY RCW:
@skip   while( ( *X == ATL_@(upr)ZERO ) && ( X != StX ) ) { X += INCX; n--; }
   while( (X != StX)  && ( *X == ATL_@(upr)ZERO ) ) { X += INCX; n--; }

   if( X == StX ) return( ATL_@(upr)ZERO );

   if( ( nu = ( n >> 3 ) << 3 ) != 0 )
   {
      StX = (@(type) *)X + nu * INCX;

      do
      {
         x0 = (*X);     x4 = X[incX4]; x1 = X[INCX ]; x5 = X[incX5]; 
         x2 = X[incX2]; x6 = X[incX6]; x3 = X[incX3]; x7 = X[incX7];

         absxi = @(abs)( x0 );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }

         absxi = @(abs)( x4 );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }

         absxi = @(abs)( x1 );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }

         absxi = @(abs)( x5 );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }

         absxi = @(abs)( x2 );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }

         absxi = @(abs)( x6 );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }

         absxi = @(abs)( x3 );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }

         absxi = @(abs)( x7 );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }

         X  += incX8;

      } while( X != StX );
   }

   for( i = n - nu; i != 0; i-- )
   {
      x0  = (*X);

      absxi = @(abs)( x0 );
      if( scale < absxi )
      {
         temp = scale / absxi; scale = absxi;
         ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
      }
      else { temp = absxi / scale; ssq += temp * temp; }

      X  += INCX;
   }
@type real
   return( scale * (float)(sqrt( (double)(ssq) )) );
@type dble
   return( scale * sqrt( ssq ) );
@type cplx zplx
@extract @(LOCAL_VARIABLE)
   @(reg_utyp_decl) scale = ATL_@(upr)ZERO, ssq = ATL_@(upr)ONE,
                              absxi, temp, x0_r, x0_i, x1_r, x1_i,
                              x2_r, x2_i, x3_r, x3_i;
   register int               i;
   int                        incx2 = 2 * INCX, n = (int)(N), nu;
   const int                  incX2 = 2 * incx2, incX3 = 3 * incx2,
                              incX4 = 4 * incx2;
   @(utyp_decl) * StX = (@(type) *)X + N * incx2;
@extract @(EXECUTABLE_STATEMENT)
   if( ( N < 1 ) || ( INCX < 1 ) ) return( ATL_@(upr)ZERO );

@SKIP CHANGE MADE BY RCW:
@skip   while( ( ( *X   == ATL_@(upr)ZERO ) &&
@skip        ( X[1] == ATL_@(upr)ZERO ) ) && ( X != StX ) ) { X += incx2; n--; }
   while( X != StX && *X == ATL_@(upr)ZERO && X[1] == ATL_@(upr)ZERO )
   {
      X += incx2;
      n--;
   }

   if( X == StX ) return( ATL_@(upr)ZERO );

   x0_r = (*X); x0_i = X[1];
      
   if( x0_r != ATL_@(upr)ZERO )
   {
      absxi = @(abs)( x0_r );
      if( scale < absxi )
      {
         temp = scale / absxi; scale = absxi;
         ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
      }
      else { temp = absxi / scale; ssq += temp * temp; }
   }
 
   if( x0_i != ATL_@(upr)ZERO )
   {
      absxi = @(abs)( x0_i );
      if( scale < absxi )
      {
         temp = scale / absxi; scale = absxi;
         ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
      }
      else { temp = absxi / scale; ssq += temp * temp; }
   }
   X += incx2; n--;

   if( ( nu = ( n >> 2 ) << 2 ) != 0 )
   {  
      StX = (@(utyp) *)X + nu * incx2;
   
      do
      {
         x0_r = (*X);       x2_r = X[incX2  ]; 
         x0_i = X[1];       x2_i = X[incX2+1];
         x1_r = X[incx2  ]; x3_r = X[incX3  ];
         x1_i = X[incx2+1]; x3_i = X[incX3+1];

         absxi = @(abs)( x0_r );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }
 
         absxi = @(abs)( x2_r );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }
 
         absxi = @(abs)( x0_i );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }
   
         absxi = @(abs)( x2_i );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }
   
         absxi = @(abs)( x1_r );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }
 
         absxi = @(abs)( x3_r );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }
 
         absxi = @(abs)( x1_i );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }
   
         absxi = @(abs)( x3_i );
         if( scale < absxi )
         {
            temp = scale / absxi; scale = absxi;
            ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
         }
         else { temp = absxi / scale; ssq += temp * temp; }
   
         X  += incX4;
      
      } while( X != StX );
   }
   
   for( i = n - nu; i != 0; i-- )
   {
      x0_r = (*X); x0_i = X[1];

      absxi = @(abs)( x0_r );
      if( scale < absxi )
      {
         temp = scale / absxi; scale = absxi;
         ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
      }
      else { temp = absxi / scale; ssq += temp * temp; }
 
      absxi = @(abs)( x0_i );
      if( scale < absxi )
      {
         temp = scale / absxi; scale = absxi;
         ssq  = ATL_@(upr)ONE + ssq * ( temp * temp );
      }
      else { temp = absxi / scale; ssq += temp * temp; }
      
      X  += incx2;
   }
@type cplx
   return( scale * (float)(sqrt( (double)(ssq) )) );
@type zplx
   return( scale * sqrt( ssq ) );
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout asum
@type real dble
@define rname @ATL_@(pre)refasum@
@type cplx zplx
@define rname @ATL_@(upr)@(pre)refasum@
@type real dble cplx zplx
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)

@type real dble
@(type) @(rname)
(
   const int                  N,
   @(cst_type_decl) * X,
   const int                  INCX
)
@type cplx zplx
@(utyp) @(rname)
(
   const int                  N,
   @(cst_utyp_decl) * X,
   const int                  INCX
)
@type real dble cplx zplx
{
@extract @(ATLAS_REF_COMMENT)
@type real dble
@extract @(LOCAL_VARIABLE)
   @(reg_type_decl) sum = ATL_@(upr)ZERO, x0, x1, x2, x3,
                              x4, x5, x6, x7;
   @(type_decl) * StX;
   register int               i;
   int                        nu;
   const int                  incX2 = 2 * INCX, incX3 = 3 * INCX,
                              incX4 = 4 * INCX, incX5 = 5 * INCX,
                              incX6 = 6 * INCX, incX7 = 7 * INCX,
                              incX8 = 8 * INCX;
@extract @(EXECUTABLE_STATEMENT)
   if( ( N > 0 ) && ( INCX >= 1 ) )
   {
      if( ( nu = ( N >> 3 ) << 3 ) != 0 )
      {
         StX = (@(type) *)X + nu * INCX;

         do
         {
            x0 = (*X);     x4 = X[incX4]; x1 = X[INCX ]; x5 = X[incX5];
            x2 = X[incX2]; x6 = X[incX6]; x3 = X[incX3]; x7 = X[incX7];

            sum += @(abs)( x0 ); sum += @(abs)( x4 );
            sum += @(abs)( x1 ); sum += @(abs)( x3 );
            sum += @(abs)( x2 ); sum += @(abs)( x6 );
            sum += @(abs)( x5 ); sum += @(abs)( x7 );

            X  += incX8;

         } while( X != StX );
      }

      for( i = N - nu; i != 0; i-- )
      {
         x0   = (*X);
         sum += @(abs)( x0 );
         X   += INCX;
      }
   }
   return( sum );
@type cplx zplx
@extract @(LOCAL_VARIABLE)
   @(reg_utyp_decl) sum = ATL_@(upr)ZERO, x0_r, x0_i, x1_r, x1_i,
                              x2_r, x2_i, x3_r, x3_i;
   @(utyp_decl) * StX;
   register int               i;
   int                        incx2 = 2 * INCX,  nu;
   const int                  incX2 = 2 * incx2, incX3 = 3 * incx2,
                              incX4 = 4 * incx2;
@extract @(EXECUTABLE_STATEMENT)
   if( ( N > 0 ) && ( INCX >= 1 ) )
   {
      if( ( nu = ( N >> 2 ) << 2 ) != 0 )
      {
         StX = (@(utyp) *)X + nu * incx2;

         do
         {
            x0_r = (*X);       x2_r = X[incX2  ];
            x0_i = X[1];       x2_i = X[incX2+1];
            x1_r = X[incx2  ]; x3_r = X[incX3  ];
            x1_i = X[incx2+1]; x3_i = X[incX3+1];

            sum += @(abs)( x0_r ); sum += @(abs)( x2_r );
            sum += @(abs)( x0_i ); sum += @(abs)( x2_i ); 
            sum += @(abs)( x1_r ); sum += @(abs)( x3_r );
            sum += @(abs)( x1_i ); sum += @(abs)( x3_i ); 

            X  += incX4;

         } while( X != StX );
      }

      for( i = N - nu; i != 0; i-- )
      {
         x0_r = (*X);          x0_i = X[1];
         sum += @(abs)( x0_r ); sum += @(abs)( x0_i ); 
         X   += incx2;
      }
   }
   return( sum );
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout amax
@define rname @ATL_i@(pre)refamax@
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)

int @(rname)
(
   const int                  N,
   @(cst_type_decl) * X,
   const int                  INCX
) 
{
@extract @(ATLAS_REF_COMMENT)
@type real dble
@extract @(LOCAL_VARIABLE)
   @(reg_type_decl) absxi, smax = ATL_@(upr)ZERO, x0, x1, x2, x3,
                              x4, x5, x6, x7;
   @(type_decl) * StX;
   register int               imax = 0, i = 0, j;
   int                        nu;
   const int                  incX2 = 2 * INCX, incX3 = 3 * INCX,
                              incX4 = 4 * INCX, incX5 = 5 * INCX,
                              incX6 = 6 * INCX, incX7 = 7 * INCX,
                              incX8 = 8 * INCX;
@extract @(EXECUTABLE_STATEMENT)
   if( N > 0 )
   {
      if( ( nu = ( N >> 3 ) << 3 ) != 0 )
      {
         StX = (@(type) *)X + nu * INCX;

         do
         {
            x0 = (*X);     x4 = X[incX4]; x1 = X[INCX ]; x5 = X[incX5];
            x2 = X[incX2]; x6 = X[incX6]; x3 = X[incX3]; x7 = X[incX7];

            absxi = @(abs)( x0 ); if( absxi > smax ) { imax = i; smax = absxi; }
            i    += 1;
            absxi = @(abs)( x1 ); if( absxi > smax ) { imax = i; smax = absxi; }
            i    += 1;
            absxi = @(abs)( x2 ); if( absxi > smax ) { imax = i; smax = absxi; }
            i    += 1;
            absxi = @(abs)( x3 ); if( absxi > smax ) { imax = i; smax = absxi; }
            i    += 1;
            absxi = @(abs)( x4 ); if( absxi > smax ) { imax = i; smax = absxi; }
            i    += 1;
            absxi = @(abs)( x5 ); if( absxi > smax ) { imax = i; smax = absxi; }
            i    += 1;
            absxi = @(abs)( x6 ); if( absxi > smax ) { imax = i; smax = absxi; }
            i    += 1;
            absxi = @(abs)( x7 ); if( absxi > smax ) { imax = i; smax = absxi; }
            i    += 1;

            X    += incX8;

         } while( X != StX );
      }

      for( j = N - nu; j != 0; j-- )
      {
         x0    = (*X);
         absxi = @(abs)( x0 ); if( absxi > smax ) { imax = i; smax = absxi; }
         i    += 1;
         X    += INCX;
      }
   } 
   return( imax );
@type cplx zplx
@extract @(LOCAL_VARIABLE)
   @(reg_utyp_decl) absxi, smax = ATL_@(upr)ZERO, x0_r, x0_i, x1_r, x1_i,
                              x2_r, x2_i, x3_r, x3_i;
   @(utyp_decl) * StX;
   register int               imax = 0, i = 0, j;
   int                        incx2 = 2 * INCX,  nu;
   const int                  incX2 = 2 * incx2, incX3 = 3 * incx2,
                              incX4 = 4 * incx2;    
@extract @(EXECUTABLE_STATEMENT)
   if( N > 0 )
   {
      if( ( nu = ( N >> 2 ) << 2 ) != 0 )
      {
         StX = (@(utyp) *)X + nu * incx2;

         do
         {
            x0_r = (*X);       x2_r = X[incX2  ];
            x0_i = X[1];       x2_i = X[incX2+1];
            x1_r = X[incx2  ]; x3_r = X[incX3  ];
            x1_i = X[incx2+1]; x3_i = X[incX3+1];

            absxi = @(abs)( x0_r ) + @(abs)( x0_i );
            if( absxi > smax ) { imax = i; smax = absxi; }
            i    += 1;

            absxi = @(abs)( x1_r ) + @(abs)( x1_i );
            if( absxi > smax ) { imax = i; smax = absxi; }
            i    += 1;

            absxi = @(abs)( x2_r ) + @(abs)( x2_i );
            if( absxi > smax ) { imax = i; smax = absxi; }
            i    += 1;

            absxi = @(abs)( x3_r ) + @(abs)( x3_i );
            if( absxi > smax ) { imax = i; smax = absxi; }
            i    += 1;

            X  += incX4;
   
         } while( X != StX );
      }  
   
      for( j = N - nu; j != 0; j-- )
      {
         x0_r  = (*X); x0_i = X[1];
         absxi = @(abs)( x0_r ) + @(abs)( x0_i );
         if( absxi > smax ) { imax = i; smax = absxi; }
         i    += 1;
         X  += incx2;
      }
   }
   return( imax );
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout scal
@type real dble cplx zplx
@define rname @ATL_@(pre)refscal@
@type chex zhex
@define rname @ATL_@(pre)@(upr)refscal@
@type real dble cplx zplx chex zhex
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)

void @(rname)
(
   const int                  N, 
@type real dble
   @(cst_type_decl) ALPHA,
   @(type_decl) * X,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(utyp_decl) * X,
@type chex zhex 
   @(cst_utyp_decl) ALPHA,
   @(utyp_decl) * X,
@type real dble cplx zplx chex zhex
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@type real dble
@extract @(LOCAL_VARIABLE)
@extract @(EXECUTABLE_STATEMENT)
   @(reg_type_decl) x0, x1, x2, x3, x4, x5, x6, x7;
   @(reg_cst_type_decl) alpha = ALPHA;
   @(type_decl) * StX;
   register int               i;
   int                        nu;
   const int                  incX2 = 2 * INCX, incX3 = 3 * INCX,
                              incX4 = 4 * INCX, incX5 = 5 * INCX,
                              incX6 = 6 * INCX, incX7 = 7 * INCX,
                              incX8 = 8 * INCX;
@extract @(EXECUTABLE_STATEMENT)
   if( ( N > 0 ) && ( alpha != ATL_@(upr)ONE ) )
   {
@beginskip  RCW: 4/10/09 : illegal by BLAS standard
      if( alpha == ATL_@(upr)ZERO )
      {
         if( ( nu = ( N >> 3 ) << 3 ) != 0 )
         {
            StX = (@(type) *)X + nu * INCX;

            do
            {
               (*X)     = ATL_@(upr)ZERO; X[incX4] = ATL_@(upr)ZERO;
               X[INCX ] = ATL_@(upr)ZERO; X[incX5] = ATL_@(upr)ZERO;
               X[incX2] = ATL_@(upr)ZERO; X[incX6] = ATL_@(upr)ZERO;
               X[incX3] = ATL_@(upr)ZERO; X[incX7] = ATL_@(upr)ZERO;

               X  += incX8;

            } while( X != StX );
         }

         for( i = N - nu; i != 0; i-- )
         {
            *X = ATL_@(upr)ZERO;
            X += INCX;
         }
      }
      else
      {
@endskip
         if( ( nu = ( N >> 3 ) << 3 ) != 0 )
         {
            StX = (@(type) *)X + nu * INCX;
 
            do
            {
               x0 = (*X);     x4 = X[incX4]; 
               x1 = X[INCX ]; x5 = X[incX5]; 
               x2 = X[incX2]; x6 = X[incX6]; 
               x3 = X[incX3]; x7 = X[incX7];

               x0 *= alpha;   x4 *= alpha;   
               x1 *= alpha;   x5 *= alpha;   
               x2 *= alpha;   x6 *= alpha;   
               x3 *= alpha;   x7 *= alpha;
 
               (*X)     = x0; X[incX4] = x4; 
               X[INCX ] = x1; X[incX5] = x5; 
               X[incX2] = x2; X[incX6] = x6; 
               X[incX3] = x3; X[incX7] = x7;
 
               X  += incX8;
 
            } while( X != StX );
         }
 
         for( i = N - nu; i != 0; i-- )
         {
            x0  = (*X);
            x0 *= alpha;
            *X  = x0;
            X  += INCX;
         }
@skip      }   // end RCW 4/10/09 change
   } 
@type cplx zplx
@extract @(LOCAL_VARIABLE)
   @(reg_cst_utyp_decl) alpha_r = *ALPHA, alpha_i = ALPHA[1];
   @(reg_utyp_decl) x0_r, x0_i, x1_r, x1_i, x2_r, x2_i, x3_r, x3_i;
   @(utyp_decl) * StX;
   register int               i;
   int                        incx2 = 2 * INCX,  nu;
   const int                  incX2 = 2 * incx2, incX3 = 3 * incx2,
                              incX4 = 4 * incx2;    
@extract @(EXECUTABLE_STATEMENT)
   if( ( N > 0 ) && !@(iso)( alpha_r, alpha_i ) )
   {
      if( @(isz)( alpha_r, alpha_i ) )
      {
         if( ( nu = ( N >> 2 ) << 2 ) != 0 )
         {
            StX = (@(utyp) *)X + nu * incx2;
 
            do
            {
               (*X)       = ATL_@(upr)ZERO; X[incX2  ] = ATL_@(upr)ZERO;
               X[1]       = ATL_@(upr)ZERO; X[incX2+1] = ATL_@(upr)ZERO;
               X[incx2  ] = ATL_@(upr)ZERO; X[incX3  ] = ATL_@(upr)ZERO;
               X[incx2+1] = ATL_@(upr)ZERO; X[incX3+1] = ATL_@(upr)ZERO;
 
               X  += incX4;
 
            } while( X != StX );
         }
 
         for( i = N - nu; i != 0; i-- )
         {
            *X   = ATL_@(upr)ZERO;
            X[1] = ATL_@(upr)ZERO;
            X   += incx2;
         }
      }
      else
      {
         if( ( nu = ( N >> 2 ) << 2 ) != 0 )
         {
            StX = (@(utyp) *)X + nu * incx2;
 
            do
            {
               x0_r  = (*X);       x2_r  = X[incX2  ]; 
               x0_i  = X[1];       x2_i  = X[incX2+1];
               x1_r  = X[incx2  ]; x3_r  = X[incX3  ]; 
               x1_i  = X[incx2+1]; x3_i  = X[incX3+1];

               (*X)       = alpha_r * x0_r - alpha_i * x0_i;
               X[incx2  ] = alpha_r * x1_r - alpha_i * x1_i;
               X[1]       = alpha_i * x0_r + alpha_r * x0_i;
               X[incx2+1] = alpha_i * x1_r + alpha_r * x1_i;
               X[incX2  ] = alpha_r * x2_r - alpha_i * x2_i;
               X[incX3  ] = alpha_r * x3_r - alpha_i * x3_i;
               X[incX2+1] = alpha_i * x2_r + alpha_r * x2_i;
               X[incX3+1] = alpha_i * x3_r + alpha_r * x3_i;
 
               X  += incX4;
 
            } while( X != StX );
         }
 
         for( i = N - nu; i != 0; i-- )
         {
            x0_r  = (*X);
            x0_i  = X[1];
            (*X)  = alpha_r * x0_r - alpha_i * x0_i;
            X[1]  = alpha_i * x0_r + alpha_r * x0_i;
            X    += incx2;
         }
      }
   }
@type chex zhex
@extract @(LOCAL_VARIABLE)
   @(reg_cst_utyp_decl) alpha = ALPHA;
   @(reg_utyp_decl) x0_r, x0_i, x1_r, x1_i, x2_r, x2_i, x3_r, x3_i;
   @(utyp_decl) * StX;
   register int               i;
   int                        incx2 = 2 * INCX,  nu;
   const int                  incX2 = 2 * incx2, incX3 = 3 * incx2,
                              incX4 = 4 * incx2;
@extract @(EXECUTABLE_STATEMENT)
   if( ( N > 0 ) && ( alpha != ATL_@(upr)ONE ) )
   {
      if( alpha == ATL_@(upr)ZERO )
      {
         if( ( nu = ( N >> 2 ) << 2 ) != 0 )
         {
            StX = (@(utyp) *)X + nu * incx2;
 
            do
            {
               (*X)       = ATL_@(upr)ZERO; X[incX2  ] = ATL_@(upr)ZERO;
               X[1]       = ATL_@(upr)ZERO; X[incX2+1] = ATL_@(upr)ZERO;
               X[incx2  ] = ATL_@(upr)ZERO; X[incX3  ] = ATL_@(upr)ZERO;
               X[incx2+1] = ATL_@(upr)ZERO; X[incX3+1] = ATL_@(upr)ZERO;
 
               X  += incX4;
 
            } while( X != StX );
         }
 
         for( i = N - nu; i != 0; i-- )
         {
            *X   = ATL_@(upr)ZERO;
            X[1] = ATL_@(upr)ZERO;
            X   += incx2;
         }
      }
      else
      {
         if( ( nu = ( N >> 2 ) << 2 ) != 0 )
         {
            StX = (@(utyp) *)X + nu * incx2;
 
            do
            {
               x0_r  = (*X);       x2_r  = X[incX2  ]; 
               x0_i  = X[1];       x2_i  = X[incX2+1];
               x1_r  = X[incx2  ]; x3_r  = X[incX3  ]; 
               x1_i  = X[incx2+1]; x3_i  = X[incX3+1];

               x0_r *= alpha;      x2_r *= alpha;
               x0_i *= alpha;      x2_i *= alpha;
               x1_r *= alpha;      x3_r *= alpha;
               x1_i *= alpha;      x3_i *= alpha;
 
               (*X)       = x0_r;  X[incX2  ] = x2_r;
               X[1]       = x0_i;  X[incX2+1] = x2_i;
               X[incx2  ] = x1_r;  X[incX3  ] = x3_r;
               X[incx2+1] = x1_i;  X[incX3+1] = x3_i;
 
               X  += incX4;
 
            } while( X != StX );
         }
 
         for( i = N - nu; i != 0; i-- )
         {
            x0_r  = (*X);  x0_i  = X[1];
            x0_r *= alpha; x0_i *= alpha;
            *X    = x0_r;  X[1]  = x0_i;
            X    += incx2;
         }
      }
   }
@type real dble cplx zplx chex zhex
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout axpy
@define rname @ATL_@(pre)refaxpy@
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)

void @(rname)
(
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(type_decl) * Y,
   const int                  INCY
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(utyp_decl) * Y,
   const int                  INCY
@type real dble cplx zplx
)
{
@extract @(ATLAS_REF_COMMENT)
@type real dble
@extract @(LOCAL_VARIABLE)
   @(reg_cst_type_decl) alpha = ALPHA;
   @(reg_type_decl) x0, x1, x2, x3, y0, y1, y2, y3;
   @(type_decl) * StX;
   register int               i;
   int                        nu;
   const int                  incX2 = 2 * INCX, incY2 = 2 * INCY,
                              incX3 = 3 * INCX, incY3 = 3 * INCY,
                              incX4 = 4 * INCX, incY4 = 4 * INCY;
@extract @(EXECUTABLE_STATEMENT)
   if( ( N > 0 ) && ( alpha != ATL_@(upr)ZERO ) )
   {
      if( ( nu = ( N >> 2 ) << 2 ) != 0 )
      {  
         StX = (@(type) *)X + nu * INCX;

         do
         {
            x0 = (*X);     y0 = (*Y);     x1 = X[INCX ]; y1 = Y[INCY ];
            x2 = X[incX2]; y2 = Y[incY2]; x3 = X[incX3]; y3 = Y[incY3];

            *Y       = y0 + alpha * x0; Y[INCY ] = y1 + alpha * x1;
            Y[incY2] = y2 + alpha * x2; Y[incY3] = y3 + alpha * x3;
      
            X  += incX4;
            Y  += incY4;
      
         } while( X != StX );
      }
   
      for( i = N - nu; i != 0; i-- )
      {  
         x0  = (*X);
         y0  = (*Y);
      
         *Y  = y0 + alpha * x0;
      
         X  += INCX;
         Y  += INCY;
      }
   }
@type cplx zplx
@extract @(LOCAL_VARIABLE)
   @(reg_cst_utyp_decl) alpha_r = *ALPHA, alpha_i = ALPHA[1];
   @(reg_utyp_decl) x0_r, x0_i, x1_r, x1_i, y0_r, y0_i, y1_r, y1_i;
   @(utyp_decl) * StX;
   register int               i;
   int                        incx2 = 2 * INCX,  incy2 = 2 * INCY,  nu;
   const int                  incX2 = 2 * incx2, incY2 = 2 * incy2;
@extract @(EXECUTABLE_STATEMENT)
   if( ( N > 0 ) && !@(isz)( alpha_r, alpha_i ) )
   {
      if( ( nu = ( N >> 1 ) << 1 ) != 0 )
      {  
         StX = (@(utyp) *)X + nu * incx2;
      
         do
         {
            x0_r = (*X);       y0_r = (*Y);
            x0_i = X[1];       y0_i = Y[1];
            x1_r = X[incx2  ]; y1_r = Y[incy2  ];
            x1_i = X[incx2+1]; y1_i = Y[incy2+1];

            *Y         = y0_r + alpha_r * x0_r - alpha_i * x0_i;
            Y[1]       = y0_i + alpha_i * x0_r + alpha_r * x0_i;
            Y[incy2  ] = y1_r + alpha_r * x1_r - alpha_i * x1_i;
            Y[incy2+1] = y1_i + alpha_i * x1_r + alpha_r * x1_i;
      
            X += incX2;
            Y += incY2;
      
         } while( X != StX );
      }
   
      for( i = N - nu; i != 0; i-- )
      {
         x0_r = (*X); y0_r = (*Y);
         x0_i = X[1]; y0_i = Y[1];
      
         *Y   = y0_r + alpha_r * x0_r - alpha_i * x0_i;
         Y[1] = y0_i + alpha_i * x0_r + alpha_r * x0_i;
      
         X += incx2;
         Y += incy2;
      }
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout copy
@define rname @ATL_@(pre)refcopy@
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)

void @(rname)
(
   const int                  N,
@type real dble
   @(cst_type_decl) * X,
   const int                  INCX,
   @(type_decl) * Y,
   const int                  INCY
@type cplx zplx
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(utyp_decl) * Y,
   const int                  INCY
@type real dble cplx zplx
)
{
@extract @(ATLAS_REF_COMMENT)
@type real dble
@extract @(LOCAL_VARIABLE)
   @(reg_type_decl) x0, x1, x2, x3, x4, x5, x6, x7;
   @(type_decl) * StX;
   register int               i;
   int                        nu;
   const int                  incX2 = 2 * INCX, incY2 = 2 * INCY,
                              incX3 = 3 * INCX, incY3 = 3 * INCY,
                              incX4 = 4 * INCX, incY4 = 4 * INCY,
                              incX5 = 5 * INCX, incY5 = 5 * INCY,
                              incX6 = 6 * INCX, incY6 = 6 * INCY,
                              incX7 = 7 * INCX, incY7 = 7 * INCY,
                              incX8 = 8 * INCX, incY8 = 8 * INCY;
@extract @(EXECUTABLE_STATEMENT)
   if( N > 0 )
   {
      if( ( nu = ( N >> 3 ) << 3 ) != 0 )
      {  
         StX = (@(type) *)X + nu * INCX;

         do
         {
            x0 = (*X);     x4 = X[incX4]; x1 = X[INCX ]; x5 = X[incX5];
            x2 = X[incX2]; x6 = X[incX6]; x3 = X[incX3]; x7 = X[incX7];

            *Y       = x0; Y[incY4] = x4; Y[INCY ] = x1; Y[incY5] = x5;
            Y[incY2] = x2; Y[incY6] = x6; Y[incY3] = x3; Y[incY7] = x7;
      
            X  += incX8;
            Y  += incY8;
      
         } while( X != StX );
      }
   
      for( i = N - nu; i != 0; i-- )
      {  
         x0  = (*X);
         *Y  = x0;
      
         X  += INCX;
         Y  += INCY;
      }
   }
@type cplx zplx
@extract @(LOCAL_VARIABLE)
   @(reg_utyp_decl) x0_r, x0_i, x1_r, x1_i, x2_r, x2_i, x3_r, x3_i;
   @(utyp_decl) * StX;
   register int               i;
   int                        incx2 = 2 * INCX,  incy2 = 2 * INCY,  nu;
   const int                  incX2 = 2 * incx2, incY2 = 2 * incy2,
                              incX3 = 3 * incx2, incY3 = 3 * incy2,
                              incX4 = 4 * incx2, incY4 = 4 * incy2;
@extract @(EXECUTABLE_STATEMENT)
   if( N > 0 )
   {
      if( ( nu = ( N >> 2 ) << 2 ) != 0 )
      {  
         StX = (@(utyp) *)X + nu * incx2;
      
         do
         {
            x0_r = (*X);       x2_r = X[incX2  ];
            x0_i = X[1];       x2_i = X[incX2+1];
            x1_r = X[incx2  ]; x3_r = X[incX3  ];
            x1_i = X[incx2+1]; x3_i = X[incX3+1];

            *Y         = x0_r; Y[incY2  ] = x2_r; 
            Y[1]       = x0_i; Y[incY2+1] = x2_i;
            Y[incy2]   = x1_r; Y[incY3  ] = x3_r; 
            Y[incy2+1] = x1_i; Y[incY3+1] = x3_i;
      
            X  += incX4;
            Y  += incY4;
      
         } while( X != StX );
      }
   
      for( i = N - nu; i != 0; i-- )
      {  
         x0_r = (*X); x0_i = X[1];
         (*Y) = x0_r; Y[1] = x0_i;
      
         X  += incx2;
         Y  += incy2;
      }
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout swap
@define rname @ATL_@(pre)refswap@
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)

void @(rname)
(
   const int                  N, 
@type real dble
   @(type_decl) * X,
   const int                  INCX,
   @(type_decl) * Y,
   const int                  INCY
@type cplx zplx
   @(utyp_decl) * X,
   const int                  INCX,
   @(utyp_decl) * Y,
   const int                  INCY
@type real dble cplx zplx
)
{
@extract @(ATLAS_REF_COMMENT)
@type real dble
@extract @(LOCAL_VARIABLE)
   @(reg_type_decl) x0, x1, x2, x3, y0, y1, y2, y3;
   @(type_decl) * StX;
   register int               i;
   int                        nu;
   const int                  incX2 = 2 * INCX, incY2 = 2 * INCY,
                              incX3 = 3 * INCX, incY3 = 3 * INCY,
                              incX4 = 4 * INCX, incY4 = 4 * INCY;
@extract @(EXECUTABLE_STATEMENT)
   if( N > 0 )
   {
      if( ( nu = ( N >> 2 ) << 2 ) != 0 )
      {  
         StX = (@(type) *)X + nu * INCX;

         do
         {
            x0 = (*X);     y0 = (*Y);
            x1 = X[INCX ]; y1 = Y[INCY ];
            x2 = X[incX2]; y2 = Y[incY2];
            x3 = X[incX3]; y3 = Y[incY3];

            *Y        = x0; *X        = y0;
            Y[INCY ]  = x1; X[INCX ]  = y1;
            Y[incY2]  = x2; X[incX2]  = y2;
            Y[incY3]  = x3; X[incX3]  = y3;
      
            X += incX4;
            Y += incY4;
      
         } while( X != StX );
      }
   
      for( i = N - nu; i != 0; i-- )
      {  
         x0  = (*X);
         y0  = (*Y);
      
         *Y  = x0;
         *X  = y0;
      
         X  += INCX;
         Y  += INCY;
      }
   }
@type cplx zplx
@extract @(LOCAL_VARIABLE)
   @(reg_utyp_decl) x0_r, x0_i, x1_r, x1_i, y0_r, y0_i, y1_r, y1_i;
   @(utyp_decl) * StX;
   register int               i;
   int                        incx2 = 2 * INCX,  incy2 = 2 * INCY,  nu;
   const int                  incX2 = 2 * incx2, incY2 = 2 * incy2;
@extract @(EXECUTABLE_STATEMENT)
   if( N > 0 )
   {
      if( ( nu = ( N >> 1 ) << 1 ) != 0 )
      {  
         StX = (@(utyp) *)X + nu * incx2;
      
         do 
         {  
            x0_r = (*X);       y0_r = (*Y);
            x0_i = X[1];       y0_i = Y[1];
            x1_r = X[incx2  ]; y1_r = Y[incy2  ];
            x1_i = X[incx2+1]; y1_i = Y[incy2+1];
         
            *Y         = x0_r; *X         = y0_r;
            Y[1]       = x0_i; X[1]       = y0_i;
            Y[incy2  ] = x1_r; X[incx2  ] = y1_r;
            Y[incy2+1] = x1_i; X[incx2+1] = y1_i;
   
            X  += incX2;
            Y  += incY2;
      
         } while( X != StX );
      }
   
      for( i = N - nu; i != 0; i-- )
      {
         x0_r = (*X); y0_r = (*Y);
         x0_i = X[1]; y0_i = Y[1];

         *Y   = x0_r; *X   = y0_r;
         Y[1] = x0_i; X[1] = y0_i;

         X  += incx2;
         Y  += incy2;
      }
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout rot
@type real dble
@define rname @ATL_@(pre)refrot@
@type cplx zplx
@define rname @ATL_@(pre)@(upr)refrot@
@type real dble cplx zplx
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)

void @(rname)
(
   const int                  N,
@type real dble
   @(type_decl) * X,
   const int                  INCX,
   @(type_decl) * Y,
   const int                  INCY,
   @(cst_type_decl) C, 
   @(cst_type_decl) S
@type cplx zplx
   @(utyp_decl) * X,
   const int                  INCX,
   @(utyp_decl) * Y,
   const int                  INCY,
   @(cst_utyp_decl) C, 
   @(cst_utyp_decl) S
@type real dble cplx zplx
)
{
@extract @(ATLAS_REF_COMMENT)
@type real dble
@extract @(LOCAL_VARIABLE)
   @(reg_type_decl) x0, x1, x2, x3, y0, y1, y2, y3;
   @(reg_cst_type_decl) co = C, si = S;
   @(type_decl) * StX;
   register int               i;
   int                        nu;
   const int                  incX2 = 2 * INCX, incY2 = 2 * INCY,
                              incX3 = 3 * INCX, incY3 = 3 * INCY,
                              incX4 = 4 * INCX, incY4 = 4 * INCY;
@extract @(EXECUTABLE_STATEMENT)
   if( ( N > 0 ) && !@(iso)( co, si ) )
   {
      if( ( nu = ( N >> 2 ) << 2 ) != 0 )
      {  
         StX = (@(type) *)X + nu * INCX;

         do
         {
            x0 = (*X);     y0 = (*Y);
            x1 = X[INCX ]; y1 = Y[INCY ];
            x2 = X[incX2]; y2 = Y[incY2];
            x3 = X[incX3]; y3 = Y[incY3];

            *X       = co * x0 + si * y0; *Y       = co * y0 - si * x0;
            X[INCX ] = co * x1 + si * y1; Y[INCY ] = co * y1 - si * x1;
            X[incX2] = co * x2 + si * y2; Y[incY2] = co * y2 - si * x2;
            X[incX3] = co * x3 + si * y3; Y[incY3] = co * y3 - si * x3;
      
            X  += incX4;
            Y  += incY4;
      
         } while( X != StX );
      }
   
      for( i = N - nu; i != 0; i-- )
      {  
         x0  = (*X);
         y0  = (*Y);

         *X  = co * x0 + si * y0;
         *Y  = co * y0 - si * x0;
      
         X  += INCX;
         Y  += INCY;
      }
   }
@type cplx zplx
@extract @(LOCAL_VARIABLE)
   @(reg_cst_type_decl) co = C, si = S;
   @(reg_utyp_decl) x0_r, x0_i, x1_r, x1_i, y0_r, y0_i, y1_r, y1_i;
   @(utyp_decl) * StX;
   register int               i;
   int                        incx2 = 2 * INCX,  incy2 = 2 * INCY,  nu;
   const int                  incX2 = 2 * incx2, incY2 = 2 * incy2;
@extract @(EXECUTABLE_STATEMENT)
   if( ( N > 0 ) && !@(iso)( co, si ) )
   {
      if( ( nu = ( N >> 1 ) << 1 ) != 0 )
      {  
         StX = (@(utyp) *)X + nu * incx2;
      
         do 
         {  
            x0_r = (*X);       y0_r = (*Y);
            x0_i = X[1];       y0_i = Y[1];
            x1_r = X[incx2  ]; y1_r = Y[incy2  ];
            x1_i = X[incx2+1]; y1_i = Y[incy2+1];
         
            *X         = co * x0_r + si * y0_r;
            *Y         = co * y0_r - si * x0_r;
            X[1]       = co * x0_i + si * y0_i;
            Y[1]       = co * y0_i - si * x0_i;
            X[incx2  ] = co * x1_r + si * y1_r;
            Y[incy2  ] = co * y1_r - si * x1_r;
            X[incx2+1] = co * x1_i + si * y1_i;
            Y[incy2+1] = co * y1_i - si * x1_i;
   
            X  += incX2;
            Y  += incY2;
      
         } while( X != StX );
      }
   
      for( i = N - nu; i != 0; i-- )
      {
         x0_r = (*X); y0_r = (*Y);
         x0_i = X[1]; y0_i = Y[1];
  
         *X   = co * x0_r + si * y0_r;
         *Y   = co * y0_r - si * x0_r;
         X[1] = co * x0_i + si * y0_i;
         Y[1] = co * y0_i - si * x0_i;

         X  += incx2;
         Y  += incy2;
      }
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout rotm
@define rname @ATL_@(pre)refrotm@
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)
 
void @(rname)
(
   const int                  N,
   @(type_decl) * X,
   const int                  INCX,
   @(type_decl) * Y,
   const int                  INCY,
   @(cst_type_decl) * PARAM
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
   @(reg_type_decl) h11, h12, h21, h22, x0, x1, x2, x3,
                              y0, y1, y2, y3;
   @(type_decl) * StX;
   register int               i;
   int                        nu;
   const int                  incX2 = 2 * INCX, incY2 = 2 * INCY,
                              incX3 = 3 * INCX, incY3 = 3 * INCY,
                              incX4 = 4 * INCX, incY4 = 4 * INCY;
@extract @(EXECUTABLE_STATEMENT)
   if( ( N > 0 ) && ( *PARAM != ATL_@(upr)NTWO ) )
   {
      if(      *PARAM   == ATL_@(upr)NONE )
      {
         h11 = PARAM[1]; h21 = PARAM[2]; h12 = PARAM[3]; h22 = PARAM[4];

         if( ( nu = ( N >> 2 ) << 2 ) != 0 )
         {  
            StX = (@(type) *)X + nu * INCX;

            do
            {
               x0 = (*X);     y0 = (*Y);     x1 = X[INCX ]; y1 = Y[INCY ];
               x2 = X[incX2]; y2 = Y[incY2]; x3 = X[incX3]; y3 = Y[incY3];

               *X        = ( x0 * h11 ) + ( y0 * h12 );
               *Y        = ( x0 * h21 ) + ( y0 * h22 );
               X[INCX ]  = ( x1 * h11 ) + ( y1 * h12 );
               Y[INCY ]  = ( x1 * h21 ) + ( y1 * h22 );
               X[incX2]  = ( x2 * h11 ) + ( y2 * h12 );
               Y[incY2]  = ( x2 * h21 ) + ( y2 * h22 );
               X[incX3]  = ( x3 * h11 ) + ( y3 * h12 );
               Y[incY3]  = ( x3 * h21 ) + ( y3 * h22 );
      
               X  += incX4;
               Y  += incY4;
      
            } while( X != StX );
         }
   
         for( i = N - nu; i != 0; i-- )
         {  
            x0  = (*X); y0  = (*Y);

            *X  = ( x0 * h11 ) + ( y0 * h12 );
            *Y  = ( x0 * h21 ) + ( y0 * h22 );
      
            X  += INCX;
            Y  += INCY;
         }
      }
      else if( *PARAM == ATL_@(upr)ZERO )
      {
         h21 = PARAM[2]; h12 = PARAM[3];

         if( ( nu = ( N >> 2 ) << 2 ) != 0 )
         {
            StX = (@(type) *)X + nu * INCX;
 
            do
            {
               x0 = (*X);     y0 = (*Y);     x1 = X[INCX ]; y1 = Y[INCY ];
               x2 = X[incX2]; y2 = Y[incY2]; x3 = X[incX3]; y3 = Y[incY3];
 
               *X       = x0 + ( y0 * h12 ); *Y       = y0 + ( x0 * h21 );
               X[INCX ] = x1 + ( y1 * h12 ); Y[INCY ] = y1 + ( x1 * h21 );
               X[incX2] = x2 + ( y2 * h12 ); Y[incY2] = y2 + ( x2 * h21 );
               X[incX3] = x3 + ( y3 * h12 ); Y[incY3] = y3 + ( x3 * h21 );
 
               X  += incX4;
               Y  += incY4;
 
            } while( X != StX );
         }
 
         for( i = N - nu; i != 0; i-- )
         {
            x0  = (*X); y0  = (*Y);
            *X  = x0 + ( y0 * h12 ); *Y  = y0 + ( x0 * h21 );
            X  += INCX; Y  += INCY;
         }
      }
      else if( *PARAM == ATL_@(upr)ONE )
      {
         h11 = PARAM[1]; h22 = PARAM[4];

         if( ( nu = ( N >> 2 ) << 2 ) != 0 )
         {
            StX = (@(type) *)X + nu * INCX;
 
            do
            {
               x0 = (*X);     y0 = (*Y);     x1 = X[INCX ]; y1 = Y[INCY ];
               x2 = X[incX2]; y2 = Y[incY2]; x3 = X[incX3]; y3 = Y[incY3];
 
               *X       = ( x0 * h11 ) + y0; *Y       = ( y0 * h22 ) - x0;
               X[INCX ] = ( x1 * h11 ) + y1; Y[INCY ] = ( y1 * h22 ) - x1;
               X[incX2] = ( x2 * h11 ) + y2; Y[incY2] = ( y2 * h22 ) - x2;
               X[incX3] = ( x3 * h11 ) + y3; Y[incY3] = ( y3 * h22 ) - x3;
 
               X  += incX4;
               Y  += incY4;
 
            } while( X != StX );
         }
 
         for( i = N - nu; i != 0; i-- )
         {
            x0  = (*X); y0  = (*Y);
            *X  = ( x0 * h11 ) + y0; *Y  = ( h22 * y0 ) - x0;
            X  += INCX; Y  += INCY;
         }
      }
   }
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout dot
@type real dble
@define rname @ATL_@(pre)refdot@
@type cplx zplx chex zhex
@define rname @ATL_@(pre)refdot@(uc)_sub@
@type real dble cplx zplx chex zhex
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)
 
@type real dble
@(type) @(rname)
(
   const int                  N,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) * Y,
   const int                  INCY
)
@type cplx zplx chex zhex
void @(rname)
(
   const int                  N,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * Y,
   const int                  INCY,
   @(utyp_decl) * DOT
)
@type real dble cplx zplx chex zhex
{
@extract @(ATLAS_REF_COMMENT)
@type real dble
@extract @(LOCAL_VARIABLE)
   @(reg_type_decl) dot = ATL_@(pre)ZERO, x0, x1, x2, x3,
                              y0, y1, y2, y3;
   @(type_decl) * StX;
   register int               i;
   int                        nu;
   const int                  incX2 = 2 * INCX, incY2 = 2 * INCY,
                              incX3 = 3 * INCX, incY3 = 3 * INCY,
                              incX4 = 4 * INCX, incY4 = 4 * INCY;
@extract @(EXECUTABLE_STATEMENT)
   if( N > 0 )
   {
      if( ( nu = ( N >> 2 ) << 2 ) != 0 )
      {  
         StX = (@(type) *)X + nu * INCX;

         do
         {
            x0 = (*X);     y0 = (*Y);     x1 = X[INCX ]; y1 = Y[INCY ];
            x2 = X[incX2]; y2 = Y[incY2]; x3 = X[incX3]; y3 = Y[incY3];
            dot += x0 * y0; dot += x1 * y1; dot += x2 * y2; dot += x3 * y3;
            X  += incX4; Y  += incY4;
         } while( X != StX );
      }
   
      for( i = N - nu; i != 0; i-- )
      {  x0 = (*X); y0 = (*Y); dot += x0 * y0; X += INCX; Y += INCY; }
   }
   return( dot );
@type cplx zplx chex zhex
   register int               i;
   int                        incx2 = 2 * INCX,  incy2 = 2 * INCY,  nu;
   const int                  incX2 = 2 * incx2, incY2 = 2 * incy2;
   @(utyp_decl) * StX;
   @(reg_utyp_decl) id = ATL_@(upr)ZERO, rd = ATL_@(upr)ZERO,
                              x0_r, x0_i, x1_r, x1_i, y0_r, y0_i, y1_r, y1_i;
@extract @(EXECUTABLE_STATEMENT)
   if( N > 0 )
   {
      if( ( nu = ( N >> 1 ) << 1 ) != 0 )
      {  
         StX = (@(utyp) *)X + nu * incx2;
      
         do 
         {  
            x0_r = (*X);       y0_r = (*Y);
            x0_i = X[1];       y0_i = Y[1];
            x1_r = X[incx2  ]; y1_r = Y[incy2  ];
            x1_i = X[incx2+1]; y1_i = Y[incy2+1];
   
@type cplx zplx
            rd += x0_r * y0_r - x0_i * y0_i;
            id += x0_r * y0_i + x0_i * y0_r;
            rd += x1_r * y1_r - x1_i * y1_i;
            id += x1_r * y1_i + x1_i * y1_r;
@type chex zhex
            rd += x0_r * y0_r + x0_i * y0_i;
            id += x0_r * y0_i - x0_i * y0_r;
            rd += x1_r * y1_r + x1_i * y1_i;
            id += x1_r * y1_i - x1_i * y1_r;
@type cplx zplx chex zhex
   
            X  += incX2;
            Y  += incY2;
      
         } while( X != StX );
      }
   
      for( i = N - nu; i != 0; i-- )
      {
         x0_r = (*X); y0_r = (*Y); x0_i = X[1]; y0_i = Y[1];
@type cplx zplx
         rd += x0_r * y0_r - x0_i * y0_i; id += x0_r * y0_i + x0_i * y0_r;
@type chex zhex
         rd += x0_r * y0_r + x0_i * y0_i; id += x0_r * y0_i - x0_i * y0_r;
@type cplx zplx chex zhex
         X  += incx2; Y  += incy2;
      }
   }
   *DOT   = rd; DOT[1] = id;
@type real dble cplx zplx chex zhex
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout dsdot
@define rname @ATL_dsrefdot@
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)
 
double @(rname)
(
   const int                  N,
   const float                * X,
   const int                  INCX,
   const float                * Y,
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
   register double            dot = ATL_dZERO, x0, x1, x2, x3, y0, y1, y2, y3;
   float                      * StX;
   register int               i;
   int                        nu;
   const int                  incX2 = 2 * INCX, incY2 = 2 * INCY,
                              incX3 = 3 * INCX, incY3 = 3 * INCY,
                              incX4 = 4 * INCX, incY4 = 4 * INCY;
@extract @(EXECUTABLE_STATEMENT)
   if( N > 0 )
   {
      if( ( nu = ( N >> 2 ) << 2 ) != 0 )
      {  
         StX = (float *)X + nu * INCX;

         do
         {
            x0 = (double)(*X);       y0 = (double)(*Y);
            x1 = (double)(X[INCX ]); y1 = (double)(Y[INCY ]);
            x2 = (double)(X[incX2]); y2 = (double)(Y[incY2]);
            x3 = (double)(X[incX3]); y3 = (double)(Y[incY3]);
            dot += x0 * y0; dot += x1 * y1; dot += x2 * y2; dot += x3 * y3;
            X  += incX4;
            Y  += incY4;
      
         } while( X != StX );
      }
   
      for( i = N - nu; i != 0; i-- )
      {  
         x0 = (double)(*X); y0 = (double)(*Y); dot += x0 * y0;
         X += INCX; Y += INCY;
      }
   }
   return( dot );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout sdsdot
@define rname @ATL_sdsrefdot@
@extract @(VER_ATLAS_SRC)
@extract @(RF1_INCLUDE)
 
float @(rname)
(
   const int                  N,
   const float                B,
   const float                * X,
   const int                  INCX,
   const float                * Y,
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
   register double            dot = (double)(B), x0, x1, x2, x3, y0, y1, y2, y3;
   float                      * StX;
   register int               i;
   int                        nu;
   const int                  incX2 = 2 * INCX, incY2 = 2 * INCY,
                              incX3 = 3 * INCX, incY3 = 3 * INCY,
                              incX4 = 4 * INCX, incY4 = 4 * INCY;
@extract @(EXECUTABLE_STATEMENT)
   if( N > 0 )
   {
      if( ( nu = ( N >> 2 ) << 2 ) != 0 )
      {
         StX = (float *)X + nu * INCX;
 
         do
         {
            x0 = (double)(*X);       y0 = (double)(*Y);
            x1 = (double)(X[INCX ]); y1 = (double)(Y[INCY ]);
            x2 = (double)(X[incX2]); y2 = (double)(Y[incY2]);
            x3 = (double)(X[incX3]); y3 = (double)(Y[incY3]);
            dot += x0 * y0; dot += x1 * y1; dot += x2 * y2; dot += x3 * y3;
            X  += incX4; Y  += incY4;
         } while( X != StX );
      }
 
      for( i = N - nu; i != 0; i-- )
      {
         x0  = (double)(*X); y0  = (double)(*Y); dot += x0 * y0;
         X  += INCX;
         Y  += INCY;
      }
   }
   return( (float)(dot) );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gbmv
@define rname @ATL_@(pre)refgbmv@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_TRANS     TRANS,
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
@type real dble
   if( ( M == 0 ) || ( N == 0 ) ||
       ( ( ALPHA == ATL_@(upr)ZERO ) && ( BETA == ATL_@(upr)ONE  ) ) ) return;
 
   if( ALPHA == ATL_@(upr)ZERO ) { M@(pre)vscal( M, BETA, Y, INCY ); return; }
 
   if( ( TRANS == AtlasNoTrans ) || ( TRANS == AtlasConj ) )
   {
      ATL_@(pre)refgbmvN( M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY );
   }
   else
   {
      ATL_@(pre)refgbmvT( M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY );
   }
@type cplx zplx
   if( ( M == 0 ) || ( N == 0 ) ||
       ( @(isz)( ALPHA[0], ALPHA[1] ) && @(iso)( BETA[0], BETA[1] ) ) )
      return;
 
   if( @(isz)( ALPHA[0], ALPHA[1] ) )
   { M@(pre)vscal( M, BETA, Y, INCY ); return; }
 
   if(      TRANS == AtlasNoTrans )
   {
      ATL_@(pre)refgbmvN( M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY );
   }
   else if( TRANS == AtlasConj    )
   {
      ATL_@(pre)refgbmvC( M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY );
   }
   else if( TRANS == AtlasTrans   )
   {
      ATL_@(pre)refgbmvT( M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY );
   }
   else
   {
      ATL_@(pre)refgbmvH( M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY );
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gbmvN
@define rname @ATL_@(pre)refgbmvN@
@rout gbmvC
@define rname @ATL_@(pre)refgbmvC@
@rout gbmvN gbmvC
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_utyp_decl) t0;
   int                        i, i0, i1, iaij, iy, j, jaj, jx, k, kx=0, ky=0;
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( M, BETA, Y, INCY );

   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = ALPHA * X[jx]; k = KU - j; i0 = ( j - KU > 0 ? j - KU : 0 );
      i1 = ( M - 1 > j + KL ? j + KL : M - 1 );
      for( i = i0, iaij  = k+i0+jaj, iy = ky; i <= i1;
           i++,    iaij += 1,        iy += INCY ) { Y[iy] += A[iaij] * t0; }
      if( j >= KU ) ky += INCY;
   } 
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, i1, iaij, iy, j, jaj, jx, k, kx=0, ky=0;
   int                        incx2 = 2 * INCX, incy2 = 2 * INCY,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( M, BETA, Y, INCY );

   for( j = 0, jaj  = 0, jx  = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
      k = KU - j; i0 = ( j - KU > 0 ? j - KU : 0 );
      i1   = ( M - 1 > j + KL ? j + KL : M - 1 );
 
      for( i = i0, iaij = ((k+i0) << 1)+jaj, iy = ky; i <= i1;
           i++, iaij += 2, iy += incy2 )
@rout gbmvN
      { Mmla( A[iaij],  A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] ); }
@rout gbmvC
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] ); }
@rout gbmvN gbmvC
      if( j >= KU ) ky += incy2;
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gbmvT
@define rname @ATL_@(pre)refgbmvT@
@rout gbmvH
@define rname @ATL_@(pre)refgbmvH@
@rout gbmvT gbmvH
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_utyp_decl) t0;
   int                        i, i0, i1, iaij, ix, j, jaj, jy, k, kx=0, ky=0;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jy = ky; j < M; j++, jaj += LDA, jy += INCY )
   {
      t0 = ATL_@(upr)ZERO; k = KU - j; i0 = ( j - KU > 0 ? j - KU : 0 );
      i1 = ( N - 1 > j + KL ? j + KL : N - 1 );
 
      for( i = i0, iaij = k+i0+jaj, ix = kx; i <= i1;
           i++, iaij += 1, ix += INCX ) { t0 += A[iaij] * X[ix]; }
      M@(pre)elscal( BETA, Y[jy] ); Y[jy] += ALPHA * t0;
      if( j >= KU ) kx += INCX;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, i1, iaij, ix, j, jaj, jy, k, kx=0, ky=0;
   int                        incx2 = 2 * INCX, incy2 = 2 * INCY,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jy = ky; j < M; j++, jaj += lda2, jy += incy2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      k = KU - j; i0 = ( j - KU > 0 ? j - KU : 0 );
      i1 = ( N - 1 > j + KL ? j + KL : N - 1 );

      for( i  = i0,      iaij  = ((k+i0) << 1)+jaj, ix  = kx;
           i <= i1; i++, iaij += 2,                 ix += incx2 )
@rout gbmvT
      { Mmla( A[iaij],  A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
@rout gbmvH
      { Mmla( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
@rout gbmvT gbmvH
      M@(pre)elscal( BETA[0], BETA[1], Y[jy], Y[jy+1] );
      Mmla( ALPHA[0], ALPHA[1], t0_r, t0_i, Y[jy], Y[jy+1] );
      if( j >= KU ) kx += incx2;
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gpmv
@define rname @ATL_@(pre)refgpmv@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
@type real dble
   if( ( M == 0 ) || ( N == 0 ) ||
       ( ( ALPHA == ATL_@(upr)ZERO ) && ( BETA == ATL_@(upr)ONE  ) ) ) return;
 
   if( ALPHA == ATL_@(upr)ZERO ) { M@(pre)vscal( M, BETA, Y, INCY ); return; }
 
   if( UPLO == AtlasUpper )
   {
      if( ( TRANS == AtlasNoTrans ) || ( TRANS == AtlasConj ) )
      { ATL_@(pre)refgpmvUN( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
      else
      { ATL_@(pre)refgpmvUT( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
   }
   else
   {
      if( ( TRANS == AtlasNoTrans ) || ( TRANS == AtlasConj ) )
      { ATL_@(pre)refgpmvLN( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
      else
      { ATL_@(pre)refgpmvLT( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
   }
@type cplx zplx
   if( ( M == 0 ) || ( N == 0 ) ||
       ( @(isz)( ALPHA[0], ALPHA[1] ) && @(iso)( BETA[0], BETA[1] ) ) )
      return;

   if( @(isz)( ALPHA[0], ALPHA[1] ) )
   { M@(pre)vscal( M, BETA, Y, INCY ); return; }
 
   if( UPLO == AtlasUpper )
   {
      if(      TRANS == AtlasNoTrans )
      { ATL_@(pre)refgpmvUN( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
      else if( TRANS == AtlasConj    )
      { ATL_@(pre)refgpmvUC( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
      else if( TRANS == AtlasTrans   )
      { ATL_@(pre)refgpmvUT( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
      else
      { ATL_@(pre)refgpmvUH( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
   }
   else
   {
      if(      TRANS == AtlasNoTrans )
      { ATL_@(pre)refgpmvLN( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
      else if( TRANS == AtlasConj    )
      { ATL_@(pre)refgpmvLC( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
      else if( TRANS == AtlasTrans   )
      { ATL_@(pre)refgpmvLT( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
      else
      { ATL_@(pre)refgpmvLH( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gpmvLN
@define rname @ATL_@(pre)refgpmvLN@
@rout gpmvLC
@define rname @ATL_@(pre)refgpmvLC@
@rout gpmvLN gpmvLC
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, iy, j, jaj, jx, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( M, BETA, Y, INCY );

   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += INCX )
   {
      t0 = ALPHA * X[jx];
      for( i = 0, iaij = jaj, iy = 0; i < M; i++, iaij += 1, iy += INCY )
      { Y[iy] += A[iaij] * t0; }
      lda -= 1; jaj += lda;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, incy2 = 2 * INCY,
                              iy, j, jaj, jx, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( M, BETA, Y, INCY );

   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
 
      for( i = 0, iaij = jaj, iy = 0; i < M; i++, iaij += 2, iy += incy2 )
@rout gpmvLN
      { Mmla( A[iaij],  A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] ); }
@rout gpmvLC
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] ); }
@rout gpmvLN gpmvLC
      lda2 -= 2; jaj += lda2;
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gpmvLT
@define rname @ATL_@(pre)refgpmvLT@
@rout gpmvLH
@define rname @ATL_@(pre)refgpmvLH@
@rout gpmvLT gpmvLH
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jy, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jy = 0; j < M; j++, jy += INCY )
   {
      t0 = ATL_@(upr)ZERO;
      for( i = 0, iaij = jaj, ix = 0; i < N; i++, iaij += 1, ix += INCX )
      { t0 += A[iaij] * X[ix]; }
      M@(pre)elscal( BETA, Y[jy] ); Y[jy] += ALPHA * t0;
      lda -= 1; jaj += lda;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, incy2 = 2 * INCY,
                              ix, j, jaj, jy, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jy = 0; j < M; j++, jy += incy2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < N; i++, iaij += 2, ix += incx2 )
@rout gpmvLT
      { Mmla( A[iaij],  A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
@rout gpmvLH
      { Mmla( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
@rout gpmvLT gpmvLH
      M@(pre)elscal( BETA[0], BETA[1], Y[jy], Y[jy+1] );
      Mmla( ALPHA[0], ALPHA[1], t0_r, t0_i, Y[jy], Y[jy+1] );
      lda2 -= 2; jaj += lda2;
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gpmvUN
@define rname @ATL_@(pre)refgpmvUN@
@rout gpmvUC
@define rname @ATL_@(pre)refgpmvUC@
@rout gpmvUN gpmvUC
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, iy, j, jaj, jx, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( M, BETA, Y, INCY );

   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += INCX )
   {
      t0 = ALPHA * X[jx];
      for( i = 0, iaij = jaj, iy = 0; i < M; i++, iaij += 1, iy += INCY )
      { Y[iy] += A[iaij] * t0; }
      jaj += lda; lda += 1;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, incy2 = 2 * INCY,
                              iy, j, jaj, jx, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( M, BETA, Y, INCY );

   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
 
      for( i = 0, iaij = jaj, iy = 0; i < M; i++, iaij += 2, iy += incy2 )
@rout gpmvUN
      { Mmla( A[iaij],  A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] ); }
@rout gpmvUC
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] ); }
@rout gpmvUN gpmvUC
      jaj += lda2; lda2 += 2;
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gpmvUT
@define rname @ATL_@(pre)refgpmvUT@
@rout gpmvUH
@define rname @ATL_@(pre)refgpmvUH@
@rout gpmvUT gpmvUH
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jy, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jy = 0; j < M; j++, jy += INCY )
   {
      t0 = ATL_@(upr)ZERO;
      for( i = 0, iaij = jaj, ix = 0; i < N; i++, iaij += 1, ix += INCX )
      { t0 += A[iaij] * X[ix]; }
      M@(pre)elscal( BETA, Y[jy] ); Y[jy] += ALPHA * t0;
      jaj += lda; lda += 1;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, incy2 = 2 * INCY,
                              ix, j, jaj, jy, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jy = 0; j < M; j++, jy += incy2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < N; i++, iaij += 2, ix += incx2 )
@rout gpmvUT
      { Mmla( A[iaij],  A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
@rout gpmvUH
      { Mmla( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
@rout gpmvUT gpmvUH
      M@(pre)elscal( BETA[0], BETA[1], Y[jy], Y[jy+1] );
      Mmla( ALPHA[0], ALPHA[1], t0_r, t0_i, Y[jy], Y[jy+1] );
      jaj += lda2; lda2 += 2;
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gemv
@define rname @ATL_@(pre)refgemv@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_TRANS     TRANS,
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
@type real dble
   if( ( M == 0 ) || ( N == 0 ) ||
       ( ( ALPHA == ATL_@(upr)ZERO ) && ( BETA == ATL_@(upr)ONE  ) ) ) return;
 
   if( ALPHA == ATL_@(upr)ZERO ) { M@(pre)vscal( M, BETA, Y, INCY ); return; }
 
   if( ( TRANS == AtlasNoTrans ) || ( TRANS == AtlasConj ) )
   { ATL_@(pre)refgemvN( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
   else
   { ATL_@(pre)refgemvT( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
@type cplx zplx
   if( ( M == 0 ) || ( N == 0 ) ||
       ( @(isz)( ALPHA[0], ALPHA[1] ) && @(iso)( BETA[0], BETA[1] ) ) )
      return;
 
   if( @(isz)( ALPHA[0], ALPHA[1] ) )
   { M@(pre)vscal( M, BETA, Y, INCY ); return; }
 
   if(      TRANS == AtlasNoTrans )
   { ATL_@(pre)refgemvN( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
   else if( TRANS == AtlasConj    )
   { ATL_@(pre)refgemvC( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
   else if( TRANS == AtlasTrans   )
   { ATL_@(pre)refgemvT( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
   else
   { ATL_@(pre)refgemvH( M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY ); }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gemvN
@define rname @ATL_@(pre)refgemvN@
@rout gemvC
@define rname @ATL_@(pre)refgemvC@
@rout gemvN gemvC
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_utyp_decl) t0;
   int                        i, iaij, iy, j, jaj, jx; 
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( M, BETA, Y, INCY );
   for( j = 0, jaj  = 0, jx = 0; j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = ALPHA * X[jx];
      for( i = 0, iaij = jaj, iy = 0; i < M; i++, iaij += 1, iy += INCY )
      { Y[iy] += A[iaij] * t0; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, iy, j, jaj, jx; 
   int                        incx2 = 2 * INCX, incy2 = 2 * INCY,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( M, BETA, Y, INCY );
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, iy = 0; i < M; i++, iaij += 2, iy += incy2 )
@rout gemvN
      { Mmla( A[iaij],  A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] ); }
@rout gemvC
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] ); }
@rout gemvN gemvC
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gemvT
@define rname @ATL_@(pre)refgemvT@
@rout gemvH
@define rname @ATL_@(pre)refgemvH@
@rout gemvT gemvH
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_utyp_decl) t0;
   int                        i, iaij, ix, j, jaj, jy;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj  = 0, jy  = 0; j < M; j++, jaj += LDA, jy += INCY )
   {
      t0 = ATL_@(upr)ZERO;
      for( i = 0, iaij = jaj, ix = 0; i < N; i++, iaij += 1, ix += INCX )
      { t0 += A[iaij] * X[ix]; }
      M@(pre)elscal( BETA, Y[jy] ); Y[jy] += ALPHA * t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, ix, j, jaj, jy;
   int                        incx2 = 2 * INCX, incy2 = 2 * INCY,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jy = 0; j < M; j++, jaj += lda2, jy += incy2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < N; i++, iaij += 2, ix += incx2 )
@rout gemvT
      { Mmla( A[iaij],  A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
@rout gemvH
      { Mmla( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
@rout gemvT gemvH
      M@(pre)elscal( BETA[0], BETA[1], Y[jy], Y[jy+1] );
      Mmla( ALPHA[0], ALPHA[1], t0_r, t0_i, Y[jy], Y[jy+1] );
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gpr
@define rname @ATL_@(pre)refgpr@(uc)@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) * Y,
   const int                  INCY,
   @(type_decl) * A,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * Y,
   const int                  INCY,
   @(utyp_decl) * A,
@type real dble cplx zplx chex zhex
   const int                  LDA
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
@type real dble
   if( ( M == 0 ) || ( N == 0 ) || ( ALPHA == ATL_@(upr)ZERO ) ) return;
@type cplx zplx chex zhex
   if( ( M == 0 ) || ( N == 0 ) || @(isz)( ALPHA[0], ALPHA[1] ) ) return;
@type real dble cplx zplx chex zhex
 
   if( UPLO == AtlasLower )
   { ATL_@(pre)refgpr@(uc)L( M, N, ALPHA, X, INCX, Y, INCY, A, LDA ); }
   else
   { ATL_@(pre)refgpr@(uc)U( M, N, ALPHA, X, INCX, Y, INCY, A, LDA ); }
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip

@define rname @ATL_@(pre)refgpr@(uc)L@
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) * Y,
   const int                  INCY,
   @(type_decl) * A,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * Y,
   const int                  INCY,
   @(utyp_decl) * A,
@type real dble cplx zplx chex zhex
   const int                  LDA
)
{
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jy, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jy = 0; j < N; j++, jy += INCY )
   {
      t0 = ALPHA * Y[jy];
      for( i = 0, iaij  = jaj, ix  = 0; i < M; i++, iaij += 1, ix += INCX )
      { A[iaij] += X[ix] * t0; }
      lda -= 1; jaj += lda;
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, incy2 = 2 * INCY,
                              ix, j, jaj, jy, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jy = 0; j < N; j++, jy += incy2 )
   {
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], Y[jy],  Y[jy+1], t0_r, t0_i );
@type chex zhex
      Mmul( ALPHA[0], ALPHA[1], Y[jy], -Y[jy+1], t0_r, t0_i );
@type cplx zplx chex zhex
      for( i = 0, iaij = jaj, ix = 0; i < M; i++, iaij += 2, ix += incx2 )
      { Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] ); }
      lda2 -= 2; jaj += lda2;
   }
@type real dble cplx zplx chex zhex
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
 
@define rname @ATL_@(pre)refgpr@(uc)U@
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) * Y,
   const int                  INCY,
   @(type_decl) * A,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * Y,
   const int                  INCY,
   @(utyp_decl) * A,
@type real dble cplx zplx chex zhex
   const int                  LDA
)
{
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jy, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jy = 0; j < N; j++, jy += INCY )
   {
      t0 = ALPHA * Y[jy];
      for( i = 0, iaij  = jaj, ix  = 0; i < M; i++, iaij += 1, ix += INCX )
      { A[iaij] += X[ix] * t0; }
      jaj += lda; lda += 1;
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, incy2 = 2 * INCY,
                              ix, j, jaj, jy, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jy = 0; j < N; j++, jy += incy2 )
   {
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], Y[jy],  Y[jy+1], t0_r, t0_i );
@type chex zhex
      Mmul( ALPHA[0], ALPHA[1], Y[jy], -Y[jy+1], t0_r, t0_i );
@type cplx zplx chex zhex
      for( i = 0, iaij = jaj, ix = 0; i < M; i++, iaij += 2, ix += incx2 )
      { Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] ); }
      jaj += lda2; lda2 += 2;
   }
@type real dble cplx zplx chex zhex
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout ger
@define rname @ATL_@(pre)refger@(uc)@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) * Y,
   const int                  INCY,
   @(type_decl) * A,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * Y,
   const int                  INCY,
   @(utyp_decl) * A,
@type real dble cplx zplx chex zhex
   const int                  LDA
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jy;
@extract @(EXECUTABLE_STATEMENT)
   if( ( M == 0 ) || ( N == 0 ) || ( ALPHA == ATL_@(upr)ZERO ) ) return;
 
   for( j = 0, jaj = 0, jy = 0; j < N; j++, jaj += LDA, jy += INCY )
   {
      t0 = ALPHA * Y[jy];
      for( i = 0, iaij = jaj, ix = 0; i < M; i++, iaij += 1, ix += INCX )
      { A[iaij] += X[ix] * t0; }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, incy2 = 2 * INCY,
                              ix, j, jaj, jy, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   if( ( M == 0 ) || ( N == 0 ) || @(isz)( ALPHA[0], ALPHA[1] ) ) return;
 
   for( j = 0, jaj = 0, jy = 0; j < N; j++, jaj += lda2, jy += incy2 )
   {
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], Y[jy], Y[jy+1], t0_r, t0_i ); 
@type chex zhex
      Mmul( ALPHA[0], ALPHA[1], Y[jy], -Y[jy+1], t0_r, t0_i ); 
@type cplx zplx chex zhex
      for( i = 0, iaij = jaj, ix = 0; i < M; i++, iaij += 2, ix += incx2 )
      { Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] ); }
   }
@type real dble cplx zplx chex zhex
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout sbmv
@define rname @ATL_@(pre)ref@(sbhb)mv@
@rout spmv
@define rname @ATL_@(pre)ref@(sphp)mv@
@rout symv
@define rname @ATL_@(pre)ref@(syhe)mv@
@rout sbmv spmv symv
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
@rout sbmv
   const int                  K,
@rout sbmv spmv symv
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
@rout sbmv symv
   const int                  LDA,
@rout sbmv spmv symv
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
@rout sbmv symv
   const int                  LDA,
@rout sbmv spmv symv
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx chex zhex
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
@type real dble
   if( ( N == 0 ) || ( ( ALPHA == ATL_@(upr)ZERO ) &&
                       ( BETA  == ATL_@(upr)ONE  ) ) ) return;
   if( ALPHA == ATL_@(upr)ZERO ) { M@(pre)vscal( N, BETA, Y, INCY ); return; }
@type cplx zplx chex zhex
   if( ( N == 0 ) ||
       ( @(isz)( ALPHA[0], ALPHA[1] ) && @(iso)( BETA[0], BETA[1] ) ) ) return;
   if( @(isz)( ALPHA[0], ALPHA[1] ) )
   { M@(pre)vscal( N, BETA, Y, INCY ); return; }
@type real dble cplx zplx chex zhex

   if( UPLO == AtlasUpper )
   {
@rout sbmv
      ATL_@(pre)ref@(sbhb)mvU( N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY );
@rout spmv
      ATL_@(pre)ref@(sphp)mvU( N,    ALPHA, A, 1,   X, INCX, BETA, Y, INCY );
@rout symv
      ATL_@(pre)ref@(syhe)mvU( N,    ALPHA, A, LDA, X, INCX, BETA, Y, INCY );
@rout sbmv spmv symv
   }
   else
   {
@rout sbmv
      ATL_@(pre)ref@(sbhb)mvL( N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY );
@rout spmv
      ATL_@(pre)ref@(sphp)mvL( N,    ALPHA, A, N,   X, INCX, BETA, Y, INCY );
@rout symv
      ATL_@(pre)ref@(syhe)mvL( N,    ALPHA, A, LDA, X, INCX, BETA, Y, INCY );
@rout sbmv spmv symv
   }
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout sbmvL
@define rname @ATL_@(pre)ref@(sbhb)mvL@
@rout spmvL
@define rname @ATL_@(pre)ref@(sphp)mvL@
@rout symvL
@define rname @ATL_@(pre)ref@(syhe)mvL@
@rout sbmvL spmvL symvL
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  N,
@rout sbmvL
   const int                  K,
@rout sbmvL spmvL symvL
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx chex zhex
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@rout sbmvL
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, i1, iaij, ix, iy, j, jaj, jx, jy, kx = 0,
                              ky = 0;
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( N, BETA, Y, INCY );

   for( j = 0, jaj = 0, jx = kx, jy = ky; j < N;
        j++, jaj += LDA, jx += INCX, jy += INCY )
   {
      t0 = ALPHA * X[jx]; t1 = ATL_@(upr)ZERO;
      i1 = ( N - 1 > j + K ? j + K : N - 1 ); Y[jy] += t0 * A[jaj];
      for( i = j+1,      iaij  = 1+jaj, ix  = jx + INCX, iy  = jy + INCY;
           i <= i1; i++, iaij += 1,     ix += INCX,      iy += INCY )
      { Y[iy] += A[iaij] * t0; t1    += A[iaij] * X[ix]; }
      Y[jy] += ALPHA * t1;
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, i1, iaij, ix, iy, j, jaj, jx, jy, kx = 0,
                              ky = 0, incx2 = 2 * INCX, incy2 = 2 * INCY,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( N, BETA, Y, INCY );

   for( j = 0,      jaj  = 0,    jx  = kx,    jy  = ky;
        j < N; j++, jaj += lda2, jx += incx2, jy += incy2 )
   {
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t1_r, t1_i );
      i1     = ( N - 1 > j + K ? j + K : N - 1 );
@type cplx zplx
      Mmla( A[jaj], A[jaj+1], t0_r, t0_i, Y[jy], Y[jy+1] );
@type chex zhex
      Mset( Y[jy] + A[jaj]*t0_r, Y[jy+1] + A[jaj]*t0_i, Y[jy], Y[jy+1] );
@type cplx zplx chex zhex
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2, iy  = jy + incy2;
           i <= i1; i++, iaij += 2,     ix += incx2,      iy += incy2 )
      {
         Mmla( A[iaij], A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] );
@type cplx zplx
         Mmla( A[iaij], A[iaij+1], X[ix], X[ix+1], t1_r, t1_i );
@type chex zhex
         Mmla( A[iaij], -A[iaij+1], X[ix], X[ix+1], t1_r, t1_i );
@type cplx zplx chex zhex
      }
      Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, Y[jy], Y[jy+1] );
   }
@type real dble cplx zplx chex zhex
@rout spmvL
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iaij, ix, iy, j, jaj = 0, jx, jy, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( N, BETA, Y, INCY );

   for( j = 0, jx = 0, jy = 0; j < N; j++, jx += INCX, jy += INCY )
   {
      t0  = ALPHA * X[jx]; t1  = ATL_@(upr)ZERO; Y[jy] += t0 * A[jaj];
      for( i = j+1,    iaij  = jaj+1, ix  = jx+INCX, iy  = jy+INCY;
           i < N; i++, iaij += 1,     ix += INCX,    iy += INCY )
      { Y[iy] += t0 * A[iaij]; t1 += A[iaij] * X[ix]; }
      Y[jy] += ALPHA * t1; jaj += lda; lda -= 1;
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iaij, ix, iy, j, jaj = 0, jx, jy, 
                              lda2 = ( LDA << 1 ), incx2 = 2 * INCX,
                              incy2 = 2 * INCY;
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( N, BETA, Y, INCY );

   for( j = 0, jx = 0, jy = 0; j < N; j++, jx += incx2, jy += incy2 )
   {
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t1_r, t1_i );
@type cplx zplx
      Mmla( A[jaj], A[jaj+1], t0_r, t0_i, Y[jy], Y[jy+1] );
@type chex zhex
      Mset( Y[jy] + A[jaj]*t0_r, Y[jy+1] + A[jaj]*t0_i, Y[jy], Y[jy+1] );
@type cplx zplx chex zhex
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2, iy  = jy+incy2;
           i < N; i++, iaij += 2,     ix += incx2,    iy += incy2 )
      {
         Mmla( A[iaij],  A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] );
@type cplx zplx
         Mmla( A[iaij],  A[iaij+1], X[ix], X[ix+1], t1_r, t1_i );
@type chex zhex
         Mmla( A[iaij], -A[iaij+1], X[ix], X[ix+1], t1_r, t1_i );
@type cplx zplx chex zhex
      }
      Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, Y[jy], Y[jy+1] );
      jaj += lda2; lda2 -= 2;
   }
@type real dble cplx zplx chex zhex
@rout symvL
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iaij, ix, iy, j, jaj, jx, jy, ldap1 = LDA + 1;
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( N, BETA, Y, INCY );

   for( j = 0,      jaj  = 0,     jx  = 0,    jy  = 0;
        j < N; j++, jaj += ldap1, jx += INCX, jy += INCY )
   {
      t0 = ALPHA * X[jx]; t1 = ATL_@(upr)ZERO; Y[jy] += t0 * A[jaj];
      for( i = j+1,    iaij  = 1+jaj, ix  = jx + INCX, iy  = jy + INCY;
           i < N; i++, iaij += 1,     ix += INCX,      iy += INCY )
      { Y[iy] += A[iaij] * t0; t1    += A[iaij] * X[ix]; }
      Y[jy] += ALPHA * t1;
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iaij, ix, iy, j, jaj, jx, jy,
                              incx2 = 2 * INCX, incy2 = 2 * INCY,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( N, BETA, Y, INCY );

   for( j = 0,      jaj = 0,       jx  = 0,     jy  = 0;
        j < N; j++, jaj += ldap12, jx += incx2, jy += incy2 )
   {
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t1_r, t1_i );
@type cplx zplx
      Mmla( A[jaj], A[jaj+1], t0_r, t0_i, Y[jy], Y[jy+1] );
@type chex zhex
      Mset( Y[jy] + A[jaj]*t0_r, Y[jy+1] + A[jaj]*t0_i, Y[jy], Y[jy+1] );
@type cplx zplx chex zhex
      for( i = j+1,    iaij  = jaj+2, ix  = jx + incx2, iy  = jy + incy2;
           i < N; i++, iaij += 2,     ix += incx2,      iy += incy2 )
      {
         Mmla( A[iaij], A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] );
@type cplx zplx
         Mmla( A[iaij], A[iaij+1], X[ix], X[ix+1], t1_r, t1_i );
@type chex zhex
         Mmla( A[iaij], -A[iaij+1], X[ix], X[ix+1], t1_r, t1_i );
@type cplx zplx chex zhex
      }
      Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, Y[jy], Y[jy+1] );
   }
@type real dble cplx zplx chex zhex
@rout sbmvL spmvL symvL
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout sbmvU
@define rname @ATL_@(pre)ref@(sbhb)mvU@
@rout spmvU
@define rname @ATL_@(pre)ref@(sphp)mvU@
@rout symvU
@define rname @ATL_@(pre)ref@(syhe)mvU@
@rout sbmvU spmvU symvU
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  N,
@rout sbmvU
   const int                  K,
@rout sbmvU spmvU symvU
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) BETA,
   @(type_decl) * Y,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * Y,
@type real dble cplx zplx chex zhex
   const int                  INCY
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout sbmvU
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, i0, iaij, ix, iy, j, jaj, jx, jy, kx = 0,
                              ky = 0, l;
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( N, BETA, Y, INCY );

   for( j = 0,      jaj = 0,    jx  = kx,   jy  = ky;
        j < N; j++, jaj += LDA, jx += INCX, jy += INCY )
   {
      t0 = ALPHA * X[jx]; t1 = ATL_@(upr)ZERO;
      l = K - j; i0 = ( j - K > 0 ? j - K : 0 );

      for( i = i0,      iaij  = l+i0+jaj, ix  = kx,   iy  = ky;
           i < j;  i++, iaij += 1,        ix += INCX, iy += INCY )
      { Y[iy] += A[iaij] * t0; t1 += A[iaij] * X[ix]; }
      Y[jy] += A[iaij] * t0 + ALPHA * t1;
      if( j >= K ) { kx += INCX; ky += INCY; }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, i0, iaij, ix, iy, j, jaj, jx, jy, kx = 0,
                              ky = 0, l, incx2 = 2 * INCX, incy2 = 2 * INCY,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( N, BETA, Y, INCY );

   for( j = 0,      jaj = 0,     jx  = kx,    jy  = ky;
        j < N; j++, jaj += lda2, jx += incx2, jy += incy2 )
   {
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t1_r, t1_i );
      l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
 
      for( i = i0,      iaij  = ((l+i0) << 1)+jaj, ix  = kx,    iy  = ky;
           i < j;  i++, iaij += 2,                 ix += incx2, iy += incy2 )
      {
         Mmla( A[iaij], A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] );
@type cplx zplx
         Mmla( A[iaij], A[iaij+1], X[ix], X[ix+1], t1_r, t1_i );
      }
      Mmla( A[iaij], A[iaij+1], t0_r, t0_i, Y[jy], Y[jy+1] );
      Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, Y[jy], Y[jy+1] );
@type chex zhex
         Mmla( A[iaij], -A[iaij+1], X[ix], X[ix+1], t1_r, t1_i );
      }
      Mset( Y[jy] + A[iaij]*t0_r, Y[jy+1] + A[iaij]*t0_i, Y[jy], Y[jy+1] );
      Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, Y[jy], Y[jy+1] );
@type chex zhex cplx zplx
      if( j >= K ) { kx += incx2; ky += incy2; }
   }
@type real dble cplx zplx chex zhex
@rout spmvU
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iaij, ix, iy, j, jaj, jx, jy, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( N, BETA, Y, INCY );

   for( j = 0, jaj = 0, jx = 0, jy = 0; j < N; j++, jx += INCX, jy += INCY )
   {
      t0 = ALPHA * X[jx]; t1 = ATL_@(upr)ZERO;
      for( i = 0,      iaij  = jaj, ix  = 0,    iy  = 0;
           i < j; i++, iaij += 1,   ix += INCX, iy += INCY )
      { Y[iy] += t0 * A[iaij]; t1    += A[iaij] * X[ix]; }
      Y[jy] += t0 * A[iaij] + ALPHA * t1; jaj += lda; lda += 1;
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iaij, ix, iy, j, jaj = 0, jx, jy,
                              lda2 = ( LDA << 1 ), incx2 = 2 * INCX,
                              incy2 = 2 * INCY;
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( N, BETA, Y, INCY );

   for( j = 0, jaj = 0, jx = 0, jy = 0; j < N; j++, jx += incx2, jy += incy2 )
   {
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t1_r, t1_i );
 
      for( i = 0,      iaij  = jaj, ix  = 0,     iy  = 0;
           i < j; i++, iaij += 2,   ix += incx2, iy += incy2 )
      {
         Mmla( A[iaij], A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] );
@type cplx zplx
         Mmla( A[iaij], A[iaij+1], X[ix], X[ix+1], t1_r, t1_i );
      }
      Mmla( A[iaij], A[iaij+1], t0_r, t0_i, Y[jy], Y[jy+1] );
      Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, Y[jy], Y[jy+1] );
@type chex zhex
         Mmla( A[iaij], -A[iaij+1], X[ix], X[ix+1], t1_r, t1_i );
      }
      Mset( Y[jy] + A[iaij]*t0_r, Y[jy+1] + A[iaij]*t0_i, Y[jy], Y[jy+1] );
      Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, Y[jy], Y[jy+1] );
@type cplx zplx chex zhex
      jaj += lda2; lda2 += 2;
   }
@type real dble cplx zplx chex zhex
@rout symvU
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iaij, ix, iy, j, jaj, jx, jy;
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( N, BETA, Y, INCY );

   for( j = 0,      jaj = 0,    jx  = 0,    jy  = 0;
        j < N; j++, jaj += LDA, jx += INCX, jy += INCY )
   {
      t0 = ALPHA * X[jx]; t1 = ATL_@(upr)ZERO;
      for( i = 0,      iaij  = jaj, ix  = 0,    iy  = 0;
           i < j; i++, iaij += 1,   ix += INCX, iy += INCY )
      { Y[iy] += A[iaij] * t0; t1 += A[iaij] * X[ix]; }
      Y[jy] += A[iaij] * t0 + ALPHA * t1;
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iaij, ix, iy, j, jaj, jx, jy;
   int                        incx2 = 2 * INCX, incy2 = 2 * INCY,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   M@(pre)vscal( N, BETA, Y, INCY );

   for( j = 0,      jaj  = 0,    jx  = 0,     jy  = 0;
        j < N; j++, jaj += lda2, jx += incx2, jy += incy2 )
   {
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t1_r, t1_i );
 
      for( i = 0,      iaij  = jaj, ix  = 0,     iy  = 0;
           i < j; i++, iaij += 2,   ix += incx2, iy += incy2 )
      {
         Mmla( A[iaij], A[iaij+1], t0_r, t0_i, Y[iy], Y[iy+1] );
@type cplx zplx
         Mmla( A[iaij], A[iaij+1], X[ix], X[ix+1], t1_r, t1_i );
      }
      Mmla( A[iaij], A[iaij+1], t0_r, t0_i, Y[jy], Y[jy+1] );
      Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, Y[jy], Y[jy+1] );
@type chex zhex
         Mmla( A[iaij], -A[iaij+1], X[ix], X[ix+1], t1_r, t1_i );
      }
      Mset( Y[jy] + A[iaij]*t0_r, Y[jy+1] + A[iaij]*t0_i, Y[jy], Y[jy+1] );
      Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, Y[jy], Y[jy+1] );
@type cplx zplx chex zhex
   }
@type real dble cplx zplx chex zhex
@rout sbmvU spmvU symvU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout spr
@define rname @ATL_@(pre)ref@(sphp)r@
@rout syr
@define rname @ATL_@(pre)ref@(syhe)r@
@rout spr syr
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
@type real dble chex zhex
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * X,
   const int                  INCX,
@rout spr
   @(type_decl) * A
@rout syr
   @(type_decl) * A,
   const int                  LDA
@rout spr syr
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
@rout spr
   @(utyp_decl) * A
@rout syr
   @(utyp_decl) * A,
   const int                  LDA
@rout spr syr
@type real dble cplx zplx chex zhex
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
@type real dble
   if( ( N == 0 ) || ( ALPHA == ATL_@(upr)ZERO ) ) return;
@type cplx zplx
   if( ( N == 0 ) || @(isz)( ALPHA[0], ALPHA[1] ) ) return;
@type chex zhex
   if( ( N == 0 ) || ( ALPHA == ATL_@(upr)ZERO ) ) return;
@type real dble cplx zplx chex zhex

   if( UPLO == AtlasUpper )
   { 
@rout spr
      ATL_@(pre)ref@(sphp)rU( N, ALPHA, X, INCX, A, 1   );
@rout syr
      ATL_@(pre)ref@(syhe)rU( N, ALPHA, X, INCX, A, LDA );
@rout spr syr
   }
   else
   {
@rout spr
      ATL_@(pre)ref@(sphp)rL( N, ALPHA, X, INCX, A, N   );
@rout syr
      ATL_@(pre)ref@(syhe)rL( N, ALPHA, X, INCX, A, LDA );
@rout spr syr
   }
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout sprL
@define rname @ATL_@(pre)ref@(sphp)rL@
@rout syrL
@define rname @ATL_@(pre)ref@(syhe)rL@
@rout sprL syrL
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  N,
@type real dble chex zhex
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(type_decl) * A,
   const int                  LDA
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(utyp_decl) * A,
   const int                  LDA
@type real dble cplx zplx chex zhex
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout sprL
@type real dble
   @(reg_type_decl) t0;
   int                        i, jaj, iaij, ix, j, jx, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += INCX )
   {
      t0 = ALPHA * X[jx];
      for( i = j, iaij = jaj, ix = jx; i < N; i++, iaij += 1, ix += INCX )
      { A[iaij] += X[ix] * t0; }
      jaj += lda; lda -= 1; 
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, jaj, iaij, ix, j, jx, lda2 = ( LDA << 1 ),
                              incx2 = 2 * INCX;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
      for( i = j, iaij = jaj, ix = jx; i < N; i++, iaij += 2, ix += incx2 )
      { Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] ); }
@type chex zhex
      Mset( ALPHA * X[jx], -ALPHA * X[jx+1], t0_r, t0_i );
      Mset( A[jaj] + X[jx] * t0_r - X[jx+1] * t0_i, ATL_@(upr)ZERO,
            A[jaj], A[jaj+1] );
      for( i = j+1, iaij = jaj+2, ix = jx+incx2; i < N;
           i++, iaij += 2, ix += incx2 )
      { Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] ); }
@type cplx zplx chex zhex
      jaj += lda2; lda2 -= 2;
   }
@type real dble cplx zplx chex zhex
@rout syrL
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, ldap1 = LDA + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jaj += ldap1, jx += INCX )
   {
      t0 = ALPHA * X[jx];
      for( i = j, iaij = jaj, ix = jx; i < N; i++, iaij += 1, ix += INCX )
      { A[iaij] += X[ix] * t0; }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( LDA + 1 ) << 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += ldap12, jx += incx2 )
   {
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
      for( i = j, iaij = jaj, ix  = jx; i < N; i++, iaij += 2, ix += incx2 )
      { Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] ); }
@type chex zhex
      Mset( ALPHA * X[jx], -ALPHA * X[jx+1], t0_r, t0_i );
      Mset( A[jaj] + X[jx] * t0_r - X[jx+1] * t0_i, ATL_@(upr)ZERO,
            A[jaj], A[jaj+1] );
      for( i = j+1, iaij = jaj+2, ix = jx+incx2; i < N;
           i++, iaij += 2, ix += incx2 )
      { Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] ); }
@type cplx zplx chex zhex
   }
@type real dble cplx zplx chex zhex
@rout sprL syrL
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout sprU
@define rname @ATL_@(pre)ref@(sphp)rU@
@rout syrU
@define rname @ATL_@(pre)ref@(syhe)rU@
@rout sprU syrU
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  N,
@type real dble chex zhex
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(type_decl) * A,
   const int                  LDA
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(utyp_decl) * A,
   const int                  LDA
@type real dble cplx zplx chex zhex
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout sprU
@type real dble
   @(reg_type_decl) t0;
   int                        i, jaj, iaij, ix, j, jx, lda = LDA;
@extract @(EXECUTABLE_STATEMENT) 
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += INCX )
   {
      t0 = ALPHA * X[jx];
      for( i = 0, iaij = jaj, ix = 0; i <= j; i++, iaij += 1, ix += INCX )
      { A[iaij] += X[ix] * t0; }
      jaj += lda; lda += 1;
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, ix, j, jaj, jx, lda2 = ( LDA << 1 ),
                              incx2 = 2 * INCX;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i <= j; i++, iaij += 2, ix += incx2 )
      { Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] ); }
@type chex zhex
      Mset( ALPHA * X[jx], -ALPHA * X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] ); }
      Mset( A[iaij] + X[jx] * t0_r - X[jx+1] * t0_i, ATL_@(upr)ZERO,
            A[iaij], A[iaij+1] );
@type cplx zplx chex zhex
      jaj += lda2; lda2 += 2;
   }
@type real dble cplx zplx chex zhex
@rout syrU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = ALPHA * X[jx];
      for( i = 0, iaij = jaj, ix = 0; i <= j; i++, iaij += 1, ix += INCX )
      { A[iaij] += X[ix] * t0; }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += lda2, jx += incx2 )
   {
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t0_r, t0_i );
      for( i  = 0, iaij = jaj, ix = 0; i <= j; i++, iaij += 2, ix += incx2 )
      { Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] ); }
@type chex zhex
      Mset( ALPHA * X[jx], -ALPHA * X[jx+1], t0_r, t0_i );
      for( i = 0,      iaij  = jaj, ix  = 0;
           i < j; i++, iaij += 2,   ix += incx2 )
      { Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] ); }
      Mset( A[iaij] + X[jx] * t0_r - X[jx+1] * t0_i, ATL_@(upr)ZERO,
            A[iaij], A[iaij+1] );
@type cplx zplx chex zhex
   }
@type real dble cplx zplx chex zhex
@rout sprU syrU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout spr2
@define rname @ATL_@(pre)ref@(sphp)r2@
@rout syr2
@define rname @ATL_@(pre)ref@(syhe)r2@
@rout spr2 syr2
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) * Y,
   const int                  INCY,
@rout spr2
   @(type_decl) * A
@rout syr2
   @(type_decl) * A,
   const int                  LDA
@rout spr2 syr2
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * Y,
   const int                  INCY,
@rout spr2
   @(utyp_decl) * A
@rout syr2
   @(utyp_decl) * A,
   const int                  LDA
@rout spr2 syr2
@type real dble cplx zplx chex zhex
) 
{
@extract @(ATLAS_REF_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
@type real dble
   if( ( N == 0 ) || ( ALPHA == ATL_@(upr)ZERO ) ) return;
@type cplx zplx chex zhex
   if( ( N == 0 ) || @(isz)( ALPHA[0], ALPHA[1] ) ) return;
@type real dble cplx zplx chex zhex
 
   if( UPLO == AtlasUpper )
   {
@rout spr2
      ATL_@(pre)ref@(sphp)r2U( N, ALPHA, X, INCX, Y, INCY, A, 1   );
@rout syr2
      ATL_@(pre)ref@(syhe)r2U( N, ALPHA, X, INCX, Y, INCY, A, LDA );
@rout spr2 syr2
   }
   else
   {
@rout spr2
      ATL_@(pre)ref@(sphp)r2L( N, ALPHA, X, INCX, Y, INCY, A, N   );
@rout syr2
      ATL_@(pre)ref@(syhe)r2L( N, ALPHA, X, INCX, Y, INCY, A, LDA );
@rout spr2 syr2
   }
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout spr2L
@define rname @ATL_@(pre)ref@(sphp)r2L@
@rout syr2L
@define rname @ATL_@(pre)ref@(syhe)r2L@
@rout spr2L syr2L
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) * Y,
   const int                  INCY,
   @(type_decl) * A,
   const int                  LDA
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * Y,
   const int                  INCY,
   @(utyp_decl) * A,
   const int                  LDA
@type real dble cplx zplx chex zhex
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout spr2L
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iaij, ix, iy, j, jaj, jx, jy, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0, jy = 0; j < N; j++, jx += INCX, jy += INCY )
   {
      t0 = ALPHA * Y[jy]; t1 = ALPHA * X[jx];
      for( i = j,      iaij  = jaj, ix  = jx,   iy  = jy;
           i < N; i++, iaij += 1,   ix += INCX, iy += INCY )
      { A[iaij] += X[ix] * t0 + Y[iy] * t1; }
      jaj += lda; lda -= 1;
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iaij, incx2 = 2 * INCX, incy2 = 2 * INCY,
                              ix, iy, j, jaj, jx, jy, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0, jy = 0; j < N; j++, jx += incx2, jy += incy2 )
   {
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], Y[jy], Y[jy+1], t0_r, t0_i );
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t1_r, t1_i );
      for( i = j,      iaij  = jaj, ix  = jx,    iy  = jy;
           i < N; i++, iaij += 2,   ix += incx2, iy += incy2 )
      {
         Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] );
         Mmla( Y[iy], Y[iy+1], t1_r, t1_i, A[iaij], A[iaij+1] );
      }
@type chex zhex
      Mmul( ALPHA[0],  ALPHA[1], Y[jy], -Y[jy+1], t0_r, t0_i );
      Mmul( ALPHA[0], -ALPHA[1], X[jx], -X[jx+1], t1_r, t1_i );
      Mset( A[jaj] + X[jx] * t0_r - X[jx+1] * t0_i +
                     Y[jy] * t1_r - Y[jy+1] * t1_i, ATL_@(upr)ZERO,
            A[jaj], A[jaj+1] );
      for( i = j+1,    iaij  = jaj+2, ix  = jx + incx2, iy  = jy + incy2;
           i < N; i++, iaij += 2,     ix += incx2,      iy += incy2 )
      {
         Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] );
         Mmla( Y[iy], Y[iy+1], t1_r, t1_i, A[iaij], A[iaij+1] );
      }
@type cplx zplx chex zhex
      jaj += lda2; lda2 -= 2;
   }
@type real dble cplx zplx chex zhex
@rout syr2L
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iaij, ix, iy, j, jaj, jx, jy, ldap1 = LDA + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      jaj  = 0,     jx  = 0,    jy  = 0;
        j < N; j++, jaj += ldap1, jx += INCX, jy += INCY )
   {
      t0 = ALPHA * Y[jy]; t1 = ALPHA * X[jx];
      for( i = j,      iaij  = jaj, ix  = jx,   iy  = jy;
           i < N; i++, iaij += 1,   ix += INCX, iy += INCY )
      { A[iaij] += X[ix] * t0 + Y[iy] * t1; }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iaij, incx2 = 2*INCX, incy2 = 2*INCY, ix, iy,
                              j, jaj, jx, jy, ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      jaj  = 0,      jx  = 0,     jy  = 0;
        j < N; j++, jaj += ldap12, jx += incx2, jy += incy2 )
   {
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], Y[jy], Y[jy+1], t0_r, t0_i );
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t1_r, t1_i );
      for( i = j,      iaij  = jaj, ix  = jx,    iy  = jy;
           i < N; i++, iaij += 2,   ix += incx2, iy += incy2 )
      {
         Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] );
         Mmla( Y[iy], Y[iy+1], t1_r, t1_i, A[iaij], A[iaij+1] );
      }
@type chex zhex
      Mmul( ALPHA[0],  ALPHA[1], Y[jy], -Y[jy+1], t0_r, t0_i );
      Mmul( ALPHA[0], -ALPHA[1], X[jx], -X[jx+1], t1_r, t1_i );
      Mset( A[jaj] + X[jx] * t0_r - X[jx+1] * t0_i +
                     Y[jy] * t1_r - Y[jy+1] * t1_i,
            ATL_@(upr)ZERO, A[jaj], A[jaj+1] );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2, iy  = jy+incy2;
           i < N; i++, iaij += 2,     ix += incx2,    iy += incy2 )
      {
         Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] );
         Mmla( Y[iy], Y[iy+1], t1_r, t1_i, A[iaij], A[iaij+1] );
      }
@type cplx zplx chex zhex
   }
@type real dble cplx zplx chex zhex
@rout spr2L syr2L
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout spr2U
@define rname @ATL_@(pre)ref@(sphp)r2U@
@rout syr2U
@define rname @ATL_@(pre)ref@(syhe)r2U@
@rout spr2U syr2U
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * X,
   const int                  INCX,
   @(cst_type_decl) * Y,
   const int                  INCY,
   @(type_decl) * A,
   const int                  LDA
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * X,
   const int                  INCX,
   @(cst_utyp_decl) * Y,
   const int                  INCY,
   @(utyp_decl) * A,
   const int                  LDA
@type real dble cplx zplx chex zhex
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout spr2U
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iaij, ix, iy, j, jaj, jx, jy, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0, jy = 0; j < N; j++, jx += INCX, jy += INCY )
   {
      t0 = ALPHA * Y[jy]; t1 = ALPHA * X[jx];
      for( i  = 0,      iaij  = jaj, ix  = 0,    iy  = 0;
           i <= j; i++, iaij += 1,   ix += INCX, iy += INCY )
      { A[iaij] += X[ix] * t0 + Y[iy] * t1; }
      jaj += lda; lda += 1;
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iaij, incx2 = 2 * INCX, incy2 = 2 * INCY,
                              ix, iy, j, jaj, jx, jy, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0, jy = 0; j < N; j++, jx += incx2, jy += incy2 )
   {
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], Y[jy], Y[jy+1], t0_r, t0_i );
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t1_r, t1_i );
      for( i  = 0,      iaij  = jaj, ix  = 0,     iy  = 0;
           i <= j; i++, iaij += 2,   ix += incx2, iy += incy2 )
      {
         Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] );
         Mmla( Y[iy], Y[iy+1], t1_r, t1_i, A[iaij], A[iaij+1] );
      }
@type chex zhex
      Mmul( ALPHA[0],  ALPHA[1], Y[jy], -Y[jy+1], t0_r, t0_i );
      Mmul( ALPHA[0], -ALPHA[1], X[jx], -X[jx+1], t1_r, t1_i );
      for( i = 0,      iaij  = jaj, ix  = 0,     iy  = 0;
           i < j; i++, iaij += 2,   ix += incx2, iy += incy2 )
      {
         Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] );
         Mmla( Y[iy], Y[iy+1], t1_r, t1_i, A[iaij], A[iaij+1] );
      }
      Mset( A[iaij] + X[jx] * t0_r - X[jx+1] * t0_i +
                      Y[jy] * t1_r - Y[jy+1] * t1_i, ATL_@(upr)ZERO,
            A[iaij], A[iaij+1] );
@type cplx zplx chex zhex
      jaj += lda2; lda2 += 2;
   }
@type real dble cplx zplx chex zhex
@rout syr2U
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iaij, ix, iy, j, jaj, jx, jy;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      jaj  = 0,   jx  = 0,    jy  = 0;
        j < N; j++, jaj += LDA, jx += INCX, jy += INCY )
   {
      t0 = ALPHA * Y[jy]; t1 = ALPHA * X[jx];
      for( i  = 0,      iaij  = jaj, ix  = 0,   iy  = 0;
           i <= j; i++, iaij += 1,   ix += INCX, iy += INCY )
      { A[iaij] += X[ix] * t0 + Y[iy] * t1; }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iaij, incx2 = 2 * INCX, incy2 = 2 * INCY,
                              ix, iy, j, jaj, jx, jy, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      jaj  = 0,    jx  = 0,     jy  = 0;
        j < N; j++, jaj += lda2, jx += incx2, jy += incy2 )
   {
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], Y[jy], Y[jy+1], t0_r, t0_i );
      Mmul( ALPHA[0], ALPHA[1], X[jx], X[jx+1], t1_r, t1_i );
      for( i  = 0,      iaij  = jaj, ix  = 0,     iy  = 0;
           i <= j; i++, iaij += 2,   ix += incx2, iy += incy2 )
      {
         Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] );
         Mmla( Y[iy], Y[iy+1], t1_r, t1_i, A[iaij], A[iaij+1] );
      }
@type chex zhex
      Mmul( ALPHA[0],  ALPHA[1], Y[jy], -Y[jy+1], t0_r, t0_i );
      Mmul( ALPHA[0], -ALPHA[1], X[jx], -X[jx+1], t1_r, t1_i );
      for( i = 0,      iaij  = jaj, ix  = 0,     iy  = 0;
           i < j; i++, iaij += 2,   ix += incx2, iy += incy2 )
      {
         Mmla( X[ix], X[ix+1], t0_r, t0_i, A[iaij], A[iaij+1] );
         Mmla( Y[iy], Y[iy+1], t1_r, t1_i, A[iaij], A[iaij+1] );
      }
      Mset( A[iaij] + X[jx] * t0_r - X[jx+1] * t0_i +
                      Y[jy] * t1_r - Y[jy+1] * t1_i, ATL_@(upr)ZERO,
            A[iaij], A[iaij+1] );
@type cplx zplx chex zhex
   }
@type real dble cplx zplx chex zhex
@rout spr2U syr2U
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmv tbsv tpmv tpsv trmv trsv
@define rname @ATL_@(pre)ref@(@rout)@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG,
   const int                  N,
@rout tbmv tbsv
   const int                  K,
@rout tbmv tbsv tpmv tpsv trmv trsv
   @(cst_utyp_decl) * A,
@rout tbmv trmv tbsv trsv
   const int                  LDA,
@rout tbmv tbsv tpmv tpsv trmv trsv
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( N == 0 ) return;

@type real dble
   if( UPLO == AtlasUpper ) 
   {
      if( ( TRANS == AtlasNoTrans ) || ( TRANS == AtlasConj ) )
      {
         if( DIAG == AtlasNonUnit )
         {
@define suf @UNN@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, 1,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
         else
         {
@define suf @UNU@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, 1,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
      }
      else
      {
         if( DIAG == AtlasNonUnit )
         {
@define suf @UTN@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, 1,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
         else
         {
@define suf @UTU@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, 1,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
      }
   }
   else
   {
      if( ( TRANS == AtlasNoTrans ) || ( TRANS == AtlasConj ) )
      {
         if( DIAG == AtlasNonUnit )
         {
@define suf @LNN@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, N,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
         else
         {
@define suf @LNU@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, N,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
      }
      else
      {
         if( DIAG == AtlasNonUnit )
         {
@define suf @LTN@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, N,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
         else
         {
@define suf @LTU@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, N,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
      }
   }
@type cplx zplx
   if( UPLO == AtlasUpper ) 
   {
      if(      TRANS == AtlasNoTrans )
      {
         if( DIAG == AtlasNonUnit )
         {
@define suf @UNN@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, 1,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
         else
         {
@define suf @UNU@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, 1,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
      }
      else if( TRANS == AtlasConj    )
      {
         if( DIAG == AtlasNonUnit )
         {
@define suf @UCN@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, 1,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
         else
         {
@define suf @UCU@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, 1,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
      }
      else if( TRANS == AtlasTrans   )
      {
         if( DIAG == AtlasNonUnit )
         {
@define suf @UTN@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, 1,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
         else
         {
@define suf @UTU@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, 1,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
      }
      else
      {
         if( DIAG == AtlasNonUnit )
         {
@define suf @UHN@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, 1,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
         else
         {
@define suf @UHU@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, 1,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
      }
   }
   else
   {
      if(      TRANS == AtlasNoTrans )
      {
         if( DIAG == AtlasNonUnit )
         {
@define suf @LNN@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, N,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
         else
         {
@define suf @LNU@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, N,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
      }
      else if( TRANS == AtlasConj    )
      {
         if( DIAG == AtlasNonUnit )
         {
@define suf @LCN@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, N,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
         else
         {
@define suf @LCU@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, N,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
      }
      else if( TRANS == AtlasTrans   )
      {
         if( DIAG == AtlasNonUnit )
         {
@define suf @LTN@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, N,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
         else
         {
@define suf @LTU@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, N,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
      }
      else
      {
         if( DIAG == AtlasNonUnit )
         {
@define suf @LHN@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, N,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
         else
         {
@define suf @LHU@
@rout tbmv tbsv
            ATL_@(pre)ref@(@rout)@(suf)( N, K, A, LDA, X, INCX );
@rout tpmv tpsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, N,   X, INCX );
@rout trmv trsv
            ATL_@(pre)ref@(@rout)@(suf)( N,    A, LDA, X, INCX );
@rout tbmv tbsv tpmv tpsv trmv trsv
@undef suf
         }
      }
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvLNN tbsvLNN tpmvLNN tpsvLNN trmvLNN trsvLNN
@define rname @ATL_@(pre)ref@4l@(@rout)LNN@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)
 
void @(rname)
(
   const int                  N,
@rout tbmvLNN tbsvLNN
   const int                  K,
@rout tbmvLNN tbsvLNN tpmvLNN tpsvLNN trmvLNN trsvLNN
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE) 
@rout tbmvLNN
@type real dble
   @(reg_type_decl) t0;
   int                        i, i1, iaij, ix, j, jaj, jx, kx = 0;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*LDA, jx  = kx+(N-1)*INCX;
        j >= 0; j--, jaj -= LDA,       jx -= INCX )
   {
      t0 = X[jx]; X[jx] *= A[jaj];
      i1   = ( N - 1 > j + K ? j + K : N - 1 );
      for( i  = j+1,     iaij  = 1+jaj, ix  = jx + INCX;
           i <= i1; i++, iaij += 1,     ix += INCX ) { X[ix] += A[iaij] * t0; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j,
                              jaj, jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      @(scl)( A[jaj], A[jaj+1], X[jx], X[jx+1] );
      i1 = ( N - 1 > j + K ? j + K : N - 1 );
      for( i  = j+1,     iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
   }
@type real dble cplx zplx
@rout tbsvLNN
@type real dble
   @(reg_type_decl) t0;
   int                        i, i1, iaij, ix, j, jaj, jx, kx = 0;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += LDA, jx += INCX )
   {
      X[jx] /= A[jaj]; i1 = ( N - 1 > j + K ? j + K : N - 1 ); t0 = X[jx];
      for( i = j+1,      iaij  = 1+jaj, ix  = jx + INCX;
           i <= i1; i++, iaij += 1,     ix += INCX ) { X[ix] -= t0 * A[iaij]; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix,
                              j, jaj, jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      jaj  = 0,    jx  = kx;
        j < N; j++, jaj += lda2, jx += incx2 )
   {
      @(div)( A[jaj], A[jaj+1], X[jx], X[jx+1] );
      i1 = ( N - 1 > j + K ? j + K : N - 1 );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@type real dble cplx zplx
@rout tpmvLNN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA - N + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j  = N-1,    jaj = (LDA+1)*(N-1) - ( ((N-1)*N) >> 1 ), jx = (N-1)*INCX;
        j >= 0; j--,                                           jx -= INCX )
   {
      t0 = X[jx]; X[jx] = A[jaj] * t0;
      for( i = j+1, iaij = jaj+1, ix = jx + INCX; i < N;
           i++, iaij += 1, ix += INCX ) { X[ix] += A[iaij] * t0; }
      lda += 1; jaj -= lda;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, lda2 = ( ( LDA - N + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (((LDA+1)*(N-1)) << 1) - (N-1)*N, jx = (N-1)*incx2;
        j >= 0; j--,                                         jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      @(scl)( A[jaj], A[jaj+1], X[jx], X[jx+1] );
      for( i = j+1, iaij = jaj+2, ix = jx+incx2; i < N;
           i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      lda2 += 2; jaj -= lda2;
   }
@type real dble cplx zplx
@rout tpsvLNN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jx += INCX )
   {
      X[jx] /= A[jaj]; t0 = X[jx];
      for( i = j+1, iaij = jaj+1, ix = jx + INCX; i < N;
           i++, iaij += 1, ix += INCX ) { X[ix] -= t0 * A[iaij]; }
      jaj += lda; lda -= 1;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
      @(div)( A[jaj], A[jaj+1], X[jx], X[jx+1] );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1, iaij = jaj+2, ix  = jx+incx2; i < N;
           i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
      jaj += lda2; lda2 -= 2;
   }
@type real dble cplx zplx
@rout trmvLNN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, ldap1 = LDA + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*(ldap1), jx  = (N-1)*INCX;
        j >= 0; j--, jaj -= ldap1,         jx -= INCX )
   {
      t0 = X[jx]; X[jx] *= A[jaj];
      for( i = j+1,    iaij  = jaj+1, ix  = jx + INCX;
           i < N; i++, iaij += 1,     ix += INCX ) { X[ix] += A[iaij] * t0; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*ldap12, jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= ldap12,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      @(scl)( A[jaj], A[jaj+1], X[jx], X[jx+1] );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
   }
@type real dble cplx zplx
@rout trsvLNN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, ldap1 = LDA + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jaj += ldap1, jx += INCX )
   {
      X[jx] /= A[jaj]; t0 = X[jx];
      for( i = j+1,    iaij  = jaj+1, ix  = jx + INCX;
           i < N; i++, iaij += 1,     ix += INCX ) { X[ix] -= t0 * A[iaij]; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jaj += ldap12, jx += incx2 )
   {
      @(div)( A[jaj], A[jaj+1], X[jx], X[jx+1] );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@type real dble cplx zplx
@rout tbmvLNN tbsvLNN tpmvLNN tpsvLNN trmvLNN trsvLNN
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvLNU tbsvLNU tpmvLNU tpsvLNU trmvLNU trsvLNU
@define rname @ATL_@(pre)ref@4l@(@rout)LNU@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvLNU tbsvLNU
   const int                  K,
@rout tbmvLNU tbsvLNU tpmvLNU tpsvLNU trmvLNU trsvLNU
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvLNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, i1, iaij, ix, j, jaj, jx, kx = 0;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*LDA, jx  = kx+(N-1)*INCX;
        j >= 0; j--, jaj -= LDA,       jx -= INCX )
   {
      t0 = X[jx];
      i1   = ( N - 1 > j + K ? j + K : N - 1 );
      for( i  = j+1,     iaij  = 1+jaj, ix  = jx + INCX;
           i <= i1; i++, iaij += 1,     ix += INCX ) { X[ix] += A[iaij] * t0; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j,
                              jaj, jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      i1   = ( N - 1 > j + K ? j + K : N - 1 );
      for( i  = j+1,     iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
   }
@type real dble cplx zplx
@rout tbsvLNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, i1, iaij, ix, j, jaj, jx, kx = 0;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += LDA, jx += INCX )
   {
      i1 = ( N - 1 > j + K ? j + K : N - 1 ); t0 = X[jx];
      for( i = j+1,      iaij  = 1+jaj, ix  = jx + INCX;
           i <= i1; i++, iaij += 1,     ix += INCX ) { X[ix] -= t0 * A[iaij]; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j,
                              jaj, jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      i1 = ( N - 1 > j + K ? j + K : N - 1 );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@type real dble cplx zplx
@rout tpmvLNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA - N + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j  = N-1,    jaj = (LDA+1)*(N-1) - ( ((N-1)*N) >> 1 ), jx  = (N-1)*INCX;
        j >= 0; j--,                                           jx -= INCX )
   {
      t0 = X[jx];
      for( i = j+1,    iaij  = jaj+1, ix  = jx + INCX;
           i < N; i++, iaij += 1,     ix += INCX ) { X[ix] += A[iaij] * t0; }
      lda += 1; jaj -= lda;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, lda2 = ( ( LDA - N + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (((LDA+1)*(N-1)) << 1) - (N-1)*N, jx  = (N-1)*incx2;
        j >= 0; j--,                                         jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,    ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      lda2 += 2; jaj -= lda2;
   }
@type real dble cplx zplx
@rout tpsvLNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jx += INCX )
   {
      t0  = X[jx];
      for( i = j+1,    iaij  = jaj+1, ix  = jx + INCX;
           i < N; i++, iaij += 1,     ix += INCX ) { X[ix] -= t0 * A[iaij]; }
      jaj += lda; lda -= 1;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
      jaj += lda2; lda2 -= 2;
   }
@type real dble cplx zplx
@rout trmvLNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, ldap1 = LDA + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*(ldap1), jx  = (N-1)*INCX;
        j >= 0; j--, jaj -= ldap1,         jx -= INCX )
   {
      t0 = X[jx];
      for( i = j+1,    iaij  = jaj+1, ix  = jx + INCX;
           i < N; i++, iaij += 1,     ix += INCX ) { X[ix] += A[iaij] * t0; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*ldap12, jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= ldap12,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
   }
@type real dble cplx zplx
@rout trsvLNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, ldap1 = LDA + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += ldap1, jx += INCX )
   {
      t0 = X[jx];
      for( i = j+1,    iaij  = jaj+1, ix  = jx + INCX;
           i < N; i++, iaij += 1,     ix += INCX ) { X[ix] -= t0 * A[iaij]; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += ldap12, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@type real dble cplx zplx
@rout tbmvLNU tbsvLNU tpmvLNU tpsvLNU trmvLNU trsvLNU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvLCN tbsvLCN tpmvLCN tpsvLCN trmvLCN trsvLCN
@define rname @ATL_@(pre)ref@4l@(@rout)LCN@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvLCN tbsvLCN
   const int                  K,
@rout tbmvLCN tbsvLCN tpmvLCN tpsvLCN trmvLCN trsvLCN
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvLCN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      @(scl)( A[jaj], -A[jaj+1], X[jx], X[jx+1] );
      i1   = ( N - 1 > j + K ? j + K : N - 1 );
      for( i  = j+1,     iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
   }
@rout tbsvLCN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      @(div)( A[jaj], -A[jaj+1], X[jx], X[jx+1] );
      i1   = ( N - 1 > j + K ? j + K : N - 1 );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@rout tpmvLCN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( ( LDA - N + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1, jaj = (((LDA+1)*(N-1)) << 1) - (N-1)*N, jx  = (N-1)*incx2;
        j >= 0; j--,                                     jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      @(scl)( A[jaj], -A[jaj+1], X[jx], X[jx+1] );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      lda2 += 2; jaj -= lda2;
   }
@rout tpsvLCN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
      @(div)( A[jaj], -A[jaj+1], X[jx], X[jx+1] );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
      jaj += lda2; lda2 -= 2;
   }
@rout trmvLCN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*ldap12, jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= ldap12,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      @(scl)( A[jaj], -A[jaj+1], X[jx], X[jx+1] );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
   }
@rout trsvLCN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += ldap12, jx += incx2 )
   {
      @(div)( A[jaj], -A[jaj+1], X[jx], X[jx+1] );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@rout tbmvLCN tbsvLCN tpmvLCN tpsvLCN trmvLCN trsvLCN
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvLCU tbsvLCU tpmvLCU tpsvLCU trmvLCU trsvLCU
@define rname @ATL_@(pre)ref@4l@(@rout)LCU@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvLCU tbsvLCU
   const int                  K,
@rout tbmvLCU tbsvLCU tpmvLCU tpsvLCU trmvLCU trsvLCU
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvLCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      i1   = ( N - 1 > j + K ? j + K : N - 1 );
      for( i  = j+1,     iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
   } 
@rout tbsvLCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      i1   = ( N - 1 > j + K ? j + K : N - 1 );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@rout tpmvLCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( ( LDA - N + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (((LDA+1)*(N-1)) << 1) - (N-1)*N, jx = (N-1)*incx2;
        j >= 0; j--,                                         jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      lda2 += 2; jaj -= lda2;
   }
@rout tpsvLCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
      jaj += lda2; lda2 -= 2;
   }
@rout trmvLCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*ldap12, jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= ldap12,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
   }
@rout trsvLCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += ldap12, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@rout tbmvLCU tbsvLCU tpmvLCU tpsvLCU trmvLCU trsvLCU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvLTN tbsvLTN tpmvLTN tpsvLTN trmvLTN trsvLTN
@define rname @ATL_@(pre)ref@4l@(@rout)LTN@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvLTN tbsvLTN
   const int                  K,
@rout tbmvLTN tbsvLTN tpmvLTN tpsvLTN trmvLTN trsvLTN
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvLTN
@type real dble
   @(reg_type_decl) t0;
   int                        i, i1, iaij, ix, j, jaj, jx, kx = 0;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = X[jx]; t0 *= A[jaj]; i1 = ( N - 1 > j + K ? j + K : N - 1 );
      for( i = j+1,      iaij  = 1+jaj, ix  = jx + INCX;
           i <= i1; i++, iaij += 1,     ix += INCX ) { t0 += A[iaij] * X[ix]; }
      X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mmul( A[jaj], A[jaj+1], X[jx] , X[jx+1], t0_r, t0_i );
      i1   = ( N - 1 > j + K ? j + K : N - 1 );
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout tbsvLTN
@type real dble
   @(reg_type_decl) t0;
   int                        i, i1, iaij, ix, j, jaj, jx, kx = 0;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*(LDA), jx  = kx+(N-1)*INCX;
        j >= 0; j--, jaj -= LDA,         jx -= INCX )
   {
      t0 = X[jx]; i1   = ( N - 1 > j + K ? j + K : N - 1 );
      for( i = j+1,      iaij  = 1+jaj, ix  = jx + INCX;
           i <= i1; i++, iaij += 1,     ix += INCX ) { t0 -= A[iaij] * X[ix]; }
      t0 /= A[jaj]; X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j,
                              jaj, jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      i1 = ( N - 1 > j + K ? j + K : N - 1 );
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      @(div)( A[jaj], A[jaj+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout tpmvLTN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jx += INCX )
   {
      t0 = X[jx]; t0 *= A[jaj];
      for( i = j+1, iaij  = jaj+1, ix  = jx + INCX; i < N;
           i++,     iaij += 1,     ix += INCX ) { t0 += A[iaij] * X[ix]; }
      X[jx] = t0; jaj += lda; lda -= 1;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
      Mmul( A[jaj], A[jaj+1], X[jx] , X[jx+1], t0_r, t0_i );
      for( i = j+1, iaij  = jaj+2, ix  = jx+incx2; i < N;
           i++,     iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); jaj += lda2; lda2 -= 2;
   }
@type real dble cplx zplx
@rout tpsvLTN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA - N + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (LDA+1)*(N-1) - ( ((N-1)*N) >> 1 ), jx  = (N-1)*INCX;
        j >= 0; j--,                                           jx -= INCX )
   {
      t0  = X[jx];
      for( i = j+1,    iaij = jaj+1, ix  = jx + INCX;
           i < N; i++, iaij += 1,    ix += INCX ) { t0 -= A[iaij] * X[ix]; }
      t0 /= A[jaj]; X[jx] = t0; lda += 1; jaj -= lda;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, lda2 = ( ( LDA - N + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (((LDA+1)*(N-1)) << 1) - (N-1)*N, jx  = (N-1)*incx2;
        j >= 0; j--,                                         jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx + incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      @(div)( A[jaj], A[jaj+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); lda2 += 2; jaj -= lda2;
   }
@type real dble cplx zplx
@rout trmvLTN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, ldap1 = LDA + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jaj += ldap1, jx += INCX )
   {
      t0 = X[jx]; t0 *= A[jaj];
      for( i = j+1,    iaij  = jaj+1, ix  = jx + INCX;
           i < N; i++, iaij += 1,     ix += INCX ) { t0 += A[iaij] * X[ix]; }
      X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += ldap12, jx += incx2 )
   {
      Mmul( A[jaj], A[jaj+1], X[jx] , X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout trsvLTN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, ldap1 = LDA + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*(ldap1), jx  = (N-1)*INCX;
        j >= 0; j--, jaj -= ldap1,         jx -= INCX )
   {
      t0 = X[jx];
      for( i = j+1,    iaij  = 1+jaj, ix  = jx + INCX;
           i < N; i++, iaij += 1,     ix += INCX ) { t0 -= A[iaij] * X[ix]; }
      t0 /= A[jaj]; X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*(ldap12), jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= ldap12,         jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx + incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      @(div)( A[jaj], A[jaj+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout tbmvLTN tbsvLTN tpmvLTN tpsvLTN trmvLTN trsvLTN
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvLTU tbsvLTU tpmvLTU tpsvLTU trmvLTU trsvLTU
@define rname @ATL_@(pre)ref@4l@(@rout)LTU@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvLTU tbsvLTU
   const int                  K,
@rout tbmvLTU tbsvLTU tpmvLTU tpsvLTU trmvLTU trsvLTU
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvLTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, i1, iaij, ix, j, jaj, jx, kx = 0;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = X[jx]; i1 = ( N - 1 > j + K ? j + K : N - 1 );
      for( i = j+1,      iaij  = 1+jaj, ix  = jx + INCX;
           i <= i1; i++, iaij += 1,     ix += INCX ) { t0 += A[iaij] * X[ix]; }
      X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      i1 = ( N - 1 > j + K ? j + K : N - 1 );
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout tbsvLTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, i1, iaij, ix, j, jaj, jx, kx = 0;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*(LDA), jx  = kx+(N-1)*INCX;
        j >= 0; j--, jaj -= LDA,         jx -= INCX )
   {
      t0 = X[jx]; i1 = ( N - 1 > j + K ? j + K : N - 1 );
      for( i = j+1,      iaij  = 1+jaj, ix  = jx + INCX;
           i <= i1; i++, iaij += 1,     ix += INCX ) { t0 -= A[iaij] * X[ix]; }
      X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      i1   = ( N - 1 > j + K ? j + K : N - 1 );
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout tpmvLTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jx += INCX )
   {
      t0 = X[jx];
      for( i = j+1, iaij  = jaj+1, ix = jx + INCX; i < N;
           i++,     iaij += 1,     ix += INCX ) { t0 += A[iaij] * X[ix]; }
      X[jx] = t0; jaj += lda; lda -= 1;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i ); iaij += 2;
      for( i = j+1, iaij  = jaj+2, ix  = jx+incx2; i < N;
           i++,     iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); jaj += lda2; lda2 -= 2;
   }
@type real dble cplx zplx
@rout tpsvLTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA - N + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (LDA+1)*(N-1) - ( ((N-1)*N) >> 1 ), jx  = (N-1)*INCX;
        j >= 0; j--,                                           jx -= INCX )
   {
      t0  = X[jx];
      for( i = j+1,    iaij  = jaj+1, ix  = jx + INCX;
           i < N; i++, iaij += 1,     ix += INCX ) { t0 -= A[iaij] * X[ix]; }
      X[jx] = t0; lda += 1; jaj -= lda;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( ( LDA - N + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (((LDA+1)*(N-1)) << 1) - (N-1)*N, jx  = (N-1)*incx2;
        j >= 0; j--,                                         jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx + incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); lda2 += 2; jaj -= lda2;
   }
@type real dble cplx zplx
@rout trmvLTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, ldap1 = LDA + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jaj += ldap1, jx += INCX )
   {
      t0 = X[jx];
      for( i = j+1,    iaij  = jaj+1, ix  = jx + INCX;
           i < N; i++, iaij += 1,     ix += INCX ) { t0 += A[iaij] * X[ix]; }
      X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += ldap12, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout trsvLTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, ldap1 = LDA + 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*(ldap1), jx  = (N-1)*INCX;
        j >= 0; j--, jaj -= ldap1,         jx -= INCX )
   {
      t0 = X[jx];
      for( i = j+1,    iaij  = 1+jaj, ix  = jx + INCX;
           i < N; i++, iaij += 1,     ix += INCX ) { t0 -= A[iaij] * X[ix]; }
      X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*(ldap12), jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= ldap12,         jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = 2+jaj, ix  = jx + incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout tbmvLTU tbsvLTU tpmvLTU tpsvLTU trmvLTU trsvLTU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvLHN tbsvLHN tpmvLHN tpsvLHN trmvLHN trsvLHN
@define rname @ATL_@(pre)ref@4l@(@rout)LHN@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvLHN tbsvLHN
   const int                  K,
@rout tbmvLHN tbsvLHN tpmvLHN tpsvLHN trmvLHN trsvLHN
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvLHN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj  = 0, jx  = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mmul( A[jaj], -A[jaj+1], X[jx] , X[jx+1], t0_r, t0_i );
      i1   = ( N - 1 > j + K ? j + K : N - 1 );
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout tbsvLHN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      i1   = ( N - 1 > j + K ? j + K : N - 1 );
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      @(div)( A[jaj], -A[jaj+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout tpmvLHN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jx += incx2 )
   {
      Mmul( A[jaj], -A[jaj+1], X[jx] , X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); jaj += lda2; lda2 -= 2;
   }
@rout tpsvLHN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( ( LDA - N + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (((LDA+1)*(N-1)) << 1) - (N-1)*N, jx  = (N-1)*incx2;
        j >= 0; j--,                                         jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx + incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      @(div)( A[jaj], -A[jaj+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); lda2 += 2; jaj -= lda2;
   }
@rout trmvLHN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += ldap12, jx += incx2 )
   {
      Mmul( A[jaj], -A[jaj+1], X[jx] , X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout trsvLHN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*(ldap12), jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= ldap12,         jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = 2+jaj, ix  = jx + incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      @(div)( A[jaj], -A[jaj+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout tbmvLHN tbsvLHN tpmvLHN tpsvLHN trmvLHN trsvLHN
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvLHU tbsvLHU tpmvLHU tpsvLHU trmvLHU trsvLHU
@define rname @ATL_@(pre)ref@4l@(@rout)LHU@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvLHU tbsvLHU
   const int                  K,
@rout tbmvLHU tbsvLHU tpmvLHU tpsvLHU trmvLHU trsvLHU
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvLHU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj  = 0, jx  = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      i1   = ( N - 1 > j + K ? j + K : N - 1 );
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout tbsvLHU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i1, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      i1 = ( N - 1 > j + K ? j + K : N - 1 );
      for( i = j+1,      iaij  = 2+jaj, ix  = jx + incx2;
           i <= i1; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout tpmvLHU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2,  ix  = jx+incx2;
           i < N; i++, iaij += 2,      ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); jaj += lda2; lda2 -= 2;
   }
@rout tpsvLHU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( ( LDA - N + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (((LDA+1)*(N-1)) << 1) - (N-1)*N, jx  = (N-1)*incx2;
        j >= 0; j--,                                         jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx + incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); lda2 += 2; jaj -= lda2;
   }
@rout trmvLHU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += ldap12, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = jaj+2, ix  = jx+incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout trsvLHU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              ldap12 = ( ( LDA + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*(ldap12), jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= ldap12,         jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = j+1,    iaij  = 2+jaj, ix  = jx + incx2;
           i < N; i++, iaij += 2,     ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout tbmvLHU tbsvLHU tpmvLHU tpsvLHU trmvLHU trsvLHU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvUNN tbsvUNN tpmvUNN tpsvUNN trmvUNN trsvUNN
@define rname @ATL_@(pre)ref@4l@(@rout)UNN@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvUNN tbsvUNN
   const int                  K,
@rout tbmvUNN tbsvUNN tpmvUNN tpsvUNN trmvUNN trsvUNN
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvUNN
@type real dble
   @(reg_type_decl) t0;
   int                        i, i0, iaij, ix, j, jaj, jx, kx = 0, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = X[jx]; l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0, iaij = l+i0+jaj, ix = kx; i < j; i++, iaij += 1, ix += INCX )
      { X[ix] += t0 * A[iaij]; }
      X[jx] = A[iaij] * X[jx];
      if( j >= K ) { kx += INCX; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      Mmul( A[iaij], A[iaij+1], t0_r, t0_i, X[jx] , X[jx+1] );
      if( j >= K ) { kx += incx2; }
   }
@type real dble cplx zplx
@rout tbsvUNN
@type real dble
   @(reg_type_decl) t0;
   int                        i, i0, iaij, ix, j, jaj, jx, kx = 0, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*LDA, jx  = kx+(N-1)*INCX;
        j >= 0; j--, jaj -= LDA,       jx -= INCX )
   {
      l = K -j; i0 = ( j - K > 0 ? j - K : 0 ); X[jx] /= A[K+jaj]; t0 = X[jx];
      for( i = i0,     iaij  = l+i0+jaj, ix  = kx+i0*INCX;
           i < j; i++, iaij += 1,        ix += INCX ) { X[ix] -= t0 * A[iaij]; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, iajj, incx2 = 2 * INCX, ix, j,
                              jaj, jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      l = K -j; i0 = ( j - K > 0 ? j - K : 0 ); iajj = ( K << 1 ) + jaj;
      @(div)( A[iajj], A[iajj+1], X[jx], X[jx+1] );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx+i0*incx2;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@type real dble cplx zplx
@rout tpmvUNN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += INCX )
   {
      t0 = X[jx];
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { X[ix] += t0 * A[iaij]; }
      X[jx] *= A[iaij]; jaj += lda; lda += 1;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      Mmul( A[iaij], A[iaij+1], t0_r, t0_i, X[jx] , X[jx+1] );
      jaj += lda2; lda2 += 2;
   }
@type real dble cplx zplx
@rout tpsvUNN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA + N - 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (((N-1)*(2*LDA+N-2)) >> 1), jx  = (N-1)*INCX;
        j >= 0; j--,                                   jx -= INCX )
   {
      X[jx] /= A[j+jaj]; t0 = X[jx];
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { X[ix] -= t0 * A[iaij]; }
      lda -= 1; jaj -= lda;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, iajj, incx2 = 2 * INCX, ix, j, jaj,
                              jx, lda2 = ( ( LDA + N - 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1, jaj = (N-1)*(2*LDA+N-2), jx  = (N-1)*incx2;
        j >= 0; j--,                      jx -= incx2 )
   {
      iajj = (j << 1) + jaj; @(div)( A[iajj], A[iajj+1], X[jx], X[jx+1] );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
      lda2 -= 2; jaj -= lda2;
   }
@type real dble cplx zplx
@rout trmvUNN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = X[jx];
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { X[ix] += t0 * A[iaij]; }
      X[jx] *= A[iaij];
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      Mmul( A[iaij], A[iaij+1], t0_r, t0_i, X[jx] , X[jx+1] );
   }
@type real dble cplx zplx
@rout trsvUNN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*LDA, jx  = (N-1)*INCX;
        j >= 0; j--, jaj -= LDA,       jx -= INCX )
   {
      X[jx] /= A[j+jaj]; t0 = X[jx];
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { X[ix] -= t0 * A[iaij]; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, iajj, incx2 = 2 * INCX, ix, j, jaj,
                              jx, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      iajj = ( j << 1 ) + jaj; @(div)( A[iajj], A[iajj+1], X[jx], X[jx+1] );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@type real dble cplx zplx
@rout tbmvUNN tbsvUNN tpmvUNN tpsvUNN trmvUNN trsvUNN
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvUNU tbsvUNU tpmvUNU tpsvUNU trmvUNU trsvUNU
@define rname @ATL_@(pre)ref@4l@(@rout)UNU@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvUNU tbsvUNU
   const int                  K,
@rout tbmvUNU tbsvUNU tpmvUNU tpsvUNU trmvUNU trsvUNU
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvUNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, i0, iaij, ix, j, jaj, jx, kx = 0, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = X[jx]; l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0, iaij = l+i0+jaj, ix = kx; i < j; i++, iaij += 1, ix += INCX )
      { X[ix] += t0 * A[iaij]; }
      if( j >= K ) { kx += INCX; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      if( j >= K ) { kx += incx2; }
   }
@type real dble cplx zplx
@rout tbsvUNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, i0, iaij, ix, j, jaj, jx, kx = 0, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*LDA, jx  = kx+(N-1)*INCX;
        j >= 0; j--, jaj -= LDA,       jx -= INCX )
   {
      l = K -j; i0 = ( j - K > 0 ? j - K : 0 ); t0 = X[jx];
      for( i = i0,     iaij  = l+i0+jaj, ix  = kx+i0*INCX;
           i < j; i++, iaij += 1,        ix += INCX ) { X[ix] -= t0 * A[iaij]; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      l = K -j; i0 = ( j - K > 0 ? j - K : 0 );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx+i0*incx2;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@type real dble cplx zplx
@rout tpmvUNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += INCX )
   {
      t0 = X[jx];
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { X[ix] += t0 * A[iaij]; }
      jaj += lda; lda += 1;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++,  jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      jaj += lda2; lda2 += 2;
   }
@type real dble cplx zplx
@rout tpsvUNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA + N - 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (((N-1)*(2*LDA+N-2)) >> 1), jx  = (N-1)*INCX;
        j >= 0; j--,                                   jx -= INCX )
   {
      t0 = X[jx];
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { X[ix] -= t0 * A[iaij]; }
      lda -= 1; jaj -= lda; 
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( ( LDA + N - 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (N-1)*(2*LDA+N-2), jx  = (N-1)*incx2;
        j >= 0; j--,                          jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
      lda2 -= 2; jaj -= lda2;
   }
@type real dble cplx zplx
@rout trmvUNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = X[jx];
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { X[ix] += t0 * A[iaij]; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
   }
@type real dble cplx zplx
@rout trsvUNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*LDA, jx  = (N-1)*INCX;
        j >= 0; j--, jaj -= LDA,       jx -= INCX )
   {
      t0 = X[jx];
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { X[ix] -= t0 * A[iaij]; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij  = jaj, ix  = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   } 
@type real dble cplx zplx
@rout tbmvUNU tbsvUNU tpmvUNU tpsvUNU trmvUNU trsvUNU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvUCN tbsvUCN tpmvUCN tpsvUCN trmvUCN trsvUCN
@define rname @ATL_@(pre)ref@4l@(@rout)UCN@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvUCN tbsvUCN
   const int                  K,
@rout tbmvUCN tbsvUCN tpmvUCN tpsvUCN trmvUCN trsvUCN
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvUCN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      Mmul( A[iaij], -A[iaij+1], t0_r, t0_i, X[jx] , X[jx+1] );
      if( j >= K ) { kx += incx2; }
   }
@rout tbsvUCN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, iajj, incx2 = 2 * INCX, ix, j,
                              jaj, jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      l = K -j; i0 = ( j - K > 0 ? j - K : 0 );
      iajj = ( K << 1 ) + jaj; @(div)( A[iajj], -A[iajj+1], X[jx], X[jx+1] );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx+i0*incx2;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@rout tpmvUCN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      Mmul( A[iaij], -A[iaij+1], t0_r, t0_i, X[jx] , X[jx+1] );
      jaj += lda2; lda2 += 2;
   }
@rout tpsvUCN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, iajj, incx2 = 2 * INCX, ix, j, jaj,
                              jx, lda2 = ( ( LDA + N - 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (N-1)*(2*LDA+N-2), jx  = (N-1)*incx2;
        j >= 0; j--,                          jx -= incx2 )
   {
      iajj = ( j << 1 ) + jaj; @(div)( A[iajj], -A[iajj+1], X[jx], X[jx+1] );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
      lda2 -= 2; jaj -= lda2;
   }
@rout trmvUCN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      Mmul( A[iaij], -A[iaij+1], t0_r, t0_i, X[jx] , X[jx+1] );
   }
@rout trsvUCN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, iajj, incx2 = 2 * INCX, ix, j, jaj,
                              jx, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      iajj = ( j << 1 ) + jaj; @(div)( A[iajj], -A[iajj+1], X[jx], X[jx+1] );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@rout tbmvUCN tbsvUCN tpmvUCN tpsvUCN trmvUCN trsvUCN
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvUCU tbsvUCU tpmvUCU tpsvUCU trmvUCU trsvUCU
@define rname @ATL_@(pre)ref@4l@(@rout)UCU@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvUCU tbsvUCU
   const int                  K,
@rout tbmvUCU tbsvUCU tpmvUCU tpsvUCU trmvUCU trsvUCU
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvUCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      if( j >= K ) { kx += incx2; }
   }
@rout tbsvUCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      l = K -j; i0 = ( j - K > 0 ? j - K : 0 );
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx+i0*incx2;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@rout tpmvUCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
      jaj += lda2; lda2 += 2;
   }
@rout tpsvUCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( ( LDA + N - 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (N-1)*(2*LDA+N-2), jx  = (N-1)*incx2;
        j >= 0; j--,                          jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
      lda2 -= 2; jaj -= lda2; 
   }
@rout trmvUCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix] , X[ix+1] ); }
   }
@rout trsvUCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], t0_r, t0_i, X[ix], X[ix+1] ); }
   }
@rout tbmvUCU tbsvUCU tpmvUCU tpsvUCU trmvUCU trsvUCU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvUTN tbsvUTN tpmvUTN tpsvUTN trmvUTN trsvUTN
@define rname @ATL_@(pre)ref@4l@(@rout)UTN@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvUTN tbsvUTN
   const int                  K,
@rout tbmvUTN tbsvUTN tpmvUTN tpsvUTN trmvUTN trsvUTN
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvUTN
@type real dble
   @(reg_type_decl) t0;
   int                        i, i0, iaij, ix, j, jaj, jx, kx = 0, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*LDA, jx  = kx+(N-1)*INCX;
        j >= 0; j--, jaj -= LDA,       jx -= INCX )
   {
      t0 = ATL_@(upr)ZERO; l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = l+i0+jaj, ix  = kx+i0*INCX;
           i < j; i++, iaij += 1,        ix += INCX ) { t0 += A[iaij] * X[ix]; }
      t0 += A[iaij] * X[jx]; X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx+i0*incx2;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mmla( A[iaij], A[iaij+1], X[jx] , X[jx+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout tbsvUTN
@type real dble
   @(reg_type_decl) t0;
   int                        i, i0, iaij, ix, j, jaj, jx, kx = 0, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = X[jx]; l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0, iaij = l+i0+jaj, ix = kx; i < j; i++, iaij += 1, ix += INCX )
      { t0 -= A[iaij] * X[ix]; }
      t0 /= A[iaij]; X[jx] = t0;
      if( j >= K ) { kx += INCX; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      @(div)( A[iaij], A[iaij+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
      if( j >= K ) { kx += incx2; }
   }
@type real dble cplx zplx
@rout tpmvUTN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA + N - 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j  = N-1,     jaj = (((N-1)*(2*LDA+N-2)) >> 1), jx = (N-1)*INCX;
        j >= 0; j--,                                    jx -= INCX )
   {
      t0 = ATL_@(upr)ZERO;
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { t0 += A[iaij] * X[ix]; }
      t0 += A[iaij] * X[jx]; X[jx] = t0; lda -= 1; jaj -= lda;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( ( LDA + N - 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1, jaj = (N-1)*(2*LDA+N-2), jx  = (N-1)*incx2;
        j >= 0; j--,                      jx -= incx2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mmla( A[iaij], A[iaij+1], X[jx] , X[jx+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); lda2 -= 2; jaj -= lda2;
   }
@type real dble cplx zplx
@rout tpsvUTN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += INCX )
   {
      t0 = X[jx];
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { t0 -= A[iaij] * X[ix]; }
      t0 /= A[iaij]; X[jx] = t0; jaj += lda; lda += 1;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      @(div)( A[iaij], A[iaij+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); jaj += lda2; lda2 += 2;
   }
@type real dble cplx zplx
@rout trmvUTN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*LDA, jx  = (N-1)*INCX;
        j >= 0; j--, jaj -= LDA,       jx -= INCX )
   {
      t0 = ATL_@(upr)ZERO;
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { t0 += A[iaij] * X[ix]; }
      t0 += A[iaij] * X[jx]; X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mmla( A[iaij], A[iaij+1], X[jx] , X[jx+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout trsvUTN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0,jx = 0; j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = X[jx];
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { t0 -= A[iaij] * X[ix]; }
      t0 /= A[iaij]; X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      @(div)( A[iaij], A[iaij+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout tbmvUTN tbsvUTN tpmvUTN tpsvUTN trmvUTN trsvUTN
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvUTU tbsvUTU tpmvUTU tpsvUTU trmvUTU trsvUTU
@define rname @ATL_@(pre)ref@4l@(@rout)UTU@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvUTU tbsvUTU
   const int                  K,
@rout tbmvUTU tbsvUTU tpmvUTU tpsvUTU trmvUTU trsvUTU
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvUTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, i0, iaij, ix, j, jaj, jx, kx = 0, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*LDA, jx  = kx+(N-1)*INCX;
        j >= 0; j--, jaj -= LDA,       jx -= INCX )
   {
      t0 = ATL_@(upr)ZERO; l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = l+i0+jaj, ix  = kx+i0*INCX;
           i < j; i++, iaij += 1,        ix += INCX ) { t0 += A[iaij] * X[ix]; }
      t0 += X[jx]; X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      l       = K - j;
      i0      = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx+i0*incx2;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r + X[jx], t0_i + X[jx+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout tbsvUTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, i0, iaij, ix, j, jaj, jx, kx = 0, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      jaj  = 0,   jx  = kx;
        j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = X[jx]; l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = l+i0+jaj, ix  = kx;
           i < j; i++, iaij += 1,        ix += INCX ) { t0 -= A[iaij] * X[ix]; }
      X[jx] = t0;
      if( j >= K ) { kx += INCX; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      jaj  = 0,    jx  = kx;
        j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      l     = K - j;
      i0    = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
      if( j >= K ) { kx += incx2; }
   }
@type real dble cplx zplx
@rout tpmvUTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA + N - 1;
@extract @(EXECUTABLE_STATEMENT)
   for( j  = N-1,    jaj = (((N-1)*(2*LDA+N-2)) >> 1), jx  = (N-1)*INCX;
        j >= 0; j--,                                   jx -= INCX )
   {
      t0 = ATL_@(upr)ZERO;
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { t0 += A[iaij] * X[ix]; }
      t0 += X[jx]; X[jx] = t0; lda -= 1; jaj -= lda;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( ( LDA + N - 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj = (N-1)*(2*LDA+N-2), jx  = (N-1)*incx2;
        j >= 0; j--,                                     jx -= incx2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      for( i = 0, iaij = jaj, ix  = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r + X[jx], t0_i + X[jx+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); lda2 -= 2; jaj -= lda2;
   }
@type real dble cplx zplx
@rout tpsvUTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx, lda = LDA;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += INCX )
   {
      t0 = X[jx];
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { t0 -= A[iaij] * X[ix]; }
      X[jx] = t0; jaj += lda; lda += 1;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx  = 0; j < N; j++, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); jaj += lda2; lda2 += 2;
   }
@type real dble cplx zplx
@rout trmvUTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*LDA, jx  = (N-1)*INCX;
        j >= 0; j--, jaj -= LDA,       jx -= INCX )
   {
      t0 = ATL_@(upr)ZERO;
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { t0 += A[iaij] * X[ix]; }
      t0 += X[jx]; X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r + X[jx], t0_i + X[jx+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout trsvUTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaij, ix, j, jaj, jx;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += LDA, jx += INCX )
   {
      t0 = X[jx];
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 1, ix += INCX )
      { t0 -= A[iaij] * X[ix]; }
      X[jx] = t0;
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@type real dble cplx zplx
@rout tbmvUTU tbsvUTU tpmvUTU tpsvUTU trmvUTU trsvUTU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvUHN tbsvUHN tpmvUHN tpsvUHN trmvUHN trsvUHN
@define rname @ATL_@(pre)ref@4l@(@rout)UHN@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvUHN tbsvUHN
   const int                  K,
@rout tbmvUHN tbsvUHN tpmvUHN tpsvUHN trmvUHN trsvUHN
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvUHN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx+i0*incx2;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mmla( A[iaij], -A[iaij+1], X[jx] , X[jx+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout tbsvUHN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      @(div)( A[iaij], -A[iaij+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
      if( j >= K ) { kx += incx2; }
   } 
@rout tpmvUHN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( ( LDA + N - 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1, jaj = (N-1)*(2*LDA+N-2), jx  = (N-1)*incx2;
        j >= 0; j--,                      jx -= incx2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mmla( A[iaij], -A[iaij+1], X[jx] , X[jx+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); lda2 -= 2; jaj -= lda2;
   }
@rout tpsvUHN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      @(div)( A[iaij], -A[iaij+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); jaj += lda2; lda2 += 2;
   }
@rout trmvUHN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mmla( A[iaij], -A[iaij+1], X[jx] , X[jx+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout trsvUHN
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      @(div)( A[iaij], -A[iaij+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout tbmvUHN tbsvUHN tpmvUHN tpsvUHN trmvUHN trsvUHN
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout tbmvUHU tbsvUHU tpmvUHU tpsvUHU trmvUHU trsvUHU
@define rname @ATL_@(pre)ref@4l@(@rout)UHU@
@extract @(VER_ATLAS_SRC)
@extract @(RF2_INCLUDE)

void @(rname)
(
   const int                  N,
@rout tbmvUHU tbsvUHU
   const int                  K,
@rout tbmvUHU tbsvUHU tpmvUHU tpsvUHU trmvUHU trsvUHU
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * X,
   const int                  INCX
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout tbmvUHU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = kx+(N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx+i0*incx2;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r + X[jx], t0_i + X[jx+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout tbsvUHU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, i0, iaij, incx2 = 2 * INCX, ix, j, jaj,
                              jx, kx = 0, l, lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = kx; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      l = K - j; i0 = ( j - K > 0 ? j - K : 0 );
      for( i = i0,     iaij  = ((l+i0) << 1)+jaj, ix  = kx;
           i < j; i++, iaij += 2,                 ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
      if( j >= K ) { kx += incx2; }
   }
@rout tpmvUHU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( ( LDA + N - 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1, jaj = (N-1)*(2*LDA+N-2), jx  = (N-1)*incx2;
        j >= 0; j--,                      jx -= incx2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      for( i = 0, iaij = jaj, ix  = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r + X[jx], t0_i + X[jx+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); lda2 -= 2; jaj -= lda2;
   }
@rout tpsvUHU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] ); jaj += lda2; lda2 += 2;
   }
@rout trmvUHU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jx  = (N-1)*incx2;
        j >= 0; j--, jaj -= lda2,       jx -= incx2 )
   {
      Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmla( A[iaij], -A[iaij+1], X[ix] , X[ix+1], t0_r, t0_i ); }
      Mset( t0_r + X[jx], t0_i + X[jx+1], t0_r, t0_i );
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout trsvUHU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaij, incx2 = 2 * INCX, ix, j, jaj, jx,
                              lda2 = ( LDA << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jx = 0; j < N; j++, jaj += lda2, jx += incx2 )
   {
      Mset( X[jx], X[jx+1], t0_r, t0_i );
      for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += incx2 )
      { Mmls( A[iaij], -A[iaij+1], X[ix], X[ix+1], t0_r, t0_i ); }
      Mset( t0_r, t0_i, X[jx], X[jx+1] );
   }
@rout tbmvUHU tbsvUHU tpmvUHU tpsvUHU trmvUHU trsvUHU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gemm
@define rname @ATL_@(pre)refgemm@
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)

void @(rname)
(
   const enum ATLAS_TRANS     TRANSA,  
   const enum ATLAS_TRANS     TRANSB,  
   const int                  M,
   const int                  N,
   const int                  K,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * B,
   const int                  LDB,
   @(cst_type_decl) BETA,
   @(type_decl) * C,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * B,
   const int                  LDB,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * C,
@type real dble cplx zplx
   const int                  LDC
)     
{
@extract @(ATLAS_REF_COMMENT)
@type real dble
   if( ( M == 0 ) || ( N == 0 ) ||
       ( ( ( ALPHA == ATL_@(upr)ZERO ) || ( K == 0 ) ) &&
         ( BETA == ATL_@(upr)ONE ) ) ) return;
 
   if( ALPHA == ATL_@(upr)ZERO )
   { M@(pre)gescal( M, N, BETA, C, LDC ); return; }

   if( TRANSB == AtlasNoTrans )
   {
      if( TRANSA == AtlasNoTrans )
      {
         ATL_@(pre)refgemmNN( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }
      else
      {
         ATL_@(pre)refgemmTN( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }
   }
   else
   {
      if( TRANSA == AtlasNoTrans )
      {
         ATL_@(pre)refgemmNT( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }  
      else
      {
         ATL_@(pre)refgemmTT( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }
   }
@type cplx zplx
   if( ( M == 0 ) || ( N == 0 ) ||
       ( ( @(isz)( ALPHA[0], ALPHA[1] ) || ( K == 0 ) ) &&
         @(iso)( BETA[0], BETA[1] ) ) ) return;
 
   if( @(isz)( ALPHA[0], ALPHA[1] ) )
   { M@(pre)gescal( M, N, BETA, C, LDC ); return; }
 
   if( TRANSB == AtlasNoTrans )
   {
      if(      TRANSA == AtlasNoTrans )
      {
         ATL_@(pre)refgemmNN( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }
      else if( TRANSA == AtlasTrans )
      {
         ATL_@(pre)refgemmTN( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }
      else
      {
         ATL_@(pre)refgemmCN( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }
   }
   else if( TRANSB == AtlasTrans )
   {
      if( TRANSA == AtlasNoTrans )
      {
         ATL_@(pre)refgemmNT( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }
      else if( TRANSA == AtlasTrans )
      {
         ATL_@(pre)refgemmTT( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }
      else
      {
         ATL_@(pre)refgemmCT( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }
   }
   else
   {
      if( TRANSA == AtlasNoTrans )
      {
         ATL_@(pre)refgemmNC( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }
      else if( TRANSA == AtlasTrans )
      {
         ATL_@(pre)refgemmTC( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }
      else
      {
         ATL_@(pre)refgemmCC( M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC );
      }
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gemmNN
@define rname @ATL_@(pre)refgemmNN@
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
   const int                  K,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * B,
   const int                  LDB,
   @(cst_type_decl) BETA,
   @(type_decl) * C,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * B,
   const int                  LDB,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * C,
@type real dble cplx zplx
   const int                  LDC
)
{ 
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0;
   int                        i, iail, iblj, icij, j, jal, jbj, jcj, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0, jcj  = 0; j < N; j++, jbj += LDB, jcj += LDC )
   {
      M@(pre)gescal( M, 1, BETA, C+jcj, LDC );
      for( l = 0, jal = 0, iblj = jbj; l < K; l++, jal += LDA, iblj += 1 )
      {
         t0 = ALPHA * B[iblj];
         for( i = 0, iail = jal, icij = jcj; i < M; i++, iail += 1, icij += 1 )
         { C[icij] += A[iail] * t0; }
      }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iail, iblj, icij, j, jal, jbj, jcj, l,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 ),
                              ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj  = 0, jcj  = 0; j < N; j++, jbj += ldb2, jcj += ldc2 )
   {
      M@(pre)gescal( M, 1, BETA, C+jcj, LDC );
      for( l = 0, jal = 0, iblj = jbj; l < K; l++, jal += lda2, iblj += 2 )
      {
         Mmul( ALPHA[0], ALPHA[1], B[iblj], B[iblj+1], t0_r, t0_i );
         for( i = 0, iail = jal, icij = jcj; i < M; i++, iail += 2, icij += 2 )
         { Mmla( A[iail], A[iail+1], t0_r, t0_i, C[icij], C[icij+1] ); }
      }
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gemmTN
@define rname @ATL_@(pre)refgemmTN@
@rout gemmCN
@define rname @ATL_@(pre)refgemmCN@
@rout gemmTN gemmCN
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
   const int                  K,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * B,
   const int                  LDB,
   @(cst_type_decl) BETA,
   @(type_decl) * C,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * B,
   const int                  LDB,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * C,
@type real dble cplx zplx
   const int                  LDC
)
{
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0;
   int                        i, iai, iail, iblj, icij, j, jbj, jcj, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0, jcj = 0; j < N; j++, jbj += LDB, jcj += LDC )
   {
      for( i = 0, icij = jcj, iai = 0; i < M; i++, icij += 1, iai += LDA )
      {
         t0 = ATL_@(upr)ZERO;
         for( l = 0, iail = iai, iblj = jbj; l < K; l++, iail += 1, iblj += 1 )
         { t0 += A[iail] * B[iblj]; }
         M@(pre)elscal( BETA, C[icij] ); C[icij] += ALPHA * t0;
      }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iai, iail, iblj, icij, j, jbj, jcj, l,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 ),
                              ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0, jcj = 0; j < N; j++, jbj += ldb2, jcj += ldc2 )
   {
      for( i = 0, icij = jcj, iai = 0; i < M; i++, icij += 2, iai += lda2 )
      {
         Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
         for( l = 0, iail = iai, iblj = jbj; l < K; l++, iail += 2, iblj += 2 )
@rout gemmTN
         { Mmla( A[iail],  A[iail+1], B[iblj], B[iblj+1], t0_r, t0_i ); }
@rout gemmCN
         { Mmla( A[iail], -A[iail+1], B[iblj], B[iblj+1], t0_r, t0_i ); }
@rout gemmTN gemmCN
         M@(pre)elscal( BETA[0], BETA[1], C[icij], C[icij+1] );
         Mmla( ALPHA[0], ALPHA[1], t0_r, t0_i, C[icij], C[icij+1] );
      }
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gemmNT
@define rname @ATL_@(pre)refgemmNT@
@rout gemmNC
@define rname @ATL_@(pre)refgemmNC@
@rout gemmNT gemmNC
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
   const int                  K,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * B,
   const int                  LDB,
   @(cst_type_decl) BETA,
   @(type_decl) * C,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * B,
   const int                  LDB,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * C,
@type real dble cplx zplx
   const int                  LDC
)
{
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0;
   int                        i, iail, ibj, ibjl, icij, j, jal, jcj, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, ibj  = 0, jcj  = 0; j < N; j++, ibj += 1, jcj += LDC )
   {
      M@(pre)gescal( M, 1, BETA, C+jcj, LDC );
      for( l = 0, jal  = 0, ibjl = ibj; l < K; l++, jal += LDA, ibjl += LDB )
      {
         t0 = ALPHA * B[ibjl];
         for( i = 0, iail = jal, icij = jcj; i < M; i++, iail += 1, icij += 1 )
         { C[icij] += A[iail] * t0; }
      }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iail, ibj, ibjl, icij, j, jal, jcj, l,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 ),
                              ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, ibj = 0, jcj = 0; j < N; j++, ibj += 2, jcj += ldc2 )
   {
      M@(pre)gescal( M, 1, BETA, C+jcj, LDC );
      for( l = 0, jal = 0, ibjl = ibj; l < K; l++, jal += lda2, ibjl += ldb2 )
      {
@rout gemmNT
         Mmul( ALPHA[0], ALPHA[1], B[ibjl],  B[ibjl+1], t0_r, t0_i );
@rout gemmNC
         Mmul( ALPHA[0], ALPHA[1], B[ibjl], -B[ibjl+1], t0_r, t0_i );
@rout gemmNT gemmNC
         for( i = 0, iail = jal, icij = jcj; i < M; i++, iail += 2, icij += 2 )
         { Mmla( A[iail], A[iail+1], t0_r, t0_i, C[icij], C[icij+1] ); }
      }
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout gemmTT
@define rname @ATL_@(pre)refgemmTT@
@rout gemmTC
@define rname @ATL_@(pre)refgemmTC@
@rout gemmCT
@define rname @ATL_@(pre)refgemmCT@
@rout gemmCC
@define rname @ATL_@(pre)refgemmCC@
@rout gemmTT gemmTC gemmCT gemmCC
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
   const int                  K,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * B,
   const int                  LDB,
   @(cst_type_decl) BETA,
   @(type_decl) * C,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * B,
   const int                  LDB,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * C,
@type real dble cplx zplx
   const int                  LDC
)
{
@extract @(LOCAL_VARIABLE)
@type real dble
   @(reg_type_decl) t0;
   int                        i, iali, ibj, ibjl, icij, j, jai, jcj, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, ibj = 0, jcj  = 0; j < N; j++, ibj += 1, jcj += LDC )
   {
      for( i = 0, icij = jcj, jai = 0; i < M; i++, icij += 1, jai += LDA )
      {
         t0 = ATL_@(upr)ZERO;
         for( l = 0,      iali  = jai, ibjl  = ibj;
              l < K; l++, iali += 1,   ibjl += LDB ) t0 += A[iali] * B[ibjl];
         M@(pre)elscal( BETA, C[icij] ); C[icij] += ALPHA * t0;
      }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iali, ibj, ibjl, icij, j, jai, jcj, l,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 ),
                              ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, ibj = 0, jcj = 0; j < N; j++, ibj += 2, jcj += ldc2 )
   {
      for( i = 0, icij = jcj, jai = 0; i < M; i++, icij += 2, jai += lda2 )
      {
         Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
         for( l = 0,      iali  = jai, ibjl  = ibj;
              l < K; l++, iali += 2,   ibjl += ldb2 )
@rout gemmTT
         { Mmla( A[iali],  A[iali+1], B[ibjl],  B[ibjl+1], t0_r, t0_i ); }
@rout gemmCT
         { Mmla( A[iali], -A[iali+1], B[ibjl],  B[ibjl+1], t0_r, t0_i ); }
@rout gemmTC
         { Mmla( A[iali],  A[iali+1], B[ibjl], -B[ibjl+1], t0_r, t0_i ); }
@rout gemmCC
         { Mmla( A[iali], -A[iali+1], B[ibjl], -B[ibjl+1], t0_r, t0_i ); }
@rout gemmTT gemmTC gemmCT gemmCC
         M@(pre)elscal( BETA[0], BETA[1], C[icij], C[icij+1] );
         Mmla( ALPHA[0], ALPHA[1], t0_r, t0_i, C[icij], C[icij+1] );
      }
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout symm
@define rname @ATL_@(pre)ref@(syhe)mm@
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_SIDE      SIDE,
   const enum ATLAS_UPLO      UPLO,
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * B,
   const int                  LDB,
   @(cst_type_decl) BETA,
   @(type_decl) * C,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * B,
   const int                  LDB,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * C,
@type real dble cplx zplx chex zhex
   const int                  LDC
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
@type real dble
   if( ( M == 0 ) || ( N == 0 ) ||
       ( ( ALPHA == ATL_@(upr)ZERO ) && ( BETA  == ATL_@(upr)ONE  ) ) ) return;

   if( ALPHA == ATL_@(upr)ZERO )
   { M@(pre)gescal( M, N, BETA, C, LDC ); return; }
@type cplx zplx chex zhex
   if( ( M == 0 ) || ( N == 0 ) || ( @(isz)( ALPHA[0], ALPHA[1] ) &&
                                     @(iso) ( BETA [0], BETA [1] ) ) ) return;

   if( @(isz)( ALPHA[0], ALPHA[1] ) )
   { M@(pre)gescal( M, N, BETA, C, LDC ); return; }
@type real dble cplx zplx chex zhex

   if( SIDE == AtlasLeft )
   {
      if( UPLO == AtlasUpper )
      { ATL_@(pre)ref@(syhe)mmLU( M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC ); }
      else
      { ATL_@(pre)ref@(syhe)mmLL( M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC ); }
   }
   else
   {
      if( UPLO == AtlasUpper )
      { ATL_@(pre)ref@(syhe)mmRU( M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC ); }
      else
      { ATL_@(pre)ref@(syhe)mmRL( M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC ); }
   }
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout symmLL
@define rname @ATL_@(pre)ref@(syhe)mmLL@
@rout symmLU
@define rname @ATL_@(pre)ref@(syhe)mmLU@
@rout symmRL
@define rname @ATL_@(pre)ref@(syhe)mmRL@
@rout symmRU
@define rname @ATL_@(pre)ref@(syhe)mmRU@
@rout symmLL symmLU symmRL symmRU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * B,
   const int                  LDB,
   @(cst_type_decl) BETA,
   @(type_decl) * C,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * B,
   const int                  LDB,
   @(cst_utyp_decl) * BETA,
   @(utyp_decl) * C,
@type real dble cplx zplx chex zhex
   const int                  LDC
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout symmLL
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iaki, ibij, ibkj, icij, ickj, j, jai,
                              jbj, jcj, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0, jcj = 0; j < N; j++, jbj += LDB, jcj += LDC )
   {
      for( i = M-1,     jai  = (M-1)*LDA, ibij  = M-1+jbj, icij  = M-1+jcj;
           i >= 0; i--, jai -= LDA,       ibij -= 1,       icij -= 1 )
      {
         t0 = ALPHA * B[ibij]; t1 = ATL_@(upr)ZERO;
         for( k = i+1, iaki  = i+1+jai, ibkj  = i+1+jbj, ickj  = i+1+jcj;
           k < M; k++, iaki += 1,       ibkj += 1,       ickj += 1 )
         { C[ickj] += t0   * A[iaki]; t1   += B[ibkj] * A[iaki]; }
         M@(pre)elscal( BETA, C[icij] ); C[icij] += t0 * A[i+jai] + ALPHA * t1;
      }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iaki, ibij, ibkj, icij, ickj, j, jai,
                              jbj, jcj, k, lda2 = ( LDA << 1 ),
                              ldb2 = ( LDB << 1 ), ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0, jcj = 0; j < N; j++, jbj += ldb2, jcj += ldc2 )
   {
      for( i = M-1, jai  = (M-1)*lda2, ibij  = ( (M-1) << 1 )+jbj,
           icij  = ( (M-1) << 1 )+jcj; i >= 0;
           i--, jai -= lda2, ibij -= 2, icij -= 2 )
      {
         Mmul( ALPHA[0], ALPHA[1], B[ibij], B[ibij+1], t0_r, t0_i );
         Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t1_r, t1_i );
         for( k = i+1, iaki = ( (i+1) << 1 )+jai, ibkj = ( (i+1) << 1 )+jbj,
              ickj = ( (i+1) << 1 )+jcj; k < M;
              k++, iaki += 2, ibkj += 2, ickj += 2 )
         {
            Mmla( A[iaki], A[iaki+1], t0_r, t0_i, C[ickj], C[ickj+1] );
@type cplx zplx
            Mmla( B[ibkj], B[ibkj+1], A[iaki], A[iaki+1], t1_r, t1_i );
         }
         M@(pre)elscal( BETA[0], BETA[1], C[icij], C[icij+1] );
         k = ( i << 1 ) + jai;
         Mmla( t0_r, t0_i, A[k], A[k+1], C[icij], C[icij+1] );
         Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, C[icij], C[icij+1] );
@type chex zhex
            Mmla( B[ibkj], B[ibkj+1], A[iaki], -A[iaki+1], t1_r, t1_i );
         }
         M@(pre)elscal( BETA[0], BETA[1], C[icij], C[icij+1] );
         k = ( i << 1 ) + jai;
         Mset( C[icij] + t0_r * A[k], C[icij+1] + t0_i * A[k],
               C[icij], C[icij+1] );
         Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, C[icij], C[icij+1] );
@type cplx zplx chex zhex
      }
   }
@type real dble cplx zplx chex zhex
@rout symmLU
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iaki, ibij, ibkj, icij, ickj, j, jai,
                              jbj, jcj, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0, jcj = 0; j < N; j++, jbj += LDB, jcj += LDC )
   {
      for( i = 0,      jai  = 0,   ibij  = jbj, icij  = jcj;
           i < M; i++, jai += LDA, ibij += 1,   icij += 1 )
      {
         t0 = ALPHA * B[ibij]; t1 = ATL_@(upr)ZERO;
         for( k = 0,      iaki  = jai, ibkj  = jbj, ickj  = jcj;
              k < i; k++, iaki += 1,   ibkj += 1,   ickj += 1 )
         { C[ickj] += t0   * A[iaki]; t1   += B[ibkj] * A[iaki]; }
         M@(pre)elscal( BETA, C[icij] ); C[icij] += t0 * A[i+jai] + ALPHA * t1;
      }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iaki, ibij, ibkj, icij, ickj, j, jai,
                              jbj, jcj, k, lda2 = ( LDA << 1 ),
                              ldb2 = ( LDB << 1 ), ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0, jcj = 0; j < N; j++, jbj += ldb2, jcj += ldc2 )
   {
      for( i = 0,      jai  = 0,    ibij  = jbj, icij  = jcj;
           i < M; i++, jai += lda2, ibij += 2,   icij += 2 )
      {
         Mmul( ALPHA[0], ALPHA[1], B[ibij], B[ibij+1], t0_r, t0_i );
         Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t1_r, t1_i );
         for( k = 0,      iaki  = jai, ibkj  = jbj, ickj  = jcj;
              k < i; k++, iaki += 2,   ibkj += 2,   ickj += 2 )
         {
            Mmla( A[iaki], A[iaki+1], t0_r, t0_i, C[ickj], C[ickj+1] );
@type cplx zplx
            Mmla( B[ibkj], B[ibkj+1], A[iaki], A[iaki+1], t1_r, t1_i );
         }
         M@(pre)elscal( BETA[0], BETA[1], C[icij], C[icij+1] );
         k = ( i << 1 ) + jai;
         Mmla( t0_r, t0_i, A[k], A[k+1], C[icij], C[icij+1] );
         Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, C[icij], C[icij+1] );
@type chex zhex
            Mmla( B[ibkj], B[ibkj+1], A[iaki], -A[iaki+1], t1_r, t1_i );
         }
         M@(pre)elscal( BETA[0], BETA[1], C[icij], C[icij+1] );
         k = ( i << 1 ) + jai;
         Mset( C[icij] + t0_r * A[k], C[icij+1] + t0_i * A[k],
               C[icij], C[icij+1] );
         Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, C[icij], C[icij+1] );
@type cplx zplx chex zhex
      }
   }
@type real dble cplx zplx chex zhex
@rout symmRL
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaj, iajk, iakj, ibij, ibik, icij, j,
                              jaj, jbj, jbk, jcj, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      iaj  = 0, jaj  = 0,   jbj  = 0,   jcj  = 0;
        j < N; j++, iaj += 1, jaj += LDA, jbj += LDB, jcj += LDC )
   {
      t0 = ALPHA * A[j+jaj];
      for( i = 0, ibij = jbj, icij = jcj; i < M; i++, ibij += 1, icij += 1 )
      { M@(pre)elscal( BETA, C[icij] ); C[icij] += t0 * B[ibij]; }
      for( k = 0, iajk = iaj, jbk = 0; k < j; k++, iajk += LDA, jbk += LDB )
      {
         t0 = ALPHA * A[iajk];
         for( i = 0, ibik = jbk, icij = jcj; i < M; i++, ibik += 1, icij += 1 )
         { C[icij] += t0 * B[ibik]; }
      }
      for( k = j+1,    iakj  = j+1+jaj, jbk  = (j+1)*LDB;
           k < N; k++, iakj += 1,       jbk += LDB )
      {
         t0 = ALPHA * A[iakj];
         for( i = 0, ibik = jbk, icij = jcj; i < M; i++, ibik += 1, icij += 1 )
         { C[icij] += t0 * B[ibik]; }
      }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaj, iajk, iakj, ibij, ibik, icij, j,
                              jaj, jbj, jbk, jcj, k, lda2 = ( LDA << 1 ),
                              ldb2 = ( LDB << 1 ), ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      iaj  = 0, jaj  = 0,    jbj  = 0,    jcj  = 0;
        j < N; j++, iaj += 2, jaj += lda2, jbj += ldb2, jcj += ldc2 )
   {
      i = ( j << 1 ) + jaj;
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], A[i], A[i+1], t0_r, t0_i );
@type chex zhex
      Mset( ALPHA[0] * A[i], ALPHA[1] * A[i], t0_r, t0_i );
@type cplx zplx chex zhex
      for( i = 0, ibij = jbj, icij = jcj; i < M; i++, ibij += 2, icij += 2 )
      { 
         M@(pre)elscal( BETA[0], BETA[1], C[icij], C[icij+1] );
         Mmla( t0_r, t0_i, B[ibij], B[ibij+1], C[icij], C[icij+1] );
      }
      for( k = 0, iajk = iaj, jbk = 0; k < j; k++, iajk += lda2, jbk += ldb2 )
      {
@type cplx zplx
         Mmul( ALPHA[0], ALPHA[1], A[iajk],  A[iajk+1], t0_r, t0_i );
@type chex zhex
         Mmul( ALPHA[0], ALPHA[1], A[iajk], -A[iajk+1], t0_r, t0_i );
@type cplx zplx chex zhex
         for( i = 0, ibik = jbk, icij = jcj; i < M; i++, ibik += 2, icij += 2 )
         { Mmla( t0_r, t0_i, B[ibik], B[ibik+1], C[icij], C[icij+1] ); }
      }
      for( k = j+1,    iakj  = ((j+1) << 1)+jaj, jbk  = (j+1)*ldb2;
           k < N; k++, iakj += 2,                jbk += ldb2 )
      {
         Mmul( ALPHA[0], ALPHA[1], A[iakj], A[iakj+1], t0_r, t0_i );
         for( i = 0, ibik = jbk, icij = jcj; i < M; i++, ibik += 2, icij += 2 )
         { Mmla( t0_r, t0_i, B[ibik], B[ibik+1], C[icij], C[icij+1] ); }
      }
   }
@type real dble cplx zplx chex zhex
@rout symmRU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaj, iajk, iakj, ibij, ibik, icij, j,
                              jaj, jbj, jbk, jcj, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      iaj  = 0, jaj  = 0,   jbj  = 0,   jcj  = 0;
        j < N; j++, iaj += 1, jaj += LDA, jbj += LDB, jcj += LDC )
   {
      t0 = ALPHA * A[j+jaj];
      for( i = 0, ibij = jbj, icij = jcj; i < M; i++, ibij += 1, icij += 1 )
      { M@(pre)elscal( BETA, C[icij] ); C[icij] += t0 * B[ibij]; }
      for( k = 0, iakj = jaj, jbk = 0; k < j; k++, iakj += 1, jbk += LDB )
      {
         t0 = ALPHA * A[iakj];
         for( i = 0, ibik = jbk, icij = jcj; i < M; i++, ibik += 1, icij += 1 )
         { C[icij] += t0 * B[ibik]; }
      }
      for( k = j+1,    iajk  = iaj+(j+1)*LDA, jbk  = (j+1)*LDB;
           k < N; k++, iajk += LDA,           jbk += LDB )
      {
         t0 = ALPHA * A[iajk];
         for( i = 0, ibik = jbk, icij = jcj; i < M; i++, ibik += 1, icij += 1 )
         { C[icij] += t0 * B[ibik]; }
      }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaj, iajk, iakj, ibij, ibik, icij, j,
                              jaj, jbj, jbk, jcj, k, lda2 = ( LDA << 1 ),
                              ldb2 = ( LDB << 1 ), ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      iaj  = 0, jaj  = 0,    jbj  = 0,    jcj  = 0;
        j < N; j++, iaj += 2, jaj += lda2, jbj += ldb2, jcj += ldc2 )
   {
      i = ( j << 1 ) + jaj;
@type cplx zplx
      Mmul( ALPHA[0], ALPHA[1], A[i], A[i+1], t0_r, t0_i );
@type chex zhex
      Mset( ALPHA[0] * A[i], ALPHA[1] * A[i], t0_r, t0_i );
@type cplx zplx chex zhex
      for( i = 0, ibij = jbj, icij = jcj; i < M; i++, ibij += 2, icij += 2 )
      {
         M@(pre)elscal( BETA[0], BETA[1], C[icij], C[icij+1] );
         Mmla( t0_r, t0_i, B[ibij], B[ibij+1], C[icij], C[icij+1] );
      }
      for( k = 0, iakj = jaj, jbk = 0; k < j; k++, iakj += 2, jbk += ldb2 )
      {
         Mmul( ALPHA[0], ALPHA[1], A[iakj], A[iakj+1], t0_r, t0_i );
         for( i = 0,      ibik  = jbk, icij  = jcj;
              i < M; i++, ibik += 2,   icij += 2 )
         { Mmla( t0_r, t0_i, B[ibik], B[ibik+1], C[icij], C[icij+1] ); }
      }
      for( k = j+1,    iajk  = iaj+(j+1)*lda2, jbk  = (j+1)*ldb2;
           k < N; k++, iajk += lda2,           jbk += ldb2 )
      {
@type cplx zplx
         Mmul( ALPHA[0], ALPHA[1], A[iajk], A[iajk+1], t0_r, t0_i );
@type chex zhex
         Mmul( ALPHA[0], ALPHA[1], A[iajk], -A[iajk+1], t0_r, t0_i );
@type cplx zplx chex zhex
         for( i = 0, ibik = jbk, icij = jcj; i < M; i++, ibik += 2, icij += 2 )
         { Mmla( t0_r, t0_i, B[ibik], B[ibik+1], C[icij], C[icij+1] ); }
      }
   }
@type real dble cplx zplx chex zhex
@rout symmLL symmLU symmRL symmRU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout syrk
@define rname @ATL_@(pre)ref@(syhe)rk@
@rout syr2k
@define rname @ATL_@(pre)ref@(syhe)r2k@
@rout syrk syr2k
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const int                  N,
   const int                  K,
@rout syrk
@type real dble chex zhex
   @(cst_type_decl) ALPHA,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
@type real dble
   @(cst_type_decl) * A,
@type chex zhex cplx zplx
   @(cst_utyp_decl) * A,
@type real dble chex zhex cplx zplx
   const int                  LDA,
@rout syr2k
@type real dble
   @(cst_type_decl) ALPHA,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
@type real dble chex zhex cplx zplx
@type real dble
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * B,
   const int                  LDB,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * B,
   const int                  LDB,
@type real dble chex zhex cplx zplx
@rout syrk syr2k
@type real dble chex zhex
   @(cst_type_decl) BETA,
@type cplx zplx
   @(cst_utyp_decl) * BETA,
@type real dble
   @(type_decl) * C, 
@type cplx zplx chex zhex
   @(utyp_decl) * C,
@type real dble chex zhex cplx zplx
   const int                  LDC
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@type real dble
   int                        i, icij, j, jcj; 
@extract @(EXECUTABLE_STATEMENT)
@rout syrk
   if( ( N == 0 ) || ( ( ( ALPHA == ATL_@(upr)ZERO ) || ( K == 0 ) ) &&
                       ( BETA == ATL_@(upr)ONE ) ) ) return;
@rout syr2k
   if( ( N == 0 ) || ( ( ( ALPHA == ATL_@(upr)ZERO ) || ( K == 0 ) ) &&
                       ( BETA == ATL_@(upr)ONE ) ) ) return;
@rout syrk syr2k

   if( ALPHA == ATL_@(upr)ZERO )
   {
      if( UPLO == AtlasUpper )
      {
         if( BETA == ATL_@(upr)ZERO )
         {
            for( j = 0, jcj = 0; j < N; j++, jcj += LDC )
            {
               for( i = 0, icij = jcj; i <= j; i++, icij += 1 )
               { C[icij] = ATL_@(upr)ZERO; }
            }
         }
         else if( BETA != ATL_@(upr)ONE )
         {
            for( j = 0, jcj = 0; j < N; j++, jcj += LDC )
            {
               for( i = 0, icij = jcj; i <= j; i++, icij += 1 )
               { C[icij] *= BETA; }
            }
         }
      }
      else
      {
         if( BETA == ATL_@(upr)ZERO )
         {
            for( j = 0, jcj = 0; j < N; j++, jcj += LDC )
            {
               for( i = j, icij = j+jcj; i < N; i++, icij += 1 )
               { C[icij] = ATL_@(upr)ZERO; }
            }
         }
         else if( BETA != ATL_@(upr)ONE )
         {
            for( j = 0, jcj = 0; j < N; j++, jcj += LDC )
            {
               for( i = j, icij = j+jcj; i < N; i++, icij += 1 )
               { C[icij] *= BETA; }
            }
         }
      }
      return;
   }
@type cplx zplx
   int                        i, icij, j, jcj, ldc2 = ( LDC << 1 ),
                              ldcp12 = ( ( LDC + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
@rout syrk
   if( ( N == 0 ) ||
       ( ( @(isz)( ALPHA[0], ALPHA[1] ) || ( K == 0 ) ) &&
         @(iso)( BETA[0], BETA[1] ) ) ) return;
@rout syr2k
   if( ( N == 0 ) ||
       ( ( @(isz)( ALPHA[0], ALPHA[1] ) || ( K == 0 ) ) &&
         @(iso)( BETA[0], BETA[1] ) ) ) return;
@rout syrk syr2k
 
   if( @(isz)( ALPHA[0], ALPHA[1] ) )
   {
      if( UPLO == AtlasUpper )
      {
         if( @(isz)( BETA[0], BETA[1] ) )
         {
            for( j = 0, jcj = 0; j < N; j++, jcj += ldc2 )
            {
               for( i = 0, icij = jcj; i <= j; i++, icij += 2 )
               { Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, C[icij], C[icij+1] ); }
            }
         }
         else if( !@(iso)( BETA[0], BETA[1] ) )
         {
            for( j = 0, jcj = 0; j < N; j++, jcj += ldc2 )
            {
               for( i = 0, icij = jcj; i <= j; i++, icij += 2 )
               { @(scl)( BETA[0], BETA[1], C[icij], C[icij+1] ); }
            }
         }
      }
      else
      {
         if( @(isz)( BETA[0], BETA[1] ) )
         {
            for( j = 0, jcj = 0; j < N; j++, jcj += ldcp12 )
            {
               for( i = j, icij = jcj; i < N; i++, icij += 2 )
               { Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, C[icij], C[icij+1] ); }
            }
         }
         else if( !@(iso)( BETA[0], BETA[1] ) )
         {
            for( j = 0, jcj = 0; j < N; j++, jcj += ldcp12 )
            {
               for( i = j, icij = jcj; i < N; i++, icij += 2 )
               { @(scl)( BETA[0], BETA[1], C[icij], C[icij+1] ); }
            }
         }
      }
      return;
   }
@type chex zhex
   int                        i, icij, j, jcj, ldc2 = ( LDC << 1 ),
                              ldcp12 = ( ( LDC + 1 ) << 1 );
@extract @(EXECUTABLE_STATEMENT)
@rout syrk
   if( ( N == 0 ) || ( ( ( ALPHA == ATL_@(upr)ZERO ) || ( K == 0 ) ) &&
                       ( BETA == ATL_@(upr)ONE ) ) )
      return;

   if( ALPHA == ATL_@(upr)ZERO )
@rout syr2k
   if( ( N == 0 ) || ( ( @(isz)( ALPHA[0], ALPHA[1] ) || ( K == 0 ) ) &&
                       ( BETA == ATL_@(upr)ONE ) ) )
      return;

   if( @(isz)( ALPHA[0], ALPHA[1] ) )
@rout syrk syr2k
   {
      if( UPLO == AtlasUpper )
      {
         if( BETA == ATL_@(upr)ZERO )
         {
            for( j = 0, jcj = 0; j < N; j++, jcj += ldc2 )
            {
               for( i = 0, icij = jcj; i <= j; i++, icij += 2 )
               { Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, C[icij], C[icij+1] ); }
            }
         }
         else if( BETA != ATL_@(upr)ONE )
         {
            for( j = 0, jcj = 0; j < N; j++, jcj += ldc2 )
            {
               for( i = 0, icij = jcj; i < j; i++, icij += 2 )
               { Mset( BETA * C[icij], BETA * C[icij+1], C[icij], C[icij+1] ); }
               Mset( BETA * C[icij], ATL_@(upr)ZERO, C[icij], C[icij+1] );
            }
         }
      }
      else
      {
         if( BETA == ATL_@(upr)ZERO )
         {
            for( j = 0, jcj = 0; j < N; j++, jcj += ldcp12 )
            {
               for( i = j, icij = jcj; i < N; i++, icij += 2 )
               { Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, C[icij], C[icij+1] ); }
            }
         }
         else if( BETA != ATL_@(upr)ONE )
         {
            for( j = 0, jcj = 0; j < N; j++, jcj += ldcp12 )
            {
               Mset( BETA * C[jcj], ATL_@(upr)ZERO, C[jcj], C[jcj+1] );
               for( i = j+1, icij = jcj+2; i < N; i++, icij += 2 )
               { Mset( BETA * C[icij], BETA * C[icij+1], C[icij], C[icij+1] ); }
            }
         }
      }
      return; 
   }
@type real dble cplx zplx chex zhex

   if( UPLO == AtlasUpper )
   { 
@rout syrk
      if( TRANS == AtlasNoTrans )
      { @(rname)UN( N, K, ALPHA, A, LDA, BETA, C, LDC ); }
      else
@type real dble cplx zplx
      { @(rname)UT( N, K, ALPHA, A, LDA, BETA, C, LDC ); }
@type chex zhex
      { @(rname)UC( N, K, ALPHA, A, LDA, BETA, C, LDC ); }
@type real dble cplx zplx chex zhex
@rout syr2k
      if( TRANS == AtlasNoTrans )
      { @(rname)UN( N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC ); }
      else
@type real dble cplx zplx
      { @(rname)UT( N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC ); }
@type chex zhex
      { @(rname)UC( N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC ); }
@type real dble cplx zplx chex zhex
@rout syrk syr2k
   }
   else
   {
@rout syrk
      if( TRANS == AtlasNoTrans )
      { @(rname)LN( N, K, ALPHA, A, LDA, BETA, C, LDC ); }
      else
@type real dble cplx zplx
      { @(rname)LT( N, K, ALPHA, A, LDA, BETA, C, LDC ); }
@type chex zhex
      { @(rname)LC( N, K, ALPHA, A, LDA, BETA, C, LDC ); }
@type real dble cplx zplx chex zhex
@rout syr2k
      if( TRANS == AtlasNoTrans )
      { @(rname)LN( N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC ); }
      else
@type real dble cplx zplx
      { @(rname)LT( N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC ); }
@type chex zhex
      { @(rname)LC( N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC ); }
@type real dble cplx zplx chex zhex
@rout syrk syr2k
   }
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout syrkLN
@define rname @ATL_@(pre)ref@(syhe)rkLN@
@rout syrkLT
@type real dble cplx zplx
@define rname @ATL_@(pre)ref@(syhe)rkLT@
@type chex zhex
@define rname @ATL_@(pre)ref@(syhe)rkLC@
@type real dble cplx zplx chex zhex
@rout syrkUN
@define rname @ATL_@(pre)ref@(syhe)rkUN@
@rout syrkUT
@type real dble cplx zplx
@define rname @ATL_@(pre)ref@(syhe)rkUT@
@type chex zhex
@define rname @ATL_@(pre)ref@(syhe)rkUC@
@type real dble cplx zplx chex zhex
@rout syr2kLN
@define rname @ATL_@(pre)ref@(syhe)r2kLN@
@rout syr2kLT
@type real dble cplx zplx
@define rname @ATL_@(pre)ref@(syhe)r2kLT@
@type chex zhex
@define rname @ATL_@(pre)ref@(syhe)r2kLC@
@type real dble cplx zplx chex zhex
@rout syr2kUN
@define rname @ATL_@(pre)ref@(syhe)r2kUN@
@rout syr2kUT
@type real dble cplx zplx
@define rname @ATL_@(pre)ref@(syhe)r2kUT@
@type chex zhex
@define rname @ATL_@(pre)ref@(syhe)r2kUC@
@type real dble cplx zplx chex zhex
@rout syrkLN syrkLT syrkUN syrkUT syr2kLN syr2kLT syr2kUN syr2kUT
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  N,
   const int                  K,
@rout syrkLN syrkLT syrkUN syrkUT
@type real dble chex zhex
   @(cst_type_decl) ALPHA,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
@type real dble
   @(cst_type_decl) * A,
@type chex zhex cplx zplx
   @(cst_utyp_decl) * A,
@type real dble chex zhex cplx zplx
   const int                  LDA,
@rout syr2kLN syr2kLT syr2kUN syr2kUT
@type real dble
   @(cst_type_decl) ALPHA,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * ALPHA,
@type real dble chex zhex cplx zplx
@type real dble
   @(cst_type_decl) * A,
   const int                  LDA,
   @(cst_type_decl) * B,
   const int                  LDB,
@type cplx zplx chex zhex
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(cst_utyp_decl) * B,
   const int                  LDB,
@type real dble chex zhex cplx zplx
@rout syrkLN syrkLT syrkUN syrkUT syr2kLN syr2kLT syr2kUN syr2kUT
@type real dble chex zhex
   @(cst_type_decl) BETA,
@type cplx zplx
   @(cst_utyp_decl) * BETA,
@type real dble
   @(type_decl) * C, 
@type cplx zplx chex zhex
   @(utyp_decl) * C,
@type real dble chex zhex cplx zplx
   const int                  LDC
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout syrkLN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iail, iaj, iajl, icij, j, jal, jcj, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, iaj = 0, jcj = 0; j < N; j++, iaj += 1, jcj += LDC )
   {
      M@(pre)vscal( N-j, BETA, C+j+jcj, 1 );
      for( l = 0, iajl = iaj, jal = 0; l < K; l++, iajl += LDA, jal += LDA )
      {
         t0 = ALPHA * A[iajl];
         for( i = j, iail = j+jal, icij = j+jcj;
              i < N; i++, iail += 1,     icij += 1 )
         { C[icij] += t0 * A[iail]; }
      }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iail, iaj, iajl, icij, j, jal, jcj, l,
                              lda2 = ( LDA << 1 ), ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, iaj = 0, jcj  = 0; j < N; j++, iaj += 2, jcj += ldc2 )
   {
@type cplx zplx
      M@(pre)vscal( N-j, BETA, C+(j << 1)+jcj, 1 );
      for( l = 0, iajl = iaj, jal = 0; l < K; l++, iajl += lda2, jal += lda2 )
      {
         Mmul( ALPHA[0], ALPHA[1], A[iajl], A[iajl+1], t0_r, t0_i );
         for( i = j,      iail  = (j << 1)+jal, icij  = (j << 1)+jcj;
              i < N; i++, iail += 2,            icij += 2 )
         { Mmla( t0_r, t0_i, A[iail], A[iail+1], C[icij], C[icij+1] ); }
      }
@type chex zhex
      icij       = ( j << 1 ) + jcj;
      M@(upr)elscal( BETA, C[icij] ); C[icij+1] = ATL_@(upr)ZERO;
      M@(upr)vscal( ((N-j-1) << 1), BETA, C+icij+2, 1 );

      for( l = 0, iajl = iaj, jal = 0; l < K; l++, iajl += lda2, jal += lda2 )
      {
         Mset( ALPHA * A[iajl], -ALPHA * A[iajl+1], t0_r, t0_i );
         iail = ( j << 1 ) + jal; icij = ( j << 1 ) + jcj;
         Mset( C[icij] + t0_r * A[iail] - t0_i * A[iail+1],
               ATL_@(upr)ZERO, C[icij], C[icij+1] );
         iail += 2; icij += 2;
         for( i = j+1; i < N; i++, iail += 2, icij += 2 )
         { Mmla( t0_r, t0_i, A[iail], A[iail+1], C[icij], C[icij+1] ); }
      }
@type cplx zplx chex zhex
   }
@type real dble cplx zplx chex zhex
@rout syrkLT
@type real dble
   @(reg_type_decl) t0;
   int                        i, iali, ialj, icij, j, jai, jaj, jcj, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jcj = 0; j < N; j++, jaj += LDA, jcj += LDC )
   {
      for( i = j, jai = j*LDA, icij = j+jcj; i < N; i++, jai += LDA, icij += 1 )
      {
         t0 = ATL_@(upr)ZERO;
         for( l = 0, iali = jai, ialj = jaj; l < K; l++, iali += 1, ialj += 1 )
         { t0 += A[iali] * A[ialj]; }
         M@(pre)elscal( BETA, C[icij] ); C[icij] += ALPHA * t0;
      }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iali, ialj, icij, j, jai, jaj, jcj, l,
                              lda2 = ( LDA << 1 ), ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jcj = 0; j < N; j++, jaj += lda2, jcj += ldc2 )
   {
@type cplx zplx
      for( i = j,      jai  = j*lda2, icij  = (j << 1)+jcj;
           i < N; i++, jai += lda2,   icij += 2 )
      {
         Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
         for( l = 0, iali = jai, ialj = jaj; l < K; l++, iali += 2, ialj += 2 )
         { Mmla( A[iali], A[iali+1], A[ialj], A[ialj+1], t0_r, t0_i ); }
         M@(pre)elscal( BETA[0], BETA[1], C[icij], C[icij+1] );
         Mmla( ALPHA[0], ALPHA[1], t0_r, t0_i, C[icij], C[icij+1] );
      }
@type chex zhex
      jai   = j * lda2; icij  = ( j << 1 ) + jcj; t0_r = ATL_@(upr)ZERO;
 
      for( l = 0, iali = jai, ialj = jaj; l < K; l++, iali += 2, ialj += 2 )
      { t0_r += A[iali] * A[ialj] + A[iali+1] * A[ialj+1]; }
      M@(upr)elscal( BETA, C[icij] ); 
      Mset( C[icij] + ALPHA * t0_r, ATL_@(upr)ZERO, C[icij], C[icij+1] );
      icij += 2; jai += lda2;
 
      for( i = j+1; i < N; i++, jai += lda2, icij += 2 )
      {
         Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
         for( l = 0, iali = jai, ialj = jaj; l < K; l++, iali += 2, ialj += 2 )
         { Mmla( A[iali], -A[iali+1], A[ialj], A[ialj+1], t0_r, t0_i ); }
         M@(upr)elscal( BETA, C[icij  ] ); M@(upr)elscal( BETA, C[icij+1] );
         Mset( C[icij] + ALPHA * t0_r, C[icij+1] + ALPHA * t0_i,
               C[icij], C[icij+1] );
      }
@type cplx zplx chex zhex
   }
@type real dble cplx zplx chex zhex
@rout syrkUN
@type real dble
   @(reg_type_decl) t0;
   int                        i, iail, iaj, iajl, icij, j, jal, jcj, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, iaj = 0, jcj  = 0; j < N; j++, iaj += 1, jcj += LDC )
   {
      M@(pre)vscal( j+1, BETA, C+jcj, 1 );
      for( l = 0, iajl = iaj, jal  = 0; l < K; l++, iajl += LDA, jal += LDA )
      {
         t0 = ALPHA * A[iajl];
         for( i = 0, iail = jal, icij = jcj; i <= j; i++, iail += 1, icij += 1 )
         { C[icij] += t0 * A[iail]; }
      }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iail, iaj, iajl, icij, j, jal, jcj, l,
                              lda2 = ( LDA << 1 ), ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, iaj = 0, jcj  = 0; j < N; j++, iaj += 2, jcj += ldc2 )
   {
@type cplx zplx
      M@(pre)vscal( j+1, BETA, C+jcj, 1 );

      for( l = 0, iajl = iaj, jal = 0; l < K; l++, iajl += lda2, jal += lda2 )
      {
         Mmul( ALPHA[0], ALPHA[1], A[iajl], A[iajl+1], t0_r, t0_i );
         for( i = 0, iail = jal, icij = jcj; i <= j; i++, iail += 2, icij += 2 )
         { Mmla( t0_r, t0_i, A[iail], A[iail+1], C[icij], C[icij+1] ); }
      }
@type chex zhex
      M@(upr)vscal( (j << 1), BETA, C+jcj, 1 );
      icij       = ( j << 1 ) + jcj;
      M@(upr)elscal( BETA, C[icij] ); C[icij+1] = ATL_@(upr)ZERO;

      for( l = 0, iajl = iaj, jal = 0; l < K; l++, iajl += lda2, jal += lda2 )
      {
         Mset( ALPHA * A[iajl], -ALPHA * A[iajl+1], t0_r, t0_i );
         for( i = 0, iail = jal, icij = jcj; i < j; i++, iail += 2, icij += 2 )
         { Mmla( t0_r, t0_i, A[iail], A[iail+1], C[icij], C[icij+1] ); }
         Mset( C[icij] + t0_r * A[iail] - t0_i * A[iail+1], ATL_@(upr)ZERO,
               C[icij], C[icij+1] );
      }
@type cplx zplx chex zhex
   }
@type real dble cplx zplx chex zhex
@rout syrkUT
@type real dble
   @(reg_type_decl) t0;
   int                        i, iali, ialj, icij, j, jai, jaj, jcj, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jcj = 0; j < N; j++, jaj += LDA, jcj += LDC )
   {
      for( i = 0, jai = 0, icij = jcj; i <= j; i++, jai += LDA, icij += 1 )
      {
         t0 = ATL_@(upr)ZERO;
         for( l = 0, iali = jai, ialj = jaj; l < K; l++, iali += 1, ialj += 1 )
         { t0 += A[iali] * A[ialj]; }
         M@(pre)elscal( BETA, C[icij] ); C[icij] += ALPHA * t0;
      }
   }
@type cplx zplx chex zhex
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iali, ialj, icij, j, jai, jaj, jcj, l,
                              lda2 = ( LDA << 1 ), ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jcj  = 0; j < N; j++, jaj += lda2, jcj += ldc2 )
   {
@type cplx zplx
      for( i = 0, jai = 0, icij = jcj; i <= j; i++, jai += lda2, icij += 2 )
      {
         Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
         for( l = 0, iali = jai, ialj = jaj; l < K; l++, iali += 2, ialj += 2 )
         { Mmla( A[iali], A[iali+1], A[ialj], A[ialj+1], t0_r, t0_i ); }
         M@(pre)elscal( BETA[0], BETA[1], C[icij], C[icij+1] );
         Mmla( ALPHA[0], ALPHA[1], t0_r, t0_i, C[icij], C[icij+1] );
      }
@type chex zhex
      for( i = 0, jai = 0, icij = jcj; i < j; i++, jai += lda2, icij += 2 )
      {
         Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
         for( l = 0, iali = jai, ialj = jaj; l < K; l++, iali += 2, ialj += 2 )
         { Mmla( A[iali], -A[iali+1], A[ialj], A[ialj+1], t0_r, t0_i ); }
         M@(pre)elscal( BETA, ATL_@(upr)ZERO, C[icij], C[icij+1] );
         Mset( C[icij] + ALPHA * t0_r, C[icij+1] + ALPHA * t0_i,
               C[icij], C[icij+1] );
      }
 
      t0_r = ATL_@(upr)ZERO;
      for( l = 0, iali = jai, ialj = jaj; l < K; l++, iali += 2, ialj += 2 )
      { t0_r += A[iali] * A[ialj] + A[iali+1] * A[ialj+1]; }
      M@(upr)elscal( BETA, C[icij] );
      Mset( C[icij] + ALPHA * t0_r, ATL_@(upr)ZERO, C[icij], C[icij+1] );
@type cplx zplx chex zhex
   }
@type real dble cplx zplx chex zhex
@rout syr2kLN
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iail, iaj, iajl, ibil, ibj, ibjl, icij,
                              j, jal, jbl, jcj, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      iaj  = 0, ibj  = 0, jcj  = 0;
        j < N; j++, iaj += 1, ibj += 1, jcj += LDC )
   {
      M@(pre)vscal( N-j, BETA, C+j+jcj, 1 );
      for( l = 0,      iajl  = iaj, ibjl  = ibj, jal  = 0,   jbl  = 0;
           l < K; l++, iajl += LDA, ibjl += LDB, jal += LDA, jbl += LDB )
      {
         t0 = ALPHA * A[iajl]; t1 = ALPHA * B[ibjl];
         for( i = j,      iail  = j+jal, ibil  = j+jbl, icij  = j+jcj;
              i < N; i++, iail += 1,     ibil += 1,     icij += 1 )
         { C[icij] += t1 * A[iail] + t0 * B[ibil]; }
      }
   }
@type cplx zplx chex zhex
   @(utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iail, iaj, iajl, ibil, ibj, ibjl, icij,
                              j, jal, jbl, jcj, l, lda2 = ( LDA << 1 ),
                              ldb2 = ( LDB << 1 ), ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      iaj  = 0, ibj  = 0, jcj  = 0;
        j < N; j++, iaj += 2, ibj += 2, jcj += ldc2 )
   {
@type cplx zplx
      M@(pre)vscal( N-j, BETA, C+(j << 1)+jcj, 1 );

      for( l = 0,      iajl  = iaj,  ibjl  = ibj,  jal   = 0,    jbl  = 0;
           l < K; l++, iajl += lda2, ibjl += ldb2, jal  += lda2, jbl  += ldb2 )
      {
         Mmul( ALPHA[0], ALPHA[1], B[ibjl], B[ibjl+1], t0_r, t0_i );
         Mmul( ALPHA[0], ALPHA[1], A[iajl], A[iajl+1], t1_r, t1_i );
         for( i = j, iail  = (j << 1)+jal, ibil  = (j << 1)+jbl,
                     icij  = (j << 1)+jcj;
              i < N; i++, iail += 2, ibil += 2, icij += 2 )
         {
            Mmla( A[iail], A[iail+1], t0_r, t0_i, C[icij], C[icij+1] );
            Mmla( B[ibil], B[ibil+1], t1_r, t1_i, C[icij], C[icij+1] );
         }
      }
@type chex zhex
      icij       = ( j << 1 ) + jcj;
      M@(upr)elscal( BETA, C[icij] ); C[icij+1] = ATL_@(upr)ZERO;
      M@(upr)vscal( ((N-j-1) << 1), BETA, C+icij+2, 1 );

      for( l = 0,      iajl  = iaj,  ibjl  = ibj,  jal   = 0,    jbl  = 0;
           l < K; l++, iajl += lda2, ibjl += ldb2, jal  += lda2, jbl  += ldb2 )
      {
         Mmul( ALPHA[0],  ALPHA[1], B[ibjl], -B[ibjl+1], t0_r, t0_i );
         Mmul( ALPHA[0], -ALPHA[1], A[iajl], -A[iajl+1], t1_r, t1_i );
         iail = ( j << 1 ) + jal; ibil = ( j << 1 ) + jbl,
         icij = ( j << 1 ) + jcj;
         Mset( C[icij] + A[iail] * t0_r - A[iail+1] * t0_i +
                         B[ibil] * t1_r - B[ibil+1] * t1_i,
               ATL_@(upr)ZERO, C[icij], C[icij+1] );
         iail += 2; ibil += 2; icij += 2;
         for( i = j+1; i < N; i++, iail += 2, ibil += 2, icij += 2 )
         {
            Mmla( A[iail], A[iail+1], t0_r, t0_i, C[icij], C[icij+1] );
            Mmla( B[ibil], B[ibil+1], t1_r, t1_i, C[icij], C[icij+1] );
         }
      }
@type cplx zplx chex zhex
   }
@type real dble cplx zplx chex zhex
@rout syr2kLT
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iali, ialj, ibli, iblj, icij, j, jai, jaj,
                              jbi, jbj, jcj, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      jaj  = 0,   jbj  = 0,   jcj  = 0;
        j < N; j++, jaj += LDA, jbj += LDB, jcj += LDC )
   {
      for( i = j,      jai  = j*LDA, jbi  = j*LDB, icij  = j+jcj;
           i < N; i++, jai += LDA,   jbi += LDB,   icij += 1 )
      {
         t0 = ATL_@(upr)ZERO; t1 = ATL_@(upr)ZERO;
         for( l = 0,   iali  = jai, ialj  = jaj, ibli  = jbi, iblj  = jbj;
              l < K; l++, iali += 1,   ialj += 1,   ibli += 1,   iblj += 1 )
         { t0 += A[iali] * B[iblj]; t1 += B[ibli] * A[ialj]; }
         M@(pre)elscal( BETA, C[icij] ); C[icij] += ALPHA * t0 + ALPHA * t1;
      }
   } 
@type cplx zplx chex zhex
   @(utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iali, ialj, ibli, iblj, icij, j, jai, jaj,
                              jbi, jbj, jcj, l, lda2 = ( LDA << 1 ),
                              ldb2 = ( LDB << 1 ), ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      jaj  = 0,    jbj  = 0,    jcj  = 0;
        j < N; j++, jaj += lda2, jbj += ldb2, jcj += ldc2 )
   {
      for( i = j,      jai  = j*lda2, jbi  = j*ldb2, icij  = (j << 1)+jcj;
           i < N; i++, jai += lda2,   jbi += ldb2,   icij += 2 )
      {
         Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
         Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t1_r, t1_i );
         for( l = 0,   iali  = jai, ialj  = jaj, ibli  = jbi, iblj  = jbj;
              l < K; l++, iali += 2,   ialj += 2,   ibli += 2,   iblj += 2 )
         {
@type cplx zplx
            Mmla( A[iali], A[iali+1], B[iblj], B[iblj+1], t0_r, t0_i );
            Mmla( A[ialj], A[ialj+1], B[ibli], B[ibli+1], t1_r, t1_i );
@type chex zhex
            Mmla( A[iali], -A[iali+1], B[iblj], B[iblj+1], t0_r, t0_i );
            Mmla( B[ibli], -B[ibli+1], A[ialj], A[ialj+1], t1_r, t1_i );
@type cplx zplx chex zhex
         }
@type cplx zplx
         M@(pre)elscal( BETA[0], BETA[1], C[icij], C[icij+1] );
         Mmla( ALPHA[0], ALPHA[1], t0_r, t0_i, C[icij], C[icij+1] );
         Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, C[icij], C[icij+1] );
@type chex zhex
         if( i == j )
         {
            M@(upr)elscal( BETA, C[icij] );
            Mset( C[icij] + ALPHA[0] * t0_r - ALPHA[1] * t0_i +
                            ALPHA[0] * t1_r + ALPHA[1] * t1_i,
                  ATL_@(upr)ZERO, C[icij], C[icij+1] );
         }
         else
         {
            M@(upr)elscal( BETA, C[icij  ] ); M@(upr)elscal( BETA, C[icij+1] );
            Mmla( ALPHA[0],  ALPHA[1], t0_r, t0_i, C[icij], C[icij+1] );
            Mmla( ALPHA[0], -ALPHA[1], t1_r, t1_i, C[icij], C[icij+1] );
         }
@type cplx zplx chex zhex
      }
   }
@type real dble cplx zplx chex zhex
@rout syr2kUN
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iail, iaj, iajl, ibil, ibj, ibjl, icij,
                              j, jal, jbl, jcj, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      iaj  = 0, ibj  = 0, jcj  = 0;
        j < N; j++, iaj += 1, ibj += 1, jcj += LDC )
   {
      M@(pre)vscal( j+1, BETA, C+jcj, 1 );
      for( l = 0,      iajl  = iaj, ibjl  = ibj, jal  = 0,   jbl  = 0;
           l < K; l++, iajl += LDA, ibjl += LDB, jal += LDA, jbl += LDB )
      {
         t0 = ALPHA * A[iajl]; t1 = ALPHA * B[ibjl];
         for( i  = 0,      iail  = jal, ibil  = jbl, icij = jcj;
              i <= j; i++, iail += 1,   ibil += 1,   icij += 1 )
         { C[icij] += t1 * A[iail] + t0 * B[ibil]; }
      }
   }
@type cplx zplx chex zhex
   @(utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iail, iaj, iajl, ibil, ibj, ibjl, icij,
                              j, jal, jbl, jcj, l, lda2 = ( LDA << 1 ),
                              ldb2 = ( LDB << 1 ), ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      iaj  = 0, ibj  = 0, jcj  = 0;
        j < N; j++, iaj += 2, ibj += 2, jcj += ldc2 )
   {
@type cplx zplx
      M@(pre)vscal( j+1, BETA, C+jcj, 1 );

      for( l = 0,      iajl  = iaj,  ibjl  = ibj,  jal   = 0,    jbl   = 0;
           l < K; l++, iajl += lda2, ibjl += ldb2, jal  += lda2, jbl  += ldb2 )
      {
         Mmul( ALPHA[0], ALPHA[1], B[ibjl], B[ibjl+1], t0_r, t0_i );
         Mmul( ALPHA[0], ALPHA[1], A[iajl], A[iajl+1], t1_r, t1_i );
         for( i  = 0,      iail  = jal, ibil  = jbl, icij = jcj;
              i <= j; i++, iail += 2,   ibil += 2,   icij += 2 )
         {
            Mmla( A[iail], A[iail+1], t0_r, t0_i, C[icij], C[icij+1] );
            Mmla( B[ibil], B[ibil+1], t1_r, t1_i, C[icij], C[icij+1] );
         }
      }
@type chex zhex
      M@(upr)vscal( (j << 1), BETA, C+jcj, 1 );
      icij       = ( j << 1 ) + jcj;
      M@(upr)elscal( BETA, C[icij] ); C[icij+1] = ATL_@(upr)ZERO;

      for( l = 0,      iajl  = iaj,  ibjl  = ibj,  jal   = 0,    jbl   = 0;
           l < K; l++, iajl += lda2, ibjl += ldb2, jal  += lda2, jbl  += ldb2 )
      {
         Mmul( ALPHA[0],  ALPHA[1], B[ibjl], -B[ibjl+1], t0_r, t0_i );
         Mmul( ALPHA[0], -ALPHA[1], A[iajl], -A[iajl+1], t1_r, t1_i );
         for( i = 0,      iail  = jal, ibil  = jbl, icij = jcj;
              i < j; i++, iail += 2,   ibil += 2,   icij += 2 )
         {
            Mmla( A[iail], A[iail+1], t0_r, t0_i, C[icij], C[icij+1] );
            Mmla( B[ibil], B[ibil+1], t1_r, t1_i, C[icij], C[icij+1] );
         }
         Mset( C[icij] + A[iail] * t0_r - A[iail+1] * t0_i +
                         B[ibil] * t1_r - B[ibil+1] * t1_i,
               ATL_@(upr)ZERO, C[icij], C[icij+1] );
      }
@type cplx zplx chex zhex
   }
@type real dble cplx zplx chex zhex
@rout syr2kUT
@type real dble
   @(reg_type_decl) t0, t1;
   int                        i, iali, ialj, ibli, iblj, icij, j, jai, jaj,
                              jbi, jbj, jcj, l;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      jaj  = 0,   jbj  = 0,   jcj  = 0;
        j < N; j++, jaj += LDA, jbj += LDB, jcj += LDC )
   {
      for( i  = 0,      jai  = 0,   jbi  = 0,   icij  = jcj;
           i <= j; i++, jai += LDA, jbi += LDB, icij += 1 )
      {
         t0 = ATL_@(upr)ZERO; t1 = ATL_@(upr)ZERO;
         for( l = 0,      iali  = jai, ialj  = jaj, ibli  = jbi, iblj  = jbj;
              l < K; l++, iali += 1,   ialj += 1,   ibli += 1,   iblj += 1 )
         { t0 += A[iali] * B[iblj]; t1 += B[ibli] * A[ialj]; }
         M@(pre)elscal( BETA, C[icij] ); C[icij] += ALPHA * t0 + ALPHA * t1;
      }
   }
@type cplx zplx chex zhex
   @(utyp_decl) t0_i, t0_r, t1_i, t1_r;
   int                        i, iali, ialj, ibli, iblj, icij, j, jai, jaj,
                              jbi, jbj, jcj, l, lda2 = ( LDA << 1 ),
                              ldb2 = ( LDB << 1 ), ldc2 = ( LDC << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0,      jaj  = 0,    jbj  = 0,    jcj  = 0;
        j < N; j++, jaj += lda2, jbj += ldb2, jcj += ldc2 )
   {
      for( i  = 0,      jai  = 0,    jbi  = 0,    icij  = jcj;
           i <= j; i++, jai += lda2, jbi += ldb2, icij += 2 )
      {
         Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t0_r, t0_i );
         Mset( ATL_@(upr)ZERO, ATL_@(upr)ZERO, t1_r, t1_i );
         for( l = 0,      iali  = jai, ialj  = jaj, ibli  = jbi, iblj  = jbj;
              l < K; l++, iali += 2,   ialj += 2,   ibli += 2,   iblj += 2 )
         {
@type cplx zplx
            Mmla( A[iali], A[iali+1], B[iblj], B[iblj+1], t0_r, t0_i );
            Mmla( A[ialj], A[ialj+1], B[ibli], B[ibli+1], t1_r, t1_i );
@type chex zhex
            Mmla( A[iali], -A[iali+1], B[iblj], B[iblj+1], t0_r, t0_i );
            Mmla( B[ibli], -B[ibli+1], A[ialj], A[ialj+1], t1_r, t1_i );
@type cplx zplx chex zhex
         }
@type cplx zplx
         M@(pre)elscal( BETA[0], BETA[1], C[icij], C[icij+1] );
         Mmla( ALPHA[0], ALPHA[1], t0_r, t0_i, C[icij], C[icij+1] );
         Mmla( ALPHA[0], ALPHA[1], t1_r, t1_i, C[icij], C[icij+1] );
@type chex zhex
         if( i == j )
         {
            M@(upr)elscal( BETA, C[icij] );
            Mset( C[icij] + ALPHA[0] * t0_r - ALPHA[1] * t0_i +
                            ALPHA[0] * t1_r + ALPHA[1] * t1_i,
                  ATL_@(upr)ZERO, C[icij], C[icij+1] );
         }
         else
         {
            M@(pre)elscal( BETA, ATL_@(upr)ZERO, C[icij], C[icij+1] ); 
            Mmla( ALPHA[0],  ALPHA[1], t0_r, t0_i, C[icij], C[icij+1] );
            Mmla( ALPHA[0], -ALPHA[1], t1_r, t1_i, C[icij], C[icij+1] );
         }
@type cplx zplx chex zhex
      }
   }
@type real dble cplx zplx chex zhex
@rout syrkLN syrkLT syrkUN syrkUT syr2kLN syr2kLT syr2kUN syr2kUT
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmm trsm
@define rname @ATL_@(pre)ref@(@rout)@
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_SIDE      SIDE,
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG,
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(type_decl) * B,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
@type real dble cplx zplx
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( ( M == 0 ) || ( N == 0 ) ) return;

@type real dble
   if( ALPHA == ATL_@(upr)ZERO )
   { M@(pre)gescal( M, N, ALPHA, B, LDB ); return; }

   if( SIDE == AtlasLeft )
   {
      if( UPLO == AtlasUpper )
      {
         if( TRANS == AtlasNoTrans )
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)LUNN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)LUNU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
         else
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)LUTN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)LUTU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
      }
      else
      {
         if( TRANS == AtlasNoTrans )
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)LLNN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)LLNU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
         else
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)LLTN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)LLTU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
      }
   }
   else 
   {
      if( UPLO == AtlasUpper )
      {
         if( TRANS == AtlasNoTrans )
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)RUNN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)RUNU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
         else
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)RUTN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)RUTU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
      }
      else
      {
         if( TRANS == AtlasNoTrans )
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)RLNN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)RLNU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
         else
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)RLTN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)RLTU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
      }
   }
@type cplx zplx
   if( @(isz)( ALPHA[0], ALPHA[1] ) )
   { M@(pre)gescal( M, N, ALPHA, B, LDB ); return; }

   if( SIDE == AtlasLeft )
   {
      if( UPLO == AtlasUpper )
      {
         if(      TRANS == AtlasNoTrans )
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)LUNN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)LUNU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
         else if( TRANS == AtlasTrans   )
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)LUTN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)LUTU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
         else
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)LUCN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)LUCU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
      }
      else
      {
         if(      TRANS == AtlasNoTrans )
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)LLNN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)LLNU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
         else if( TRANS == AtlasTrans   )
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)LLTN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)LLTU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
         else
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)LLCN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)LLCU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
      }
   }
   else
   {
      if( UPLO == AtlasUpper )
      {
         if(      TRANS == AtlasNoTrans )
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)RUNN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)RUNU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
         else if( TRANS == AtlasTrans   )
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)RUTN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)RUTU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
         else
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)RUCN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)RUCU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
      }
      else
      {
         if(      TRANS == AtlasNoTrans )
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)RLNN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)RLNU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
         else if( TRANS == AtlasTrans   )
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)RLTN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)RLTU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
         else
         {
            if( DIAG == AtlasNonUnit )
            {      ATL_@(pre)ref@(@rout)RLCN( M, N, ALPHA, A, LDA, B, LDB ); }
            else { ATL_@(pre)ref@(@rout)RLCU( M, N, ALPHA, A, LDA, B, LDB ); }
         }
      }
   }
@type real dble cplx zplx
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmmLLNN trsmLLNN
@define rname @ATL_@(pre)ref@4l@(@rout)LLNN@
@rout trmmLLNU trsmLLNU
@define rname @ATL_@(pre)ref@4l@(@rout)LLNU@
@rout trmmLLNN trmmLLNU trsmLLNN trsmLLNU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(type_decl) * B,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
@type real dble cplx zplx
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout trmmLLNN trmmLLNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaik, ibij, ibkj, j, jak, jbj, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += LDB )
   {
      for( k = M-1,     jak  = (M-1)*LDA, ibkj  = M-1+jbj;
           k >= 0; k--, jak -= LDA,       ibkj -= 1 )
      {
         t0 = ALPHA * B[ibkj]; B[ibkj] = t0;
@rout trmmLLNN
         B[ibkj] *= A[k+jak];
@rout trmmLLNN trmmLLNU
         for( i = k+1,    iaik  = k+1+jak, ibij  = k+1+jbj;
              i < M; i++, iaik += 1,       ibij += 1 )
         { B[ibij] += t0 * A[iaik]; }
      }
   }
@type cplx zplx
   @(utyp_decl) t0_i, t0_r;
   int                        i, iaik, ibij, ibkj, j, jak, jbj, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj  = 0; j < N; j++, jbj += ldb2 )
   {
      for( k = M-1,     jak  = (M-1)*lda2, ibkj  = ((M-1)<<1)+jbj;
           k >= 0; k--, jak -= lda2,       ibkj -= 2 )
      {
         Mmul( ALPHA[0], ALPHA[1], B[ibkj], B[ibkj+1], t0_r, t0_i );
         Mset( t0_r, t0_i, B[ibkj], B[ibkj+1] );
@rout trmmLLNN
         i = ( k << 1 ) + jak; @(scl)( A[i], A[i+1], B[ibkj], B[ibkj+1] );
@rout trmmLLNN trmmLLNU
         for( i = k+1, iaik  = ((k+1)<<1)+jak, ibij = ((k+1)<<1)+jbj;
           i < M; i++, iaik += 2,              ibij += 2 )
         { Mmla( t0_r, t0_i, A[iaik], A[iaik+1], B[ibij], B[ibij+1] ); }
      }
   }
@type real dble cplx zplx
@rout trsmLLNN trsmLLNU
@type real dble
   int                        i, iaik, ibij, ibkj, j, jak, jbj, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += LDB )
   {
      for( i = 0, ibij= jbj; i < M; i++, ibij += 1 ) { B[ibij] *= ALPHA; }
      for( k = 0, jak  = 0, ibkj = jbj; k < M; k++, jak += LDA, ibkj += 1 )
      {
@rout trsmLLNN
         B[ibkj] /= A[k+jak];
@rout trsmLLNN trsmLLNU
         for( i = k+1,    iaik  = k+1+jak, ibij  = k+1+jbj;
              i < M; i++, iaik +=1,        ibij += 1 )
         { B[ibij] -= B[ibkj] * A[iaik]; }
      }
   }
@type cplx zplx
   int                        i, iaik, ibij, ibkj, j, jak, jbj, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj  = 0; j < N; j++, jbj += ldb2 )
   {
      for( i = 0, ibij = jbj; i < M; i++, ibij += 2 )
      { @(scl)( ALPHA[0], ALPHA[1], B[ibij], B[ibij+1] ); }
      for( k = 0, jak = 0, ibkj = jbj; k < M; k++, jak += lda2, ibkj += 2 )
      {
@rout trsmLLNN
         i = ( k << 1 ) + jak; @(div)( A[i], A[i+1], B[ibkj], B[ibkj+1] );
@rout trsmLLNN trsmLLNU
         for( i = k+1, iaik = ((k+1) << 1)+jak, ibij = ((k+1) << 1)+jbj;
              i < M; i++, iaik += 2, ibij += 2 )
         { Mmls( A[iaik], A[iaik+1], B[ibkj], B[ibkj+1], B[ibij], B[ibij+1] ); }
      }
   }
@type real dble cplx zplx
@rout trmmLLNN trmmLLNU trsmLLNN trsmLLNU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmmLLTN trsmLLTN
@define rname @ATL_@(pre)ref@4l@(@rout)LLTN@
@rout trmmLLTU trsmLLTU
@define rname @ATL_@(pre)ref@4l@(@rout)LLTU@
@rout trmmLLTN trmmLLTU trsmLLTN trsmLLTU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(type_decl) * B,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
@type real dble cplx zplx
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout trmmLLTN trmmLLTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaki, ibij, ibkj, j, jai, jbj, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj  = 0; j < N; j++, jbj += LDB )
   {
      for( i = 0, jai = 0, ibij  = jbj; i < M; i++, jai += LDA, ibij += 1 )
      {
         t0 = B[ibij];
@rout trmmLLTN
         t0 *= A[i+jai];
@rout trmmLLTN trmmLLTU
         for( k = i+1,    iaki  = i+1+jai, ibkj  = i+1+jbj;
              k < M; k++, iaki += 1,       ibkj += 1 )
         { t0 += A[iaki] * B[ibkj]; }
         B[ibij] = ALPHA * t0;
      }
   }
@type cplx zplx
   @(utyp_decl) t0_i, t0_r;
   int                        i, iaki, ibij, ibkj, j, jai, jbj, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += ldb2 )
   {
      for( i = 0, jai = 0, ibij = jbj; i < M; i++, jai += lda2, ibij += 2 )
      {
         Mset( B[ibij], B[ibij+1], t0_r, t0_i );
@rout trmmLLTN
         k = ( i << 1 ) + jai; @(scl)( A[k], A[k+1], t0_r, t0_i );
@rout trmmLLTN trmmLLTU
         for( k = i+1, iaki = ( (i+1) << 1 )+jai, ibkj = ( (i+1) << 1 )+jbj;
              k < M; k++, iaki += 2, ibkj += 2 )
         { Mmla( A[iaki], A[iaki+1], B[ibkj], B[ibkj+1], t0_r, t0_i ); }
         Mmul( ALPHA[0], ALPHA[1], t0_r, t0_i, B[ibij], B[ibij+1] );
      }
   }
@type real dble cplx zplx
@rout trsmLLTN trsmLLTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaki, ibij, ibkj, j, jai, jbj, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += LDB )
   {
      for( i = M-1,     jai  = (M-1)*LDA, ibij  = M-1+jbj;
           i >= 0; i--, jai -= LDA,       ibij -= 1 )
      {
         t0 = ALPHA * B[ibij];
         for( k = i+1,    iaki  = i+1+jai, ibkj  = i+1+jbj;
              k < M; k++, iaki += 1,       ibkj += 1 )
         { t0 -= A[iaki] * B[ibkj]; }
@rout trsmLLTN
         t0 /= A[i+jai];
@rout trsmLLTN trsmLLTU
         B[ibij] = t0;
      }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaki, ibij, ibkj, j, jai, jbj, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += ldb2 )
   {
      for( i = M-1,     jai  = (M-1)*lda2, ibij  = ((M-1) << 1)+jbj;
           i >= 0; i--, jai -= lda2,       ibij -= 2 )
      {
         Mmul( ALPHA[0], ALPHA[1], B[ibij], B[ibij+1], t0_r, t0_i );
         for( k = i+1, iaki  = ((i+1) << 1)+jai, ibkj  = ((i+1) << 1)+jbj;
              k < M; k++, iaki += 2, ibkj += 2 )
         { Mmls( A[iaki], A[iaki+1], B[ibkj], B[ibkj+1], t0_r, t0_i ); }
@rout trsmLLTN
         k = ( i << 1 ) + jai; @(div)( A[k], A[k+1], t0_r, t0_i );
@rout trsmLLTN trsmLLTU
         Mset( t0_r, t0_i, B[ibij], B[ibij+1] );
      }
   }
@type real dble cplx zplx
@rout trmmLLTN trmmLLTU trsmLLTN trsmLLTU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmmLLCN trsmLLCN
@define rname @ATL_@(pre)ref@4l@(@rout)LLCN@
@rout trmmLLCU trsmLLCU
@define rname @ATL_@(pre)ref@4l@(@rout)LLCU@
@rout trmmLLCN trmmLLCU trsmLLCN trsmLLCU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout trmmLLCN trmmLLCU
   @(utyp_decl) t0_i, t0_r;
   int                        i, iaki, ibij, ibkj, j, jai, jbj, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += ldb2 )
   {
      for( i = 0, jai = 0, ibij = jbj; i < M; i++, jai += lda2, ibij += 2 )
      {
         Mset( B[ibij], B[ibij+1], t0_r, t0_i );
@rout trmmLLCN
         k = ( i << 1 ) + jai; @(scl)( A[k], -A[k+1], t0_r, t0_i );
@rout trmmLLCN trmmLLCU
         for( k = i+1, iaki  = ((i+1)<<1)+jai, ibkj  = ((i+1)<<1)+jbj;
           k < M; k++, iaki += 2,              ibkj += 2 )
         { Mmla( A[iaki], -A[iaki+1], B[ibkj], B[ibkj+1], t0_r, t0_i ); }
         Mmul( ALPHA[0], ALPHA[1], t0_r, t0_i, B[ibij], B[ibij+1] );
      }
   }
@rout trsmLLCN trsmLLCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaki, ibij, ibkj, j, jai, jbj, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += ldb2 )
   {
      for( i = M-1,     jai  = (M-1)*lda2, ibij  = ((M-1) << 1)+jbj;
           i >= 0; i--, jai -= lda2,       ibij -= 2 )
      {
         Mmul( ALPHA[0], ALPHA[1], B[ibij], B[ibij+1], t0_r, t0_i );
         for( k = i+1, iaki = ((i+1) << 1)+jai, ibkj  = ((i+1) << 1)+jbj;
              k < M; k++, iaki += 2, ibkj += 2 )
         { Mmls( A[iaki], -A[iaki+1], B[ibkj], B[ibkj+1], t0_r, t0_i ); }
@rout trsmLLCN
         k = ( i << 1 ) + jai; @(div)( A[k], -A[k+1], t0_r, t0_i );
@rout trsmLLCN trsmLLCU
         Mset( t0_r, t0_i, B[ibij], B[ibij+1] );
      }
   } 
@rout trmmLLCN trmmLLCU trsmLLCN trsmLLCU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmmLUNN trsmLUNN
@define rname @ATL_@(pre)ref@4l@(@rout)LUNN@
@rout trmmLUNU trsmLUNU
@define rname @ATL_@(pre)ref@4l@(@rout)LUNU@
@rout trmmLUNN trmmLUNU trsmLUNN trsmLUNU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(type_decl) * B,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
@type real dble cplx zplx
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout trmmLUNN trmmLUNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaik, ibij, ibkj, j, jak, jbj, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += LDB )
   {
      for( k = 0, jak = 0, ibkj = jbj; k < M; k++, jak += LDA, ibkj += 1 )
      {
         t0 = ALPHA * B[ibkj];
         for( i = 0, iaik = jak, ibij = jbj; i < k; i++, iaik += 1, ibij += 1 )
         { B[ibij] += t0 * A[iaik]; }
@rout trmmLUNN
         t0 *= A[iaik];
@rout trmmLUNN trmmLUNU
         B[ibkj] = t0;
      }
   }
@type cplx zplx
   @(utyp_decl) t0_i, t0_r;
   int                        i, iaik, ibij, ibkj, j, jak, jbj, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += ldb2 )
   {
      for( k = 0, jak = 0, ibkj = jbj; k < M; k++, jak += lda2, ibkj += 2 )
      {
         Mmul( ALPHA[0], ALPHA[1], B[ibkj], B[ibkj+1], t0_r, t0_i );
         for( i = 0, iaik = jak, ibij = jbj; i < k; i++, iaik += 2, ibij += 2 )
         { Mmla( t0_r, t0_i, A[iaik], A[iaik+1], B[ibij], B[ibij+1] ); }
@rout trmmLUNN
         @(scl)( A[iaik], A[iaik+1], t0_r, t0_i );
@rout trmmLUNN trmmLUNU
         Mset( t0_r, t0_i, B[ibkj], B[ibkj+1] );
      }
   }
@type real dble cplx zplx
@rout trsmLUNN trsmLUNU
@type real dble
   int                        i, iaik, ibij, ibkj, j, jak, jbj, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += LDB )
   {
      for( i = 0, ibij = jbj; i < M; i++, ibij += 1 ) { B[ibij] *= ALPHA; }
      for( k = M-1,     jak  = (M-1)*LDA, ibkj  = M-1+jbj;
           k >= 0; k--, jak -= LDA,       ibkj -= 1 )
      {
@rout trsmLUNN
         B[ibkj] /= A[k+jak];
@rout trsmLUNN trsmLUNU
         for( i = 0,      iaik  = jak, ibij  = jbj;
              i < k; i++, iaik += 1,   ibij += 1 )
         { B[ibij] -= B[ibkj] * A[iaik]; }
      }
   }
@type cplx zplx
   int                        i, iaik, ibij, ibkj, j, jak, jbj, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += ldb2 )
   {
      for( i = 0, ibij = jbj; i < M; i++, ibij += 2 )
      { @(scl)( ALPHA[0], ALPHA[1], B[ibij], B[ibij+1] ); }
      for( k = M-1,     jak  = (M-1)*lda2, ibkj  = ((M-1) << 1)+jbj;
           k >= 0; k--, jak -= lda2,       ibkj -= 2 )
      {
@rout trsmLUNN
         i = ( k << 1 ) + jak; @(div)( A[i], A[i+1], B[ibkj], B[ibkj+1] );
@rout trsmLUNN trsmLUNU
         for( i = 0,      iaik  = jak, ibij  = jbj;
              i < k; i++, iaik += 2,   ibij += 2 )
         { Mmls( A[iaik], A[iaik+1], B[ibkj], B[ibkj+1], B[ibij], B[ibij+1] ); }
      }
   }
@type real dble cplx zplx
@rout trmmLUNN trmmLUNU trsmLUNN trsmLUNU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmmLUTN trsmLUTN
@define rname @ATL_@(pre)ref@4l@(@rout)LUTN@
@rout trmmLUTU trsmLUTU
@define rname @ATL_@(pre)ref@4l@(@rout)LUTU@
@rout trmmLUTN trmmLUTU trsmLUTN trsmLUTU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(type_decl) * B,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
@type real dble cplx zplx
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout trmmLUTN trmmLUTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaki, ibij, ibkj, j, jai, jbj, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += LDB )
   {
      for( i = M-1,     jai  = (M-1)*LDA, ibij  = M-1+jbj;
           i >= 0; i--, jai -= LDA,       ibij -= 1 )
      {
         t0 = B[ibij];
@rout trmmLUTN
         t0 *= A[i+jai];
@rout trmmLUTN trmmLUTU
         for( k = 0, iaki = jai, ibkj = jbj; k < i; k++, iaki += 1, ibkj += 1 )
         { t0 += A[iaki] * B[ibkj]; }
         B[ibij] = ALPHA * t0;
      }
   }
@type cplx zplx
   @(utyp_decl) t0_i, t0_r;
   int                        i, iaki, ibij, ibkj, j, jai, jbj, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += ldb2 )
   {
      for( i = M-1,     jai  = (M-1)*lda2, ibij  = ((M-1)<<1)+jbj;
           i >= 0; i--, jai -= lda2,       ibij -= 2 )
      {
         Mset( B[ibij], B[ibij+1], t0_r, t0_i );
@rout trmmLUTN
         k = ( i << 1 ) + jai; @(scl)( A[k], A[k+1], t0_r, t0_i );
@rout trmmLUTN trmmLUTU
         for( k = 0, iaki = jai, ibkj = jbj; k < i; k++, iaki += 2, ibkj += 2 )
         { Mmla( A[iaki], A[iaki+1], B[ibkj], B[ibkj+1], t0_r, t0_i ); }
         Mmul( ALPHA[0], ALPHA[1], t0_r, t0_i, B[ibij], B[ibij+1] );
      }
   }
@type real dble cplx zplx
@rout trsmLUTN trsmLUTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iaki, ibij, ibkj, j, jai, jbj, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj  = 0; j < N; j++, jbj += LDB )
   {
      for( i = 0, jai  = 0, ibij = jbj; i < M; i++, jai += LDA, ibij += 1 )
      {
         t0 = ALPHA * B[ibij];
         for( k = 0, iaki = jai, ibkj = jbj; k < i; k++, iaki += 1, ibkj += 1 )
         { t0 -= A[iaki] * B[ibkj]; }
@rout trsmLUTN
         t0 /= A[i+jai];
@rout trsmLUTN trsmLUTU
         B[ibij] = t0;
      }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaki, ibij, ibkj, j, jai, jbj, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += ldb2 )
   {
      for( i = 0, jai = 0, ibij  = jbj; i < M; i++, jai += lda2, ibij += 2 )
      {
         Mmul( ALPHA[0], ALPHA[1], B[ibij], B[ibij+1], t0_r, t0_i );
         for( k = 0, iaki = jai, ibkj = jbj; k < i; k++, iaki += 2, ibkj += 2 )
         { Mmls( A[iaki], A[iaki+1], B[ibkj], B[ibkj+1], t0_r, t0_i ); }
@rout trsmLUTN
         k = ( i << 1 ) + jai; @(div)( A[k], A[k+1], t0_r, t0_i );
@rout trsmLUTN trsmLUTU
         Mset( t0_r, t0_i, B[ibij], B[ibij+1] );
      }
   }
@type real dble cplx zplx
@rout trmmLUTN trmmLUTU trsmLUTN trsmLUTU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmmLUCN trsmLUCN
@define rname @ATL_@(pre)ref@4l@(@rout)LUCN@
@rout trmmLUCU trsmLUCU
@define rname @ATL_@(pre)ref@4l@(@rout)LUCU@
@rout trmmLUCN trmmLUCU trsmLUCN trsmLUCU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout trmmLUCN trmmLUCU
   @(utyp_decl) t0_i, t0_r;
   int                        i, iaki, ibij, ibkj, j, jai, jbj, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj = 0; j < N; j++, jbj += ldb2 )
   {
      for( i = M-1,     jai  = (M-1)*lda2, ibij  = ((M-1)<<1)+jbj;
           i >= 0; i--, jai -= lda2,       ibij -= 2 )
      {
         Mset( B[ibij], B[ibij+1], t0_r, t0_i );
@rout trmmLUCN
         k = ( i << 1 ) + jai; @(scl)( A[k], -A[k+1], t0_r, t0_i );
@rout trmmLUCN trmmLUCU
         for( k = 0, iaki = jai, ibkj = jbj; k < i; k++, iaki += 2, ibkj += 2 )
         { Mmla( A[iaki], -A[iaki+1], B[ibkj], B[ibkj+1], t0_r, t0_i ); }
         Mmul( ALPHA[0], ALPHA[1], t0_r, t0_i, B[ibij], B[ibij+1] );
      }
   }
@rout trsmLUCN trsmLUCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iaki, ibij, ibkj, j, jai, jbj, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jbj  = 0; j < N; j++, jbj += ldb2 )
   {
      for( i = 0, jai = 0, ibij = jbj; i < M; i++, jai += lda2, ibij += 2 )
      {
         Mmul( ALPHA[0], ALPHA[1], B[ibij], B[ibij+1], t0_r, t0_i );
         for( k = 0, iaki = jai, ibkj = jbj; k < i; k++, iaki += 2, ibkj += 2 )
         { Mmls( A[iaki], -A[iaki+1], B[ibkj], B[ibkj+1], t0_r, t0_i ); }
@rout trsmLUCN
         k = ( i << 1 ) + jai; @(div)( A[k], -A[k+1], t0_r, t0_i );
@rout trsmLUCN trsmLUCU
         Mset( t0_r, t0_i, B[ibij], B[ibij+1] );
      }
   }
@rout trmmLUCN trmmLUCU trsmLUCN trsmLUCU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmmRLNN trsmRLNN
@define rname @ATL_@(pre)ref@4l@(@rout)RLNN@
@rout trmmRLNU trsmRLNU
@define rname @ATL_@(pre)ref@4l@(@rout)RLNU@
@rout trmmRLNN trmmRLNU trsmRLNN trsmRLNU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(type_decl) * B,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
@type real dble cplx zplx
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout trmmRLNN trmmRLNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iakj, ibij, ibik, j, jaj, jbj, jbk, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jbj = 0; j < N; j++, jaj += LDA, jbj += LDB )
   {
      t0 = ALPHA;
@rout trmmRLNN
      t0 *= A[j+jaj];
@rout trmmRLNN trmmRLNU
      for( i = 0, ibij = jbj; i < M; i++, ibij += 1 ) { B[ibij] *= t0; }
      for( k = j+1,    iakj  = j+1+jaj, jbk  = (j+1)*LDB;
           k < N; k++, iakj += 1,       jbk += LDB )
      {
         t0 = ALPHA * A[iakj];
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 1, ibik += 1 )
         { B[ibij] += t0 * B[ibik]; }
      }
   }
@type cplx zplx
   @(utyp_decl) t0_i, t0_r;
   int                        i, iakj, ibij, ibik, j, jaj, jbj, jbk, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj  = 0, jbj  = 0; j < N; j++, jaj += lda2, jbj += ldb2 )
   {
      Mset( ALPHA[0], ALPHA[1], t0_r, t0_i );
@rout trmmRLNN
      i = ( j << 1 ) + jaj; @(scl)( A[i], A[i+1], t0_r, t0_i );
@rout trmmRLNN trmmRLNU
      for( i = 0,      ibij  = jbj; i < M; i++, ibij += 2 )
      { @(scl)( t0_r, t0_i, B[ibij], B[ibij+1] ); }
      for( k = j+1,    iakj  = ((j+1)<<1)+jaj, jbk  = (j+1)*ldb2;
           k < N; k++, iakj += 2,              jbk += ldb2 )
      {
         Mmul( ALPHA[0], ALPHA[1], A[iakj], A[iakj+1], t0_r, t0_i );
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 2, ibik += 2 )
         { Mmla( t0_r, t0_i, B[ibik], B[ibik+1], B[ibij], B[ibij+1] ); }
      }
   }
@type real dble cplx zplx
@rout trsmRLNN trsmRLNU
@type real dble
   int                        i, iakj, ibij, ibik, j, jaj, jbj, jbk, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,      jaj  = (N-1)*LDA, jbj  = (N-1)*LDB;
        j >= 0;  j--, jaj -= LDA,       jbj -= LDB )
   {
      for( i = 0, ibij = jbj; i < M; i++, ibij += 1 ) { B[ibij] *= ALPHA; }
      for( k = j+1,    iakj  = j+1+jaj, jbk  = (j+1)*LDB;
           k < N; k++, iakj += 1,       jbk += LDB )
      {
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 1, ibik += 1 )
         { B[ibij] -= A[iakj] * B[ibik]; }
      }
@rout trsmRLNN
      for( i = 0, ibij = jbj; i < M; i++, ibij += 1 ) { B[ibij] /= A[j+jaj]; }
@rout trsmRLNN trsmRLNU
   }
@type cplx zplx
   int                        i, iakj, ibij, ibik, j, jaj, jbj, jbk, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,      jaj  = (N-1)*lda2, jbj  = (N-1)*ldb2;
        j >= 0;  j--, jaj -= lda2,       jbj -= ldb2 )
   {
      for( i = 0, ibij  = jbj; i < M; i++, ibij += 2 )
      { @(scl)( ALPHA[0], ALPHA[1], B[ibij], B[ibij+1] ); }
      for( k = j+1,    iakj  = ((j+1) << 1)+jaj, jbk  = (j+1)*ldb2;
           k < N; k++, iakj += 2,                jbk += ldb2 )
      {
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 2, ibik += 2 )
         { Mmls( A[iakj], A[iakj+1], B[ibik], B[ibik+1], B[ibij], B[ibij+1] ); }
      }
@rout trsmRLNN
      for( i = 0, ibij = jbj; i < M; i++, ibij += 2 )
      { k = ( j << 1 ) + jaj; @(div)( A[k], A[k+1], B[ibij], B[ibij+1] ); }
@rout trsmRLNN trsmRLNU
   }
@type real dble cplx zplx
@rout trmmRLNN trmmRLNU trsmRLNN trsmRLNU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmmRLTN trsmRLTN
@define rname @ATL_@(pre)ref@4l@(@rout)RLTN@
@rout trmmRLTU trsmRLTU
@define rname @ATL_@(pre)ref@4l@(@rout)RLTU@
@rout trmmRLTN trmmRLTU trsmRLTN trsmRLTU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(type_decl) * B,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
@type real dble cplx zplx
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout trmmRLTN trmmRLTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iajk, ibij, ibik, j, jak, jbj, jbk, k;
@extract @(EXECUTABLE_STATEMENT)
   for( k = N-1,     jak  = (N-1)*LDA, jbk  = (N-1)*LDB;
        k >= 0; k--, jak -= LDA,       jbk -= LDB )
   {
      for( j = k+1,    iajk  = k+1+jak, jbj  = (k+1)*LDB;
           j < N; j++, iajk += 1,       jbj += LDB )
      {
         t0 = ALPHA * A[iajk];
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 1, ibik += 1 )
         { B[ibij] += t0 * B[ibik]; }
      }
      t0 = ALPHA;
@rout trmmRLTN
      t0 *= A[k+jak];
@rout trmmRLTN trmmRLTU
      for( i = 0, ibik = jbk; i < M; i++, ibik += 1 )
      { B[ibik] = t0 * B[ibik]; }
   }
@type cplx zplx
   @(utyp_decl) t0_i, t0_r;
   int                        i, iajk, ibij, ibik, j, jak, jbj, jbk, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( k = N-1,     jak  = (N-1)*lda2, jbk  = (N-1)*ldb2;
        k >= 0; k--, jak -= lda2,       jbk -= ldb2 )
   {
      for( j = k+1,    iajk  = ( (k+1) << 1 )+jak, jbj  = (k+1)*ldb2;
           j < N; j++, iajk += 2,                  jbj += ldb2 )
      {
         Mmul( ALPHA[0], ALPHA[1], A[iajk], A[iajk+1], t0_r, t0_i );
         for( i = 0,      ibij  = jbj, ibik  = jbk;
              i < M; i++, ibij += 2,   ibik += 2 )
         { Mmla( t0_r, t0_i, B[ibik], B[ibik+1], B[ibij], B[ibij+1] ); }
      }
      Mset( ALPHA[0], ALPHA[1], t0_r, t0_i );
@rout trmmRLTN
      i = ( k << 1 ) + jak; @(scl)( A[i], A[i+1], t0_r, t0_i );
@rout trmmRLTN trmmRLTU
      for( i = 0, ibik = jbk; i < M; i++, ibik += 2 )
      { @(scl)( t0_r, t0_i, B[ibik], B[ibik+1] ); }
   }
@type real dble cplx zplx
@rout trsmRLTN trsmRLTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iajk, ibij, ibik, j, jak, jbj, jbk, k;
@extract @(EXECUTABLE_STATEMENT)
   for( k = 0, jak = 0, jbk = 0; k < N; k++, jak += LDA, jbk += LDB )
   {
@rout trsmRLTN
      for( i = 0, ibik = jbk; i < M; i++, ibik += 1 ) { B[ibik] /= A[k+jak]; }
@rout trsmRLTN trsmRLTU
      for( j = k+1,    iajk  = (k+1)+jak, jbj  = (k+1)*LDB;
           j < N; j++, iajk += 1,         jbj += LDB )
      {
         t0 = A[iajk];
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 1, ibik += 1 )
         { B[ibij] -= t0 * B[ibik]; }
      }
      for( i = 0, ibik = jbk; i < M; i++, ibik += 1 ) { B[ibik] *= ALPHA; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iajk, ibij, ibik, j, jak, jbj, jbk, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( k = 0, jak = 0, jbk = 0; k < N; k++, jak += lda2, jbk += ldb2 )
   {
@rout trsmRLTN
      for( i = 0, ibik = jbk; i < M; i++, ibik += 2 )
      { j = ( k << 1 ) + jak; @(div)( A[j], A[j+1], B[ibik], B[ibik+1] ); }
@rout trsmRLTN trsmRLTU
      for( j = k+1,    iajk  = ((k+1) << 1)+jak, jbj  = (k+1)*ldb2;
           j < N; j++, iajk += 2,                jbj += ldb2 )
      {
         Mset( A[iajk], A[iajk+1], t0_r, t0_i );
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 2, ibik += 2 )
         { Mmls( t0_r, t0_i, B[ibik], B[ibik+1], B[ibij], B[ibij+1] ); }
      }
      for( i = 0, ibik = jbk; i < M; i++, ibik += 2 )
      { @(scl)( ALPHA[0], ALPHA[1], B[ibik], B[ibik+1] ); }
   }
@type real dble cplx zplx
@rout trmmRLTN trmmRLTU trsmRLTN trsmRLTU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmmRLCN trsmRLCN
@define rname @ATL_@(pre)ref@4l@(@rout)RLCN@
@rout trmmRLCU trsmRLCU
@define rname @ATL_@(pre)ref@4l@(@rout)RLCU@
@rout trmmRLCN trmmRLCU trsmRLCN trsmRLCU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout trmmRLCN trmmRLCU
   @(utyp_decl) t0_i, t0_r;
   int                        i, iajk, ibij, ibik, j, jak, jbj, jbk, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( k = N-1,     jak  = (N-1)*lda2, jbk  = (N-1)*ldb2;
        k >= 0; k--, jak -= lda2,       jbk -= ldb2 )
   {
      for( j = k+1,    iajk  = ((k+1)<<1)+jak, jbj  = (k+1)*ldb2;
           j < N; j++, iajk += 2,              jbj += ldb2 )
      {
         Mmul( ALPHA[0], ALPHA[1], A[iajk], -A[iajk+1], t0_r, t0_i );
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 2, ibik += 2 )
         { Mmla( t0_r, t0_i, B[ibik], B[ibik+1], B[ibij], B[ibij+1] ); }
      }
      Mset( ALPHA[0], ALPHA[1], t0_r, t0_i );
@rout trmmRLCN
      i = ( k << 1 ) + jak; @(scl)( A[i], -A[i+1], t0_r, t0_i );
@rout trmmRLCN trmmRLCU
      for( i = 0, ibik = jbk; i < M; i++, ibik += 2 )
      { @(scl)( t0_r, t0_i, B[ibik], B[ibik+1] ); }
   }
@rout trsmRLCN trsmRLCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iajk, ibij, ibik, j, jak, jbj, jbk, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( k = 0, jak = 0, jbk = 0; k < N; k++, jak += lda2, jbk += ldb2 )
   {
@rout trsmRLCN
      for( i = 0, ibik = jbk; i < M; i++, ibik += 2 )
      { j = ( k << 1 ) + jak; @(div)( A[j], -A[j+1], B[ibik], B[ibik+1] ); }
@rout trsmRLCN trsmRLCU
      for( j = k+1,    iajk  = ((k+1) << 1)+jak, jbj  = (k+1)*ldb2;
           j < N; j++, iajk += 2,                jbj += ldb2 )
      {
         Mset( A[iajk], -A[iajk+1], t0_r, t0_i );
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 2, ibik += 2 )
         { Mmls( t0_r, t0_i, B[ibik], B[ibik+1], B[ibij], B[ibij+1] ); }
      }
      for( i = 0,  ibik = jbk; i < M; i++, ibik += 2 )
      { @(scl)( ALPHA[0], ALPHA[1], B[ibik], B[ibik+1] ); }
   }
@rout trmmRLCN trmmRLCU trsmRLCN trsmRLCU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmmRUNN trsmRUNN
@define rname @ATL_@(pre)ref@4l@(@rout)RUNN@
@rout trmmRUNU trsmRUNU
@define rname @ATL_@(pre)ref@4l@(@rout)RUNU@
@rout trmmRUNN trmmRUNU trsmRUNN trsmRUNU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(type_decl) * B,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
@type real dble cplx zplx
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout trmmRUNN trmmRUNU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iakj, ibij, ibik, j, jaj, jbj, jbk, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*LDA, jbj  = (N-1)*LDB;
        j >= 0; j--, jaj -= LDA,       jbj -= LDB )
   {
      t0 = ALPHA;
@rout trmmRUNN
      t0 *= A[j+jaj];
@rout trmmRUNN trmmRUNU
      for( i = 0, ibij = jbj; i < M; i++, ibij += 1 ) { B[ibij] *= t0; }
      for( k = 0, iakj = jaj, jbk = 0; k < j; k++, iakj += 1, jbk += LDB )
      {
         t0 = ALPHA * A[iakj];
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 1, ibik += 1 )
         { B[ibij] += t0 * B[ibik]; }
      }
   }
@type cplx zplx
   @(utyp_decl) t0_i, t0_r;
   int                        i, iakj, ibij, ibik, j, jaj, jbj, jbk, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = N-1,     jaj  = (N-1)*lda2, jbj  = (N-1)*ldb2;
        j >= 0; j--, jaj -= lda2,       jbj -= ldb2 )
   {
      Mset( ALPHA[0], ALPHA[1], t0_r, t0_i );
@rout trmmRUNN
      i = ( j << 1 ) + jaj; @(scl)( A[i], A[i+1], t0_r, t0_i );
@rout trmmRUNN trmmRUNU
      for( i = 0, ibij = jbj; i < M; i++, ibij += 2 )
      { @(scl)( t0_r, t0_i, B[ibij], B[ibij+1] ); }
      for( k = 0, iakj = jaj, jbk = 0; k < j; k++, iakj += 2, jbk += ldb2 )
      {
         Mmul( ALPHA[0], ALPHA[1], A[iakj], A[iakj+1], t0_r, t0_i );
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 2, ibik += 2 )
         { Mmla( t0_r, t0_i, B[ibik], B[ibik+1], B[ibij], B[ibij+1] ); }
      }
   }
@type real dble cplx zplx
@rout trsmRUNN trsmRUNU
@type real dble
   int                        i, iakj, ibij, ibik, j, jaj, jbj, jbk, k;
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jbj = 0; j < N; j++, jaj += LDA, jbj += LDB )
   {
      for( i = 0, ibij = jbj; i < M; i++, ibij += 1 ) { B[ibij] *= ALPHA; }
      for( k = 0, iakj = jaj, jbk = 0; k < j; k++, iakj += 1, jbk += LDB )
      {
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 1, ibik += 1 )
         { B[ibij] -= A[iakj] * B[ibik]; }
      }
@rout trsmRUNN
      for( i = 0, ibij = jbj; i < M; i++, ibij += 1 ) { B[ibij] /= A[j+jaj]; }
@rout trsmRUNN trsmRUNU
   }
@type cplx zplx
   int                        i, iakj, ibij, ibik, j, jaj, jbj, jbk, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( j = 0, jaj = 0, jbj = 0; j < N; j++, jaj += lda2, jbj += ldb2 )
   {
      for( i = 0, ibij = jbj; i < M; i++, ibij += 2 )
      { @(scl)( ALPHA[0], ALPHA[1], B[ibij], B[ibij+1] ); }
      for( k = 0, iakj = jaj, jbk = 0; k < j; k++, iakj += 2, jbk += ldb2 )
      {
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 2, ibik += 2 )
         { Mmls( A[iakj], A[iakj+1], B[ibik], B[ibik+1], B[ibij], B[ibij+1] ); }
      }
@rout trsmRUNN
      for( i = 0, ibij = jbj; i < M; i++, ibij += 2 )
      { k = ( j << 1 ) + jaj; @(div)( A[k], A[k+1], B[ibij], B[ibij+1] ); }
@rout trsmRUNN trsmRUNU
   }
@type real dble cplx zplx
@rout trmmRUNN trmmRUNU trsmRUNN trsmRUNU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmmRUTN trsmRUTN
@define rname @ATL_@(pre)ref@4l@(@rout)RUTN@
@rout trmmRUTU trsmRUTU
@define rname @ATL_@(pre)ref@4l@(@rout)RUTU@
@rout trmmRUTN trmmRUTU trsmRUTN trsmRUTU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
@type real dble
   @(cst_type_decl) ALPHA,
   @(cst_type_decl) * A,
   const int                  LDA,
   @(type_decl) * B,
@type cplx zplx
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
@type real dble cplx zplx
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout trmmRUTN trmmRUTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iajk, ibij, ibik, j, jak, jbj, jbk, k;
@extract @(EXECUTABLE_STATEMENT)
   for( k = 0, jak = 0, jbk = 0; k < N; k++, jak += LDA, jbk += LDB )
   {
      for( j = 0, iajk = jak, jbj = 0; j < k; j++, iajk += 1, jbj += LDB )
      {
         t0 = ALPHA * A[iajk];
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 1, ibik += 1 )
         { B[ibij] += t0 * B[ibik]; }
      }
      t0 = ALPHA;
@rout trmmRUTN
      t0 *= A[iajk];
@rout trmmRUTN trmmRUTU
      for( i = 0, ibik = jbk; i < M; i++, ibik += 1 )
      { B[ibik] = t0 * B[ibik]; }
   } 
@type cplx zplx
   @(utyp_decl) t0_i, t0_r;
   int                        i, iajk, ibij, ibik, j, jak, jbj, jbk, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( k = 0, jak = 0, jbk = 0; k < N; k++, jak += lda2, jbk += ldb2 )
   {
      for( j = 0, iajk = jak, jbj = 0; j < k; j++, iajk += 2, jbj += ldb2 )
      {
         Mmul( ALPHA[0], ALPHA[1], A[iajk], A[iajk+1], t0_r, t0_i );
         for( i = 0,      ibij  = jbj, ibik  = jbk;
              i < M; i++, ibij += 2,   ibik += 2 )
         { Mmla( t0_r, t0_i, B[ibik], B[ibik+1], B[ibij], B[ibij+1] ); }
      }
      Mset( ALPHA[0], ALPHA[1], t0_r, t0_i );
@rout trmmRUTN
      i = ( k << 1 ) + jak; @(scl)( A[i], A[i+1], t0_r, t0_i );
@rout trmmRUTN trmmRUTU
      for( i = 0, ibik = jbk; i < M; i++, ibik += 2 )
      { @(scl)( t0_r, t0_i, B[ibik], B[ibik+1] ); }
   }
@type real dble cplx zplx
@rout trsmRUTN trsmRUTU
@type real dble
   @(reg_type_decl) t0;
   int                        i, iajk, ibij, ibik, j, jak, jbj, jbk, k;
@extract @(EXECUTABLE_STATEMENT)
   for( k = N-1,     jak  = (N-1)*LDA, jbk  = (N-1)*LDB;
        k >= 0; k--, jak -= LDA,       jbk -= LDB )
   {
@rout trsmRUTN
      for( i = 0, ibik = jbk; i < M; i++, ibik += 1 ) { B[ibik] /= A[k+jak]; }
@rout trsmRUTN trsmRUTU
      for( j = 0, iajk = jak, jbj = 0; j < k; j++, iajk += 1, jbj += LDB )
      {
         t0 = A[iajk];
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 1, ibik += 1 )
         { B[ibij] -= t0 * B[ibik]; }
      }
      for( i = 0, ibik = jbk; i < M; i++, ibik += 1 ) { B[ibik] *= ALPHA; }
   }
@type cplx zplx
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iajk, ibij, ibik, j, jak, jbj, jbk, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( k = N-1,     jak  = (N-1)*lda2, jbk  = (N-1)*ldb2;
        k >= 0; k--, jak -= lda2,       jbk -= ldb2 )
   {
@rout trsmRUTN
      for( i = 0, ibik = jbk; i < M; i++, ibik += 2 )
      { j = ( k << 1 ) + jak; @(div)( A[j], A[j+1], B[ibik], B[ibik+1] ); }
@rout trsmRUTN trsmRUTU
      for( j = 0, iajk = jak, jbj = 0; j < k; j++, iajk += 2, jbj += ldb2 )
      {
         Mset( A[iajk], A[iajk+1], t0_r, t0_i );
         for( i = 0, ibij = jbj, ibik = jbk; i < M; i++, ibij += 2, ibik += 2 )
         { Mmls( t0_r, t0_i, B[ibik], B[ibik+1], B[ibij], B[ibij+1] ); }
      }
      for( i = 0, ibik = jbk; i < M; i++, ibik += 2 )
      { @(scl)( ALPHA[0], ALPHA[1], B[ibik], B[ibik+1] ); }
   }
@type real dble cplx zplx
@rout trmmRUTN trmmRUTU trsmRUTN trsmRUTU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout trmmRUCN trsmRUCN
@define rname @ATL_@(pre)ref@4l@(@rout)RUCN@
@rout trmmRUCU trsmRUCU
@define rname @ATL_@(pre)ref@4l@(@rout)RUCU@
@rout trmmRUCN trmmRUCU trsmRUCN trsmRUCU
@extract @(VER_ATLAS_SRC)
@extract @(RF3_INCLUDE)
 
void @(rname)
(
   const int                  M,
   const int                  N,
   @(cst_utyp_decl) * ALPHA,
   @(cst_utyp_decl) * A,
   const int                  LDA,
   @(utyp_decl) * B,
   const int                  LDB
)
{
@extract @(ATLAS_REF_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout trmmRUCN trmmRUCU
   @(utyp_decl) t0_i, t0_r;
   int                        i, iajk, ibij, ibik, j, jak, jbj, jbk, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( k = 0, jak = 0, jbk = 0; k < N; k++, jak += lda2, jbk += ldb2 )
   {
      for( j = 0, iajk  = jak, jbj  = 0; j < k; j++, iajk += 2,   jbj += ldb2 )
      {
         Mmul( ALPHA[0], ALPHA[1], A[iajk], -A[iajk+1], t0_r, t0_i );
         for( i = 0,      ibij  = jbj, ibik  = jbk;
              i < M; i++, ibij += 2,   ibik += 2 )
         { Mmla( t0_r, t0_i, B[ibik], B[ibik+1], B[ibij], B[ibij+1] ); }
      }
      Mset( ALPHA[0], ALPHA[1], t0_r, t0_i );
@rout trmmRUCN
      i = ( k << 1 ) + jak; @(scl)( A[i], -A[i+1], t0_r, t0_i );
@rout trmmRUCN trmmRUCU
      for( i = 0, ibik = jbk; i < M; i++, ibik += 2 )
      { @(scl)( t0_r, t0_i, B[ibik], B[ibik+1] ); }
   }
@rout trsmRUCN trsmRUCU
   @(reg_utyp_decl) t0_i, t0_r;
   int                        i, iajk, ibij, ibik, j, jak, jbj, jbk, k,
                              lda2 = ( LDA << 1 ), ldb2 = ( LDB << 1 );
@extract @(EXECUTABLE_STATEMENT)
   for( k = N-1,     jak  = (N-1)*lda2, jbk  = (N-1)*ldb2;
        k >= 0; k--, jak -= lda2,       jbk -= ldb2 )
   {
@rout trsmRUCN
      for( i = 0, ibik = jbk; i < M; i++, ibik += 2 )
      { j = ( k << 1 ) + jak; @(div)( A[j], -A[j+1], B[ibik], B[ibik+1] ); }
@rout trsmRUCN trsmRUCU
      for( j = 0, iajk = jak, jbj = 0; j < k; j++, iajk += 2, jbj += ldb2 )
      {
         Mset( A[iajk], -A[iajk+1], t0_r, t0_i );
         for( i = 0,      ibij  = jbj, ibik = jbk;
              i < M; i++, ibij += 2,   ibik += 2 )
         { Mmls( t0_r, t0_i, B[ibik], B[ibik+1], B[ibij], B[ibij+1] ); }
      }
      for( i = 0, ibik  = jbk; i < M; i++, ibik += 2 )
      { @(scl)( ALPHA[0], ALPHA[1], B[ibik], B[ibik+1] ); }
   }
@rout trmmRUCN trmmRUCU trsmRUCN trsmRUCU
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout Make.l1ref
@extract @(VER_ATLAS_MAK)
#
include Make.inc
mySRCdir = $(SRCdir)/src/blas/reference/level1
#
########################################################################
#
REFBLASlib = @(atllib)
INC1dep    = $(INCSdir)/atlas_enum.h $(INCSdir)/atlas_refmisc.h \
             $(INCSdir)/atlas_reflevel1.h
#
## Object files ########################################################
#
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
ATL_@(pre_)lvl1obj = \
   @declare "   " y y
   @ptyp_ s
      @multidef rout_
         dsdot sdsdot dot rotm rot axpy copy swap scal amax asum nrm2 rotmg rotg
      @endmultidef
   @ptyp_ d
      @multidef rout_
         dot rotm rot axpy copy swap scal amax asum nrm2 rotmg rotg
      @endmultidef
   @ptyp_ c z
      @multidef rout_
         dotu_sub dotc_sub rot axpy copy swap rscal scal amax asum nrm2 rotg
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      @addkeys prou_=@(rout_)
      @prou_ rotg rotmg scal axpy copy swap rotm dot dotu_sub dotc_sub
         ATL_@(pre_)ref@(rout_).o
      @prou_ amax
         ATL_i@(pre_)ref@(rout_).o
      @prou_ nrm2 asum
         @ptyp_ s d
            ATL_@(pre_)ref@(rout_).o
         @ptyp_ c
            ATL_scref@(rout_).o
         @ptyp_ z
            ATL_dzref@(rout_).o
         @ptyp_ !
      @prou_ rot
         @ptyp_ s d
            ATL_@(pre_)ref@(rout_).o
         @ptyp_ c
            ATL_csref@(rout_).o
         @ptyp_ z
            ATL_zdref@(rout_).o
         @ptyp_ !
      @prou_ rscal
         @ptyp_ c
            ATL_csrefscal.o
         @ptyp_ z
            ATL_zdrefscal.o
         @ptyp_ !
      @prou_ sdsdot
         ATL_sdsrefdot.o
      @prou_ dsdot
         ATL_dsrefdot.o
      @prou_ !
      @killkeys prou_
   @endwhile
   @killkeys ptyp_
   @enddeclare
#
@endwhile
## Targets #############################################################
# 
all   : lib
#
lvl1  : lib
#
lib   : slib dlib clib zlib
#
@whiledef pre_ z c d s
@(pre_)lvl1 : @(pre_)lib
@endwhile
#
########################################################################
#
@whiledef pre_ z c d s
@(pre_)lib  : @(pre_)lib.grd
@endwhile
#
@whiledef pre_ z c d s
@(pre_)lib.grd  : $(ATL_@(pre_)lvl1obj)
	@(arch) @(archflgs) @(reflib) $(ATL_@(pre_)lvl1obj)
	@(ranlib) @(reflib)
	touch @(pre_)lib.grd
#
@endwhile
########################################################################
# 
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s
      @multidef rout_
         dsdot sdsdot dot rotm rot axpy copy swap scal amax asum nrm2 rotmg rotg
      @endmultidef
   @ptyp_ d
      @multidef rout_
         dot rotm rot axpy copy swap scal amax asum nrm2 rotmg rotg
      @endmultidef
   @ptyp_ c z
      @multidef rout_
         dotu_sub dotc_sub rot axpy copy swap rscal scal amax asum nrm2 rotg
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      @addkeys prou_=@(rout_)
      @prou_ rotg rotmg scal axpy copy swap rotm dot dotu_sub dotc_sub
         @define rpre_ @ATL_@(pre_)ref@(rout_)@
         @define rsrc_ @$(mySRCdir)/@(rpre_).c@
         @define robj_ @@(rpre_).o@
@30l@(robj_) : @(rsrc_) $(INC1dep)
@(CCcomp) @(rsrc_)
         @undef rpre_
         @undef rsrc_
         @undef robj_
      @prou_ amax
         @define rpre_ @ATL_i@(pre_)ref@(rout_)@
      @prou_ nrm2 asum
         @ptyp_ s d
            @define rpre_ @ATL_@(pre_)ref@(rout_)@
         @ptyp_ c
            @define rpre_ @ATL_scref@(rout_)@
         @ptyp_ z
            @define rpre_ @ATL_dzref@(rout_)@
         @ptyp_ !
      @prou_ rscal
         @ptyp_ c
            @define rpre_ @ATL_csrefscal@
         @ptyp_ z
            @define rpre_ @ATL_zdrefscal@
         @ptyp_ !
      @prou_ rot
         @ptyp_ s d
            @define rpre_ @ATL_@(pre_)ref@(rout_)@
         @ptyp_ c
            @define rpre_ @ATL_csref@(rout_)@
         @ptyp_ z
            @define rpre_ @ATL_zdref@(rout_)@
         @ptyp_ !
      @prou_ sdsdot
         @define rpre_ @ATL_sdsrefdot@
      @prou_ dsdot
         @define rpre_ @ATL_dsrefdot@
      @prou_ amax nrm2 asum rscal rot sdsdot dsdot
         @define rsrc_ @$(mySRCdir)/@(rpre_).c@
         @define robj_ @@(rpre_).o@
@30l@(robj_) : @(rsrc_) $(INC1dep)
@(CCcomp) @(rsrc_)
         @undef rpre_
         @undef rsrc_
         @undef robj_
      @prou_ !
      @killkeys prou_
   @endwhile
   @killkeys ptyp_
#
@endwhile
########################################################################
#
@whiledef pre_ z c d s
@(pre_)clean   :
	rm -f $(ATL_@(pre_)lvl1obj) @(pre_)*.grd
@endwhile
#
clean    :
	rm -f *.o *.grd
#
########################################################################
@skip
@skip ==================================================================
@skip
@rout Make.l2ref
@extract @(VER_ATLAS_MAK)
#
include Make.inc
mySRCdir = $(SRCdir)/src/blas/reference/level2
#
########################################################################
# 
REFBLASlib = @(atllib)
INC2dep    = $(INCSdir)/atlas_enum.h    $(INCSdir)/atlas_refmisc.h \
             $(INCSdir)/atlas_reflvl2.h $(INCSdir)/atlas_reflevel2.h
#
## Object files ########################################################
#
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
ATL_@(pre_)lvl2obj = \
   @declare "   " y y
   @ptyp_ s d
      @multidef rout_
         tbmv    tbsv    tpmv    tpsv    trmv    trsv
         tbmvLNN tbsvLNN tpmvLNN tpsvLNN trmvLNN trsvLNN
         tbmvLNU tbsvLNU tpmvLNU tpsvLNU trmvLNU trsvLNU
         tbmvLTN tbsvLTN tpmvLTN tpsvLTN trmvLTN trsvLTN
         tbmvLTU tbsvLTU tpmvLTU tpsvLTU trmvLTU trsvLTU
         tbmvUNN tbsvUNN tpmvUNN tpsvUNN trmvUNN trsvUNN
         tbmvUNU tbsvUNU tpmvUNU tpsvUNU trmvUNU trsvUNU
         tbmvUTN tbsvUTN tpmvUTN tpsvUTN trmvUTN trsvUTN
         tbmvUTU tbsvUTU tpmvUTU tpsvUTU trmvUTU trsvUTU
         syr2    syr2L   syr2U   spr2    spr2L   spr2U
         syr     syrL    syrU    spr     sprL    sprU
         sbmvU   sbmvL   sbmv    spmvU   spmvL   spmv
         symvU   symvL   symv    ger     gpr     gemvT
         gemvN   gemv    gpmvUT  gpmvUN  gpmvLT  gpmvLN
         gpmv    gbmvT   gbmvN   gbmv
      @endmultidef
   @ptyp_ c z
      @multidef rout_
         tbmv    tbsv    tpmv    tpsv    trmv    trsv
         tbmvLNN tbsvLNN tpmvLNN tpsvLNN trmvLNN trsvLNN
         tbmvLNU tbsvLNU tpmvLNU tpsvLNU trmvLNU trsvLNU
         tbmvLCN tbsvLCN tpmvLCN tpsvLCN trmvLCN trsvLCN
         tbmvLCU tbsvLCU tpmvLCU tpsvLCU trmvLCU trsvLCU
         tbmvLTN tbsvLTN tpmvLTN tpsvLTN trmvLTN trsvLTN
         tbmvLTU tbsvLTU tpmvLTU tpsvLTU trmvLTU trsvLTU
         tbmvLHN tbsvLHN tpmvLHN tpsvLHN trmvLHN trsvLHN
         tbmvLHU tbsvLHU tpmvLHU tpsvLHU trmvLHU trsvLHU
         tbmvUNN tbsvUNN tpmvUNN tpsvUNN trmvUNN trsvUNN
         tbmvUNU tbsvUNU tpmvUNU tpsvUNU trmvUNU trsvUNU
         tbmvUCN tbsvUCN tpmvUCN tpsvUCN trmvUCN trsvUCN
         tbmvUCU tbsvUCU tpmvUCU tpsvUCU trmvUCU trsvUCU
         tbmvUTN tbsvUTN tpmvUTN tpsvUTN trmvUTN trsvUTN
         tbmvUTU tbsvUTU tpmvUTU tpsvUTU trmvUTU trsvUTU
         tbmvUHN tbsvUHN tpmvUHN tpsvUHN trmvUHN trsvUHN
         tbmvUHU tbsvUHU tpmvUHU tpsvUHU trmvUHU trsvUHU
         her2    her2L   her2U   hpr2    hpr2L   hpr2U
         her     herL    herU    hpr     hprL    hprU
         hbmvU   hbmvL   hbmv    hpmvU   hpmvL   hpmv
         hemvU   hemvL   hemv    geru    gerc    gpru
         gprc    gemvH   gemvT   gemvC   gemvN   gemv
         gpmvLH  gpmvLT  gpmvLC  gpmvLN  gpmvUH  gpmvUT
         gpmvUC  gpmvUN  gpmv    gbmvH   gbmvT   gbmvC
         gbmvN   gbmv
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      ATL_@(pre_)ref@(rout_).o
   @endwhile
   @killkeys ptyp_
   @enddeclare
#
@endwhile
## Targets #############################################################
#
all    : lib
#
lvl2   : lib
#
lib    : slib dlib clib zlib
#
@whiledef pre_ z c d s
@(pre_)lvl2 : @(pre_)lib
@endwhile
#
########################################################################
#
@whiledef pre_ z c d s
@(pre_)lib  : @(pre_)lib.grd
@endwhile
#
@whiledef pre_ z c d s
@(pre_)lib.grd  : $(ATL_@(pre_)lvl2obj)
	@(arch) @(archflgs) @(reflib) $(ATL_@(pre_)lvl2obj)
	@(ranlib) @(reflib)
	touch @(pre_)lib.grd
#
@endwhile
########################################################################
#
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s d
      @multidef rout_
         tbmv    tbsv    tpmv    tpsv    trmv    trsv
         tbmvLNN tbsvLNN tpmvLNN tpsvLNN trmvLNN trsvLNN
         tbmvLNU tbsvLNU tpmvLNU tpsvLNU trmvLNU trsvLNU
         tbmvLTN tbsvLTN tpmvLTN tpsvLTN trmvLTN trsvLTN
         tbmvLTU tbsvLTU tpmvLTU tpsvLTU trmvLTU trsvLTU
         tbmvUNN tbsvUNN tpmvUNN tpsvUNN trmvUNN trsvUNN
         tbmvUNU tbsvUNU tpmvUNU tpsvUNU trmvUNU trsvUNU
         tbmvUTN tbsvUTN tpmvUTN tpsvUTN trmvUTN trsvUTN
         tbmvUTU tbsvUTU tpmvUTU tpsvUTU trmvUTU trsvUTU
         syr2    syr2L   syr2U   spr2    spr2L   spr2U
         syr     syrL    syrU    spr     sprL    sprU
         sbmvU   sbmvL   sbmv    spmvU   spmvL   spmv
         symvU   symvL   symv    ger     gpr     gemvT
         gemvN   gemv    gpmvUT  gpmvUN  gpmvLT  gpmvLN
         gpmv    gbmvT   gbmvN   gbmv
      @endmultidef
   @ptyp_ c z
      @multidef rout_
         tbmv    tbsv    tpmv    tpsv    trmv    trsv
         tbmvLNN tbsvLNN tpmvLNN tpsvLNN trmvLNN trsvLNN
         tbmvLNU tbsvLNU tpmvLNU tpsvLNU trmvLNU trsvLNU
         tbmvLCN tbsvLCN tpmvLCN tpsvLCN trmvLCN trsvLCN
         tbmvLCU tbsvLCU tpmvLCU tpsvLCU trmvLCU trsvLCU
         tbmvLTN tbsvLTN tpmvLTN tpsvLTN trmvLTN trsvLTN
         tbmvLTU tbsvLTU tpmvLTU tpsvLTU trmvLTU trsvLTU
         tbmvLHN tbsvLHN tpmvLHN tpsvLHN trmvLHN trsvLHN
         tbmvLHU tbsvLHU tpmvLHU tpsvLHU trmvLHU trsvLHU
         tbmvUNN tbsvUNN tpmvUNN tpsvUNN trmvUNN trsvUNN
         tbmvUNU tbsvUNU tpmvUNU tpsvUNU trmvUNU trsvUNU
         tbmvUCN tbsvUCN tpmvUCN tpsvUCN trmvUCN trsvUCN
         tbmvUCU tbsvUCU tpmvUCU tpsvUCU trmvUCU trsvUCU
         tbmvUTN tbsvUTN tpmvUTN tpsvUTN trmvUTN trsvUTN
         tbmvUTU tbsvUTU tpmvUTU tpsvUTU trmvUTU trsvUTU
         tbmvUHN tbsvUHN tpmvUHN tpsvUHN trmvUHN trsvUHN
         tbmvUHU tbsvUHU tpmvUHU tpsvUHU trmvUHU trsvUHU
         her2    her2L   her2U   hpr2    hpr2L   hpr2U
         her     herL    herU    hpr     hprL    hprU
         hbmvU   hbmvL   hbmv    hpmvU   hpmvL   hpmv
         hemvU   hemvL   hemv    geru    gerc    gpru
         gprc    gemvH   gemvT   gemvC   gemvN   gemv
         gpmvLH  gpmvLT  gpmvLC  gpmvLN  gpmvUH  gpmvUT
         gpmvUC  gpmvUN  gpmv    gbmvH   gbmvT   gbmvC
         gbmvN   gbmv
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      @define rpre_ @ATL_@(pre_)ref@(rout_)@
      @define rsrc_ @$(mySRCdir)/@(rpre_).c@
      @define robj_ @@(rpre_).o@
@30l@(robj_) : @(rsrc_) $(INC2dep)
@(CCcomp) @(rsrc_)
      @undef rpre_
      @undef rsrc_
      @undef robj_
   @endwhile
   @killkeys ptyp_
#
@endwhile
########################################################################
#
@whiledef pre_ z c d s
@(pre_)clean   :
	rm -f $(ATL_@(pre_)lvl2obj) @(pre_)*.grd
@endwhile
#
clean    :
	rm -f *.o *.grd
#
########################################################################
@skip
@skip ==================================================================
@skip
@rout Make.l3ref
@extract @(VER_ATLAS_MAK)
#
include Make.inc
mySRCdir = $(SRCdir)/src/blas/reference/level3
#
########################################################################
#
REFBLASlib = @(atllib)
INC3dep    = $(INCSdir)/atlas_enum.h    $(INCSdir)/atlas_refmisc.h \
             $(INCSdir)/atlas_reflvl3.h $(INCSdir)/atlas_reflevel3.h
#
## Object files ########################################################
#
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
ATL_@(pre_)lvl3obj = \
   @declare "   " y y
   @ptyp_ s d
      @multidef rout_
         trmmLLNN trmmLLNU trsmLLNN trsmLLNU
         trmmLLTN trmmLLTU trsmLLTN trsmLLTU
         trmmLUNN trmmLUNU trsmLUNN trsmLUNU
         trmmLUTN trmmLUTU trsmLUTN trsmLUTU
         trmmRLNN trmmRLNU trsmRLNN trsmRLNU
         trmmRLTN trmmRLTU trsmRLTN trsmRLTU
         trmmRUNN trmmRUNU trsmRUNN trsmRUNU
         trmmRUTN trmmRUTU trsmRUTN trsmRUTU trsm     trmm
         syr2kLN  syr2kLT  syr2kUN  syr2kUT  syr2k
         syrkLN   syrkLT   syrkUN   syrkUT   syrk
         symmLL   symmLU   symmRL   symmRU   symm  
         gemmTT   gemmNT   gemmTN   gemmNN   gemm
      @endmultidef
   @ptyp_ c z
      @multidef rout_
         trmmLLNN trmmLLNU trsmLLNN trsmLLNU
         trmmLLTN trmmLLTU trsmLLTN trsmLLTU
         trmmLLCN trmmLLCU trsmLLCN trsmLLCU
         trmmLUNN trmmLUNU trsmLUNN trsmLUNU
         trmmLUTN trmmLUTU trsmLUTN trsmLUTU
         trmmLUCN trmmLUCU trsmLUCN trsmLUCU
         trmmRLNN trmmRLNU trsmRLNN trsmRLNU
         trmmRLTN trmmRLTU trsmRLTN trsmRLTU
         trmmRLCN trmmRLCU trsmRLCN trsmRLCU
         trmmRUNN trmmRUNU trsmRUNN trsmRUNU
         trmmRUTN trmmRUTU trsmRUTN trsmRUTU
         trmmRUCN trmmRUCU trsmRUCN trsmRUCU trsm     trmm
         syr2kLN  syr2kLT  syr2kUN  syr2kUT  syr2k
         syrkLN   syrkLT   syrkUN   syrkUT   syrk
         symmLL   symmLU   symmRL   symmRU   symm  
         her2kLN  her2kLC  her2kUN  her2kUC  her2k
         herkLN   herkLC   herkUN   herkUC   herk
         hemmLL   hemmLU   hemmRL   hemmRU   hemm  
         gemmCC   gemmTC   gemmCT   gemmTT   gemmNC
         gemmNT   gemmCN   gemmTN   gemmNN   gemm
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      ATL_@(pre_)ref@(rout_).o
   @endwhile
   @killkeys ptyp_
   @enddeclare
#
@endwhile
## Targets #############################################################
#
all   : lib
#
lvl3  : lib
#
lib   : slib dlib clib zlib
#
@whiledef pre_ z c d s
@(pre_)lvl3 : @(pre_)lib
@endwhile
#
########################################################################
#
@whiledef pre_ z c d s
@(pre_)lib  : @(pre_)lib.grd
@endwhile
#
@whiledef pre_ z c d s
@(pre_)lib.grd  : $(ATL_@(pre_)lvl3obj)
	@(arch) @(archflgs) @(reflib) $(ATL_@(pre_)lvl3obj)
	@(ranlib) @(reflib)
	touch @(pre_)lib.grd
#
@endwhile
########################################################################
#
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s d
      @multidef rout_
         trmmLLNN trmmLLNU trsmLLNN trsmLLNU
         trmmLLTN trmmLLTU trsmLLTN trsmLLTU
         trmmLUNN trmmLUNU trsmLUNN trsmLUNU
         trmmLUTN trmmLUTU trsmLUTN trsmLUTU
         trmmRLNN trmmRLNU trsmRLNN trsmRLNU
         trmmRLTN trmmRLTU trsmRLTN trsmRLTU
         trmmRUNN trmmRUNU trsmRUNN trsmRUNU
         trmmRUTN trmmRUTU trsmRUTN trsmRUTU trsm     trmm
         syr2kLN  syr2kLT  syr2kUN  syr2kUT  syr2k
         syrkLN   syrkLT   syrkUN   syrkUT   syrk
         symmLL   symmLU   symmRL   symmRU   symm  
         gemmTT   gemmNT   gemmTN   gemmNN   gemm
      @endmultidef
   @ptyp_ c z
      @multidef rout_
         trmmLLNN trmmLLNU trsmLLNN trsmLLNU
         trmmLLTN trmmLLTU trsmLLTN trsmLLTU
         trmmLLCN trmmLLCU trsmLLCN trsmLLCU
         trmmLUNN trmmLUNU trsmLUNN trsmLUNU
         trmmLUTN trmmLUTU trsmLUTN trsmLUTU
         trmmLUCN trmmLUCU trsmLUCN trsmLUCU
         trmmRLNN trmmRLNU trsmRLNN trsmRLNU
         trmmRLTN trmmRLTU trsmRLTN trsmRLTU
         trmmRLCN trmmRLCU trsmRLCN trsmRLCU
         trmmRUNN trmmRUNU trsmRUNN trsmRUNU
         trmmRUTN trmmRUTU trsmRUTN trsmRUTU
         trmmRUCN trmmRUCU trsmRUCN trsmRUCU trsm     trmm
         syr2kLN  syr2kLT  syr2kUN  syr2kUT  syr2k
         syrkLN   syrkLT   syrkUN   syrkUT   syrk
         symmLL   symmLU   symmRL   symmRU   symm  
         her2kLN  her2kLC  her2kUN  her2kUC  her2k
         herkLN   herkLC   herkUN   herkUC   herk
         hemmLL   hemmLU   hemmRL   hemmRU   hemm  
         gemmCC   gemmTC   gemmCT   gemmTT   gemmNC
         gemmNT   gemmCN   gemmTN   gemmNN   gemm
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      @define rpre_ @ATL_@(pre_)ref@(rout_)@
      @define rsrc_ @$(mySRCdir)/@(rpre_).c@
      @define robj_ @@(rpre_).o@
@34l@(robj_) : @(rsrc_) $(INC3dep)
@(CCcomp) @(rsrc_)
      @undef rpre_
      @undef rsrc_
      @undef robj_
   @endwhile
   @killkeys ptyp_
#
@endwhile
########################################################################
#
@whiledef pre_ z c d s
@(pre_)clean   :
	rm -f $(ATL_@(pre_)lvl3obj) @(pre_)*.grd
@endwhile
#
clean    :
	rm -f *.o *.grd
#
########################################################################
@skip
@skip ==================================================================
@skip
@rout atlas_refalias1.h
@define rname @atlas_refalias1.h@
@extract @(VER_ATLAS_SRC)
#ifndef ATLAS_REFALIAS1_H
#define ATLAS_REFALIAS1_H

#define ATL_srotg              ATL_srefrotg
#define ATL_srotmg             ATL_srefrotmg
#define ATL_snrm2              ATL_srefnrm2
#define ATL_sasum              ATL_srefasum
#define ATL_isamax             ATL_isrefamax
#define ATL_sscal              ATL_srefscal
#define ATL_sswap              ATL_srefswap
#define ATL_scopy              ATL_srefcopy
#define ATL_saxpy              ATL_srefaxpy
#define ATL_srot               ATL_srefrot
#define ATL_srotm              ATL_srefrotm
#define ATL_sdot               ATL_srefdot
#define ATL_sdsdot             ATL_sdsrefdot
#define ATL_dsdot              ATL_dsrefdot
 
#define ATL_drotg              ATL_drefrotg
#define ATL_drotmg             ATL_drefrotmg
#define ATL_dnrm2              ATL_drefnrm2
#define ATL_dasum              ATL_drefasum
#define ATL_idamax             ATL_idrefamax
#define ATL_dscal              ATL_drefscal
#define ATL_dswap              ATL_drefswap
#define ATL_dcopy              ATL_drefcopy
#define ATL_daxpy              ATL_drefaxpy
#define ATL_drot               ATL_drefrot
#define ATL_drotm              ATL_drefrotm
#define ATL_ddot               ATL_drefdot

#define ATL_crotg              ATL_crefrotg
#define ATL_scnrm2             ATL_screfnrm2
#define ATL_scasum             ATL_screfasum
#define ATL_icamax             ATL_icrefamax
#define ATL_cscal              ATL_crefscal
#define ATL_csscal             ATL_csrefscal
#define ATL_cswap              ATL_crefswap
#define ATL_ccopy              ATL_crefcopy
#define ATL_caxpy              ATL_crefaxpy
#define ATL_csrot              ATL_csrefrot
#define ATL_cdotc_sub          ATL_crefdotc_sub
#define ATL_cdotu_sub          ATL_crefdotu_sub
 
#define ATL_zrotg              ATL_zrefrotg
#define ATL_dznrm2             ATL_dzrefnrm2
#define ATL_dzasum             ATL_dzrefasum
#define ATL_izamax             ATL_izrefamax
#define ATL_zscal              ATL_zrefscal
#define ATL_zdscal             ATL_zdrefscal
#define ATL_zswap              ATL_zrefswap
#define ATL_zcopy              ATL_zrefcopy
#define ATL_zaxpy              ATL_zrefaxpy
#define ATL_zdrot              ATL_zdrefrot
#define ATL_zdotc_sub          ATL_zrefdotc_sub
#define ATL_zdotu_sub          ATL_zrefdotu_sub

#endif 
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip ==================================================================
@skip
@rout atlas_refalias2.h
@define rname @atlas_refalias2.h@
@extract @(VER_ATLAS_SRC)
#ifndef ATLAS_REFALIAS2_H
#define ATLAS_REFALIAS2_H

@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s d
      @multidef rout_
         trsv trmv tpsv tpmv tbsv tbmv syr2 syr  symv spr2 spr  spmv 
         sbmv ger  gpr  gemv gpmv gbmv
      @endmultidef
   @ptyp_ c z
      @multidef rout_
         trsv trmv tpsv tpmv tbsv tbmv her2 her  hemv hpr2 hpr  hpmv
         hbmv geru gerc gpru gprc gemv gpmv gbmv
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      @define rpre_ @ATL_@(pre_)ref@(rout_)@
      @define rdef_ @ATL_@(pre_)@(rout_)@
#define @22l@(rdef_) @22l@(rpre_)
      @undef rdef_
      @undef rpre_
   @endwhile
   @killkeys ptyp_
 
@endwhile
#endif
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip ==================================================================
@skip
@rout atlas_refalias3.h
@define rname @atlas_refalias3.h@
@extract @(VER_ATLAS_SRC)
#ifndef ATLAS_REFALIAS3_H
#define ATLAS_REFALIAS3_H

@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s d
      @multidef rout_ trsm trmm syr2k syrk symm gemm
   @ptyp_ c z
      @multidef rout_ trsm trmm syr2k syrk symm her2k herk hemm gemm
   @ptyp_ !
   @whiledef rout_
      @define rpre_ @ATL_@(pre_)ref@(rout_)@
      @define rdef_ @ATL_@(pre_)@(rout_)@
#define @22l@(rdef_) @22l@(rpre_)
      @undef rdef_
      @undef rpre_
   @endwhile
   @killkeys ptyp_

@endwhile
#endif
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip ==================================================================
@skip
@rout atlas_reflevel1.h
@define rname @atlas_reflevel1.h@
@extract @(VER_ATLAS_SRC)
#ifndef ATLAS_REFLEVEL1_H
#define ATLAS_REFLEVEL1_H
/*
 * =====================================================================
 * Prototypes for Level 1 Reference ATLAS BLAS routines
 * =====================================================================
 */
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s
      @define sca_in_    @const float@
      @define sca_out_   @float *@
      @define rsca_in_   @const float@
      @define rsca_out_  @float *@
      @define vec_in_    @const float *,          const int@
      @define vec_out_   @float *,                const int@
      @multidef rout_
         dsdot sdsdot dot rotm rot axpy copy swap scal amax asum nrm2 rotmg rotg
      @endmultidef
   @ptyp_ d
      @define sca_in_    @const double@
      @define sca_out_   @double *@
      @define rsca_in_   @const double@
      @define rsca_out_  @double *@
      @define vec_in_    @const double *,         const int@
      @define vec_out_   @double *,               const int@
      @multidef rout_
         dot rotm rot axpy copy swap scal amax asum nrm2 rotmg rotg
      @endmultidef
   @ptyp_ c
      @define sca_in_    @const float *@
      @define sca_out_   @float *@
      @define rsca_in_   @const float@
      @define rsca_out_  @float *@
      @define vec_in_    @const float *,          const int@
      @define vec_out_   @float *,                const int@
   @ptyp_ z
      @define sca_in_    @const double *@
      @define sca_out_   @double *@
      @define rsca_in_   @const double@
      @define rsca_out_  @double *@
      @define vec_in_    @const double *,         const int@
      @define vec_out_   @double *,               const int@
   @ptyp_ c z
      @multidef rout_
         dotu_sub dotc_sub rot axpy copy swap rscal scal amax asum nrm2 rotg
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      @addkeys prou_=@(rout_)
      @prou_ rotg
void       ATL_@(pre_)ref@(rout_)
(
   @(sca_out_),
      @ptyp_ s d
   @(sca_out_),
      @ptyp_ c z
   @(sca_in_),
      @ptyp_ !
   @(sca_out_),
   @(sca_out_)
);
      @prou_ rotmg
void       ATL_@(pre_)ref@(rout_)
(
   @(sca_out_),
   @(sca_out_),
   @(sca_out_),
   @(sca_in_),
   @(sca_out_)
);
      @prou_ nrm2 asum
      @ptyp_ s
float      ATL_@(pre_)ref@(rout_)
      @ptyp_ d
double     ATL_@(pre_)ref@(rout_)
      @ptyp_ c
float      ATL_scref@(rout_)
      @ptyp_ z
double     ATL_dzref@(rout_)
      @ptyp_ !
( 
   const int,
   @(vec_in_)
);
      @prou_ amax
int        ATL_i@(pre_)ref@(rout_)
( 
   const int,
   @(vec_in_)
);
      @prou_ scal
void       ATL_@(pre_)ref@(rout_) 
( 
   const int,
   @(sca_in_),
   @(vec_out_)
);
      @prou_ rscal
      @ptyp_ c
void       ATL_csrefscal 
      @ptyp_ z
void       ATL_zdrefscal 
      @ptyp_ !
( 
   const int,
   @(rsca_in_),
   @(vec_out_)
);
      @prou_ axpy
void       ATL_@(pre_)ref@(rout_)
( 
   const int,
   @(sca_in_),
   @(vec_in_),
   @(vec_out_)
);
      @prou_ copy
void       ATL_@(pre_)ref@(rout_)
( 
   const int,
   @(vec_in_),
   @(vec_out_)
);
      @prou_ swap
void       ATL_@(pre_)ref@(rout_)
( 
   const int,
   @(vec_out_),
   @(vec_out_)
);
      @prou_ rot
      @ptyp_ s d
void       ATL_@(pre_)ref@(rout_)
      @ptyp_ c
void       ATL_csref@(rout_)
      @ptyp_ z
void       ATL_zdref@(rout_)
      @ptyp_ !
( 
   const int,
   @(vec_out_),
   @(vec_out_),
   @(rsca_in_),
   @(rsca_in_)
);
      @prou_ rotm
void       ATL_@(pre_)ref@(rout_)
( 
   const int,
   @(vec_out_),
   @(vec_out_),
      @ptyp_ s
   const float *
      @ptyp_ d
   const double *
      @ptyp_ !
);
      @prou_ dot
      @ptyp_ s
float      ATL_@(pre_)ref@(rout_)
      @ptyp_ d
double     ATL_@(pre_)ref@(rout_)
      @ptyp_ !
( 
   const int,
   @(vec_in_),
   @(vec_in_)
);
      @prou_ dotu_sub dotc_sub
void       ATL_@(pre_)ref@(rout_)
( 
   const int,
   @(vec_in_),
   @(vec_in_),
   @(sca_out_)
);
      @prou_ sdsdot
float      ATL_sdsrefdot
( 
   const int,
   @(sca_in_),
   @(vec_in_),
   @(vec_in_)
);
      @prou_ dsdot
double     ATL_dsrefdot
( 
   const int,
   @(vec_in_),
   @(vec_in_)
);
      @prou_ !
      @killkeys prou_
 
   @endwhile
   @undef sca_in_
   @undef sca_out_
   @undef rsca_in_
   @undef rsca_out_
   @undef vec_in_
   @undef vec_out_
   @killkeys ptyp_
@endwhile
#endif
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip ==================================================================
@skip
@rout atlas_reflevel2.h
@define rname @atlas_reflevel2.h@
@extract @(VER_ATLAS_SRC)
#ifndef ATLAS_REFLEVEL2_H
#define ATLAS_REFLEVEL2_H

#include "atlas_enum.h"
/*
 * =====================================================================
 * Prototypes for Level 2 Reference ATLAS BLAS routines
 * =====================================================================
 */
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s
      @define sca_in_    @const float@
      @define rsca_in_   @const float@
      @define mat_in_    @const float *,          const int@
      @define mat_out_   @float *,                const int@
      @define pmat_in_   @const float *@
      @define pmat_out_  @float *@
      @define vec_in_    @const float *,          const int@
      @define vec_out_   @float *,                const int@
   @ptyp_ d
      @define sca_in_    @const double@
      @define rsca_in_   @const double@
      @define mat_in_    @const double *,         const int@
      @define mat_out_   @double *,               const int@
      @define pmat_in_   @const double *@
      @define pmat_out_  @double *@
      @define vec_in_    @const double *,         const int@
      @define vec_out_   @double *,               const int@
   @ptyp_ s d
      @multidef rout_
         trsv trmv tpsv tpmv tbsv tbmv syr2 syr  symv spr2 spr  spmv sbmv
         ger  gpr  gemv gpmv gbmv
      @endmultidef
   @ptyp_ c
      @define sca_in_    @const float *@
      @define rsca_in_   @const float@
      @define mat_in_    @const float *,          const int@
      @define mat_out_   @float *,                const int@
      @define pmat_in_   @const float *@
      @define pmat_out_  @float *@
      @define vec_in_    @const float *,          const int@
      @define vec_out_   @float *,                const int@
   @ptyp_ z
      @define sca_in_    @const double *@
      @define rsca_in_   @const double@
      @define mat_in_    @const double *,         const int@
      @define mat_out_   @double *,               const int@
      @define pmat_in_   @const double *@
      @define pmat_out_  @double *@
      @define vec_in_    @const double *,         const int@
      @define vec_out_   @double *,               const int@
   @ptyp_ c z
      @multidef rout_
         trsv trmv tpsv tpmv tbsv tbmv her2 her  hemv hpr2 hpr  hpmv hbmv
         geru gerc gpru gprc gemv gpmv gbmv
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      @addkeys prou_=@(rout_)
void       ATL_@(pre_)ref@(rout_)
(
      @prou_ gpmv
  const enum ATLAS_UPLO, 
      @prou_ gbmv gpmv gemv
  const enum ATLAS_TRANS, 
  const int,              const int,
      @prou_ gbmv
  const int,              const int,
      @prou_ gbmv gpmv gemv
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ tbmv tbsv tpmv tpsv trmv trsv
  const enum ATLAS_UPLO,  const enum ATLAS_TRANS, const enum ATLAS_DIAG,
      @prou_ tbmv tbsv
  const int,              const int,
      @prou_ tpmv tpsv trmv trsv
  const int,
      @prou_ tbmv tbsv trmv trsv
  @(mat_in_),
      @prou_ tpmv tpsv
  @(pmat_in_),
      @prou_ tbmv tbsv tpmv tpsv trmv trsv
  @(vec_out_)
      @prou_ hbmv hpmv hemv sbmv spmv symv
  const enum ATLAS_UPLO,
      @prou_ hbmv sbmv
  const int,              const int,
      @prou_ hpmv hemv spmv symv
  const int,
      @prou_ hbmv hpmv hemv sbmv spmv symv
  @(sca_in_),
      @prou_ hbmv hemv sbmv symv
  @(mat_in_),
      @prou_ hpmv spmv
  @(pmat_in_),
      @prou_ hbmv hpmv hemv sbmv spmv symv
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpr gprc gpru
  const enum ATLAS_UPLO,
      @prou_ ger gerc geru gpr gprc gpru
  const int,              const int,
  @(sca_in_),
  @(vec_in_),
  @(vec_in_),
  @(mat_out_)
      @prou_ hpr her spr syr
  const enum ATLAS_UPLO,
  const int,
  @(rsca_in_),
  @(vec_in_),
      @prou_ hpr spr
  @(pmat_out_)
      @prou_ her syr
  @(mat_out_)
      @prou_ hpr2 her2 spr2 syr2
  const enum ATLAS_UPLO,
  const int,
  @(sca_in_),
  @(vec_in_),
  @(vec_in_),
      @prou_ hpr2 spr2
  @(pmat_out_)
      @prou_ her2 syr2
  @(mat_out_)
      @prou_ !
      @killkeys prou_
);
 
   @endwhile
   @undef sca_in_
   @undef rsca_in_
   @undef mat_in_
   @undef mat_out_
   @undef pmat_in_
   @undef pmat_out_
   @undef vec_in_
   @undef vec_out_
   @killkeys ptyp_
@endwhile
#endif
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip ==================================================================
@skip
@rout atlas_reflvl2.h
@define rname @atlas_reflvl2.h@
@extract @(VER_ATLAS_SRC)
#ifndef ATLAS_REFLVL2_H
#define ATLAS_REFLVL2_H
/*
 * =====================================================================
 * Prototypes for Level 2 Reference Internal ATLAS BLAS routines
 * =====================================================================
 */
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s
      @define sca_in_    @const float@
      @define rsca_in_   @const float@
      @define mat_in_    @const float *,          const int@
      @define mat_out_   @float *,                const int@
      @define pmat_in_   @const float *@
      @define pmat_out_  @float *@
      @define vec_in_    @const float *,          const int@
      @define vec_out_   @float *,                const int@
   @ptyp_ d
      @define sca_in_    @const double@
      @define rsca_in_   @const double@
      @define mat_in_    @const double *,         const int@
      @define mat_out_   @double *,               const int@
      @define pmat_in_   @const double *@
      @define pmat_out_  @double *@
      @define vec_in_    @const double *,         const int@
      @define vec_out_   @double *,               const int@
   @ptyp_ s d
      @multidef rout_
         trsvUTU  trsvUTN  trsvUNU  trsvUNN  trsvLTU  trsvLTN  trsvLNU  trsvLNN
         tpsvUTU  tpsvUTN  tpsvUNU  tpsvUNN  tpsvLTU  tpsvLTN  tpsvLNU  tpsvLNN
         tbsvUTU  tbsvUTN  tbsvUNU  tbsvUNN  tbsvLTU  tbsvLTN  tbsvLNU  tbsvLNN
         trmvUTU  trmvUTN  trmvUNU  trmvUNN  trmvLTU  trmvLTN  trmvLNU  trmvLNN
         tpmvUTU  tpmvUTN  tpmvUNU  tpmvUNN  tpmvLTU  tpmvLTN  tpmvLNU  tpmvLNN
         tbmvUTU  tbmvUTN  tbmvUNU  tbmvUNN  tbmvLTU  tbmvLTN  tbmvLNU  tbmvLNN
         syr2U    syr2L    syrU     syrL     symvU    symvL    spr2U    spr2L
         sprU     sprL     spmvU    spmvL    sbmvU    sbmvL    gprU     gprL
         gemvT    gemvN    gpmvLT   gpmvLN   gpmvUT   gpmvUN   gbmvT    gbmvN
      @endmultidef
   @ptyp_ c
      @define sca_in_    @const float *@
      @define rsca_in_   @const float@
      @define mat_in_    @const float *,          const int@
      @define mat_out_   @float *,                const int@
      @define pmat_in_   @const float *@
      @define pmat_out_  @float *@
      @define vec_in_    @const float *,          const int@
      @define vec_out_   @float *,                const int@
   @ptyp_ z
      @define sca_in_    @const double *@
      @define rsca_in_   @const double@
      @define mat_in_    @const double *,         const int@
      @define mat_out_   @double *,               const int@
      @define pmat_in_   @const double *@
      @define pmat_out_  @double *@
      @define vec_in_    @const double *,         const int@
      @define vec_out_   @double *,               const int@
   @ptyp_ c z
      @multidef rout_
         trsvUHU  trsvUHN  trsvUCU  trsvUCN  trsvUTU  trsvUTN  trsvUNU  trsvUNN
         trsvLHU  trsvLHN  trsvLCU  trsvLCN  trsvLTU  trsvLTN  trsvLNU  trsvLNN
         tpsvUHU  tpsvUHN  tpsvUCU  tpsvUCN  tpsvUTU  tpsvUTN  tpsvUNU  tpsvUNN
         tpsvLHU  tpsvLHN  tpsvLCU  tpsvLCN  tpsvLTU  tpsvLTN  tpsvLNU  tpsvLNN
         tbsvUHU  tbsvUHN  tbsvUCU  tbsvUCN  tbsvUTU  tbsvUTN  tbsvUNU  tbsvUNN
         tbsvLHU  tbsvLHN  tbsvLCU  tbsvLCN  tbsvLTU  tbsvLTN  tbsvLNU  tbsvLNN
         trmvUHU  trmvUHN  trmvUCU  trmvUCN  trmvUTU  trmvUTN  trmvUNU  trmvUNN
         trmvLHU  trmvLHN  trmvLCU  trmvLCN  trmvLTU  trmvLTN  trmvLNU  trmvLNN
         tpmvUHU  tpmvUHN  tpmvUCU  tpmvUCN  tpmvUTU  tpmvUTN  tpmvUNU  tpmvUNN
         tpmvLHU  tpmvLHN  tpmvLCU  tpmvLCN  tpmvLTU  tpmvLTN  tpmvLNU  tpmvLNN
         tbmvUHU  tbmvUHN  tbmvUCU  tbmvUCN  tbmvUTU  tbmvUTN  tbmvUNU  tbmvUNN
         tbmvLHU  tbmvLHN  tbmvLCU  tbmvLCN  tbmvLTU  tbmvLTN  tbmvLNU  tbmvLNN
         her2U    her2L    herU     herL     hemvU    hemvL    hpr2U    hpr2L
         hprU     hprL     hpmvU    hpmvL    hbmvU    hbmvL    gpruU    gpruL
         gprcU    gprcL    gemvH    gemvC    gemvT    gemvN    gpmvLH   gpmvLC
         gpmvLT   gpmvLN   gpmvUH   gpmvUC   gpmvUT   gpmvUN   gbmvH    gbmvC
         gbmvT    gbmvN
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      @addkeys prou_=@(rout_)
void       ATL_@(pre_)ref@(rout_)
(
      @prou_ gemvH gemvC gemvT gemvN gbmvH gbmvC gbmvT gbmvN
  const int,              const int,
      @prou_ gbmvH gbmvC gbmvT gbmvN
  const int,              const int,
      @prou_ gemvH gemvC gemvT gemvN gbmvH gbmvC gbmvT gbmvN
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvLH gpmvLC gpmvLT gpmvLN gpmvUH gpmvUC gpmvUT gpmvUN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gprU gprL gprcU gprcL gpruU gpruL
  const int,              const int,
  @(sca_in_),
  @(vec_in_),
  @(vec_in_),
  @(mat_out_)
      @prou_ tbmvUHU tbmvUHN tbmvUCU tbmvUCN tbmvUTU tbmvUTN tbmvUNU tbmvUNN
  const int,              const int,
  @(mat_in_),
  @(vec_out_)
      @prou_ tbsvUHU tbsvUHN tbsvUCU tbsvUCN tbsvUTU tbsvUTN tbsvUNU tbsvUNN
  const int,              const int,
  @(mat_in_),
  @(vec_out_)
      @prou_ tbmvLHU tbmvLHN tbmvLCU tbmvLCN tbmvLTU tbmvLTN tbmvLNU tbmvLNN
  const int,              const int,
  @(mat_in_),
  @(vec_out_)
      @prou_ tbsvLHU tbsvLHN tbsvLCU tbsvLCN tbsvLTU tbsvLTN tbsvLNU tbsvLNN
  const int,              const int,
  @(mat_in_),
  @(vec_out_)
      @prou_ tpmvLHU tpmvLHN tpmvLCU tpmvLCN tpmvLTU tpmvLTN tpmvLNU tpmvLNN
  const int,
  @(mat_in_),
  @(vec_out_)
      @prou_ tpsvLHU tpsvLHN tpsvLCU tpsvLCN tpsvLTU tpsvLTN tpsvLNU tpsvLNN
  const int,
  @(mat_in_),
  @(vec_out_)
      @prou_ tpmvUHU tpmvUHN tpmvUCU tpmvUCN tpmvUTU tpmvUTN tpmvUNU tpmvUNN
  const int,
  @(mat_in_),
  @(vec_out_)
      @prou_ tpsvUHU tpsvUHN tpsvUCU tpsvUCN tpsvUTU tpsvUTN tpsvUNU tpsvUNN
  const int,
  @(mat_in_),
  @(vec_out_)
      @prou_ trmvLHU trmvLHN trmvLCU trmvLCN trmvLTU trmvLTN trmvLNU trmvLNN
  const int,
  @(mat_in_),
  @(vec_out_)
      @prou_ trsvLHU trsvLHN trsvLCU trsvLCN trsvLTU trsvLTN trsvLNU trsvLNN
  const int,
  @(mat_in_),
  @(vec_out_)
      @prou_ trmvUHU trmvUHN trmvUCU trmvUCN trmvUTU trmvUTN trmvUNU trmvUNN
  const int,
  @(mat_in_),
  @(vec_out_)
      @prou_ trsvUHU trsvUHN trsvUCU trsvUCN trsvUTU trsvUTN trsvUNU trsvUNN
  const int,
  @(mat_in_),
  @(vec_out_)
      @prou_ hbmvL sbmvL
  const int,              const int,
      @prou_ hemvL hpmvL symvL spmvL
  const int,
      @prou_ hemvL hpmvL hbmvL symvL spmvL sbmvL
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ hbmvU sbmvU
  const int,              const int,
      @prou_ hemvU hpmvU symvU spmvU
  const int,
      @prou_ hemvU hpmvU hbmvU symvU spmvU sbmvU
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ hprU hprL sprU sprL herU herL syrU syrL
  const int,
  @(rsca_in_),
  @(vec_in_),
  @(mat_out_)
      @prou_ hpr2U hpr2L spr2U spr2L her2U her2L syr2U syr2L
  const int,
  @(sca_in_),
  @(vec_in_),
  @(vec_in_),
  @(mat_out_)
      @prou_ !
      @killkeys prou_
);
 
   @endwhile
   @undef sca_in_
   @undef rsca_in_
   @undef mat_in_
   @undef mat_out_
   @undef pmat_in_
   @undef pmat_out_
   @undef vec_in_
   @undef vec_out_
   @killkeys ptyp_
@endwhile
#endif
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip ==================================================================
@skip
@rout atlas_reflevel3.h
@define rname @atlas_reflevel3.h@
@extract @(VER_ATLAS_SRC)
#ifndef ATLAS_REFLEVEL3_H
#define ATLAS_REFLEVEL3_H

#include "atlas_enum.h"
/*
 * =====================================================================
 * Prototypes for Level 3 Reference ATLAS BLAS routines
 * =====================================================================
 */
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s
      @define sca_in_    @const float@
      @define rsca_in_   @const float@
      @define mat_in_    @const float *,          const int@
      @define mat_out_   @float *,                const int@
   @ptyp_ d
      @define sca_in_    @const double@
      @define rsca_in_   @const double@
      @define mat_in_    @const double *,         const int@
      @define mat_out_   @double *,               const int@
   @ptyp_ s d
      @multidef rout_ trsm trmm syr2k syrk symm gemm
   @ptyp_ c
      @define sca_in_    @const float *@
      @define rsca_in_   @const float@
      @define mat_in_    @const float *,          const int@
      @define mat_out_   @float *,                const int@
   @ptyp_ z
      @define sca_in_    @const double *@
      @define rsca_in_   @const double@
      @define mat_in_    @const double *,         const int@
      @define mat_out_   @double *,               const int@
   @ptyp_ c z
      @multidef rout_ trsm trmm syr2k syrk symm her2k herk hemm gemm
   @ptyp_ !
   @whiledef rout_
      @addkeys prou_=@(rout_)
void       ATL_@(pre_)ref@(rout_)
(
      @prou_ gemm
  const enum ATLAS_TRANS, const enum ATLAS_TRANS,
  const int,              const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_in_),
  @(sca_in_),
  @(mat_out_)
      @prou_ hemm symm
  const enum ATLAS_SIDE,  const enum ATLAS_UPLO,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_in_),
  @(sca_in_),
  @(mat_out_)
      @prou_ herk
  const enum ATLAS_UPLO,  const enum ATLAS_TRANS,
  const int,              const int,
  @(rsca_in_),
  @(mat_in_),
  @(rsca_in_),
  @(mat_out_)
      @prou_ syrk
  const enum ATLAS_UPLO,  const enum ATLAS_TRANS,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(sca_in_),
  @(mat_out_)
      @prou_ her2k
  const enum ATLAS_UPLO,  const enum ATLAS_TRANS,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_in_),
  @(rsca_in_),
  @(mat_out_)
      @prou_ syr2k
  const enum ATLAS_UPLO,  const enum ATLAS_TRANS,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_in_),
  @(sca_in_),
  @(mat_out_)
      @prou_ trmm trsm
  const enum ATLAS_SIDE,  const enum ATLAS_UPLO,
  const enum ATLAS_TRANS, const enum ATLAS_DIAG,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ !
      @killkeys prou_
);

   @endwhile
   @undef sca_in_
   @undef rsca_in_
   @undef mat_in_
   @undef mat_out_
   @killkeys ptyp_
@endwhile
#endif
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip ==================================================================
@skip
@rout atlas_reflvl3.h
@define rname @atlas_reflvl3.h@
@extract @(VER_ATLAS_SRC)
#ifndef ATLAS_REFLVL3_H
#define ATLAS_REFLVL3_H
/*
 * =====================================================================
 * Prototypes for Level 3 Reference Internal ATLAS BLAS routines
 * =====================================================================
 */
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s
      @define sca_in_    @const float@
      @define rsca_in_   @const float@
      @define mat_in_    @const float *,          const int@
      @define mat_out_   @float *,                const int@
   @ptyp_ d
      @define sca_in_    @const double@
      @define rsca_in_   @const double@
      @define mat_in_    @const double *,         const int@
      @define mat_out_   @double *,               const int@
   @ptyp_ s d
      @multidef rout_
         trsmRUTU  trsmRUTN  trsmRUNU  trsmRUNN
         trsmRLTU  trsmRLTN  trsmRLNU  trsmRLNN
         trsmLUTU  trsmLUTN  trsmLUNU  trsmLUNN
         trsmLLTU  trsmLLTN  trsmLLNU  trsmLLNN
         trmmRUTU  trmmRUTN  trmmRUNU  trmmRUNN
         trmmRLTU  trmmRLTN  trmmRLNU  trmmRLNN
         trmmLUTU  trmmLUTN  trmmLUNU  trmmLUNN
         trmmLLTU  trmmLLTN  trmmLLNU  trmmLLNN
         syr2kUT   syr2kUN   syr2kLT   syr2kLN
         syrkUT    syrkUN    syrkLT    syrkLN
         symmRU    symmRL    symmLU    symmLL
         gemmTT    gemmTN    gemmNT    gemmNN
      @endmultidef
   @ptyp_ c
      @define sca_in_    @const float *@
      @define rsca_in_   @const float@
      @define mat_in_    @const float *,          const int@
      @define mat_out_   @float *,                const int@
   @ptyp_ z
      @define sca_in_    @const double *@
      @define rsca_in_   @const double@
      @define mat_in_    @const double *,         const int@
      @define mat_out_   @double *,               const int@
   @ptyp_ c z
      @multidef rout_
         trsmRUCU  trsmRUCN  trsmRUTU  trsmRUTN
         trsmRUNU  trsmRUNN  trsmRLCU  trsmRLCN
         trsmRLTU  trsmRLTN  trsmRLNU  trsmRLNN
         trsmLUCU  trsmLUCN  trsmLUTU  trsmLUTN
         trsmLUNU  trsmLUNN  trsmLLCU  trsmLLCN
         trsmLLTU  trsmLLTN  trsmLLNU  trsmLLNN
         trmmRUCU  trmmRUCN  trmmRUTU  trmmRUTN
         trmmRUNU  trmmRUNN  trmmRLCU  trmmRLCN
         trmmRLTU  trmmRLTN  trmmRLNU  trmmRLNN
         trmmLUCU  trmmLUCN  trmmLUTU  trmmLUTN
         trmmLUNU  trmmLUNN  trmmLLCU  trmmLLCN
         trmmLLTU  trmmLLTN  trmmLLNU  trmmLLNN
         syr2kUT   syr2kUN   syr2kLT   syr2kLN
         syrkUT    syrkUN    syrkLT    syrkLN
         symmRU    symmRL    symmLU    symmLL
         her2kUC   her2kUN   her2kLC   her2kLN
         herkUC    herkUN    herkLC    herkLN
         hemmRU    hemmRL    hemmLU    hemmLL
         gemmCC    gemmCT    gemmCN    gemmTC    gemmTT    gemmTN    gemmNC
         gemmNT    gemmNN
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      @addkeys prou_=@(rout_)
void       ATL_@(pre_)ref@(rout_)
(
      @prou_ gemmCC gemmCT gemmCN gemmTC gemmTT gemmTN gemmNC gemmNT gemmNN
  const int,              const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_in_),
  @(sca_in_),
  @(mat_out_)
      @prou_ symmRU symmRL symmLU symmLL hemmRU hemmRL hemmLU hemmLL
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_in_),
  @(sca_in_),
  @(mat_out_)
      @prou_ herkUC herkUN herkLC herkLN
  const int,              const int,
  @(rsca_in_),
  @(mat_in_),
  @(rsca_in_),
  @(mat_out_)
      @prou_ syrkUT syrkUN syrkLT syrkLN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(sca_in_),
  @(mat_out_)
      @prou_ her2kUC her2kUN her2kLC her2kLN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_in_),
  @(rsca_in_),
  @(mat_out_)
      @prou_ syr2kUT syr2kUN syr2kLT syr2kLN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_in_),
  @(sca_in_),
  @(mat_out_)
      @prou_ trsmRUCU trsmRUCN trsmRUTU trsmRUTN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ trsmRUNU trsmRUNN trsmRLCU trsmRLCN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ trsmRLTU trsmRLTN trsmRLNU trsmRLNN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ trsmLUCU trsmLUCN trsmLUTU trsmLUTN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ trsmLUNU trsmLUNN trsmLLCU trsmLLCN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ trsmLLTU trsmLLTN trsmLLNU trsmLLNN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ trmmRUCU trmmRUCN trmmRUTU trmmRUTN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ trmmRUNU trmmRUNN trmmRLCU trmmRLCN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ trmmRLTU trmmRLTN trmmRLNU trmmRLNN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ trmmLUCU trmmLUCN trmmLUTU trmmLUTN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ trmmLUNU trmmLUNN trmmLLCU trmmLLCN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ trmmLLTU trmmLLTN trmmLLNU trmmLLNN
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(mat_out_)
      @prou_ !
      @killkeys prou_
);

   @endwhile
   @undef sca_in_
   @undef rsca_in_
   @undef mat_in_
   @undef mat_out_
   @killkeys ptyp_
@endwhile
#endif
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip ==================================================================
@skip
@rout atlas_refmisc.h
@define rname @atlas_refmisc.h@
@extract @(VER_ATLAS_SRC)
#ifndef ATL_REFMISC_H
#define ATL_REFMISC_H
/*
 * =====================================================================
 * Include files
 * =====================================================================
 */
#include <math.h>
#include "atlas_enum.h"
/*
 * =====================================================================
 * #define macro constants
 * =====================================================================
 */
#define    ATL_sNONE                     (-1.0f)
#define    ATL_sNTWO                     (-2.0f)
#define    ATL_sONE                      ( 1.0f)
#define    ATL_sZERO                     ( 0.0f)

#define    ATL_dNONE                     (-1.0)
#define    ATL_dNTWO                     (-2.0)
#define    ATL_dONE                      ( 1.0)
#define    ATL_dZERO                     ( 0.0)
/*
 * =====================================================================
 * # macro functions
 * =====================================================================
 */ 
#define    Msabs( a_ ) ( ( (a_) < ATL_sZERO ) ? -(a_) : (a_) )

#define    Mszero( a_r_, a_i_ )                                        \
           ( ( (a_r_) == ATL_sZERO ) && ( (a_i_) == ATL_sZERO ) )

#define    Msone( a_r_,  a_i_ )                                        \
           ( ( (a_r_) == ATL_sONE  ) && ( (a_i_) == ATL_sZERO ) )

#define    Msscl( a_r_, a_i_, c_r_, c_i_ )                             \
           {                                                           \
              register float tmp_r_, tmp_i_;                           \
              tmp_r_ = (a_r_) * c_r_ - (a_i_) * c_i_;                  \
              tmp_i_ = (a_r_) * c_i_ + (a_i_) * c_r_;                  \
              c_r_   = tmp_r_;                                         \
              c_i_   = tmp_i_;                                         \
           }
/*
 * Msdiv performs complex division in real arithmetic
 *    a_r_ + i * a_i_ = ( a_r_ + i * a_i_ ) / ( b_r_ + i * b_i_ );
 * The algorithm is due to Robert L. Smith and can be found in D. Knuth,
 * The art of Computer Programming, Vol.2, p.195
 */
#define    Msdiv( b_r_, b_i_, a_r_, a_i_ )                             \
           {                                                           \
              register float c_i_, c_r_, tmp1_, tmp2_;                 \
              if( Msabs( b_i_ ) < Msabs( b_r_ ) )                      \
              {                                                        \
                 tmp1_ = (b_i_) / (b_r_);                              \
                 tmp2_ = (b_r_) + (b_i_) * tmp1_;                      \
                 c_r_  = ( (a_r_) + (a_i_) * tmp1_ ) / tmp2_;          \
                 c_i_  = ( (a_i_) - (a_r_) * tmp1_ ) / tmp2_;          \
              }                                                        \
              else                                                     \
              {                                                        \
                 tmp1_ = (b_r_) / (b_i_);                              \
                 tmp2_ = (b_i_) + (b_r_) * tmp1_;                      \
                 c_r_  = (  (a_i_) + (a_r_) * tmp1_ ) / tmp2_;         \
                 c_i_  = ( -(a_r_) + (a_i_) * tmp1_ ) / tmp2_;         \
              }                                                        \
              a_r_ = c_r_;                                             \
              a_i_ = c_i_;                                             \
           }

#define    Mdabs( a_ ) ( ( (a_) < ATL_dZERO ) ? -(a_) : (a_) )

#define    Mdzero( a_r_, a_i_ )                                        \
           ( ( (a_r_) == ATL_dZERO ) && ( (a_i_) == ATL_dZERO ) )

#define    Mdone( a_r_, a_i_ )                                         \
           ( ( (a_r_) == ATL_dONE  ) && ( (a_i_) == ATL_dZERO ) )

#define    Mdscl( a_r_, a_i_, c_r_, c_i_ )                             \
           {                                                           \
              register double tmp_r_, tmp_i_;                          \
              tmp_r_ = (a_r_) * c_r_ - (a_i_) * c_i_;                  \
              tmp_i_ = (a_r_) * c_i_ + (a_i_) * c_r_;                  \
              c_r_   = tmp_r_;                                         \
              c_i_   = tmp_i_;                                         \
           }
/*
 * Mddiv performs complex division in real arithmetic
 *    a_r_ + i * a_i_ = ( a_r_ + i * a_i_ ) / ( b_r_ + i * b_i_ );
 * The algorithm is due to Robert L. Smith and can be found in D. Knuth,
 * The art of Computer Programming, Vol.2, p.195
 */
#define    Mddiv( b_r_, b_i_, a_r_, a_i_ )                             \
           {                                                           \
              register double c_i_, c_r_, tmp1_, tmp2_;                \
              if( Mdabs( b_i_ ) < Mdabs( b_r_ ) )                      \
              {                                                        \
                 tmp1_ = (b_i_) / (b_r_);                              \
                 tmp2_ = (b_r_) + (b_i_) * tmp1_;                      \
                 c_r_  = ( (a_r_) + (a_i_) * tmp1_ ) / tmp2_;          \
                 c_i_  = ( (a_i_) - (a_r_) * tmp1_ ) / tmp2_;          \
              }                                                        \
              else                                                     \
              {                                                        \
                 tmp1_ = (b_r_) / (b_i_);                              \
                 tmp2_ = (b_i_) + (b_r_) * tmp1_;                      \
                 c_r_  = (  (a_i_) + (a_r_) * tmp1_ ) / tmp2_;         \
                 c_i_  = ( -(a_r_) + (a_i_) * tmp1_ ) / tmp2_;         \
              }                                                        \
              a_r_ = c_r_;                                             \
              a_i_ = c_i_;                                             \
           }

#define    Mmin( a_, b_ ) ( ( (a_) < (b_) ) ?  (a_) : (b_) )

#define    Mmax( a_, b_ ) ( ( (a_) > (b_) ) ?  (a_) : (b_) )

#define    Mmul( a_r_, a_i_, b_r_, b_i_, c_r_, c_i_ )                  \
           {                                                           \
              c_r_ = (a_r_) * (b_r_) - (a_i_) * (b_i_);                \
              c_i_ = (a_r_) * (b_i_) + (a_i_) * (b_r_);                \
           }

#define    Mmla( a_r_, a_i_, b_r_, b_i_, c_r_, c_i_ )                  \
           {                                                           \
              c_r_ += (a_r_) * (b_r_) - (a_i_) * (b_i_);               \
              c_i_ += (a_r_) * (b_i_) + (a_i_) * (b_r_);               \
           }

#define    Mmls( a_r_, a_i_, b_r_, b_i_, c_r_, c_i_ )                  \
           {                                                           \
              c_r_ -= (a_r_) * (b_r_) - (a_i_) * (b_i_);               \
              c_i_ -= (a_r_) * (b_i_) + (a_i_) * (b_r_);               \
           }

#define    Mset( a_r_, a_i_, b_r_, b_i_ )                              \
           {                                                           \
              b_r_ = (a_r_);                                           \
              b_i_ = (a_i_);                                           \
           }

#define    Mselscal( al_, a_ )                                         \
           {                                                           \
              if(      (al_) == ATL_sZERO ) { (a_)  = ATL_sZERO; }     \
              else if( (al_) != ATL_sONE  ) { (a_) *= (al_);     }     \
           }

#define    Mdelscal( al_, a_ )                                         \
           {                                                           \
              if(      (al_) == ATL_dZERO ) { (a_)  = ATL_dZERO; }     \
              else if( (al_) != ATL_dONE  ) { (a_) *= (al_);     }     \
           }

#define    Mcelscal( al_r_, al_i_, a_r_, a_i_ )                        \
           {                                                           \
              if( Mszero( (al_r_), (al_i_) ) )                         \
              { (a_r_) = (a_i_) = ATL_sZERO; }                         \
              else if( ! Msone( (al_r_), (al_i_) ) )                   \
              { Msscl( (al_r_), (al_i_), (a_r_), (a_i_) ); }           \
           }

#define    Mzelscal( al_r_, al_i_, a_r_, a_i_ )                        \
           {                                                           \
              if( Mdzero( (al_r_), (al_i_) ) )                         \
              { (a_r_) = (a_i_) = ATL_dZERO; }                         \
              else if( ! Mdone( (al_r_), (al_i_) ) )                   \
              { Mdscl( (al_r_), (al_i_), (a_r_), (a_i_) ); }           \
           }

#define    Msvscal( n_, al_, x_, incx_ )                               \
           {                                                           \
            int i_, ix_;                                               \
            if(      (al_) == ATL_sZERO )                              \
            {                                                          \
             for( i_ = 0, ix_ = 0; i_ < (n_); i_++, ix_ += (incx_) )   \
             { (x_)[ix_] = ATL_sZERO; }                                \
            }                                                          \
            else if( (al_) != ATL_sONE )                               \
            {                                                          \
             for( i_ = 0, ix_ = 0; i_ < (n_); i_++, ix_ += (incx_) )   \
             { (x_)[ix_] *= (al_); }                                   \
            }                                                          \
           }

#define    Mdvscal( n_, al_, x_, incx_ )                               \
           {                                                           \
            int i_, ix_;                                               \
            if(      (al_) == ATL_dZERO )                              \
            {                                                          \
             for( i_ = 0, ix_ = 0; i_ < (n_); i_++, ix_ += (incx_) )   \
             { (x_)[ix_] = ATL_dZERO; }                                \
            }                                                          \
            else if( (al_) != ATL_dONE )                               \
            {                                                          \
             for( i_ = 0, ix_ = 0; i_ < (n_); i_++, ix_ += (incx_) )   \
             { (x_)[ix_] *= (al_); }                                   \
            }                                                          \
           }

#define    Mcvscal( n_, al_, x_, incx_ )                               \
           {                                                           \
            int i_, ix_, incx2_ = ( 2 * (incx_) );                     \
            if( Mszero( (al_)[0], (al_)[1] ) )                         \
            {                                                          \
             for( i_ = 0, ix_ = 0; i_ < (n_); i_++, ix_ += (incx2_) )  \
             { (x_)[ix_] = (x_)[ix_+1] = ATL_sZERO; }                  \
            }                                                          \
            else if( ! Msone( (al_)[0], (al_)[1] ) )                   \
            {                                                          \
             for( i_ = 0, ix_ = 0; i_ < (n_); i_++, ix_ += (incx2_) )  \
             { Msscl( (al_)[0], (al_)[1], (x_)[ix_], (x_)[ix_+1] ); }  \
            }                                                          \
           }

#define    Mzvscal( n_, al_, x_, incx_ )                               \
           {                                                           \
            int i_, ix_, incx2_ = ( 2 * (incx_) );                     \
            if( Mdzero( (al_)[0], (al_)[1] ) )                         \
            {                                                          \
             for( i_ = 0, ix_ = 0; i_ < (n_); i_++, ix_ += (incx2_) )  \
             { (x_)[ix_] = (x_)[ix_+1] = ATL_dZERO; }                  \
            }                                                          \
            else if( ! Mdone( (al_)[0], (al_)[1] ) )                   \
            {                                                          \
             for( i_ = 0, ix_ = 0; i_ < (n_); i_++, ix_ += (incx2_) )  \
             { Mdscl( (al_)[0], (al_)[1], (x_)[ix_], (x_)[ix_+1] ); }  \
            }                                                          \
           }

#define    Msgescal( m_, n_, al_, a_, lda_ )                           \
           {                                                           \
            int i_, iaij_, j_, jaj_;                                   \
            if(      (al_) == ATL_sZERO )                              \
            {                                                          \
             for( j_ = 0, jaj_ = 0; j_ < (n_); j_++, jaj_ += (lda_) )  \
             {                                                         \
              for( i_ = 0, iaij_ = jaj_; i_ < (m_); i_++, iaij_ += 1 ) \
              { (a_)[iaij_] = ATL_sZERO; }                             \
             }                                                         \
            }                                                          \
            else if( (al_) != ATL_sONE )                               \
            {                                                          \
             for( j_ = 0, jaj_ = 0; j_ < (n_); j_++, jaj_ += (lda_) )  \
             {                                                         \
              for( i_ = 0, iaij_ = jaj_; i_ < (m_); i_++, iaij_ += 1 ) \
              { (a_)[iaij_] *= (al_); }                                \
             }                                                         \
            }                                                          \
           }

#define    Mdgescal( m_, n_, al_, a_, lda_ )                           \
           {                                                           \
            int i_, iaij_, j_, jaj_;                                   \
            if(      (al_) == ATL_dZERO )                              \
            {                                                          \
             for( j_ = 0, jaj_ = 0; j_ < (n_); j_++, jaj_ += (lda_) )  \
             {                                                         \
              for( i_ = 0, iaij_ = jaj_; i_ < (m_); i_++, iaij_ += 1 ) \
              { (a_)[iaij_] = ATL_dZERO; }                             \
             }                                                         \
            }                                                          \
            else if( (al_) != ATL_dONE )                               \
            {                                                          \
             for( j_ = 0, jaj_ = 0; j_ < (n_); j_++, jaj_ += (lda_) )  \
             {                                                         \
              for( i_ = 0, iaij_ = jaj_; i_ < (m_); i_++, iaij_ += 1 ) \
              { (a_)[iaij_] *= (al_); }                                \
             }                                                         \
            }                                                          \
           }

#define    Mcgescal( m_, n_, al_, a_, lda_ )                           \
           {                                                           \
            int i_, iaij_, j_, jaj_, lda2_ = ( (lda_) << 1 );          \
            if( Mszero( (al_)[0], (al_)[1] ) )                         \
            {                                                          \
             for( j_ = 0, jaj_ = 0; j_ < (n_); j_++, jaj_ += lda2_ )   \
             {                                                         \
              for( i_ = 0, iaij_ = jaj_; i_ < (m_); i_++, iaij_ += 2 ) \
              { (a_)[iaij_] = (a_)[iaij_+1] = ATL_sZERO; }             \
             }                                                         \
            }                                                          \
            else if( ! Msone( (al_)[0], (al_)[1] ) )                   \
            {                                                          \
             for( j_ = 0, jaj_ = 0; j_ < (n_); j_++, jaj_ += lda2_ )   \
             {                                                         \
              for( i_ = 0, iaij_ = jaj_; i_ < (m_); i_++, iaij_ += 2 ) \
              {                                                        \
              Msscl( (al_)[0], (al_)[1], (a_)[iaij_], (a_)[iaij_+1] ); \
              }                                                        \
             }                                                         \
            }                                                          \
           }

#define    Mzgescal( m_, n_, al_, a_, lda_ )                           \
           {                                                           \
            int i_, iaij_, j_, jaj_, lda2_ = ( (lda_) << 1 );          \
            if( Mdzero( (al_)[0], (al_)[1] ) )                         \
            {                                                          \
             for( j_ = 0, jaj_ = 0; j_ < (n_); j_++, jaj_ += lda2_ )   \
             {                                                         \
              for( i_ = 0, iaij_ = jaj_; i_ < (m_); i_++, iaij_ += 2 ) \
              { (a_)[iaij_] = (a_)[iaij_+1] = ATL_dZERO; }             \
             }                                                         \
            }                                                          \
            else if( ! Mdone( (al_)[0], (al_)[1] ) )                   \
            {                                                          \
             for( j_ = 0, jaj_ = 0; j_ < (n_); j_++, jaj_ += lda2_ )   \
             {                                                         \
              for( i_ = 0, iaij_ = jaj_; i_ < (m_); i_++, iaij_ += 2 ) \
              {                                                        \
              Mdscl( (al_)[0], (al_)[1], (a_)[iaij_], (a_)[iaij_+1] ); \
              }                                                        \
             }                                                         \
            }                                                          \
           }

#endif
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip
@rout !
@skip
@skip ==================================================================
@skip
@undef abs
@undef div
@undef iso
@undef isz
@undef scl
@skip
@undef RF1_INCLUDE
@undef RF2_INCLUDE
@undef RF3_INCLUDE
@skip
@skip ==================================================================
@skip
