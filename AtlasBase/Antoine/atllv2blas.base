@skip ==================================================================
@skip ATLAS / L2 BLAS                                               AP00
@skip Last modification : 05/28/00
@skip ==================================================================
@skip File layout:
@skip
@skip lv2_inc,   ATL_gbmv,  ATL_gpmv,  ATL_gpr,   ATL_gprc,  ATL_gpru,
@skip ATL_sbmv,  ATL_hbmv,  ATL_spmv,  ATL_hpmv,  ATL_symv,  ATL_hemv,
@skip ATL_spr,   ATL_hpr,   ATL_syr,   ATL_her,
@skip ATL_spr2,  ATL_hpr2,  ATL_syr2,  ATL_her2,
@skip ATL_tbmv,  ATL_tpmv,  ATL_trmv,  ATL_tbsv,  ATL_tpsv,  ATL_trsv,
@skip atlas_level2.h,       Make.l2.
@skip ==================================================================
@skip Global define statements
@skip
@extract -addkeys -b @(BASEdir)include/atlas.inc lan=C type=none
@skip ==================================================================
@skip Specific define statements
@skip
@define LV2_INCLUDE @-addkeys -b @(srcdir)/atllv2blas.base rout=lv2_inc@
@skip ==================================================================
@skip
@rout lv2_inc
@extract @(INCLUDE)
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_kernel2.h"
#include "atlas_lvl2.h"
#include "atlas_mv.h"
#include "atlas_r1.h"

#include "atlas_reflvl2.h"          /* temporary for building purposes */
#include "atlas_reflevel2.h"        /* used for gbmv, gpmv and gpr.    */
@skip
@skip ==================================================================
@skip
@rout ATL_gbmv
@define rname @Mjoin( PATL, gbmv )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)

void @(rname)
(
   const enum ATLAS_TRANS     TRANS,
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
@extract @(EXECUTABLE_STATEMENT)
   if( ( M == 0 ) || ( N == 0 ) ||
       ( ( SCALAR_IS_ZERO( ALPHA ) ) && ( SCALAR_IS_ONE( BETA ) ) ) ) return;

   if( SCALAR_IS_ZERO( ALPHA ) )
   {
      #ifdef TCPLX
         const int Ny = (TRANS == AtlasNoTrans || TRANS == AtlasConj) ? M : N;
      #else
         const int Ny = (TRANS == AtlasNoTrans) ? M : N;
      #endif
      if( SCALAR_IS_ZERO( BETA ) ) 
         Mjoin( PATL, zero )( Ny, Y, INCY );
      else if( !( SCALAR_IS_ONE( BETA ) ) ) 
         Mjoin( PATL, scal )( Ny, BETA, Y, INCY );
      return;
   }
 
   #ifdef TCPLX
   if (TRANS == AtlasNoTrans || TRANS == AtlasConj)
   #else
   if (TRANS == AtlasNoTrans)
   #endif
      Mjoin( PATL, refgbmv )( TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA,
                              Y, INCY );
   else
      Mjoin( PATL, refgbmv )( TRANS, N, M, KL, KU, ALPHA, A, LDA, X, INCX, BETA,
                              Y, INCY );
@extract @(END_OF_ROUTINE)
@undef rname

void Mjoin( PATL, gbmvN_a1_x1_b0_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#define    zero               ATL_rzero
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   Mjoin( PATL, gbmv )( AtlasNoTrans, M, N, KL, KU, one, A, LDA, X, 1,
                        zero, Y, 1 );
}

void Mjoin( PATL, gbmvT_a1_x1_b0_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#define    zero               ATL_rzero
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   Mjoin( PATL, gbmv )( AtlasTrans, M, N, KL, KU, one, A, LDA, X, 1,
                        zero, Y, 1 );
}

#ifdef TCPLX
void Mjoin( PATL, gbmvC_a1_x1_b0_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#define    zero               ATL_rzero
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   Mjoin( PATL, gbmv )( AtlasConjTrans, M, N, KL, KU, one, A, LDA, X, 1,
                        zero, Y, 1 );
}

void Mjoin( PATL, gbmvNc_a1_x1_b0_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#define    zero               ATL_rzero
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   Mjoin( PATL, gbmv )( AtlasConj, M, N, KL, KU, one, A, LDA, X, 1,
                        zero, Y, 1 );
}

#endif

#ifdef TCPLX
void Mjoin( PATL, gbmvN_a1_x1_bXi0_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   TYPE                       beta[2];

   beta[0] = *BETA; beta[1] = ATL_rzero;
   Mjoin( PATL, gbmv )( AtlasNoTrans, M, N, KL, KU, one, A, LDA, X, 1,
                        beta, Y, 1 );
}

void Mjoin( PATL, gbmvT_a1_x1_bXi0_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   TYPE                       beta[2];

   beta[0] = *BETA; beta[1] = ATL_rzero;
   Mjoin( PATL, gbmv )( AtlasTrans, M, N, KL, KU, one, A, LDA, X, 1,
                        beta, Y, 1 );
}

void Mjoin( PATL, gbmvC_a1_x1_bXi0_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one [2] = { ATL_rone, ATL_rzero };
   TYPE                       beta[2];

   beta[0] = *BETA; beta[1] = ATL_rzero;
   Mjoin( PATL, gbmv )( AtlasConjTrans, M, N, KL, KU, one, A, LDA, X, 1,
                        beta, Y, 1 );
}

void Mjoin( PATL, gbmvNc_a1_x1_bXi0_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one [2] = { ATL_rone, ATL_rzero };
   TYPE                       beta[2];

   beta[0] = *BETA; beta[1] = ATL_rzero;
   Mjoin( PATL, gbmv )( AtlasConj, M, N, KL, KU, one, A, LDA, X, 1,
                        beta, Y, 1 );
}

#endif

void Mjoin( PATL, gbmvN_a1_x1_b1_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gbmv )( AtlasNoTrans, M, N, KL, KU, one, A, LDA, X, 1,
                        one, Y, 1 );
}

void Mjoin( PATL, gbmvT_a1_x1_b1_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gbmv )( AtlasTrans, M, N, KL, KU, one, A, LDA, X, 1,
                        one, Y, 1 );
}

#ifdef TCPLX
void Mjoin( PATL, gbmvC_a1_x1_b1_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gbmv )( AtlasConjTrans, M, N, KL, KU, one, A, LDA, X, 1,
                        one, Y, 1 );
}

void Mjoin( PATL, gbmvNc_a1_x1_b1_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gbmv )( AtlasConj, M, N, KL, KU, one, A, LDA, X, 1, one, Y, 1 );
}

#endif

void Mjoin( PATL, gbmvN_a1_x1_bX_y1  )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gbmv )( AtlasNoTrans, M, N, KL, KU, one, A, LDA, X, 1,
                        BETA, Y, 1 );
}

void Mjoin( PATL, gbmvT_a1_x1_bX_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gbmv )( AtlasTrans, M, N, KL, KU, one, A, LDA, X, 1,
                        BETA, Y, 1 );
}

#ifdef TCPLX

void Mjoin( PATL, gbmvC_a1_x1_bX_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };

   Mjoin( PATL, gbmv )( AtlasConjTrans, M, N, KL, KU, one, A, LDA, X, 1,
                        BETA, Y, 1 );
}

void Mjoin( PATL, gbmvNc_a1_x1_bX_y1 )
(
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };

   Mjoin( PATL, gbmv )( AtlasConj, M, N, KL, KU, one, A, LDA, X, 1,
                        BETA, Y, 1 );
}

#endif
@skip
@skip ==================================================================
@skip
@rout ATL_gpmv
@define rname @Mjoin( PATL, gpmv )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)

void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
@extract @(EXECUTABLE_STATEMENT)
   if( ( M == 0 ) || ( N == 0 ) ||
       ( ( SCALAR_IS_ZERO( ALPHA ) ) && ( SCALAR_IS_ONE( BETA ) ) ) ) return;

   if( SCALAR_IS_ZERO( ALPHA ) )
   {
      if( !( SCALAR_IS_ONE( BETA ) ) ) Mjoin( PATL, scal )( M, BETA, Y, INCY );
      return;
   }
 
   Mjoin( PATL, refgpmv )( UPLO, TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA,
                           Y, INCY );
@extract @(END_OF_ROUTINE)
@undef rname

void Mjoin( PATL, gpmvLN_a1_x1_b0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#define    zero               ATL_rzero
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasLower, AtlasNoTrans, M, N, one, A, LDA,
                        X, 1, zero, Y, 1 );
}

void Mjoin( PATL, gpmvLT_a1_x1_b0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#define    zero               ATL_rzero
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasLower, AtlasTrans, M, N, one, A, LDA, X, 1,
                        zero, Y, 1 );
}

#ifdef TCPLX
void Mjoin( PATL, gpmvLC_a1_x1_b0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#define    zero               ATL_rzero
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasLower, AtlasConjTrans, M, N, one, A, LDA, X, 1,
                        zero, Y, 1 );
}

void Mjoin( PATL, gpmvLNc_a1_x1_b0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#define    zero               ATL_rzero
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasLower, AtlasConj, M, N, one, A, LDA, X, 1,
                        zero, Y, 1 );
}

#endif

#ifdef TCPLX
void Mjoin( PATL, gpmvLN_a1_x1_bXi0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   TYPE                       beta[2];

   beta[0] = *BETA; beta[1] = ATL_rzero;
   Mjoin( PATL, gpmv )( AtlasLower, AtlasNoTrans, M, N, one, A, LDA, X, 1,
                        beta, Y, 1 );
}

void Mjoin( PATL, gpmvLT_a1_x1_bXi0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   TYPE                       beta[2];

   beta[0] = *BETA; beta[1] = ATL_rzero;
   Mjoin( PATL, gpmv )( AtlasLower, AtlasTrans, M, N, one, A, LDA, X, 1,
                        beta, Y, 1 );
}

void Mjoin( PATL, gpmvLC_a1_x1_bXi0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one [2] = { ATL_rone, ATL_rzero };
   TYPE                       beta[2];

   beta[0] = *BETA; beta[1] = ATL_rzero;
   Mjoin( PATL, gpmv )( AtlasLower, AtlasConjTrans, M, N, one, A, LDA, X, 1,
                        beta, Y, 1 );
}

void Mjoin( PATL, gpmvLNc_a1_x1_bXi0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one [2] = { ATL_rone, ATL_rzero };
   TYPE                       beta[2];

   beta[0] = *BETA; beta[1] = ATL_rzero;
   Mjoin( PATL, gpmv )( AtlasLower, AtlasConj, M, N, one, A, LDA, X, 1,
                        beta, Y, 1 );
}

#endif

void Mjoin( PATL, gpmvLN_a1_x1_b1_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasLower, AtlasNoTrans, M, N, one, A, LDA, X, 1,
                        one, Y, 1 );
}

void Mjoin( PATL, gpmvLT_a1_x1_b1_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasLower, AtlasTrans, M, N, one, A, LDA, X, 1,
                        one, Y, 1 );
}

#ifdef TCPLX
void Mjoin( PATL, gpmvLC_a1_x1_b1_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasLower, AtlasConjTrans, M, N, one, A, LDA, X, 1,
                        one, Y, 1 );
}

void Mjoin( PATL, gpmvLNc_a1_x1_b1_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasLower, AtlasConj, M, N, one, A, LDA, X, 1,
                        one, Y, 1 );
}

#endif

void Mjoin( PATL, gpmvLN_a1_x1_bX_y1  )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasLower, AtlasNoTrans, M, N, one, A, LDA, X, 1,
                        BETA, Y, 1 );
}

void Mjoin( PATL, gpmvLT_a1_x1_bX_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasLower, AtlasTrans, M, N, one, A, LDA, X, 1,
                        BETA, Y, 1 );
}

#ifdef TCPLX

void Mjoin( PATL, gpmvLC_a1_x1_bX_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };

   Mjoin( PATL, gpmv )( AtlasLower, AtlasConjTrans, M, N, one, A, LDA, X, 1,
                        BETA, Y, 1 );
}

void Mjoin( PATL, gpmvLNc_a1_x1_bX_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };

   Mjoin( PATL, gpmv )( AtlasLower, AtlasConj, M, N, one, A, LDA, X, 1,
                        BETA, Y, 1 );
}

#endif

void Mjoin( PATL, gpmvUN_a1_x1_b0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#define    zero               ATL_rzero
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasNoTrans, M, N, one, A, LDA,
                        X, 1, zero, Y, 1 );
}

void Mjoin( PATL, gpmvUT_a1_x1_b0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#define    zero               ATL_rzero
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasTrans, M, N, one, A, LDA, X, 1,
                        zero, Y, 1 );
}

#ifdef TCPLX
void Mjoin( PATL, gpmvUC_a1_x1_b0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#define    zero               ATL_rzero
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasConjTrans, M, N, one, A, LDA, X, 1,
                        zero, Y, 1 );
}

void Mjoin( PATL, gpmvUNc_a1_x1_b0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#define    zero               ATL_rzero
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasConj, M, N, one, A, LDA, X, 1,
                        zero, Y, 1 );
}

#endif

#ifdef TCPLX
void Mjoin( PATL, gpmvUN_a1_x1_bXi0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   TYPE                       beta[2];

   beta[0] = *BETA; beta[1] = ATL_rzero;
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasNoTrans, M, N, one, A, LDA, X, 1,
                        beta, Y, 1 );
}

void Mjoin( PATL, gpmvUT_a1_x1_bXi0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   TYPE                       beta[2];

   beta[0] = *BETA; beta[1] = ATL_rzero;
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasTrans, M, N, one, A, LDA, X, 1,
                        beta, Y, 1 );
}

void Mjoin( PATL, gpmvUC_a1_x1_bXi0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one [2] = { ATL_rone, ATL_rzero };
   TYPE                       beta[2];

   beta[0] = *BETA; beta[1] = ATL_rzero;
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasConjTrans, M, N, one, A, LDA, X, 1,
                        beta, Y, 1 );
}

void Mjoin( PATL, gpmvUNc_a1_x1_bXi0_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one [2] = { ATL_rone, ATL_rzero };
   TYPE                       beta[2];

   beta[0] = *BETA; beta[1] = ATL_rzero;
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasConj, M, N, one, A, LDA, X, 1,
                        beta, Y, 1 );
}

#endif

void Mjoin( PATL, gpmvUN_a1_x1_b1_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasNoTrans, M, N, one, A, LDA, X, 1,
                        one, Y, 1 );
}

void Mjoin( PATL, gpmvUT_a1_x1_b1_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasTrans, M, N, one, A, LDA, X, 1,
                        one, Y, 1 );
}

#ifdef TCPLX
void Mjoin( PATL, gpmvUC_a1_x1_b1_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasConjTrans, M, N, one, A, LDA, X, 1,
                        one, Y, 1 );
}

void Mjoin( PATL, gpmvUNc_a1_x1_b1_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasConj, M, N, one, A, LDA, X, 1,
                        one, Y, 1 );
}

#endif

void Mjoin( PATL, gpmvUN_a1_x1_bX_y1  )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasNoTrans, M, N, one, A, LDA, X, 1,
                        BETA, Y, 1 );
}

void Mjoin( PATL, gpmvUT_a1_x1_bX_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   Mjoin( PATL, gpmv )( AtlasUpper, AtlasTrans, M, N, one, A, LDA, X, 1,
                        BETA, Y, 1 );
}

#ifdef TCPLX

void Mjoin( PATL, gpmvUC_a1_x1_bX_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };

   Mjoin( PATL, gpmv )( AtlasUpper, AtlasConjTrans, M, N, one, A, LDA, X, 1,
                        BETA, Y, 1 );
}

void Mjoin( PATL, gpmvUNc_a1_x1_bX_y1 )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
) 
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };

   Mjoin( PATL, gpmv )( AtlasUpper, AtlasConj, M, N, one, A, LDA, X, 1,
                        BETA, Y, 1 );
}

#endif
@skip
@skip ==================================================================
@skip
@rout ATL_gpr
@define rname @Mjoin( PATL, gpr )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)

void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
@extract @(EXECUTABLE_STATEMENT)
   if( ( M == 0 ) || ( N == 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;

   Mjoin( PATL, refgpr )( UPLO, M, N, ALPHA, X, INCX, Y, INCY, A, LDA );
@extract @(END_OF_ROUTINE)
@undef rname

void Mjoin( PATL, gpr1L_a1_x1_yX )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{ Mjoin( PATL, gpr )( AtlasLower, M, N, ATL_rone, X, 1, Y, INCY, A, LDA ); }

void Mjoin( PATL, gpr1U_a1_x1_yX )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{ Mjoin( PATL, gpr )( AtlasUpper, M, N, ATL_rone, X, 1, Y, INCY, A, LDA ); }
@skip
@skip ==================================================================
@skip
@rout ATL_gprc
@define rname @Mjoin( PATL, gprc )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)

void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
@extract @(EXECUTABLE_STATEMENT)
   if( ( M == 0 ) || ( N == 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;

   Mjoin( PATL, refgprc )( UPLO, M, N, ALPHA, X, INCX, Y, INCY, A, LDA );
@extract @(END_OF_ROUTINE)
@undef rname

void Mjoin( PATL, gpr1cL_a1_x1_yX )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };

   Mjoin( PATL, gprc )( AtlasLower, M, N, one, X, 1, Y, INCY, A, LDA );
}

void Mjoin( PATL, gpr1cU_a1_x1_yX )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };

   Mjoin( PATL, gprc )( AtlasUpper, M, N, one, X, 1, Y, INCY, A, LDA );
}
@skip
@skip ==================================================================
@skip
@rout ATL_gpru
@define rname @Mjoin( PATL, gpru )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)

void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
@extract @(EXECUTABLE_STATEMENT)
   if( ( M == 0 ) || ( N == 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;

   Mjoin( PATL, refgpru )( UPLO, M, N, ALPHA, X, INCX, Y, INCY, A, LDA );
@extract @(END_OF_ROUTINE)
@undef rname

void Mjoin( PATL, gpr1uL_a1_x1_yX )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };

   Mjoin( PATL, gpru )( AtlasLower, M, N, one, X, 1, Y, INCY, A, LDA );
}

void Mjoin( PATL, gpr1uU_a1_x1_yX )
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };

   Mjoin( PATL, gpru )( AtlasUpper, M, N, one, X, 1, Y, INCY, A, LDA );
}
@skip
@skip ==================================================================
@skip
@rout ATL_sbmv
@define sbhb    @sb@
@rout ATL_hbmv
@define sbhb    @hb@
@rout ATL_sbmv ATL_hbmv
@define rname @Mjoin( PATL, @(sbhb)mv )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)

void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const int                  K,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*gbmv0)( const int, const int, const int,
                              const int, const SCALAR, const TYPE *, const int,
                              const TYPE *, const int, const SCALAR, TYPE *,
                              const int );
   void                       (*gbmv1)( const int, const int, const int,
                              const int, const SCALAR, const TYPE *, const int,
                              const TYPE *, const int, const SCALAR, TYPE *,
                              const int );
   void                       (*gbmvN)( const int, const int, const int,
                              const int, const SCALAR, const TYPE *, const int,
                              const TYPE *, const int, const SCALAR, TYPE *,
                              const int );
#ifdef TREAL
   TYPE                       alphaY, beta0;
#define lda2                  LDA
#define one                   ATL_rone
#define zero                  ATL_rzero
   void                       * vx = NULL, * vy = NULL;
   TYPE                       * x, * y, * y00;
#else
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
   const TYPE                 * alphaY, * beta0;
   void                       * vx = NULL, * vy = NULL;
   TYPE                       * x, * y, * y00;
   const int                  lda2 = ( LDA SHIFT );
#endif
   int                        ian, ia, j, ja, jan, k, kb, kl, ku, ma, mb,
                              mb1, n, na, nb;
@extract @(EXECUTABLE_STATEMENT)
   if( N == 0 ) return;
 
   if( SCALAR_IS_ZERO( ALPHA ) )
   {
      if( !( SCALAR_IS_ONE( BETA ) ) ) Mjoin( PATL, scal )( N, BETA, Y, INCY );
      return;
   }
   Mjoin(PATL,ref@(sbhb)mv)(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY);
 
@beginskip
   if( ( INCX != 1 ) || ( ( INCY == 1 ) && !( SCALAR_IS_ONE( ALPHA ) ) ) )
   {
      vx = (void *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vx ); x = ATL_AlignPtr( vx );
      Mjoin( PATL, cpsc )( N, ALPHA, X, INCX, x, 1 );
      alphaY = one;
   }
   else { x = (TYPE *)(X); alphaY = ALPHA; }
 
   if( ( INCY != 1 ) || !( SCALAR_IS_ONE( alphaY ) ) )
   {
      vy = malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vy ); y00 = y = ATL_AlignPtr( vy );
      beta0 = zero;
   }
   else { y00 = y = (TYPE *)(Y); beta0 = BETA; }

@rout ATL_sbmv
   if(      SCALAR_IS_ZERO( beta0 ) ) gbmv0 = Mjoin( PATL, gbmvT_a1_x1_b0_y1 );
   else if( SCALAR_IS_ONE ( beta0 ) ) gbmv0 = Mjoin( PATL, gbmvT_a1_x1_b1_y1 );
   else                               gbmv0 = Mjoin( PATL, gbmvT_a1_x1_bX_y1 );
   gbmv1 = Mjoin( PATL, gbmvT_a1_x1_b1_y1 );
@rout ATL_hbmv
   if(      SCALAR_IS_ZERO( beta0 ) ) gbmv0 = Mjoin( PATL, gbmvC_a1_x1_b0_y1 );
   else if( SCALAR_IS_ONE ( beta0 ) ) gbmv0 = Mjoin( PATL, gbmvC_a1_x1_b1_y1 );
   else                               gbmv0 = Mjoin( PATL, gbmvC_a1_x1_bX_y1 );
   gbmv1 = Mjoin( PATL, gbmvC_a1_x1_b1_y1 );
@rout ATL_sbmv ATL_hbmv
   gbmvN = Mjoin( PATL, gbmvN_a1_x1_b1_y1 );
 
   ATL_GetPartSBMV( A, LDA, &mb, &nb );

   mb1 = N - ( ( N - 1 ) / mb ) * mb;
 
   if( UPLO == AtlasUpper )
   {
      for( n = N - mb, j = 0; n > 0; n -= mb, j += mb )
      {
         Mjoin( PATL, @(sbhb)mvU )( mb, K, A+j*lda2, LDA, x+(j SHIFT),
                               beta0, y+(j SHIFT) );
         na = N - j - mb; na = Mmin( na, K );
         for( k = 0; k < na; k += nb )
         {
            kb  = na - k; kb = Mmin( kb, nb );
            ian = j + mb + k; ia = mb - K + k; ia = j + Mmax( ia, 0 );
            ma  = ian - ia - k; kl = ma - 1;   kl = Mmax( kl, 0 );
            ku  = K - k - 1 - kl; ku = Mmax( ku, 0 );
            gbmv0( kb, ma, kl, ku, one, A+ian*lda2, LDA, x+(ia  SHIFT), 1,
                   beta0, y+(ian SHIFT), 1 );
            gbmvN( ma, kb, kl, ku, one, A+ian*lda2, LDA, x+(ian SHIFT), 1,
                   one,   y+(ia  SHIFT), 1 );
         }
         if( !( SCALAR_IS_ONE( beta0 ) ) && ( n > na ) )
            Mjoin( PATL, scal )( n-na, beta0, y+((j+mb+na) SHIFT), 1 );
         beta0 = one; gbmv0 = gbmv1;
      }
      Mjoin( PATL, @(sbhb)mvU )( mb1, K, A+j*lda2, LDA, x+(j SHIFT), beta0,
                            y+(j SHIFT) );
   }
   else
   {
      for( jan = N - mb; jan > 0; jan -= mb )
      {
         Mjoin( PATL, @(sbhb)mvL )( mb, K, A+jan*lda2, LDA, x+(jan SHIFT),
                               beta0, y+(jan SHIFT) );
         ja = jan - K; na = jan - ( ja = Mmax( ja, 0 ) );
         if( !( SCALAR_IS_ONE( beta0 ) ) && ( ja > 0 ) )
            Mjoin( PATL, scal )( ja, beta0, y, 1 );
 
         for( k = 0; k < na; k += nb )
         {
            kb = na - k; kb = Mmin( kb, nb );
            ja = jan - K; ja = k + Mmax( ja, 0 ); ku = jan - ja; kl = K - ku; 
            kl = Mmax( kl, 0 ); ma = k + kl + kb; ma = Mmin( ma, mb );
            gbmv0( kb, ma, kl, ku, one, A+ja*lda2, LDA, x+(jan SHIFT), 1,
                   beta0, y+(ja  SHIFT), 1 );
            gbmvN( ma, kb, kl, ku, one, A+ja*lda2, LDA, x+(ja  SHIFT), 1,
                   one,   y+(jan SHIFT), 1 );
         }
         beta0 = one; gbmv0 = gbmv1;
      }
      Mjoin( PATL, @(sbhb)mvL )( mb1, K, A, LDA, x, beta0, y );
   }
 
   if( vx ) free( vx );
   if( vy )
   { Mjoin( PATL, axpby )( N, alphaY, y00, 1, BETA, Y, INCY ); free( vy ); }
@endskip
@extract @(END_OF_ROUTINE)
@undef sbhb
@undef rname
@skip
@skip ==================================================================
@skip
@rout ATL_spmv
@define sphp @sp@
@rout ATL_hpmv
@define sphp @hp@
@rout ATL_spmv ATL_hpmv
@define rname @Mjoin( PATL, @(sphp)mv )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)

void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*gpmv0)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
   void                       (*gpmv1)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
   void                       (*gpmvN)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
#ifdef TREAL
   TYPE                       alphaY, beta0;
#define one                   ATL_rone
#define zero                  ATL_rzero
#else
   const TYPE                 * alphaY, * beta0;
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
#endif
   void                       * vx = NULL, * vy = NULL;
   TYPE                       * A0, * A1, * x, * x0, * x1, * y, * y00, * y0,
                              * y1;
   int                        incXY, incXY1, j, jb, lda, lda0, lda1, mb, mb1,
                              n, nb;
@extract @(EXECUTABLE_STATEMENT)
   if( N == 0 ) return;

   if( SCALAR_IS_ZERO( ALPHA ) )
   {
      if( !( SCALAR_IS_ONE( BETA ) ) ) Mjoin( PATL, scal )( N, BETA, Y, INCY );
      return;
   }
   Mjoin(PATL,ref@(sphp)mv)(UPLO, N, ALPHA, A, X, INCX, BETA, Y, INCY);

@beginskip
   if( ( INCX != 1 ) || ( ( INCY == 1 ) && !( SCALAR_IS_ONE( ALPHA ) ) ) )
   {
      vx = (void *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vx ); x = ATL_AlignPtr( vx );
      Mjoin( PATL, cpsc )( N, ALPHA, X, INCX, x, 1 );
      alphaY = one; 
   }
   else { x = (TYPE *)(X); alphaY = ALPHA; }

   if( ( INCY != 1 ) || !( SCALAR_IS_ONE( alphaY ) ) )
   { 
      vy = malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vy ); y00 = y = ATL_AlignPtr( vy );
      beta0 = zero;
   }
   else { y00 = y = (TYPE *)(Y); beta0 = BETA; }

   ATL_GetPartSPMV( A, N, &mb, &nb );

   mb1 = N - ( ( N - 1 ) / mb ) * mb; incXY1 = (nb SHIFT);

   if( UPLO == AtlasUpper )
   {
@rout ATL_spmv
      if(      SCALAR_IS_ZERO( beta0 ) )
         gpmv0 = Mjoin( PATL, gpmvUT_a1_x1_b0_y1 );
      else if( SCALAR_IS_ONE ( beta0 ) )
         gpmv0 = Mjoin( PATL, gpmvUT_a1_x1_b1_y1 );
      else
         gpmv0 = Mjoin( PATL, gpmvUT_a1_x1_bX_y1 );
      gpmv1 = Mjoin( PATL, gpmvUT_a1_x1_b1_y1 );
@rout ATL_hpmv
      if(      SCALAR_IS_ZERO( beta0 ) )
         gpmv0 = Mjoin( PATL, gpmvUC_a1_x1_b0_y1 );
      else if( SCALAR_IS_ONE ( beta0 ) )
         gpmv0 = Mjoin( PATL, gpmvUC_a1_x1_b1_y1 );
      else
         gpmv0 = Mjoin( PATL, gpmvUC_a1_x1_bX_y1 );
      gpmv1 = Mjoin( PATL, gpmvUC_a1_x1_b1_y1 );
@rout ATL_spmv ATL_hpmv
      gpmvN = Mjoin( PATL, gpmvUN_a1_x1_b1_y1 );

      lda = 1; lda0 = lda; A0 = (TYPE *)(A); MUpnext( mb, A0, lda0 );
      incXY = (mb SHIFT); x0 = x + incXY; y0 = y + incXY;

      for( n = N - mb; n > 0; n -= mb, x0 += incXY, x += incXY,
           y0 += incXY, y += incXY )
      {
         Mjoin( PATL, @(sphp)mvU )( mb, A, lda, x, beta0, y );

         for( j = 0, lda1 = lda0, A1 = A0 - (mb SHIFT), x1 = x0, y1 = y0; j < n;
              j += nb, x1 += incXY1, y1 += incXY1 )
         {
            jb = n - j; jb = Mmin( jb, nb );
            gpmv0( jb, mb, one, A1, lda1, x,  1, beta0, y1, 1 );
            gpmvN( mb, jb, one, A1, lda1, x1, 1, one,   y,  1 );
            MUpnext( jb, A1, lda1 ); A1 -= (jb SHIFT);
         }
         beta0 = one; gpmv0 = gpmv1; lda = lda0; A = A0; MUpnext( mb, A0, lda0 );
      }
      Mjoin( PATL, @(sphp)mvU )( mb1, A, lda, x, beta0, y ); 
   }
   else
   {
@rout ATL_spmv
      if(      SCALAR_IS_ZERO( beta0 ) )
         gpmv0 = Mjoin( PATL, gpmvLT_a1_x1_b0_y1 );
      else if( SCALAR_IS_ONE ( beta0 ) )
         gpmv0 = Mjoin( PATL, gpmvLT_a1_x1_b1_y1 );
      else
         gpmv0 = Mjoin( PATL, gpmvLT_a1_x1_bX_y1 );
      gpmv1 = Mjoin( PATL, gpmvLT_a1_x1_b1_y1 );
@rout ATL_hpmv
      if(      SCALAR_IS_ZERO( beta0 ) )
         gpmv0 = Mjoin( PATL, gpmvLC_a1_x1_b0_y1 );
      else if( SCALAR_IS_ONE ( beta0 ) )
         gpmv0 = Mjoin( PATL, gpmvLC_a1_x1_b1_y1 );
      else
         gpmv0 = Mjoin( PATL, gpmvLC_a1_x1_bX_y1 );
      gpmv1 = Mjoin( PATL, gpmvLC_a1_x1_b1_y1 );
@rout ATL_spmv ATL_hpmv
      gpmvN = Mjoin( PATL, gpmvLN_a1_x1_b1_y1 );

      lda = N; lda0 = lda; A0 = (TYPE *)(A); MLpnext( N, A, lda );
      incXY = (mb SHIFT); x0 = x; y0 = y;
 
      for( n  = N - mb, x += ((N-mb) SHIFT), y += ((N-mb) SHIFT); n > 0;
           n -= mb, x -= incXY, y -= incXY )
      {
         MLpprev( mb, A, lda );
         Mjoin( PATL, @(sphp)mvL )( mb, A, lda, x, beta0, y );

         for( j = 0, lda1 = lda0, A1 = A0 + (n SHIFT), x1 = x0, y1 = y0; j < n;
              j += nb, x1 += incXY1, y1 += incXY1 )
         {
            jb = n - j; jb = Mmin( jb, nb );
            gpmv0( jb, mb, one, A1, lda1, x,  1, beta0, y1, 1 );
            gpmvN( mb, jb, one, A1, lda1, x1, 1, one,   y,  1 );
            MLpnext( jb, A1, lda1 ); A1 -= (jb SHIFT);
         }
         beta0 = one; gpmv0 = gpmv1;
      }
      Mjoin( PATL, @(sphp)mvL )( mb1, A0, lda0, x0, beta0, y0 );
   }

   if( vx ) free( vx );
   if( vy )
   { Mjoin( PATL, axpby )( N, alphaY, y00, 1, BETA, Y, INCY ); free( vy ); }
@endskip
@extract @(END_OF_ROUTINE)
@undef sphp
@undef rname
@skip
@skip ==================================================================
@skip
@rout ATL_symv
@define syhe @sy@
@rout ATL_hemv
@define syhe @he@
@rout ATL_symv ATL_hemv
@define rname @Mjoin( PATL, @(syhe)mv )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)

void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*gemv0)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
   void                       (*gemv1)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
   void                       (*gemvN)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
#ifdef TREAL
   TYPE                       alphaY, beta0;
#define lda2                  LDA  
#define one                   ATL_rone
#define zero                  ATL_rzero
   void                       * vx = NULL, * vy = NULL;
   TYPE                       * x, * y;
   TYPE                       * A0, * A1, * x0, * x1, * y00, * y0, * y1;
#else
   const int                  lda2 = ( LDA SHIFT );
   const TYPE                 * alphaY, * beta0;
   const TYPE                 one [2] = { ATL_rone,  ATL_rzero },
                              zero[2] = { ATL_rzero, ATL_rzero };
   void                       * vx = NULL, * vy = NULL;
   TYPE                       * x, * y;
   TYPE                       * A0, * A1, * x0, * x1, * y00, * y0, * y1;
#endif
   int                        incA, incA1, incXY, incXY1, j, jb, mb, mb1, n, nb;
@extract @(EXECUTABLE_STATEMENT)
   if( N == 0 ) return;

   if( SCALAR_IS_ZERO( ALPHA ) )
   {
      if( !( SCALAR_IS_ONE( BETA ) ) ) Mjoin( PATL, scal )( N, BETA, Y, INCY );
      return;
   }

   if( ( INCX != 1 ) || ( ( INCY == 1 ) && !( SCALAR_IS_ONE( ALPHA ) ) ) )
   {
      vx = (void *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vx ); x = ATL_AlignPtr( vx );
      Mjoin( PATL, cpsc )( N, ALPHA, X, INCX, x, 1 );
      alphaY = one; 
   }
   else { x = (TYPE *)(X); alphaY = ALPHA; }

   if( ( INCY != 1 ) || !( SCALAR_IS_ONE( alphaY ) ) )
   { 
      vy = malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vy ); y00 = y = ATL_AlignPtr( vy );
      beta0 = zero;
   }
   else { y00 = y = (TYPE *)(Y); beta0 = BETA; }

@rout ATL_symv
   if(      SCALAR_IS_ZERO( beta0 ) ) gemv0 = Mjoin( PATL, gemvT_a1_x1_b0_y1 );
   else if( SCALAR_IS_ONE ( beta0 ) ) gemv0 = Mjoin( PATL, gemvT_a1_x1_b1_y1 );
   else                               gemv0 = Mjoin( PATL, gemvT_a1_x1_bX_y1 );
   gemv1 = Mjoin( PATL, gemvT_a1_x1_b1_y1 );
@rout ATL_hemv
   if(      SCALAR_IS_ZERO( beta0 ) ) gemv0 = Mjoin( PATL, gemvC_a1_x1_b0_y1 );
   else if( SCALAR_IS_ONE ( beta0 ) ) gemv0 = Mjoin( PATL, gemvC_a1_x1_b1_y1 );
   else                               gemv0 = Mjoin( PATL, gemvC_a1_x1_bX_y1 );
   gemv1 = Mjoin( PATL, gemvC_a1_x1_b1_y1 );
@rout ATL_symv ATL_hemv
   gemvN = Mjoin( PATL, gemvS_a1_x1_b1_y1 );

   ATL_GetPartSYMV( A, LDA, &mb, &nb );

   mb1   = N - ( ( N - 1 ) / mb ) * mb;
   incA1 = nb * lda2;  incXY1 = (nb SHIFT);

   if( UPLO == AtlasUpper )
   {
      incA  = ( incXY = (mb SHIFT) ) + mb * lda2;
      A0 = (TYPE *)(A) + mb * lda2; x0 = x + incXY; y0 = y + incXY;

      for( n  = N - mb; n > 0; n -= mb, A0 += incA, A += incA, x0 += incXY,
           x += incXY, y0 += incXY, y += incXY )
      {
         Mjoin( PATL, @(syhe)mvU )( mb, A, LDA, x, beta0, y );

         for( j  =  0, A1 = A0,     x1  = x0,     y1  = y0;     j < n;
              j += nb, A1 += incA1, x1 += incXY1, y1 += incXY1 )
         {
            jb = n - j; jb = Mmin( jb, nb );
            gemv0( jb, mb, one, A1, LDA, x,  1, beta0, y1, 1 );
            gemvN( mb, jb, one, A1, LDA, x1, 1, one,   y,  1 );
         }
         beta0 = one; gemv0 = gemv1;
      }
      Mjoin( PATL, @(syhe)mvU )( mb1, A, LDA, x, beta0, y ); 
   }
   else
   {
      incA = incXY = (mb SHIFT);
      A0 = (TYPE *)(A); x0 = x; y0 = y;
 
      for( n  = N - mb, A += ((N-mb) SHIFT), x += ((N-mb) SHIFT),
           y += ((N-mb) SHIFT); n > 0; n -= mb, A -= incA, x -= incXY,
           y -= incXY )
      {
         Mjoin( PATL, @(syhe)mvL )( mb, A+n*lda2, LDA, x, beta0, y );

         for( j  =  0, A1  = (TYPE *)(A), x1  = x0,     y1  = y0;      j < n;
              j += nb, A1 += incA1,       x1 += incXY1, y1 += incXY1 )
         {
            jb = n - j; jb = Mmin( jb, nb );
            gemv0( jb, mb, one, A1, LDA, x,  1, beta0, y1, 1 );
            gemvN( mb, jb, one, A1, LDA, x1, 1, one,   y,  1 );
         }
         beta0 = one; gemv0 = gemv1;
      }
      Mjoin( PATL, @(syhe)mvL )( mb1, A0, LDA, x0, beta0, y0 );
   }

   if( vx ) free( vx );
   if( vy )
   { Mjoin( PATL, axpby )( N, alphaY, y00, 1, BETA, Y, INCY ); free( vy ); }
@extract @(END_OF_ROUTINE)
@undef syhe
@undef rname
@skip
@skip ==================================================================
@skip
@rout ATL_spr
@define sphp  @sp@
@rout ATL_hpr
@define sphp  @hp@
@rout ATL_spr ATL_hpr
@define rname @Mjoin( PATL, @(sphp)r )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
@rout ATL_spr
   const SCALAR               ALPHA,
@rout ATL_hpr
   const TYPE                 ALPHA,
@rout ATL_spr ATL_hpr
   const TYPE                 * X,
   const int                  INCX,
   TYPE                       * A
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout ATL_hpr
   TYPE                       Calph[2];
@rout ATL_spr ATL_hpr
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   void                       * vx = NULL;
   TYPE                       * x, * y, * A0, * y0;
   int                        incA0, incX, incY, incy, lda, lda0, mb, mb1,
                              n, nb;
@rout ATL_spr
#ifdef TREAL
#define   gpr1L   Mjoin( PATL, gpr1L_a1_x1_yX  )
#define   gpr1U   Mjoin( PATL, gpr1U_a1_x1_yX  )
#else
#define   gpr1L   Mjoin( PATL, gpr1uL_a1_x1_yX )
#define   gpr1U   Mjoin( PATL, gpr1uU_a1_x1_yX )
#endif
@rout ATL_hpr
#define   gpr1L   Mjoin( PATL, gpr1cL_a1_x1_yX )
#define   gpr1U   Mjoin( PATL, gpr1cU_a1_x1_yX )
@rout ATL_spr ATL_hpr
@extract @(EXECUTABLE_STATEMENT)
@rout ATL_spr
   if( ( N == 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;
 
   Mjoin(PATL,refspr)(UPLO, N, ALPHA, X, INCX, A);
@skip   if( ( INCX == 1 ) && ( SCALAR_IS_ONE( ALPHA ) ) )
@rout ATL_hpr
   if( ( N == 0 ) || ( ALPHA == ATL_rzero ) ) return;
 
   Mjoin(PATL,refhpr)(UPLO, N, ALPHA, X, INCX, A);
@skip   if( ( INCX == 1 ) && ( ALPHA == ATL_rone ) )
@rout ATL_spr ATL_hpr
@beginskip
   {
      x = y = (TYPE *)(X); incy = INCX;
   }
   else
   {
      vx = (void *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vx ); x = ATL_AlignPtr( vx );
@rout ATL_spr
      Mjoin( PATL, cpsc )( N, ALPHA, X, INCX, x, 1 );
@rout ATL_hpr
      *Calph = ALPHA; Calph[1] = ATL_rzero;
      Mjoin( PATL, cpsc )( N, Calph, X, INCX, x, 1 );
@rout ATL_spr ATL_hpr
      y = (TYPE *)(X); incy = INCX;
   }
 
   ATL_GetPartP1( A, 1, mb, nb );
   if (!mb) mb = N;
   if (!nb) nb = N;
 
   mb1  = N - ( ( N - 1 ) / mb ) * mb;
 
   if( UPLO == AtlasLower )
   {
      lda = lda0 = N; incA0 = ( incX = (mb SHIFT) );
 
      Mjoin( PATL, @(sphp)rL )( mb1, x, y, incy, A, lda );
      A0 = (TYPE *)( A + (mb1 SHIFT) ); MLpnext( mb1, A, lda );
      x += (mb1 SHIFT);
 
      for( n = mb1; n < N; n += mb, A0 += incA0, x += incX )
      {
         gpr1L( mb, n, one, x, 1, y, incy, A0, lda0 );
         Mjoin( PATL, @(sphp)rL )( mb, x, y + n*(incy SHIFT), incy, A, lda );
         MLpnext( mb, A, lda );
      }
   }
   else
   {
      incA0 = ( incX = (mb SHIFT) ); incY = incX * incy;
      lda0 = lda = 1; A0 = (TYPE *)(A); MUpnext( mb, A0, lda0 );
 
      for( n  = N - mb, y0 = y + incY; n > 0;
           n -= mb, x += incX, y += incY, y0 += incY )
      { 
         Mjoin( PATL, @(sphp)rU )( mb, x, y, incy, A, lda );
         gpr1U(  mb, n, one, x, 1, y0, incy, A0 - incA0, lda0 );
         lda = lda0; A = A0; MUpnext( mb, A0, lda0 );
      }
      Mjoin( PATL, @(sphp)rU )( mb1, x, y, incy, A, lda );
   }
 
   if( vx ) free( vx );
@endskip
@extract @(END_OF_ROUTINE)
@undef rname
@undef sphp
@skip
@skip ==================================================================
@skip
@rout ATL_syr
@define syhe  @sy@
@rout ATL_her
@define syhe  @he@
@rout ATL_syr ATL_her
@define rname @Mjoin( PATL, @(syhe)r )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
@rout ATL_syr
   const SCALAR               ALPHA,
@rout ATL_her
   const TYPE                 ALPHA,
@rout ATL_syr ATL_her
   const TYPE                 * X,
   const int                  INCX,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout ATL_her
   TYPE                       Calph[2];
@rout ATL_syr ATL_her
#ifdef TREAL
#define    lda2               LDA
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
   void                       * vx = NULL;
   TYPE                       * x, * y, * A0, * y0;
   int                        incA0, incA, incX, incY, incy, mb, mb1, n, nb;
@rout ATL_syr
#ifdef TREAL
#define   ger1    Mjoin( PATL, ger1_a1_x1_yX  )
#else
#define   ger1    Mjoin( PATL, ger1u_a1_x1_yX )
#endif
@rout ATL_her
#define   ger1    Mjoin( PATL, ger1c_a1_x1_yX )
@rout ATL_syr ATL_her
@extract @(EXECUTABLE_STATEMENT)
@rout ATL_syr
   if( ( N == 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;

   if( ( INCX == 1 ) && ( SCALAR_IS_ONE( ALPHA ) ) )
@rout ATL_her
   if( ( N == 0 ) || ( ALPHA == ATL_rzero ) ) return;

   if( ( INCX == 1 ) && ( ALPHA == ATL_rone ) )
@rout ATL_syr ATL_her
   {
      x = y = (TYPE *)(X); incy = INCX;
   }
   else
   {
      vx = (void *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vx ); x = ATL_AlignPtr( vx );
@rout ATL_syr
      Mjoin( PATL, cpsc )( N, ALPHA, X, INCX, x, 1 );
@rout ATL_her
      *Calph = ALPHA; Calph[1] = ATL_rzero;
      Mjoin( PATL, cpsc )( N, Calph, X, INCX, x, 1 );
@rout ATL_syr ATL_her
      y = (TYPE *)(X); incy = INCX;
   }

   ATL_GetPartR1( A, LDA, mb, nb );

   mb1  = N - ( ( N - 1 ) / mb ) * mb;

   if( UPLO == AtlasLower )
   {
      incA = ( incA0 = ( incX  = (mb SHIFT) ) ) + mb * lda2;
 
      Mjoin( PATL, @(syhe)rL )( mb1, x, y, incy, A, LDA );
      A0 = (TYPE *)( A += (mb1 SHIFT) ); A += mb1 * lda2; x += (mb1 SHIFT);
 
      for( n = mb1; n < N; n += mb, A0 += incA0, A += incA, x += incX )
      {
         ger1( mb, n, one, x, 1, y, incy, A0, LDA );
         Mjoin( PATL, @(syhe)rL )( mb, x, y + n*(incy SHIFT), incy, A, LDA );
      }
   }
   else
   {
      incA = mb * lda2 + ( incX = (mb SHIFT) ); incY = incX * incy;
 
      for( n  = N - mb, A0 = (TYPE *)(A) + mb * lda2, y0 = y + incY; n > 0;
           n -= mb, A0 += incA, A += incA, x += incX, y += incY, y0 += incY )
      {
         Mjoin( PATL, @(syhe)rU )( mb, x, y, incy, A, LDA );
         ger1( mb, n, one, x, 1, y0, incy, A0, LDA );
      }
      Mjoin( PATL, @(syhe)rU )( mb1, x, y, incy, A, LDA );
   }

   if( vx ) free( vx );
@extract @(END_OF_ROUTINE)
@undef rname
@undef syhe
@skip
@skip ==================================================================
@skip
@rout ATL_spr2
@define sphp  @sp@
@rout ATL_hpr2
@define sphp  @hp@
@rout ATL_spr2 ATL_hpr2
@define rname @Mjoin( PATL, @(sphp)r2 )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout ATL_hpr2
   TYPE                       Calph[2];
@rout ATL_spr2 ATL_hpr2
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif 
   TYPE                       * A0, * A1, * x, * x0, * x1, * y, * y0, * y1;
   void                       * vx = NULL, * vy = NULL;
   int                        incA0, incXY, incXY1, j, jb, lda, lda0, lda1,
                              mb, mb1, n, nb;
@rout ATL_spr2
#ifdef TREAL
#define   gpr1L   Mjoin( PATL, gpr1L_a1_x1_yX  )
#define   gpr1U   Mjoin( PATL, gpr1U_a1_x1_yX  )
#else
#define   gpr1L   Mjoin( PATL, gpr1uL_a1_x1_yX )
#define   gpr1U   Mjoin( PATL, gpr1uU_a1_x1_yX )
#endif
@rout ATL_hpr2
#define   gpr1L   Mjoin( PATL, gpr1cL_a1_x1_yX )
#define   gpr1U   Mjoin( PATL, gpr1cU_a1_x1_yX )
@rout ATL_spr2 ATL_hpr2
@extract @(EXECUTABLE_STATEMENT)
   if( ( N == 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;
 
@rout ATL_spr2
    Mjoin(PATL,refspr2)(UPLO, N, ALPHA, X, INCX, Y, INCY, A);
@rout ATL_hpr2
    Mjoin(PATL,refhpr2)(UPLO, N, ALPHA, X, INCX, Y, INCY, A);
@rout ATL_spr2 ATL_hpr2
@beginskip
   if( INCX != 1 )
   {
      vx = (TYPE *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vx ); x = ATL_AlignPtr( vx );
      Mjoin( PATL, cpsc )( N, ALPHA, X, INCX, x, 1 );
   }
   else { x = (TYPE *)(X); }
 
   if( ( ( vx != NULL ) && ( INCY != 1 ) ) ||
       ( ( vx == NULL ) && ( !( SCALAR_IS_ONE( ALPHA ) ) || ( INCY != 1 ) ) ) )
   {
      vy = (TYPE *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vy ); y = ATL_AlignPtr( vy );
      if( ( vx != NULL ) && ( INCY != 1 ) )
      {
         Mjoin( PATL, copy )( N,        Y, INCY, y, 1 );
      }
      else
      {
@rout ATL_spr2
         Mjoin( PATL, cpsc )( N, ALPHA, Y, INCY, y, 1 );
@rout ATL_hpr2
         *Calph = *ALPHA; Calph[1] = -ALPHA[1];
         Mjoin( PATL, cpsc )( N, Calph, Y, INCY, y, 1 );
@rout ATL_spr2 ATL_hpr2
      }
   }
   else { y = (TYPE *)(Y); }
 
   ATL_GetPartP1( A, 1, mb, nb );
   if (!mb) mb = N;
   if (!nb) nb = N;
 
   mb1    = N - ( ( N - 1 ) / mb ) * mb;
   incXY  = (mb SHIFT);
   incXY1 = (nb SHIFT);
 
   if( UPLO == AtlasLower )
   {
      lda = N; Mjoin( PATL, @(sphp)r2L )( mb1, x, y, A, lda );
 
      lda0 = lda; A0 = (TYPE *)(A); MLpnext( mb1, A, lda );
      x0 = x; x += (mb1 SHIFT); y0 = y; y += (mb1 SHIFT);
 
      for( n = mb1; n < N; n += mb, x += incXY, y += incXY )
      {
         for( j  = 0, lda1 = lda0, A1 = A0 + (n SHIFT), x1 = x0, y1 = y0;
              j < n; j += nb, x1 += incXY1, y1 += incXY1 )
         {
            jb = n - j; jb = Mmin( jb, nb );
            gpr1L( mb, jb, one, x, 1, y1, 1, A1, lda1 );
            gpr1L( mb, jb, one, y, 1, x1, 1, A1, lda1 );
            MLpnext( jb, A1, lda1 ); A1 -= (jb SHIFT); 
         }
         Mjoin( PATL, @(sphp)r2L )( mb, x, y, A, lda ); MLpnext( mb, A, lda );
      }
   }
   else
   {
      incA0 = incXY; lda0 = lda = 1; A0 = (TYPE *)(A); MUpnext( mb, A0, lda0 );

      for( n  = N - mb,         x0  = x + incXY,         y0  = y + incXY; n > 0;
           n -= mb, x += incXY, x0 += incXY, y += incXY, y0 += incXY )
      {
         Mjoin( PATL, @(sphp)r2U )( mb, x, y, A, lda );
 
         for( j = 0, lda1 = lda0, A1 = A0 - incA0, x1 = x0, y1 = y0;
              j < n; j += nb, x1 += incXY1, y1 += incXY1 )
         { 
            jb = n - j; jb = Mmin( jb, nb );
            gpr1U(  mb, jb, one, x, 1, y1, 1, A1, lda1 );
            gpr1U(  mb, jb, one, y, 1, x1, 1, A1, lda1 );
            MUpnext( jb, A1, lda1 ); A1 -= (jb SHIFT);
         }
         lda = lda0; A = A0; MUpnext( mb, A0, lda0 );
      }
      Mjoin( PATL, @(sphp)r2U )( mb1, x, y, A, lda );
   }
 
   if( vx ) free( vx );
   if( vy ) free( vy );
@endskip
@extract @(END_OF_ROUTINE)
@undef rname
@undef sphp
@skip
@skip ==================================================================
@skip
@rout ATL_syr2
@define syhe  @sy@
@rout ATL_her2
@define syhe  @he@
@rout ATL_syr2 ATL_her2
@define rname @Mjoin( PATL, @(syhe)r2 )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
@rout ATL_her2
   TYPE                       Calph[2];
@rout ATL_syr2 ATL_her2
#ifdef TREAL
#define    lda2               LDA
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
   TYPE                       * A0, * A1, * x, * x0, * x1, * y, * y0, * y1;
   void                       * vx = NULL, * vy = NULL;
   int                        incA, incA0, incA1, incXY, incXY1, j, jb,
                              mb, mb1, n, nb;
@rout ATL_syr2
#ifdef TREAL
#define   ger1    Mjoin( PATL, ger1_a1_x1_yX  )
#else
#define   ger1    Mjoin( PATL, ger1u_a1_x1_yX )
#endif
@rout ATL_her2
#define   ger1    Mjoin( PATL, ger1c_a1_x1_yX )
@rout ATL_syr2 ATL_her2
@extract @(EXECUTABLE_STATEMENT)
   if( ( N == 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;

   if( INCX != 1 )
   {
      vx = (TYPE *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vx ); x = ATL_AlignPtr( vx );
      Mjoin( PATL, cpsc )( N, ALPHA, X, INCX, x, 1 );
   }
   else { x = (TYPE *)(X); }

   if( ( ( vx != NULL ) && ( INCY != 1 ) ) ||
       ( ( vx == NULL ) && ( !( SCALAR_IS_ONE( ALPHA ) ) || ( INCY != 1 ) ) ) )
   {
      vy = (TYPE *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vy ); y = ATL_AlignPtr( vy );
      if( ( vx != NULL ) && ( INCY != 1 ) )
      {
         Mjoin( PATL, copy )( N,        Y, INCY, y, 1 );
      }
      else
      {
@rout ATL_syr2
         Mjoin( PATL, cpsc )( N, ALPHA, Y, INCY, y, 1 );
@rout ATL_her2
         *Calph = *ALPHA; Calph[1] = -ALPHA[1];
         Mjoin( PATL, cpsc )( N, Calph, Y, INCY, y, 1 );
@rout ATL_syr2 ATL_her2
      }
   }
   else { y = (TYPE *)(Y); }

   ATL_GetPartR1( A, LDA, mb, nb );
 
   mb1   = N - ( ( N - 1 ) / mb ) * mb;
   incA  = ( incXY = (mb SHIFT) ) + mb * lda2;
   incA1 = nb * lda2;   incXY1 = (nb SHIFT);

   if( UPLO == AtlasLower )
   {
      incA0 = incXY;

      Mjoin( PATL, @(syhe)r2L )( mb1, x, y, A, LDA );

      A0 = (TYPE *)( A += (mb1 SHIFT) ); A += mb1 * lda2;
      x0 = x;                            x += (mb1 SHIFT);
      y0 = y;                            y += (mb1 SHIFT);
 
      for( n  = mb1; n < N;
           n += mb, A0 += incA0, A += incA, x += incXY, y += incXY )
      {
         for( j  = 0,  A1  = A0,    x1  = x0,     y1  = y0;     j < n;
              j += nb, A1 += incA1, x1 += incXY1, y1 += incXY1 )
         {
            jb = n - j; jb = Mmin( jb, nb );
            ger1( mb, jb, one, x, 1, y1, 1, A1, LDA );
            ger1( mb, jb, one, y, 1, x1, 1, A1, LDA );
         }
         Mjoin( PATL, @(syhe)r2L )( mb, x, y, A, LDA );
      }
   }
   else
   {
      for( n  = N - mb,
           A0 = (TYPE *)(A) + mb * lda2, x0 = x + incXY, y0 = y + incXY;
           n > 0;
           n -= mb,
           A += incA,  A0 += incA,
           x += incXY, x0 += incXY, y += incXY, y0 += incXY )
      {
         Mjoin( PATL, @(syhe)r2U )( mb, x, y, A, LDA );

         for( j  = 0,  A1  = A0,    x1  = x0,     y1  = y0;     j < n;
              j += nb, A1 += incA1, x1 += incXY1, y1 += incXY1 )
         {
            jb = n - j; jb = Mmin( jb, nb );
            ger1( mb, jb, one, x, 1, y1, 1, A1, LDA );
            ger1( mb, jb, one, y, 1, x1, 1, A1, LDA );
         }
      }
      Mjoin( PATL, @(syhe)r2U )( mb1, x, y, A, LDA );
   }

   if( vx ) free( vx );
   if( vy ) free( vy );
@extract @(END_OF_ROUTINE)
@undef rname
@undef syhe
@skip
@skip ==================================================================
@skip
@rout ATL_tbmv ATL_tpmv ATL_trmv 
@define ms @mv@
@rout ATL_tbsv ATL_tpsv ATL_trsv 
@define ms @sv@
@rout ATL_tbmv ATL_tbsv
@define tv @tb@(ms)@
@rout ATL_tpmv ATL_tpsv
@define tv @tp@(ms)@
@rout ATL_trmv ATL_trsv
@define tv @tr@(ms)@
@rout ATL_tbmv ATL_tpmv ATL_trmv ATL_tbsv ATL_tpsv ATL_trsv 
@define rname @Mjoin( PATL, @(tv) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(LV2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG,
   const int                  N,
@rout ATL_tbmv ATL_tbsv
   const int                  K,
@rout ATL_tbmv ATL_tpmv ATL_trmv ATL_tbsv ATL_tpsv ATL_trsv 
   const TYPE                 * A,
@rout ATL_tbmv ATL_trmv ATL_tbsv ATL_trsv 
   const int                  LDA,
@rout ATL_tbmv ATL_tpmv ATL_trmv ATL_tbsv ATL_tpsv ATL_trsv 
   TYPE                       * X,
   const int                  INCX
)
{
@extract @(ATLAS_LV2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       * vx = NULL;
   TYPE                       * x;
@extract @(EXECUTABLE_STATEMENT)
   if( N == 0 ) return;
@ROUT ATL_tpmv ATL_tpsv
   Mjoin(PATL,ref@(tv))(UPLO, TRANS, DIAG, N, A, X, INCX);
@ROUT ATL_tbmv ATL_tbsv
   Mjoin(PATL,ref@(tv))(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX);
@ROUT ATL_tbmv ATL_tpmv ATL_tpsv ATL_tbsv
   return;
@rout ATL_tbmv ATL_tpmv ATL_trmv ATL_tbsv ATL_tpsv ATL_trsv 
 
   if( INCX == 1 ) { x = X; }
   else
   {
      vx = (TYPE *)malloc( ATL_Cachelen + ATL_MulBySize( N ) );
      ATL_assert( vx ); x = ATL_AlignPtr( vx );
      Mjoin( PATL, copy )( N, X, INCX, x, 1 );
   }
 
#ifdef TREAL
   if( ( TRANS == AtlasNoTrans ) || ( TRANS == AtlasConj ) )
#else
   if( TRANS == AtlasNoTrans )
#endif
   {
@rout ATL_tbmv ATL_tbsv
      if( UPLO == AtlasUpper ) Mjoin( PATL, @(tv)UN )( DIAG, N, K, A, LDA, x );
      else                     Mjoin( PATL, @(tv)LN )( DIAG, N, K, A, LDA, x );
@rout ATL_tpmv ATL_tpsv
      if( UPLO == AtlasUpper ) Mjoin( PATL, @(tv)UN )( DIAG, N,    A,   1, x );
      else                     Mjoin( PATL, @(tv)LN )( DIAG, N,    A,   N, x );
@rout ATL_trmv ATL_trsv
      if( UPLO == AtlasUpper ) Mjoin( PATL, @(tv)UN )( DIAG, N,    A, LDA, x );
      else                     Mjoin( PATL, @(tv)LN )( DIAG, N,    A, LDA, x );
@rout ATL_tbmv ATL_tpmv ATL_trmv ATL_tbsv ATL_tpsv ATL_trsv 
   }
#ifdef TCPLX
   else if( TRANS == AtlasConj )
   {
@rout ATL_tbmv ATL_tbsv
      if( UPLO == AtlasUpper ) Mjoin( PATL, @(tv)UC )( DIAG, N, K, A, LDA, x );
      else                     Mjoin( PATL, @(tv)LC )( DIAG, N, K, A, LDA, x );
@rout ATL_tpmv ATL_tpsv
      if( UPLO == AtlasUpper ) Mjoin( PATL, @(tv)UC )( DIAG, N,    A,   1, x );
      else                     Mjoin( PATL, @(tv)LC )( DIAG, N,    A,   N, x );
@rout ATL_trmv ATL_trsv
      if( UPLO == AtlasUpper ) Mjoin( PATL, @(tv)UC )( DIAG, N,    A, LDA, x );
      else                     Mjoin( PATL, @(tv)LC )( DIAG, N,    A, LDA, x );
@rout ATL_tbmv ATL_tpmv ATL_trmv ATL_tbsv ATL_tpsv ATL_trsv 
   }
#endif
#ifdef TREAL
   else
#else
   else if( TRANS == AtlasTrans )
#endif
   {
@rout ATL_tbmv ATL_tbsv
      if( UPLO == AtlasUpper ) Mjoin( PATL, @(tv)UT )( DIAG, N, K, A, LDA, x );
      else                     Mjoin( PATL, @(tv)LT )( DIAG, N, K, A, LDA, x );
@rout ATL_tpmv ATL_tpsv
      if( UPLO == AtlasUpper ) Mjoin( PATL, @(tv)UT )( DIAG, N,    A,   1, x );
      else                     Mjoin( PATL, @(tv)LT )( DIAG, N,    A,   N, x );
@rout ATL_trmv ATL_trsv
      if( UPLO == AtlasUpper ) Mjoin( PATL, @(tv)UT )( DIAG, N,    A, LDA, x );
      else                     Mjoin( PATL, @(tv)LT )( DIAG, N,    A, LDA, x );
@rout ATL_tbmv ATL_tpmv ATL_trmv ATL_tbsv ATL_tpsv ATL_trsv 
   }
#ifdef TCPLX
   else
   {
@rout ATL_tbmv ATL_tbsv
      if( UPLO == AtlasUpper ) Mjoin( PATL, @(tv)UH )( DIAG, N, K, A, LDA, x );
      else                     Mjoin( PATL, @(tv)LH )( DIAG, N, K, A, LDA, x );
@rout ATL_tpmv ATL_tpsv
      if( UPLO == AtlasUpper ) Mjoin( PATL, @(tv)UH )( DIAG, N,    A,   1, x );
      else                     Mjoin( PATL, @(tv)LH )( DIAG, N,    A,   N, x );
@rout ATL_trmv ATL_trsv
      if( UPLO == AtlasUpper ) Mjoin( PATL, @(tv)UH )( DIAG, N,    A, LDA, x );
      else                     Mjoin( PATL, @(tv)LH )( DIAG, N,    A, LDA, x );
@rout ATL_tbmv ATL_tpmv ATL_trmv ATL_tbsv ATL_tpsv ATL_trsv 
   }
#endif
   if( vx ) { Mjoin( PATL, copy )( N, x, 1, X, INCX ); free( vx ); }
@extract @(END_OF_ROUTINE)
@undef rname
@undef tv
@undef ms
@skip
@skip ==================================================================
@skip
@rout atlas_level2.h
@define rname @atlas_level2.h@
@extract @(VER_ATLAS_SRC)
#ifndef ATLAS_LEVEL2_H
#define ATLAS_LEVEL2_H

#include "atlas_enum.h"
/*
 * =====================================================================
 * Prototypes for ATLAS Level 2 BLAS routines
 * =====================================================================
 */
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s
      @define sca_in_    @const float@
      @define rsca_in_   @const float@
      @define mat_in_    @const float *,          const int@
      @define mat_out_   @float *,                const int@
      @define pmat_in_   @const float *@
      @define pmat_out_  @float *@
      @define vec_in_    @const float *,          const int@
      @define vec_out_   @float *,                const int@
   @ptyp_ d
      @define sca_in_    @const double@
      @define rsca_in_   @const double@
      @define mat_in_    @const double *,         const int@
      @define mat_out_   @double *,               const int@
      @define pmat_in_   @const double *@
      @define pmat_out_  @double *@
      @define vec_in_    @const double *,         const int@
      @define vec_out_   @double *,               const int@
   @ptyp_ s d
      @multidef rout_
         trsv trmv tpsv tpmv tbsv tbmv syr2 syr   symv
         spr2 spr  spmv sbmv ger  gemv gbmv
      @endmultidef
   @ptyp_ c
      @define sca_in_    @const float *@
      @define rsca_in_   @const float@
      @define mat_in_    @const float *,          const int@
      @define mat_out_   @float *,                const int@
      @define pmat_in_   @const float *@
      @define pmat_out_  @float *@
      @define vec_in_    @const float *,          const int@
      @define vec_out_   @float *,                const int@
   @ptyp_ z
      @define sca_in_    @const double *@
      @define rsca_in_   @const double@
      @define mat_in_    @const double *,         const int@
      @define mat_out_   @double *,               const int@
      @define pmat_in_   @const double *@
      @define pmat_out_  @double *@
      @define vec_in_    @const double *,         const int@
      @define vec_out_   @double *,               const int@
   @ptyp_ c z
      @multidef rout_
         trsv trmv tpsv tpmv tbsv tbmv her2 her  hemv
         hpr2 hpr  hpmv hbmv geru gerc gemv gbmv
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      @addkeys prou_=@(rout_)
void       ATL_@(pre_)@(rout_)
(
      @prou_ gbmv gemv
  const enum ATLAS_TRANS,
  const int,              const int,
      @prou_ gbmv
  const int,              const int,
      @prou_ gbmv gemv
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ tbmv tbsv tpmv tpsv trmv trsv
  const enum ATLAS_UPLO,  const enum ATLAS_TRANS, const enum ATLAS_DIAG,
      @prou_ tbmv tbsv
  const int,              const int,
      @prou_ tpmv tpsv trmv trsv
  const int,
      @prou_ tbmv tbsv trmv trsv
  @(mat_in_),
      @prou_ tpmv tpsv
  @(pmat_in_),
      @prou_ tbmv tbsv tpmv tpsv trmv trsv
  @(vec_out_)
      @prou_ hbmv hpmv hemv sbmv spmv symv
  const enum ATLAS_UPLO,
      @prou_ hbmv sbmv
  const int,              const int,
      @prou_ hpmv hemv spmv symv
  const int,
      @prou_ hbmv hpmv hemv sbmv spmv symv
  @(sca_in_),
      @prou_ hbmv hemv sbmv symv
  @(mat_in_),
      @prou_ hpmv spmv
  @(pmat_in_),
      @prou_ hbmv hpmv hemv sbmv spmv symv
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ ger gerc geru
  const int,              const int,
  @(sca_in_),
  @(vec_in_),
  @(vec_in_),
  @(mat_out_)
      @prou_ hpr her spr syr
  const enum ATLAS_UPLO,
  const int,
  @(rsca_in_),
  @(vec_in_),
      @prou_ hpr spr
  @(pmat_out_)
      @prou_ her syr
  @(mat_out_)
      @prou_ hpr2 her2 spr2 syr2
  const enum ATLAS_UPLO,
  const int,
  @(sca_in_),
  @(vec_in_),
  @(vec_in_),
      @prou_ hpr2 spr2
  @(pmat_out_)
      @prou_ her2 syr2
  @(mat_out_)
      @prou_ !
      @killkeys prou_
);
 
   @endwhile
   @undef sca_in_
   @undef rsca_in_
   @undef mat_in_
   @undef mat_out_
   @undef pmat_in_
   @undef pmat_out_
   @undef vec_in_
   @undef vec_out_
   @killkeys ptyp_
@endwhile

#endif
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip ==================================================================
@skip
@rout Make.l2
@extract @(VER_ATLAS_MAK)
#
include Make.inc
mySRCdir = $(SRCdir)/src/blas/level2/
#
########################################################################
#
INC2dep      = \
   $(INCSdir)/atlas_misc.h    $(INCSdir)/atlas_aux.h        \
   $(INCSdir)/atlas_kernel2.h $(INCSdir)/atlas_lvl2.h       \
   $(INCSdir)/atlas_mv.h      $(INCSdir)/atlas_r1.h
#
## Object files ########################################################
#
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
ATL_@(pre_)lvl2obj = \
   @declare "   " y y
   ATL_L2AIsOverlapped.o
   @ptyp_ s d
      @multidef rout_
         trsv  tpsv  tbsv  trmv  tpmv  tbmv  syr2  spr2  syr
         spr   symv  spmv  sbmv  gbmv  gpmv  gpr
      @endmultidef
   @ptyp_ c z
      @multidef rout_
         trsv  tpsv  tbsv  trmv  tpmv  tbmv  her2  hpr2  her
         hpr   hemv  hpmv  hbmv  gbmv  gpmv  gprc  gpru
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      ATL_@(pre_)@(rout_).o
   @endwhile
   @killkeys ptyp_
   @enddeclare
#
@endwhile
## Targets #############################################################
#
all   : lib
#
lvl2  : lib
#
lib   : dlib slib zlib clib
#
@whiledef pre_ z c d s
@(pre_)lvl2 : @(pre_)lib
@endwhile
#
########################################################################
#
@whiledef pre_ z c d s
@skip @(pre_)lib  : @(pre_)kern @(pre_)blas2
@(pre_)lib  : @(pre_)blas2
@endwhile
#
@whiledef pre_ z c d s
@(pre_)kern :
@skip	( cd kernel; $(MAKE) @(pre_)lib )
@endwhile
#
@whiledef pre_ z c d s
@(pre_)blas2 : @(pre_)blas2.grd
@endwhile
#
@whiledef pre_ z c d s
@(pre_)blas2.grd: $(ATL_@(pre_)lvl2obj)
	@(arch) @(archflgs) @(atllib) $(ATL_@(pre_)lvl2obj)
	@(ranlib) @(atllib)
	touch @(pre_)blas2.grd
#
@endwhile
########################################################################
#
@multidef upr_ d s d s
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s d
      @multidef rout_
         trsv  tpsv  tbsv  trmv  tpmv  tbmv  syr2  spr2  syr
         spr   symv  spmv  sbmv  gbmv  gpmv  gpr
      @endmultidef
      @define cdefs @-D@up@(upr_)REAL@
   @ptyp_ c z
      @multidef rout_
         trsv  tpsv  tbsv  trmv  tpmv  tbmv  her2  hpr2  her
         hpr   hemv  hpmv  hbmv  gbmv  gpmv  gprc  gpru
      @endmultidef
      @define cdefs @-D@up@(upr_)CPLX@
   @ptyp_ !
   @whiledef rout_
      @define rpre_ @ATL_@(rout_)@
      @define rsrc_ @$(mySRCdir)/@(rpre_).c@
      @define robj_ @ATL_@(pre_)@(rout_).o@
@24l@(robj_) : @(rsrc_) $(INC2dep)
@(CCcomp) @(cdefs) @(rsrc_)
      @undef rpre_
      @undef rsrc_
      @undef robj_
   @endwhile
   @undef cdefs
   @killkeys ptyp_
   @undef upr_
#
@endwhile
ATL_L2AIsOverlapped.o : $(mySRCdir)/ATL_L2AIsOverlapped.c
	$(ICC) -o $@ -c $(ICCFLAGS) $(mySRCdir)/ATL_L2AIsOverlapped.c
########################################################################
#
@whiledef pre_ z c d s
@(pre_)clean           :
@skip	( cd kernel; $(MAKE) @(pre_)clean )
	rm -f $(ATL_@(pre_)lvl2obj) @(pre_)*.grd
#
@endwhile
clean            :
@skip	( cd kernel; $(MAKE)  clean )
	rm -f *.o *.grd
#
########################################################################
@skip
@skip ==================================================================
@skip
@rout !
@skip
@skip
@undef LV2_INCLUDE
@skip
@skip ==================================================================
@skip
