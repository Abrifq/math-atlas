@extract -addkeys -b @(BASEdir)include/atlas.inc lan=C type=none
@skip
@skip ATLAS / multithreaded BLAS L2 implementation                  AP00
@skip
@skip Last modification : 08/31/00
@skip
@skip
@define PT2_INCLUDE @-addkeys -b @(srcdir)/atlpt2blas.base rout=pt2_inc@
@skip
@skip
@rout pt2_inc
@extract @(INCLUDE)
#include "atlas_ptmisc.h"
#include "atlas_kernel2.h"
#include "atlas_reflvl2.h"
#include "atlas_lvl2.h"
#include "atlas_ptlevel1.h"
#include "atlas_ptlvl2.h"
#include "atlas_ptlevel2.h"
@skip
@skip 
@rout ATL_ptgbmv
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)

@define rname @Mjoin( PATL, ptgbmv0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_GBMV_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_GBMV_T *)(root->arg);
#ifdef TREAL
   Mjoin( PATL, gbmv )( arg->ta, arg->m, arg->n, arg->kl, arg->ku,
      (SCALAR)(*((TYPE *)(arg->al))), (TYPE *)(arg->a), arg->la,
      (TYPE *)(arg->x), arg->incx, (SCALAR)(*((TYPE *)(arg->be))),
      (TYPE *)(arg->y), arg->incy );
#else
   Mjoin( PATL, gbmv )( arg->ta, arg->m, arg->n, arg->kl, arg->ku,
      (SCALAR)(arg->al), (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x),
      arg->incx, (SCALAR)(arg->be), (TYPE *)(arg->y), arg->incy );
#endif
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip

@define rname @Mjoin( PATL, ptgbmv )@
void @(rname)
(
   const enum ATLAS_TRANS     TRANS,
   const int                  M,
   const int                  N,
   const int                  KL,
   const int                  KU,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(LOCAL_VARIABLE)
@extract @(EXECUTABLE_STATEMENT)
   if( ( M == 0 ) || ( N == 0 ) ||
       ( ( SCALAR_IS_ZERO( ALPHA ) ) && ( SCALAR_IS_ONE( BETA ) ) ) ) return;

   if( SCALAR_IS_ZERO( ALPHA ) )
   {
      if( !( SCALAR_IS_ONE( BETA ) ) )
         Mjoin( PATL, ptscal )( M, BETA, Y, INCY );
      return;
   }

   Mjoin( PATL, gbmv )( TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA,
                        Y, INCY );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_ptgemv
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)

@define rname @Mjoin( PATL, ptgemv0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_GEMV_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_GEMV_T *)(root->arg);
#ifdef TREAL
   Mjoin( PATL, gemv )( arg->ta, arg->m, arg->n, (SCALAR)(*((TYPE *)(arg->al))),
      (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x), arg->incx,
      (SCALAR)(*((TYPE *)(arg->be))), (TYPE *)(arg->y), arg->incy );
#else
   Mjoin( PATL, gemv )( arg->ta, arg->m, arg->n, (SCALAR)(arg->al),
      (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x), arg->incx,
      (SCALAR)(arg->be), (TYPE *)(arg->y), arg->incy );
#endif
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip

@define rname @Mjoin( PATL, ptgemv )@
void @(rname)
(
   const enum ATLAS_TRANS     TRANS,
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(LOCAL_VARIABLE)
@extract @(EXECUTABLE_STATEMENT)
   if( ( M == 0 ) || ( N == 0 ) ||
       ( ( SCALAR_IS_ZERO( ALPHA ) ) && ( SCALAR_IS_ONE( BETA ) ) ) ) return;

   if( SCALAR_IS_ZERO( ALPHA ) )
   {
      if( !( SCALAR_IS_ONE( BETA ) ) )
         Mjoin( PATL, ptscal )( M, BETA, Y, INCY );
      return;
   }

   Mjoin( PATL, gemv )( TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY );
/*
   ATL_thread_init( &attr );
   root = ATL_Sgemv( &type, 0, nthreads, nb, TRANS, M, N, (void *)(alpha),
                     (void *)(A), LDA, (void *)(X), INCX, (void *)(beta),
                     (void *)(Y), INCY );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_ptger ATL_ptgerc ATL_ptgeru
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)

@rout ATL_ptger
@define rname0 @Mjoin( PATL, ptger0 )@
@rout ATL_ptgerc
@define rname0 @Mjoin( PATL, ptgerc0 )@
@rout ATL_ptgeru
@define rname0 @Mjoin( PATL, ptgeru0 )@
@rout ATL_ptger ATL_ptgerc ATL_ptgeru
PT_FUN_ARG_T @(rname0)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_GER_T                   * arg = ARGS;
@extract @(EXECUTABLE_STATEMENT)
@skip   ATL_wait_tree( root );
@skip   arg = (PT_GER_T *)(root->arg);
@rout ATL_ptger
   Mjoin( PATL, ger )( arg->m, arg->n, (SCALAR)(*((TYPE *)(arg->al))),
      (TYPE *)(arg->x), arg->incx, (TYPE *)(arg->y), arg->incy,
      (TYPE *)(arg->a), arg->la );
@rout ATL_ptgerc
   Mjoin( PATL, gerc )( arg->m, arg->n, (SCALAR)(arg->al), (TYPE *)(arg->x),
      arg->incx, (TYPE *)(arg->y), arg->incy, (TYPE *)(arg->a), arg->la );
@rout ATL_ptgeru
   Mjoin( PATL, geru )( arg->m, arg->n, (SCALAR)(arg->al), (TYPE *)(arg->x),
      arg->incx, (TYPE *)(arg->y), arg->incy, (TYPE *)(arg->a), arg->la );
@rout ATL_ptger ATL_ptgerc ATL_ptgeru
@skip   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@skip
@skip
@rout ATL_ptger
@define rname @Mjoin( PATL, ptger )@
@rout ATL_ptgerc
@define rname @Mjoin( PATL, ptgerc )@
@rout ATL_ptgeru
@define rname @Mjoin( PATL, ptgeru )@
@rout ATL_ptger ATL_ptgerc ATL_ptgeru
void @(rname)
(
   const int                  M,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_PT2_COMMENT)
   pthread_t pid[ATL_NTHREADS];
   PT_GER_T arg[ATL_NTHREADS];
   pthread_attr_t attr;
   int i, nb, nn, nr, J, nthreads;
@extract @(EXECUTABLE_STATEMENT)
   if( ( M == 0 ) || ( N == 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;

   nb = N / ATL_NTHREADS;
   nthreads = nb ? ATL_NTHREADS : 1;
   if (nthreads < 2)
   {
@rout ATL_ptger
      Mjoin( PATL, ger  )( M, N, ALPHA, X, INCX, Y, INCY, A, LDA );
@rout ATL_ptgerc
      Mjoin( PATL, gerc )( M, N, ALPHA, X, INCX, Y, INCY, A, LDA );
@rout ATL_ptgeru
      Mjoin( PATL, geru )( M, N, ALPHA, X, INCX, Y, INCY, A, LDA );
@rout ATL_ptger ATL_ptgerc ATL_ptgeru
      return;
   } 
   nr = N - nb*nthreads;
   ATL_thread_init(&attr);
   for (J=i=0; i < nthreads; i++)
   {
      nn = (i < nr) ? nb+1 : nb;
      arg[i].al = SADD ALPHA;
      arg[i].x = X; 
      arg[i].incx = INCX;
      arg[i].y = Y + INCY*J;
      arg[i].incy = INCY;
      arg[i].a = A + LDA*J;
      arg[i].la = LDA;
      arg[i].m = M;
      arg[i].n = nn;
      if (i != nthreads-1)
         ATL_assert(!pthread_create(&pid[i], &attr, @(rname0), arg+i));
      J += nn SHIFT;
   }
   @(rname0)(arg+nthreads-1);
   for (i=0; i < nthreads-1; i++)
      ATL_assert(!pthread_join(pid[i], NULL));
   ATL_thread_free(&attr);

/* 
   ATL_thread_init( &attr );
   root = ATL_Sger( &type, 0, nthreads, nb, M, N, (void *)(ALPHA), (void *)(X),
                    INCX, (void *)(Y), INCY, (void *)(A), LDA );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname0
@undef rname
@skip
@skip
@rout ATL_ptsymv
@define sh @sy@
@rout ATL_pthemv
@define sh @he@
@rout ATL_ptsymv ATL_pthemv
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)

@define rname @Mjoin( PATL, pt@(sh)mv0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_SYMV_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_SYMV_T *)(root->arg);
@rout ATL_ptsymv
#ifdef TREAL
   Mjoin( PATL, @(sh)mv )( arg->up, arg->n, (SCALAR)(*((TYPE *)(arg->al))),
      (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x), arg->incx,
      (SCALAR)(*((TYPE *)(arg->be))), (TYPE *)(arg->y), arg->incy );
#else
   Mjoin( PATL, @(sh)mv )( arg->up, arg->n, (SCALAR)(arg->al),
      (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x), arg->incx,
      (SCALAR)(arg->be), (TYPE *)(arg->y), arg->incy );
#endif
@rout ATL_pthemv
   Mjoin( PATL, @(sh)mv )( arg->up, arg->n, (SCALAR)(arg->al),
      (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x), arg->incx,
      (SCALAR)(arg->be), (TYPE *)(arg->y), arg->incy );
@rout ATL_ptsymv ATL_pthemv
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip

@define rname @Mjoin( PATL, pt@(sh)mv )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( ( N == 0 ) ||
       ( ( SCALAR_IS_ZERO( ALPHA ) ) && ( SCALAR_IS_ONE( BETA ) ) ) ) return;
 
   if( SCALAR_IS_ZERO( ALPHA ) )
   {
      if( !( SCALAR_IS_ONE( BETA ) ) )
         Mjoin( PATL, ptscal )( N, BETA, Y, INCY );
      return;
   }
   Mjoin(PATL,@(sh)mv)(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY);
/*
   ATL_thread_init( &attr );
   root = ATL_Ssymv( &type, 0, nthreads, nb, UPLO, N, (void *)(alpha),
                     (void *)(A), LDA, (void *)(X), INCX, (void *)(beta),
                     (void *)(Y), INCY );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_pttrmv
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)

@define rname @Mjoin( PATL, pttrmv0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_TRMV_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_TRMV_T *)(root->arg);
   Mjoin( PATL, trmv )( arg->up, arg->ta, arg->di, arg->n, (TYPE *)(arg->a),
                        arg->la, (TYPE *)(arg->x), arg->incx );
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip

@define rname @Mjoin( PATL, pttrmv )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG,
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X,
   const int                  INCX
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( N == 0 ) return;
   Mjoin(PATL,trmv)(UPLO, TRANS, DIAG, N, A, LDA, X, INCX);
/* 
   ATL_thread_init( &attr );
   root = ATL_Strmv( &type, 0, nthreads, nb, UPLO, TRANS, DIAG, N, (void *)(A),
                     LDA, (void *)(X), INCX );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_pttrsv
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)

@define rname @Mjoin( PATL, pttrsv0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_TRSV_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_TRSV_T *)(root->arg);
   Mjoin( PATL, trsv )( arg->up, arg->ta, arg->di, arg->n, (TYPE *)(arg->a),
                        arg->la, (TYPE *)(arg->x), arg->incx );
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
 
@define rname @Mjoin( PATL, pttrsv )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG,
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X,
   const int                  INCX
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( N == 0 ) return;
   Mjoin(PATL,trsv)(UPLO, TRANS, DIAG, N, A, LDA, X, INCX);
/* 
   ATL_thread_init( &attr );
   root = ATL_Strsv( &type, 0, nthreads, nb, UPLO, TRANS, DIAG, N, (void *)(A),
                     LDA, (void *)(X), INCX );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_ptsyr
@define sh @sy@
@rout ATL_pther
@define sh @he@
@rout ATL_ptsyr ATL_pther
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)

@define rname @Mjoin( PATL, pt@(sh)r0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_SYR_T                   * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_SYR_T *)(root->arg);
@rout ATL_ptsyr
#ifdef TREAL
   Mjoin( PATL, @(sh)r )( arg->up, arg->n, (SCALAR)(*((TYPE *)(arg->al))),
      (TYPE *)(arg->x), arg->incx, (TYPE *)(arg->a), arg->la );
#else
   Mjoin( PATL, @(sh)r )( arg->up, arg->n, (SCALAR)(arg->al), (TYPE *)(arg->x),
      arg->incx, (TYPE *)(arg->a), arg->la );
#endif
@rout ATL_pther
   Mjoin( PATL, @(sh)r )( arg->up, arg->n, (TYPE)(*((TYPE *)(arg->al))),
      (TYPE *)(arg->x), arg->incx, (TYPE *)(arg->a), arg->la );
@rout ATL_ptsyr ATL_pther
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip

@define rname @Mjoin( PATL, pt@(sh)r )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
@rout ATL_ptsyr
   const SCALAR               ALPHA,
@rout ATL_pther
   const TYPE                 ALPHA,
@rout ATL_ptsyr ATL_pther
   const TYPE                 * X,
   const int                  INCX,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
@rout ATL_ptsyr
   if( ( N <= 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;
@rout ATL_pther
   if( ( N <= 0 ) || ( ALPHA == ATL_rzero ) ) return;
@rout ATL_ptsyr ATL_pther
  
   Mjoin(PATL,@(sh)r)(UPLO, N, ALPHA, X, INCX, A, LDA);
/* 
   ATL_thread_init( &attr );
   root = ATL_Ssyr( &type, 0, nthreads, nb, UPLO, N, (void *)(ALPHA),
                    (void *)(X), INCX, (void *)(A), LDA );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_ptsyr2
@define sh @sy@
@rout ATL_pther2
@define sh @he@
@rout ATL_ptsyr2 ATL_pther2
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)
 
@define rname @Mjoin( PATL, pt@(sh)r20 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_SYR2_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_SYR2_T *)(root->arg);
/*
@rout ATL_ptsyr2
#ifdef TREAL
   Mjoin( PATL, @(sh)r2 )( arg-up, arg->n, (SCALAR)(*((TYPE *)(arg->al))),
      (TYPE *)(arg->x), arg->incx, (TYPE *)(arg->y), arg->incy,
      (TYPE *)(arg->a), arg->la );
#else
   Mjoin( PATL, @(sh)r2 )( arg-up, arg->n, (SCALAR)(arg->al), (TYPE *)(arg->x),
      arg->incx, (TYPE *)(arg->y), arg->incy, (TYPE *)(arg->a), arg->la );
#endif
@rout ATL_pther2
   Mjoin( PATL, @(sh)r2 )( arg-up, arg->n, (SCALAR)(arg->al), (TYPE *)(arg->x),
      arg->incx, (TYPE *)(arg->y), arg->incy, (TYPE *)(arg->a), arg->la );
@rout ATL_ptsyr2 ATL_pther2
*/
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
 
@define rname @Mjoin( PATL, pt@(sh)r2 )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( ( N == 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;
   Mjoin(PATL,@(sh)r2)(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA);
/* 
   ATL_thread_init( &attr );
   root = ATL_Ssyr2( &type, 0, nthreads, nb, UPLO, N, (void *)(ALPHA),
                     (void *)(X), INCX, (void *)(Y), INCY, (void *)(A), LDA );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_ptspmv
@define sh @sp@
@rout ATL_pthpmv
@define sh @hp@
@rout ATL_ptspmv ATL_pthpmv
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)


#if 0

@define rname @Mjoin( PATL, pt@(sh)mv0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_SPMV_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_SPMV_T *)(root->arg);
@rout ATL_ptspmv
#ifdef TREAL
   Mjoin( PATL, @(sh)mv )( arg->up, arg->n, (SCALAR)(*((TYPE *)(arg->al))),
      (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x), arg->incx,
      (SCALAR)(*((TYPE *)(arg->be))), (TYPE *)(arg->y), arg->incy );
#else
   Mjoin( PATL, @(sh)mv )( arg->up, arg->n, (SCALAR)(arg->al),
      (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x), arg->incx,
      (SCALAR)(arg->be), (TYPE *)(arg->y), arg->incy );
#endif
@rout ATL_pthpmv
   Mjoin( PATL, @(sh)mv )( arg->up, arg->n, (SCALAR)(arg->al),
      (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x), arg->incx,
      (SCALAR)(arg->be), (TYPE *)(arg->y), arg->incy );
@rout ATL_ptspmv ATL_pthpmv
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip

#endif

@define rname @Mjoin( PATL, pt@(sh)mv )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( ( N == 0 ) ||
       ( ( SCALAR_IS_ZERO( ALPHA ) ) && ( SCALAR_IS_ONE( BETA ) ) ) ) return;
 
   if( SCALAR_IS_ZERO( ALPHA ) )
   {
      if( !( SCALAR_IS_ONE( BETA ) ) )
         Mjoin( PATL, ptscal )( N, BETA, Y, INCY );
      return;
   }
   Mjoin(PATL,@(sh)mv)(UPLO, N, ALPHA, A, X, INCX, BETA, Y, INCY);
/* 
   ATL_thread_init( &attr );
   root = ATL_Sspmv( &type, 0, nthreads, nb, UPLO, N, (void *)(alpha),
                     (void *)(A), (void *)(X), INCX, (void *)(beta),
                     (void *)(Y), INCY );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_ptspr
@define sh @sp@
@rout ATL_pthpr
@define sh @hp@
@rout ATL_ptspr ATL_pthpr
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)
 
@define rname @Mjoin( PATL, pt@(sh)r0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_SPR_T                   * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_SPR_T *)(root->arg);
/*
@rout ATL_ptspr
#ifdef TREAL
   if( arg->up == AtlasLower )
      Mjoin( PATL, @(sh)rL )( arg->n, (SCALAR)(*((TYPE *)(arg->al))),
         (TYPE *)(arg->x), arg->incx, (TYPE *)(arg->a), arg->la );
   else
      Mjoin( PATL, @(sh)rU )( arg->n, (SCALAR)(*((TYPE *)(arg->al))),
         (TYPE *)(arg->x), arg->incx, (TYPE *)(arg->a), arg->la );
#else
   if( arg->up == AtlasLower )
      Mjoin( PATL, @(sh)rL )( arg->n, (SCALAR)(arg->al), (TYPE *)(arg->x),
                           arg->incx, (TYPE *)(arg->a), arg->la );
   else
      Mjoin( PATL, @(sh)rU )( arg->n, (SCALAR)(arg->al), (TYPE *)(arg->x),
                           arg->incx, (TYPE *)(arg->a), arg->la );
#endif
@rout ATL_pthpr
   if( arg->up == AtlasLower )
      Mjoin( PATL, @(sh)rL )( arg->n, (SCALAR)(*((TYPE *)(arg->al))),
         (TYPE *)(arg->x), arg->incx, (TYPE *)(arg->a), arg->la );
   else
      Mjoin( PATL, @(sh)rU )( arg->n, (SCALAR)(*((TYPE *)(arg->al))),
         (TYPE *)(arg->x), arg->incx, (TYPE *)(arg->a), arg->la );
@rout ATL_ptspr ATL_pthpr
*/

   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip

@define rname @Mjoin( PATL, pt@(sh)r )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
@rout ATL_ptspr
   const SCALAR               ALPHA,
@rout ATL_pthpr
   const TYPE                 ALPHA,
@rout ATL_ptspr ATL_pthpr
   const TYPE                 * X,
   const int                  INCX,
   TYPE                       * A
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
@rout ATL_ptspr
   if( ( N <= 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;
@rout ATL_pthpr
   if( ( N <= 0 ) || ( ALPHA == ATL_rzero ) ) return;
@rout ATL_ptspr ATL_pthpr

   Mjoin(PATL,@(sh)r)(UPLO, N, ALPHA, X, INCX, A);
/* 
   ATL_thread_init( &attr );
   root = ATL_Sspr( &type, 0, nthreads, nb, UPLO, N, (void *)(ALPHA),
                    (void *)(X), INCX, (void *)(A), N );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_ptspr2
@define sh @sp@
@rout ATL_pthpr2
@define sh @hp@
@rout ATL_ptspr2 ATL_pthpr2
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)
 
@define rname @Mjoin( PATL, pt@(sh)r20 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_SPR2_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_SPR2_T *)(root->arg);
/*
@rout ATL_ptspr2
#ifdef TREAL
   Mjoin( PATL, @(sh)r2 )( arg-up, arg->n, (SCALAR)(*((TYPE *)(arg->al))),
      (TYPE *)(arg->x), arg->incx, (TYPE *)(arg->y), arg->incy,
      (TYPE *)(arg->a), arg->la );
#else
   Mjoin( PATL, @(sh)r2 )( arg-up, arg->n, (SCALAR)(arg->al), (TYPE *)(arg->x),
      arg->incx, (TYPE *)(arg->y), arg->incy, (TYPE *)(arg->a) );
#endif
@rout ATL_pthpr2
   Mjoin( PATL, @(sh)r2 )( arg-up, arg->n, (SCALAR)(arg->al), (TYPE *)(arg->x),
      arg->incx, (TYPE *)(arg->y), arg->incy, (TYPE *)(arg->a) );
@rout ATL_ptspr2 ATL_pthpr2
*/
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip

@define rname @Mjoin( PATL, pt@(sh)r2 )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const SCALAR               ALPHA,
   const TYPE                 * X,
   const int                  INCX,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( ( N == 0 ) || ( SCALAR_IS_ZERO( ALPHA ) ) ) return;
   Mjoin(PATL,@(sh)r2)(UPLO, N, ALPHA, X, INCX, Y, INCY, A);
/* 
   ATL_thread_init( &attr );
   root = ATL_Ssyr2( &type, 0, nthreads, nb, UPLO, N, (void *)(ALPHA),
                     (void *)(X), INCX, (void *)(Y), INCY, (void *)(A), LDA );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_pttpmv
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)
 
@define rname @Mjoin( PATL, pttpmv0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_TPMV_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_TPMV_T *)(root->arg);
   Mjoin( PATL, tpmv )( arg->up, arg->ta, arg->di, arg->n, (TYPE *)(arg->a),
                        (TYPE *)(arg->x), arg->incx );
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
 
@define rname @Mjoin( PATL, pttpmv )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG,
   const int                  N,
   const TYPE                 * A,
   TYPE                       * X,
   const int                  INCX
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( N == 0 ) return;
   Mjoin(PATL,tpmv)(UPLO, TRANS, DIAG, N, A, X, INCX);
/* 
   ATL_thread_init( &attr );
   root = ATL_Stpmv( &type, 0, nthreads, nb, UPLO, TRANS, DIAG, N, (void *)(A),
                     LDA, (void *)(X), INCX );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_pttpsv
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)
 
@define rname @Mjoin( PATL, pttpsv0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_TRSV_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_TRSV_T *)(root->arg);
   Mjoin( PATL, trsv )( arg->up, arg->ta, arg->di, arg->n, (TYPE *)(arg->a),
                        arg->la, (TYPE *)(arg->x), arg->incx );
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
 
@define rname @Mjoin( PATL, pttpsv )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG,
   const int                  N,
   const TYPE                 * A,
   TYPE                       * X,
   const int                  INCX
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( N == 0 ) return;
   Mjoin(PATL,tpsv)(UPLO, TRANS, DIAG, N, A, X, INCX);
/* 
   ATL_thread_init( &attr );
   root = ATL_Stpsv( &type, 0, nthreads, nb, UPLO, TRANS, DIAG, N, (void *)(A),
                     LDA, (void *)(X), INCX );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_ptsbmv
@define sh @sb@
@rout ATL_pthbmv
@define sh @hb@
@rout ATL_ptsbmv ATL_pthbmv
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)
 
@define rname @Mjoin( PATL, pt@(sh)mv0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_SBMV_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_SBMV_T *)(root->arg);
@rout ATL_ptsbmv
#ifdef TREAL
   Mjoin( PATL, @(sh)mv )( arg->up, arg->n, arg->k,
      (SCALAR)(*((TYPE *)(arg->al))), (TYPE *)(arg->a), arg->la,
      (TYPE *)(arg->x), arg->incx, (SCALAR)(*((TYPE *)(arg->be))),
      (TYPE *)(arg->y), arg->incy );
#else
   Mjoin( PATL, @(sh)mv )( arg->up, arg->n, arg->k, (SCALAR)(arg->al),
      (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x), arg->incx,
      (SCALAR)(arg->be), (TYPE *)(arg->y), arg->incy );
#endif
@rout ATL_pthbmv
   Mjoin( PATL, @(sh)mv )( arg->up, arg->n, arg->k, (SCALAR)(arg->al),
      (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x), arg->incx,
      (SCALAR)(arg->be), (TYPE *)(arg->y), arg->incy );
@rout ATL_ptsbmv ATL_pthbmv
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip

@define rname @Mjoin( PATL, pt@(sh)mv )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const int                  N,
   const int                  K,
   const SCALAR               ALPHA,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const int                  INCX,
   const SCALAR               BETA,
   TYPE                       * Y,
   const int                  INCY
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( ( N == 0 ) ||
       ( ( SCALAR_IS_ZERO( ALPHA ) ) && ( SCALAR_IS_ONE( BETA ) ) ) ) return;
 
   if( SCALAR_IS_ZERO( ALPHA ) )
   {
      if( !( SCALAR_IS_ONE( BETA ) ) )
         Mjoin( PATL, ptscal )( N, BETA, Y, INCY );
      return;
   }
   Mjoin(PATL,@(sh)mv)(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY);
/* 
   ATL_thread_init( &attr );
   root = ATL_Ssbmv( &type, 0, nthreads, nb, UPLO, N, K, (void *)(alpha),
                     (void *)(A), LDA, (void *)(X), INCX, (void *)(beta),
                     (void *)(Y), INCY );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_pttbmv
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)
 
@define rname @Mjoin( PATL, pttbmv0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_TBMV_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_TBMV_T *)(root->arg);
   Mjoin( PATL, tbmv )( arg->up, arg->ta, arg->di, arg->n, arg->k,
                        (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x),
                        arg->incx );
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
 
@define rname @Mjoin( PATL, pttbmv )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG,
   const int                  N,
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X,
   const int                  INCX
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( N == 0 ) return;
   Mjoin(PATL,tbmv)(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX);
/* 
   ATL_thread_init( &attr );
   root = ATL_Stbmv( &type, 0, nthreads, nb, UPLO, TRANS, DIAG, N, K,
                     (void *)(A), LDA, (void *)(X), INCX );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout ATL_pttbsv
@extract @(VER_ATLAS_SRC)
@extract @(PT2_INCLUDE)
 
@define rname @Mjoin( PATL, pttbsv0 )@
PT_FUN_ARG_T @(rname)( PT_FUN_ARG_T ARGS )
{
@extract @(LOCAL_VARIABLE)
   PT_TREE_T                  root = (PT_TREE_T)(ARGS);
   PT_TBSV_T                  * arg;
@extract @(EXECUTABLE_STATEMENT)
   ATL_wait_tree( root );
   arg = (PT_TBSV_T *)(root->arg);
   Mjoin( PATL, tbsv )( arg->up, arg->ta, arg->di, arg->n, arg->k,
                        (TYPE *)(arg->a), arg->la, (TYPE *)(arg->x),
                        arg->incx );
   ATL_signal_tree( root );
 
   return( NULL );
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
 
@define rname @Mjoin( PATL, pttbsv )@
void @(rname)
(
   const enum ATLAS_UPLO      UPLO,
   const enum ATLAS_TRANS     TRANS,
   const enum ATLAS_DIAG      DIAG,
   const int                  N,
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X,
   const int                  INCX
)
{
@extract @(ATLAS_PT2_COMMENT)
@extract @(EXECUTABLE_STATEMENT)
   if( N == 0 ) return;
   Mjoin(PATL,tbsv)(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX);
/* 
   ATL_thread_init( &attr );
   root = ATL_Stbsv( &type, 0, nthreads, nb, UPLO, TRANS, DIAG, N, K,
                     (void *)(A), LDA, (void *)(X), INCX );
   ATL_thread_tree( root, &attr );
   ATL_join_tree  ( root  );
   ATL_free_tree  ( root  );
   ATL_thread_free( &attr );
*/
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip
@rout atlas_ptlvl2.h
@define rname @atlas_ptlvl2.h@
@extract @(VER_ATLAS_SRC)
#ifndef ATLAS_PTLVL2_H
#define ATLAS_PTLVL2_H
#include "atlas_ptmisc.h"
/*
 * =====================================================================
 * Include files
 * =====================================================================
 */
#include "atlas_ptmisc.h"

#include "atlas_level2.h"
/*
 * =====================================================================
 * macro constants
 * =====================================================================
 */

/*
 * =====================================================================
 * macro functions
 * =====================================================================
 */

/*
 * =====================================================================
 * typedef definitions
 * =====================================================================
 */
typedef struct
{
   const void                 * a, * al, * x, * be;
   void                       * y;
   enum ATLAS_TRANS           ta;
   int                        incx, incy, kl, ku, la, m, n;
} PT_GBMV_T;

typedef struct
{
   const void                 * a, * al, * x, * be;
   void                       * y;
   enum ATLAS_TRANS           ta;
   int                        incx, incy, la, m, n;
} PT_GEMV_T;

typedef struct
{
   const void                 * al, * x, * y;
   void                       * a;
   int                        incx, incy, la, m, n;
} PT_GER_T;

typedef struct
{
   const void                 * al, * x, * y;
   void                       * a;
   enum ATLAS_UPLO            up;
   int                        incx, incy, la, n;
} PT_SPR2_T;

typedef struct
{
   const void                 * al, * x, * y;
   void                       * a;
   enum ATLAS_UPLO            up;
   int                        incx, incy, la, n;
} PT_SYR2_T;

typedef struct
{
   const void                 * al, * x;
   void                       * a;
   enum ATLAS_UPLO            up;
   int                        incx, la, n;
} PT_SPR_T;

typedef struct
{
   const void                 * al, * x;
   void                       * a;
   enum ATLAS_UPLO            up;
   int                        incx, la, n;
} PT_SYR_T;

typedef struct
{
   const void                 * a, * al, * x, * be;
   void                       * y;
   enum ATLAS_UPLO            up;
   int                        incx, incy, k, la, n;
} PT_SBMV_T;

typedef struct
{
   const void                 * a, * al, * x, * be;
   void                       * y;
   enum ATLAS_UPLO            up;
   int                        incx, incy, la, n;
} PT_SPMV_T;

typedef struct
{
   const void                 * a, * al, * x, * be;
   void                       * y;
   enum ATLAS_UPLO            up;
   int                        incx, incy, la, n;
} PT_SYMV_T;

typedef struct
{
   const void                 * a;
   void                       * x;
   enum ATLAS_UPLO            up;
   enum ATLAS_TRANS           ta;
   enum ATLAS_DIAG            di;
   int                        incx, k, la, n;
} PT_TBMV_T;

typedef struct
{
   const void                 * a;
   void                       * x;
   enum ATLAS_UPLO            up;
   enum ATLAS_TRANS           ta;
   enum ATLAS_DIAG            di;
   int                        incx, la, n;
} PT_TPMV_T;

typedef struct
{
   const void                 * a;
   void                       * x;
   enum ATLAS_UPLO            up;
   enum ATLAS_TRANS           ta;
   enum ATLAS_DIAG            di;
   int                        incx, la, n;
} PT_TRMV_T;

typedef struct
{
   const void                 * a;
   void                       * x;
   enum ATLAS_UPLO            up;
   enum ATLAS_TRANS           ta;
   enum ATLAS_DIAG            di;
   int                        incx, k, la, n;
} PT_TBSV_T;

typedef struct
{
   const void                 * a;
   void                       * x;
   enum ATLAS_UPLO            up;
   enum ATLAS_TRANS           ta;
   enum ATLAS_DIAG            di;
   int                        incx, la, n;
} PT_TPSV_T;

typedef struct
{
   const void                 * a;
   void                       * x;
   enum ATLAS_UPLO            up;
   enum ATLAS_TRANS           ta;
   enum ATLAS_DIAG            di;
   int                        incx, la, n;
} PT_TRSV_T;

/*
 * =====================================================================
 * Function prototypes
 * =====================================================================
 */
PT_FUN_ARG_T      Mjoin( PATL, ptgbmv0   )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, ptgemv0   )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pttbmv0   )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pttpmv0   )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pttrmv0   )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pttbsv0   )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pttpsv0   )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pttrsv0   )          ( PT_FUN_ARG_T );

#ifdef TREAL

PT_FUN_ARG_T      Mjoin( PATL, ptger0    )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, ptsbmv20  )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, ptspmv20  )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, ptsymv20  )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, ptspr0    )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, ptsyr0    )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, ptspr20   )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, ptsyr20   )          ( PT_FUN_ARG_T );

#else

PT_FUN_ARG_T      Mjoin( PATL, ptgerc0   )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, ptgeru0   )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pthbmv20  )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pthpmv20  )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pthemv20  )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pthpr0    )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pther0    )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pthpr20   )          ( PT_FUN_ARG_T );
PT_FUN_ARG_T      Mjoin( PATL, pther20   )          ( PT_FUN_ARG_T );

#endif
/*
 * =====================================================================
 * Prototypes for the Level 2 multi-threaded ATLAS BLAS routines
 * =====================================================================
 */
void              Mjoin( PATL, ptgbmv )
(  const enum ATLAS_TRANS,           const int,       const int,
   const int,       const int,       const SCALAR,    const TYPE *,
   const int,       const TYPE *,    const int,       const SCALAR,
   TYPE *,          const int );
void              Mjoin( PATL, ptgemv )
(  const enum ATLAS_TRANS,           const int,       const int,
   const SCALAR,    const TYPE *,    const int,       const TYPE *,
   const int,       const SCALAR,    TYPE *,          const int );
void              Mjoin( PATL, pttbmv )
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const int,
   const TYPE *,    const int,       TYPE *,          const int );
void              Mjoin( PATL, pttpmv )
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const TYPE *,
   TYPE *,          const int );
void              Mjoin( PATL, pttrmv )
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const TYPE *,
   const int,       TYPE *,          const int );
void              Mjoin( PATL, pttbsv )
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const int,
   const TYPE *,    const int,       TYPE *,          const int );
void              Mjoin( PATL, pttpsv )
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const TYPE *,
   TYPE *,          const int );
void              Mjoin( PATL, pttrsv )
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const TYPE *,
   const int,       TYPE *,          const int );

#ifdef TREAL

void              Mjoin( PATL, ptger  )
(  const int,       const int,       const SCALAR,    const TYPE *,
   const int,       const TYPE *,    const int,       TYPE *,
   const int );
void              Mjoin( PATL, ptsbmv )
(  const enum ATLAS_UPLO,            const int,       const int,
   const SCALAR,    const TYPE *,    const int,       const TYPE *,
   const int,       const SCALAR,    TYPE *,          const int );
void              Mjoin( PATL, ptspmv )
(  const enum ATLAS_UPLO,            const int,       const SCALAR,
   const TYPE *,    const TYPE *,    const int,       const SCALAR,
   TYPE *,          const int );
void              Mjoin( PATL, ptsymv )
(  const enum ATLAS_UPLO,            const int,       const SCALAR,
   const TYPE *,    const int,       const TYPE *,    const int,
   const SCALAR,    TYPE *,          const int );
void              Mjoin( PATL, ptspr  )
(  const enum ATLAS_UPLO,            const int,       const SCALAR,
   const TYPE *,    const int,       TYPE * );
void              Mjoin( PATL, ptsyr  )
(  const enum ATLAS_UPLO,            const int,       const SCALAR,
   const TYPE *,    const int,       TYPE *,          const int );
void              Mjoin( PATL, ptspr2 )
(  const enum ATLAS_UPLO,            const int,       const SCALAR,
   const TYPE *,    const int,       const TYPE *,    const int,
   TYPE * );
void              Mjoin( PATL, ptsyr2 )
(  const enum ATLAS_UPLO,            const int,       const SCALAR,
   const TYPE *,    const int,       const TYPE *,    const int,
   TYPE *,          const int );

#else

void              Mjoin( PATL, ptgerc )
(  const int,       const int,       const SCALAR,    const TYPE *,
   const int,       const TYPE *,    const int,       TYPE *,
   const int );
void              Mjoin( PATL, ptgeru )
(  const int,       const int,       const SCALAR,    const TYPE *,
   const int,       const TYPE *,    const int,       TYPE *,
   const int );
void              Mjoin( PATL, pthbmv )
(  const enum ATLAS_UPLO,            const int,       const int,
   const SCALAR,    const TYPE *,    const int,       const TYPE *,
   const int,       const SCALAR,    TYPE *,          const int );
void              Mjoin( PATL, pthpmv )
(  const enum ATLAS_UPLO,            const int,       const SCALAR,
   const TYPE *,    const TYPE *,    const int,       const SCALAR,
   TYPE *,          const int );
void              Mjoin( PATL, pthemv )
(  const enum ATLAS_UPLO,            const int,       const SCALAR,
   const TYPE *,    const int,       const TYPE *,    const int,
   const SCALAR,    TYPE *,          const int );
void              Mjoin( PATL, pthpr  )
(  const enum ATLAS_UPLO,            const int,       const TYPE,
   const TYPE *,    const int,       TYPE * );
void              Mjoin( PATL, pther  )
(  const enum ATLAS_UPLO,            const int,       const TYPE,
   const TYPE *,    const int,       TYPE *,          const int );
void              Mjoin( PATL, pthpr2 )
(  const enum ATLAS_UPLO,            const int,       const SCALAR,
   const TYPE *,    const int,       const TYPE *,    const int,
   TYPE * );
void              Mjoin( PATL, pther2 )
(  const enum ATLAS_UPLO,            const int,       const SCALAR,
   const TYPE *,    const int,       const TYPE *,    const int,
   TYPE *,          const int );

#endif

#endif
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip
@rout Make.l2ptblas
@extract @(VER_ATLAS_MAK)
#
include Make.inc
mySRCdir = $(SRCdir)/src/pthreads/blas/level2
#
########################################################################
#
INC2dep   = \
   $(INCAdir)/atlas_pthreads.h     $(INCSdir)/atlas_aux.h      \
   $(INCSdir)/atlas_enum.h      $(INCSdir)/atlas_misc.h     \
   $(INCSdir)/atlas_level1.h    $(INCSdir)/atlas_level2.h   \
   $(INCSdir)/atlas_ptmisc.h    $(INCSdir)/atlas_ptlvl1.h   \
   $(INCSdir)/atlas_ptlevel1.h  $(INCSdir)/atlas_ptlvl2.h   \
   $(INCSdir)/atlas_ptlevel2.h
#
## Object files ########################################################
#
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
ATL_@(pre_)lvl2obj = \
   @declare "   " y y
   @ptyp_ s d
      @multidef rout_
         trsv  tpsv  tbsv  trmv  tpmv  tbmv  syr2  spr2  syr
         spr   symv  spmv  sbmv  ger   gemv  gbmv
      @endmultidef
   @ptyp_ c z
      @multidef rout_
         trsv  tpsv  tbsv  trmv  tpmv  tbmv  her2  hpr2  her
         hpr   hemv  hpmv  hbmv  geru  gerc  gemv  gbmv
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      ATL_@(pre_)pt@(rout_).o
   @endwhile
   @killkeys ptyp_
   @enddeclare
#
@endwhile
## Targets #############################################################
#
all   : lib
#
lvl2  : lib
#
lib   : dlib slib zlib clib
#
@whiledef pre_ z c d s
@(pre_)lvl2 : @(pre_)lib
@endwhile
#
@whiledef pre_ z c d s
@(pre_)lib  : @(pre_)lib.grd
@endwhile
#
@whiledef pre_ z c d s
@(pre_)lib.grd  : $(ATL_@(pre_)lvl2obj)
	@(arch) @(archflgs) @(ptxlib) $(ATL_@(pre_)lvl2obj)
	@(ranlib) @(ptxlib)
	touch @(pre_)lib.grd
#
@endwhile
########################################################################
#
@multidef upr_ d s d s
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s d
      @multidef rout_
         trsv  tpsv  tbsv  trmv  tpmv  tbmv  syr2  spr2  syr
         spr   symv  spmv  sbmv  ger   gemv  gbmv
      @endmultidef
      @define cdefs @-D@up@(upr_)REAL@
   @ptyp_ c z
      @multidef rout_
         trsv  tpsv  tbsv  trmv  tpmv  tbmv  her2  hpr2  her
         hpr   hemv  hpmv  hbmv  geru  gerc  gemv  gbmv
      @endmultidef
      @define cdefs @-D@up@(upr_)CPLX@
   @ptyp_ !
   @whiledef rout_
      @define rpre_ @ATL_pt@(rout_)@
      @define rsrc_ @$(mySRCdir)/@(rpre_).c@
      @define robj_ @ATL_@(pre_)pt@(rout_).o@
@28l@(robj_) : @(rsrc_) $(INC2dep)
@(CCptcomp) @(cdefs) @(rsrc_)
      @undef rpre_
      @undef rsrc_
      @undef robj_
   @endwhile
   @undef cdefs
   @killkeys ptyp_
   @undef upr_
#
@endwhile
########################################################################
#
@whiledef pre_ z c d s
@(pre_)clean           :
	rm -f $(ATL_@(pre_)lvl2obj) @(pre_)*.grd
#
@endwhile
#
clean            :
	rm -f *.o *.grd
#
########################################################################
@skip
@skip
@rout atlas_ptlevel2.h
@define rname @atlas_ptlevel2.h@
@extract @(VER_ATLAS_SRC)
#ifndef ATLAS_PTLEVEL2_H
#define ATLAS_PTLEVEL2_H
/*
 * =====================================================================
 * Include files
 * =====================================================================
 */
#include "atlas_enum.h"
/*
 * =====================================================================
 * Prototypes  for single precision real  Level 2  multi-threaded  ATLAS
 * BLAS routines.
 * =====================================================================
 */
void              ATL_sptgbmv
(  const enum ATLAS_TRANS,           const int,       const int,
   const int,       const int,       const float,     const float  *,
   const int,       const float  *,  const int,       const float,
   float  *,        const int );
void              ATL_sptgemv
(  const enum ATLAS_TRANS,           const int,       const int,
   const float,     const float  *,  const int,       const float  *,
   const int,       const float,     float  *,        const int );
void              ATL_sptger
(  const int,       const int,       const float,     const float  *,
   const int,       const float  *,  const int,       float  *,
   const int );
void              ATL_sptsbmv
(  const enum ATLAS_UPLO,            const int,       const int,
   const float,     const float  *,  const int,       const float  *,
   const int,       const float,     float  *,        const int );
void              ATL_sptspmv
(  const enum ATLAS_UPLO,            const int,       const float,
   const float  *,  const float  *,  const int,       const float,
   float  *,        const int );
void              ATL_sptsymv
(  const enum ATLAS_UPLO,            const int,       const float,
   const float  *,  const int,       const float  *,  const int,
   const float,     float  *,        const int );
void              ATL_sptspr
(  const enum ATLAS_UPLO,            const int,       const float,
   const float  *,  const int,       float  * );
void              ATL_sptsyr
(  const enum ATLAS_UPLO,            const int,       const float,
   const float  *,  const int,       float  *,        const int );
void              ATL_sptspr2
(  const enum ATLAS_UPLO,            const int,       const float,
   const float  *,  const int,       const float  *,  const int,
   float  * );
void              ATL_sptsyr2
(  const enum ATLAS_UPLO,            const int,       const float,
   const float  *,  const int,       const float  *,  const int,
   float  *,        const int );
void              ATL_spttbmv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const int,
   const float  *,  const int,       float  *,        const int );
void              ATL_spttpmv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const float  *,
   float  *,        const int );
void              ATL_spttrmv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const float  *,
   const int,       float  *,        const int );
void              ATL_spttbsv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const int,
   const float  *,  const int,       float  *,        const int );
void              ATL_spttpsv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const float  *,
   float  *,        const int );
void              ATL_spttrsv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const float  *,
   const int,       float  *,        const int );
/*
 * =====================================================================
 * Prototypes  for double precision real  Level 2  multi-threaded  ATLAS
 * BLAS routines.
 * =====================================================================
 */
void              ATL_dptgbmv
(  const enum ATLAS_TRANS,           const int,       const int,
   const int,       const int,       const double,    const double *,
   const int,       const double *,  const int,       const double,
   double *,        const int );
void              ATL_dptgemv
(  const enum ATLAS_TRANS,           const int,       const int,
   const double,    const double *,  const int,       const double *,
   const int,       const double,    double *,        const int );
void              ATL_dptger
(  const int,       const int,       const double,    const double *,
   const int,       const double *,  const int,       double *,
   const int );
void              ATL_dptsbmv
(  const enum ATLAS_UPLO,            const int,       const int,
   const double,    const double *,  const int,       const double *,
   const int,       const double,    double *,        const int );
void              ATL_dptspmv
(  const enum ATLAS_UPLO,            const int,       const double,
   const double *,  const double *,  const int,       const double,
   double *,        const int );
void              ATL_dptsymv
(  const enum ATLAS_UPLO,            const int,       const double,
   const double *,  const int,       const double *,  const int,
   const double,    double *,        const int );
void              ATL_dptspr
(  const enum ATLAS_UPLO,            const int,       const double,
   const double *,  const int,       double * );
void              ATL_dptsyr
(  const enum ATLAS_UPLO,            const int,       const double,
   const double *,  const int,       double *,        const int );
void              ATL_dptspr2
(  const enum ATLAS_UPLO,            const int,       const double,
   const double *,  const int,       const double *,  const int,
   double * );
void              ATL_dptsyr2
(  const enum ATLAS_UPLO,            const int,       const double,
   const double *,  const int,       const double *,  const int,
   double *,        const int );
void              ATL_dpttbmv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const int,
   const double *,  const int,       double *,        const int );
void              ATL_dpttpmv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const double *,
   double *,        const int );
void              ATL_dpttrmv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const double *,
   const int,       double *,        const int );
void              ATL_dpttbsv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const int,
   const double *,  const int,       double *,        const int );
void              ATL_dpttpsv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const double *,
   double *,        const int );
void              ATL_dpttrsv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const double *,
   const int,       double *,        const int );
/*
 * =====================================================================
 * Prototypes  for single precision complex Level 2 multi-threaded ATLAS
 * BLAS routines.
 * =====================================================================
 */
void              ATL_cptgbmv
(  const enum ATLAS_TRANS,           const int,       const int,
   const int,       const int,       const float  *,  const float  *,
   const int,       const float  *,  const int,       const float  *,
   float  *,        const int );
void              ATL_cptgemv
(  const enum ATLAS_TRANS,           const int,       const int,
   const float  *,  const float  *,  const int,       const float  *,
   const int,       const float  *,  float  *,        const int );
void              ATL_cptgerc
(  const int,       const int,       const float  *,  const float  *,
   const int,       const float  *,  const int,       float  *,
   const int );
void              ATL_cptgeru
(  const int,       const int,       const float  *,  const float  *,
   const int,       const float  *,  const int,       float  *,
   const int );
void              ATL_cpthbmv
(  const enum ATLAS_UPLO,            const int,       const int,
   const float  *,  const float  *,  const int,       const float  *,
   const int,       const float  *,  float  *,        const int );
void              ATL_cpthpmv
(  const enum ATLAS_UPLO,            const int,       const float  *,
   const float  *,  const float  *,  const int,       const float  *,
   float  *,        const int );
void              ATL_cpthemv
(  const enum ATLAS_UPLO,            const int,       const float  *,
   const float  *,  const int,       const float  *,  const int,
   const float  *,  float  *,        const int );
void              ATL_cpthpr
(  const enum ATLAS_UPLO,            const int,       const float,
   const float  *,  const int,       float  * );
void              ATL_cpther
(  const enum ATLAS_UPLO,            const int,       const float,
   const float  *,  const int,       float  *,        const int );
void              ATL_cpthpr2
(  const enum ATLAS_UPLO,            const int,       const float  *,
   const float  *,  const int,       const float  *,  const int,
   float  * );
void              ATL_cpther2
(  const enum ATLAS_UPLO,            const int,       const float  *,
   const float  *,  const int,       const float  *,  const int,
   float  *,        const int );
void              ATL_cpttbmv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const int,
   const float  *,  const int,       float  *,        const int );
void              ATL_cpttpmv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const float  *,
   float  *,        const int );
void              ATL_cpttrmv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const float  *,
   const int,       float  *,        const int );
void              ATL_cpttbsv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const int,
   const float  *,  const int,       float  *,        const int );
void              ATL_cpttpsv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const float  *,
   float  *,        const int );
void              ATL_cpttrsv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const float  *,
   const int,       float  *,        const int );
/*
 * =====================================================================
 * Prototypes  for double precision complex Level 2 multi-threaded ATLAS
 * BLAS routines.
 * =====================================================================
 */
void              ATL_zptgbmv
(  const enum ATLAS_TRANS,           const int,       const int,
   const int,       const int,       const double *,  const double *,
   const int,       const double *,  const int,       const double *,
   double *,        const int );
void              ATL_zptgemv
(  const enum ATLAS_TRANS,           const int,       const int,
   const double *,  const double *,  const int,       const double *,
   const int,       const double *,  double *,        const int );
void              ATL_zptgerc
(  const int,       const int,       const double *,  const double *,
   const int,       const double *,  const int,       double *,
   const int );
void              ATL_zptgeru
(  const int,       const int,       const double *,  const double *,
   const int,       const double *,  const int,       double *,
   const int );
void              ATL_zpthbmv
(  const enum ATLAS_UPLO,            const int,       const int,
   const double *,  const double *,  const int,       const double *,
   const int,       const double *,  double *,        const int );
void              ATL_zpthpmv
(  const enum ATLAS_UPLO,            const int,       const double *,
   const double *,  const double *,  const int,       const double *,
   double *,        const int );
void              ATL_zpthemv
(  const enum ATLAS_UPLO,            const int,       const double *,
   const double *,  const int,       const double *,  const int,
   const double *,  double *,        const int );
void              ATL_zpthpr
(  const enum ATLAS_UPLO,            const int,       const double,
   const double *,  const int,       double * );
void              ATL_zpther
(  const enum ATLAS_UPLO,            const int,       const double,
   const double *,  const int,       double *,        const int );
void              ATL_zpthpr2
(  const enum ATLAS_UPLO,            const int,       const double *,
   const double *,  const int,       const double *,  const int,
   double * );
void              ATL_zpther2
(  const enum ATLAS_UPLO,            const int,       const double *,
   const double *,  const int,       const double *,  const int,
   double *,        const int );
void              ATL_zpttbmv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const int,
   const double *,  const int,       double *,        const int );
void              ATL_zpttpmv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const double *,
   double *,        const int );
void              ATL_zpttrmv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const double *,
   const int,       double *,        const int );
void              ATL_zpttbsv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const int,
   const double *,  const int,       double *,        const int );
void              ATL_zpttpsv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const double *,
   double *,        const int );
void              ATL_zpttrsv
(  const enum ATLAS_UPLO,            const enum ATLAS_TRANS,
   const enum ATLAS_DIAG,            const int,       const double *,
   const int,       double *,        const int );

#endif
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip
@rout !
@skip
@skip
@undef PT2_INCLUDE
@skip
@skip
