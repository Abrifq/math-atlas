@ROUT damcases.idx samcases.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
# The file has the following format:
# ROUT='routine name' AUTH='author names' COMP='compiler name' CFLAGS='flags'
# ID=<id> NU=<nu> MU=<mu> KU=<ku> KBMAX=<kbmax> KBMIN=<kbmin>
# SSE=[0,1,2,3] X87=[0,1] BMABC=<0/1> BMAB=<0/1> JKMAB=<0/1> JKMABC=<0/1>
# AOUTER=<0/1> BETAN1=<0/1> KRUNTIME=<0/1> LDCTOP=<0/1> X87=<0/1>
# ASM=[asmlist], eg., asmlist is "GAS_x8664,GAS_x8632" or "GAS_SPARC"
# ASM defaults to no assembly dialect required.
# If NU/MU is negative, then the routine can only handle multiples of NU/MU.
#
@ROUT damcases.idx
ID=1 MU=4 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm2x4x1_sse2.S' \
     SSE=3 KRUNTIME=1 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=2 MU=4 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm2x4x256_sse2.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=3 MU=6 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm3x3x256_sse2.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=4 MU=4 NU=1 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_dammm_nb4_sse2.S' \
     SSE=3 KBMIN=4 KBMAX=4 ASM=GAS_x8664 KUISKB=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=5 MU=2 NU=12 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm2x12x2_sse2.S' \
     SSE=3 KBMIN=2 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=6 MU=2 NU=12 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm2x12x256_sse2.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=7 MU=12 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm12x3x256_avx.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=8 MU=6 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm6x3x256_sse3.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=8 MU=6 NU=3 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_damm6x3x4_sse3.S' \
     SSE=3 KBMIN=4 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
@ROUT samcases.idx
ID=7 MU=24 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_samm24x3x256_avx.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
@ROUT atlas_gnuvec.h
#ifndef ATLAS_GNUVEC
   #define ATLAS_GNUVEC 1
   #ifndef TYPE
      #if defined(SREAL) || defined(SCPLX)
         #define TYPE float
      #else
         #define TYPE double
      #endif
   #endif
   #ifdef ATL_VSX
      #define ATL_NVREG 64
      #define ATL_VLENb 16
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_VLEN 4
      #else
         #define ATL_VLEN 2
      #endif
   #elif defined(ATL_AltiVec)
      #define ATL_NVREG 32
      #define ATL_VLENb 16
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_VLEN 4
      #else
         #define ATL_VLEN 2
      #endif
   #elif defined(ATL_AVXMAC) || defined(ATL_AVXFMA4) || defined(ATL_AVX)
      #ifdef ATL_GAS_x8664
         #define ATL_NVREG 16
      #else
         #define ATL_NVREG 8
      #endif
      #define ATL_VLENb 32
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_VLEN 8
         #define ATL_vec_t v8sf
      #else
         #define ATL_VLEN 4
         #define ATL_vec_t v4df
      #endif
      #define ATL_gvbcast(ptr_, v_) \
         (v_) = __builtin_ia32_vbroadcastsd256((void*)(ptr_));
   #elif defined(ATL_SSE3) || defined(ATL_SSE2)
      #ifdef ATL_GAS_x8664
         #define ATL_NVREG 16
      #else
         #define ATL_NVREG 8
      #endif
      #define ATL_VLENb 16
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_vec_t v4sf
         #define ATL_VLEN 4
      #else
         #define ATL_vec_t v2df
         #define ATL_VLEN 2
         #ifdef ATL_SSE3
            #define ATL_gvbcast(ptr_, v_) \
               (v_) = __builtin_ia32_loaddup(ptr_);
         #endif
      #endif
   #elif defined(SREAL) || defined(SCPLX)   /* single-only stuff */
      #ifdef ATL_AltiVec
         #define ATL_NVREG 32
         #define ATL_VLENb 16
         #define ATL_VLEN 4
      #elif defined(ATL_SSE1)
         #define ATL_vec_t v4sf
         #ifdef ATL_GAS_x8664
            #define ATL_NVREG 16
         #else
            #define ATL_NVREG 8
         #endif
         #define ATL_VLENb 16
         #define ATL_VLEN 4
      #elif defined(ATL_NONIEEE) && ATL_NONIEEE != 0
         #ifdef ATL_NEON
            #define ATL_NVREG 16
            #define ATL_VLENb 8
            #define ATL_VLEN 2
         #elif defined(ATL_3DNow)
            #define ATL_NVREG 8
            #define ATL_VLENb 16
            #define ATL_VLEN 4
         #endif
      #endif
   #endif
   #ifndef ATL_VLENb
      #define ATL_VLEN 1
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_VLENb 4
      #else
         #define ATL_VLENb 8
      #endif
      #if defined(ATL_GAS_x8664) || defined(ATL_GAS_x8632)
         #define ATL_NVREG 8
      #else
         #define ATL_NVREG 32
      #endif
   #endif
   #ifndef ATL_vec_t
      #if ATL_VLEN > 1
         typedef TYPE ATL_vec_t  __attribute__ ((vector_size (ATL_VLENb)));
      #else
         #define ATL_vec_t TYPE
      #endif
   #endif
/*
 * Setup macros to multiply and divide by VLEN using shifts
 */
   #if ATL_VLEN == 1
      #define ATL_DivByVLEN(i_) (i_)
      #define ATL_MulByVLEN(i_) (i_)
@iexp s 1 0 +
@iexp i 2 0 +
@iwhile i < 64
   #elif ATL_VLEN == @(i)
      #define ATL_DivByVLEN(i_) ((i_)>>@(s))
      #define ATL_MulByVLEN(i_) ((i_)<<@(s))
   @iexp s @(s) 1 +
   @iexp i @(i) 2 *
@endiwhile
   #else
      #define ATL_DivByVLEN(i_) ((i_)/ATL_VLEN)
      #define ATL_MulByVLEN(i_) ((i_)*ATL_VLEN)
   #endif
   #ifndef ATL_gvbcast
      #if ATL_VLEN == 1
         #define ATL_gvbcast(ptr_, v_) \
            v_ = {*(ptr_)}
      #elif ATL_VLEN == 2
         #define ATL_gvbcast(ptr_, v_) \
            v_ = {*(ptr_), *(ptr_)}
      #elif ATL_VLEN == 4
         #define ATL_gvbcast(ptr_, v_) \
            v_ = {*(ptr_), *(ptr_), *(ptr_), *(ptr_)}
      #elif ATL_VLEN == 8
         #define ATL_gvbcast(ptr_, v_) \
            v_ = {*(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                  *(ptr_), *(ptr_), *(ptr_), *(ptr_)}
      #elif ATL_VLEN == 16
         #define ATL_gvbcast(ptr_, v_) \
            v_ = {*(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                  *(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                  *(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                  *(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                 }
      #else
         #error "Cannot create gvbcast"
      #endif
   #endif
   
#endif
@ROUT emit_amm
@extract -b @(topd)/cw.inc lang=C -def cwdate 2012
#include "atlas_misc.h"
#define ATL_JKMDEF 1
#include "atlas_mmparse.h"
#include "atlas_sys.h"
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr, 
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -d <outdir>: directory to dump files to\n");
   fprintf(stderr, "   -i <infile> : can be repeated for multiple files\n");
   exit(ierr ? ierr : -1);
}

ATL_mmnode_t *GetFlags(int nargs, char **args, char *PRE, char **DOUT)
{
   int i, j=0, n, k;
   char pre='d';
   *DOUT = NULL;
   ATL_mmnode_t *mmb=NULL, *mmp, *mp;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      
      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 'd':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *DOUT = DupString(args[i]);
        break;
      case 'i':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        mmp = ReadMMFile(args[i]);
        if (mmb)
        {
           ATL_mmnode_t *mp;
           for (mp=mmb; mp->next; mp = mp->next);
           mp->next = mmp;
        }
        else
           mmb = mmp;
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *PRE = pre;
   if (!(*DOUT))
   {
      *DOUT = DupString("dMake_amm");
      (*DOUT)[0] = pre;
   }
   return(mmb);
}

void GenMakefile(char pre, ATL_mmnode_t *mmb, char *outd)
{
   ATL_mmnode_t *mmp, *p;
   FILE *fp;
   char *comp, *cflags;
   char *ln;
   int i;
   char be[3] = {'1', 'n', '0'};
   char *bes[3] = {"1", "N1", "0"};
   char al[3] = {'1', 'n', 'X'};
   char dcomp[8] = {'$', '(', 'D', 'M', 'C', ')', '\0'};
   char dflags[12] = {'$', '(', 'D', 'M', 'C', 'F', 'L', 'A', 'G', 'S', 
                     ')', '\0'};
   char *styp = (pre == 'd') ? "-DDREAL" : "-DSREAL";

   ln = malloc((strlen(outd)+11)*sizeof(char));
   assert(ln);
   sprintf(ln, "%s/%cMake_amm", outd, pre);
   fp = fopen(ln, "w");
   assert(fp);
   fprintf(fp, "include ../Make.inc\n");
   fprintf(fp, "CDEFS2=$(CDEFS)\n\n");
/*
 * Spew out all filenames that must be compiled
 */
   fprintf(fp, "objs =");
/*
 * Copy2blk routines
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      const int mu=mmp->mu, nu=mmp->nu;
/*
 *    See if we've already made an entry for this unrolling
 */
      for (p=mmb; p != mmp && (p->mu != mu || p->nu != nu); p = p->next);
      if (p == mmp)  /* mu,nu not seen before */
      {
         int j;
         for (j=0; j < 3; j++)
         {
            int k;
            char *rtn[2] = {"ablk2cmat", "cmat2ablk"};
            for (k=0; k < 2; k++)
            {
               fprintf(fp, " \\\n       ATL_%c%s_%dx%d_a%c_b1.o",
                       pre, rtn[k], mu, nu, al[j]);
               fprintf(fp, " ATL_%c%s_%dx%d_a%c_bX.o",
                       pre, rtn[k], mu, nu, al[j]);
               fprintf(fp, " \\\n       ATL_%c%s_%dx%d_a%c_b0.o",
                       pre, rtn[k], mu, nu, al[j]);
               fprintf(fp, " ATL_%c%s_%dx%d_a%c_bn.o",
                       pre, rtn[k], mu, nu, al[j]);
            }
         }
      }
      for (i=(mu == nu); i < 2; i++)
      {
         const int u = (i) ? mu : nu;
         for (p=mmb; p != mmp && p->mu != u && p->nu != u; p = p->next);
         if (p == mmp)  /* u not seen before */
         {
            int j;
            for (j=0; j < 3; j++)
               fprintf(fp, 
               " \\\n       ATL_%crm2am_a%c_%d.o ATL_%ccm2am_a%c_%d.o",
                       pre, al[j], u, pre, al[j], u);
         }
      }
   }
/*
 * AMM kernel routines
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      int kb = mmp->kbB;
/*
 *    Kernels that take runtime K are only compiled once, so don't repeat them
 *    for every KB
 */
      if (FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
      {
         const int id = mmp->ID;
         for (p=mmb; p != mmp && p->ID != id; p = p->next);
         if (p != mmp)
            continue;
         kb = mmp->ku;
      }
/* 
 *    ATL_<pre>AMMM_<ID>_<kb/ku>_b<X>
 */
      for (i=0; i < 3; i++)
         fprintf(fp, " \\\n       ATL_%cAMMM_%d_%d_b%c.o", pre, mmp->ID, 
                 kb, be[i], mmp->rout);
   }
/*
 * library make targets
 */
   fprintf(fp, "\n\nlib : %clib.grd\nall : %clib.grd\n%clib : %clib.grd\n", 
           pre, pre, pre, pre);
   fprintf(fp, "%clib.grd : $(objs)\n", pre);
   fprintf(fp, "\t$(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(objs)\n");
   fprintf(fp, "\t $(RANLIB) $(ATLASlib)\n");
   fprintf(fp, "\t touch %clib.grd\n", pre);

/*
 * Print out the individual rules for each needed copy function
 */
   dcomp[2] = dflags[2] = toupper(pre);
   dflags[3] = dcomp[3] = 'K';
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      const int mu=mmp->mu, nu = mmp->nu;
/*
 *    Print out 2-D ablk2Cmat and cmat2ablk targets
 */
      for (p=mmb; p != mmp && (p->mu != mu || p->nu != nu); p = p->next);
      if (p == mmp)  /* mu,nu not seen before */
      {
         char cbe[4] = {'0', '1', 'n', 'X'};
         int ibe[4] =  {0,    1,  -1,  2};
         int i, j;
         for (i=0; i < 4; i++)
         {
            for (j=0; j < 3; j++)
            {
               int k;
               char *rtn[2] = {"ablk2cmat", "cmat2ablk"};
               for (k=0; k < 2; k++)
               {
                  char rn[64];
                  sprintf(rn, "ATL_%c%s_%dx%d_a%c_b%c",
                          pre, rtn[k], mu, nu, al[j], cbe[i]);
                  fprintf(fp, "%s.o : %s.c\n", rn, rn);
                  fprintf(fp, "\t%s %s $(CDEFS) %s -c %s.c\n", 
                          dcomp, dflags, styp, rn);
               }
            }
         }
      }
      for (i=(mu == nu) ? 1:0; i < 2; i++)
      {
         const int u = (i) ? mu : nu;
/*
 *       See if we've already made a rule for this unrolling
 */
         for (p=mmb; p != mmp && p->mu != u && p->nu != u; p = p->next);
         if (p == mmp)  /* u not seen before */
         {
            int j;
            for (j=0; j < 3; j++)
            {
               fprintf(fp, "ATL_%crm2am_a%c_%d.o : ATL_%crm2am_a%c_%d.c\n",
                       pre, al[j], u, pre, al[j], u);
               fprintf(fp, "\t%s %s $(CDEFS) %s -c ATL_%crm2am_a%c_%d.c\n", 
                       dcomp, dflags, styp, pre, al[j], u, pre, al[j], u);
               fprintf(fp, "ATL_%ccm2am_a%c_%d.o : ATL_%ccm2am_a%c_%d.c\n",
                       pre, al[j], u, pre, al[j], u);
               fprintf(fp, "\t%s %s $(CDEFS) %s -c ATL_%ccm2am_a%c_%d.c\n", 
                       dcomp, dflags, styp, pre, al[j], u, pre, al[j], u);
            }
         }
      }
   }
/*
 * Print out the individual rules for each kernel compile
 */
   dflags[3] = dcomp[3] = 'M';
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
/*
 *    Kernels that take runtime K are only compiled once, so print rules on
 *    only the first encounter of that ID
 */
      if (FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
      {
         const int id = mmp->ID;
         for (p=mmb; p != mmp && p->ID != id; p = p->next);
         if (p != mmp)
            continue;
      }
      if (mmp->comp)
      {
         comp = (mmp->comp[0] == 'g' && mmp->comp[1] == 'c' && 
                 mmp->comp[2] == 'c' && 
                 (mmp->comp[3] == '\0' || mmp->comp[3] == ' ')) 
              ? "$(GOODGCC)" : mmp->comp;
         cflags = mmp->cflags;
      }
      else
      {
         comp = dcomp;
         cflags = dflags;
      }
/* 
 *    ATL_<pre>AMMM_<ID>_<kb/ku>_b<X>
 */
      for (i=0; i < 3; i++)
      {
         const int kb=FLAG_IS_SET(mmp->flag, MMF_KRUNTIME)?mmp->ku:mmp->kbB;
         fprintf(fp, "ATL_%cAMMM_%d_%d_b%c.o : %s\n", pre, mmp->ID, 
                 kb, be[i], mmp->rout);
         fprintf(fp, "\t%s $(CDEFS2) %s -DBETA%s=1", comp, styp, bes[i]);
         if (!FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
            fprintf(fp, " -DMB=%d -DNB=%d, -DKB=%d", 
                    mmp->mbB, mmp->nbB, mmp->kbB);
         fprintf(fp, " -DATL_USERMM=ATL_%cAMMM_%d_%d_b%c", pre, mmp->ID,
                 kb, be[i]);
         fprintf(fp, " %s -o ATL_%cAMMM_%d_%d_b%c.o -c %s\n", 
                 cflags, pre, mmp->ID, kb, be[i], mmp->rout);
      }
   }
   fclose(fp);
}

void GenUserFiles(char pre, ATL_mmnode_t *mmb, char *outd)
/*
 * Creates any files that can be copied from the AMMCASES directory
 */
{
   ATL_mmnode_t *mmp, *p;
   char *ln=NULL;
   int lnlen=0, dlen;
   char al[3] = {'1', 'n', 'X'};
   int ial[3] = {1,   -1,   2};

   dlen = strlen(outd);
/*
 * Extract every unique block-copy routine
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      int i;
      const int mu=mmp->mu, nu=mmp->nu;
      for (p=mmb; p != mmp && (p->mu != mu || p->nu != nu); p = p->next);
      if (p == mmp)  /* mu,nu not seen before */
      {
         char cbe[4] = {'0', '1', 'n', 'X'};
         int ibe[4] =  {0,    1,  -1,  2};
         int i, j;
         j = 64+8 + strlen(outd);
         j = (j > 128) ? j : 128;
         if (lnlen < j)
         {
            free(ln);
            lnlen = j;
            ln = malloc(j*sizeof(char));
            assert(ln);
         }
         for (i=0; i < 4; i++)
         {
            for (j=0; j < 3; j++)
            {
               char rn[64];
               int ierr;
               int k;
               for (k=0; k < 2; k++)
               {
                  if (!k)
                     sprintf(rn, "ATL_%cablk2cmat_%dx%d_a%c_b%c.c",
                             pre, mu, nu, al[j], cbe[i]);
                  else
                     sprintf(rn, "ATL_%ccmat2ablk_%dx%d_a%c_b%c.c",
                             pre, mu, nu, al[j], cbe[i]);
                  sprintf(ln, 
                     "make %s pre=%c mu=%d nu=%d al=%c be=%c alpha=%d beta=%d", 
                          rn, pre, mu, nu, al[j], cbe[i], ial[j], ibe[i]);
                  ierr = system(ln);
                  if (ierr)
                  {
                     fprintf(stderr, "FAILED CMND='%s'\n", ln);
                     exit(ierr);
                  }
                  sprintf(ln, "mv %s %s/.", rn, outd);
                  ierr = system(ln);
                  if (ierr)
                  {
                     fprintf(stderr, "FAILED CMND='%s'\n", ln);
                     exit(ierr);
                  }
               }
            }
         }
      }
      for (i=0; i < 2; i++)
      {
         const int u = (i) ? mu : nu;
/*
 *       See if we've extracted for this unrolling
 */
         for (p=mmb; p != mmp && p->mu != u && p->nu != u; p = p->next);
         if (p == mmp)  /* u not seen before */
         {
            int j;
            j = 16 * 40 + (strlen(outd)<<1);
            j = (j > 90) ? j : 90;
            if (lnlen < j)
            {
               free(ln);
               lnlen = j;
               ln = malloc(j*sizeof(char));
               assert(ln);
            }
            for (j=0; j < 3; j++)
            {
               int ierr;
               sprintf(ln, 
"make ATL_%crm2am_a%c_%d.c ATL_%ccm2am_a%c_%d.c pre=%c UR=%d alpha=%d al=%c",
                       pre, al[j], u, pre, al[j], u, pre, u, ial[j], al[j]);
               ierr = system(ln);
               if (ierr)
               {
                  fprintf(stderr, "FAILED CMND='%s'\n", ln);
                  exit(ierr);
               }
               sprintf(ln, 
                  "mv ATL_%crm2am_a%c_%d.c %s/. ;mv ATL_%ccm2am_a%c_%d.c %s/.",
                       pre, al[j], u, outd, pre, al[j], u, outd);
               ierr = system(ln);
               if (ierr)
               {
                  fprintf(stderr, "FAILED CMND='%s'\n", ln);
                  exit(ierr);
               }
            }
         }
      }
   }
   
/*
 * Copy every unique user-supplied file, but only once
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      const int id=mmp->ID;
      assert(id > 0);   /* will need to extend to handle generation! */
/*
 *    File must still be physically copied
 */
      for (p=mmb; p != mmp && p->ID != id; p = p->next);
      if (p == mmp)
      {
         int i, ierr;
         i = strlen(mmp->rout) + dlen + 16;
         if (i > lnlen)
         {
            if (ln)
               free(ln);
            ln = malloc(i*sizeof(char));
            assert(ln);
         }
         sprintf(ln, "cp AMMCASES/%s %s/.", mmp->rout, outd);
         ierr = system(ln);
         if (ierr)
         {
            fprintf(stderr, "FAILED CMND='%s'\n", ln);
            exit(ierr);
         }
      }
   }
   if (ln)
      free(ln);
}
void GenHeaderFiles(char pre, ATL_mmnode_t *mmb, char *outd)
{
}
void GenAllFiles(char pre, ATL_mmnode_t *mmb, char *outd)
{
   GenUserFiles(pre, mmb, outd);
   GenMakefile(pre, mmb, outd);
   GenHeaderFiles(pre, mmb, outd);
}

int main(int nargs, char **args)
{
   char pre='d';
   int verb=1;
   int *nbs;
   char *outd;
   ATL_mmnode_t *mmb, *mmp;

   mmb = GetFlags(nargs, args, &pre, &outd);
   assert(mmb);
   GenAllFiles(pre, mmb, outd);
   KillAllMMNodes(mmb);
   exit(0);
}
@ROUT ammusearch
@extract -b @(topd)/cw.inc lang=C -def cwdate 2012
#include "atlas_misc.h"
#define ATL_JKMDEF 1
#include "atlas_mmtesttime.h"

static int VLEN=1;
static char *VEC="scalar";

@extract -b @(basd)/atlas.base rout=Mylcm

ATL_mmnode_t *BestForThisNB
(
   int verb, 
   char pre, 
   ATL_mmnode_t *mmb, 
   int nb, 
   int pnb,  /* previous nb */
   int nnb,  /* next nb */
   int FORCE
)
/*
 * Times all kernels in mmb
 * RETURNS: ptr to best performing kernel, empty gen node if no user case wrks
 */
{
   ATL_mmnode_t *mmp, *mmB=NULL;
   double mf, mfB=0.0;

   printf("SCOPING FOR BEST PERFORMING KERNEL FOR NB=%d\n", nb);
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      int kb;
/*
 *    Choose kb, if forced only kb will do, so skip if kernel can't do it
 */
      if (FORCE || nb <= 16)
         kb = nb;
/*
 *    If this kernel can't do the exact block factor, allow leeway
 */
      else
      {
         int u;
         u = Mylcm(mmp->mu, mmp->nu);
         u = Mylcm(u, mmp->ku);
         kb = (nb/u)*u;
         if (kb != nb)
         {
            int kbB;
            kbB = ((nb+u-1)/u)*u;
            if (!kb || kbB-nb < nb-kb && kbB <= 4)
               kb = kbB;
         }
      }
      if ((mmp->kbmin && kb < mmp->kbmin) ||
          (mmp->kbmax && kb > mmp->kbmax) ||
          ((kb/mmp->mu)*mmp->mu != kb) || ((kb/mmp->nu)*mmp->nu != kb) ||
          ((kb/mmp->ku)*mmp->ku != kb) || (kb == pnb) || (kb == nnb))
      {
         
         printf("   %d. %s: SKIPPED, bad NB\n", mmp->ID, mmp->rout);
         continue;
      }
      mf = TimeMMKernel(verb, 0, mmp, pre, kb, kb, kb, kb, kb, kb, 1, 0, -1);
      if (mf > mfB)
      {
         mfB = mf;
         mmB = mmp;
         mmB->mbB = mmB->nbB = mmB->kbB = kb;
      }
      printf("   %d. %s: kb=%d, MFLOP=%.2f\n", mmp->ID, mmp->rout, kb, mf);
   }
   if (!mmB)
   {
      printf("NO KERNEL POSSIBLE FOR NB=%d\n", nb);
      mmB = GetMMNode();
      mmB->mbB = mmB->nbB = mmB->kbB = nb;
   }
   else
   {
      int i, kb = mmB->kbB;
      i = MMKernelFailsTest(pre, kb, kb, kb, 0, mmB);
      if (!i)
         i = MMKernelFailsTest(pre, kb, kb, kb, 1, mmB);
      if (!i)
         i = MMKernelFailsTest(pre, kb, kb, kb, -1, mmB);
      if (i)
      {
         printf("BEST KERNEL FAILS TESTER FOR NB=%d\n", kb);
         exit(i);
      }
      printf("BEST KERNEL FOUND FOR NB=%d: ID#%d '%s' %.2f MFLOPS\n\n", 
             nb, mmB->ID, mmB->rout, mfB);
      mmB = CloneMMNode(mmB);
      mmB->mflop[0] = mfB;
      mmB->next = NULL;
   }
   return(mmB);
}

int DeleteBadBigNBs(ATL_mmnode_t *mmb, int *nbs)
{
   ATL_mmnode_t *best=NULL, *mmp;
   double mfB=0.0;
   int n=0;
/*
 * Find the best-performing kernel
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      double mf;
      mf = mmp->mflop[0];
      if (mf > mfB)
      {
         mfB = mf;
         best = mmp;
      }
   }
/*
 * Delete all NBs larger than best
 */
   while (best->next)
   {
      best->next = KillMMNode(best->next);
      n++;
   }
   if (n)
   {
      int N = *nbs;
      N = (N >= 0) ? N : -N;
      printf("Deleted %d large, slow kernels starting at NB=%d\n", 
             n, nbs[N-n+1]);
   }
   return(n);
}

ATL_mmnode_t *FindBestForEachNB(int verb, char pre, ATL_mmnode_t *mmb, int *nbs)
{
   int i, n, FORCE;
   ATL_mmnode_t *best, *bp;
/*
 * If # of nbs is negative, then each nb is required and that exact size
 * will be used, or no NB of that size if no kernel works.  The normal behavior
 * is the exact size of forced for all nb <= 16, and inexact for larger
 */
   n = nbs[0];
   if (n < 0)  /* negative # of nbs says force exact NB or nothing */
   {
      n = -n;
      FORCE = 1;
   }
   bp = best = BestForThisNB(verb, pre, mmb, nbs[1], 0, (n == 1)?nbs[1]:0,
                             FORCE);
   for (i=2; i <= n; i++)
   {
      int pnb = nbs[i-1], nnb = (i < n) ? nbs[i+1]:0;
      bp->next = BestForThisNB(verb, pre, mmb, nbs[i], pnb, nnb, FORCE);
      bp = bp->next;
   }
   i = DeleteBadBigNBs(best, nbs);
   return(best);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr, 
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
@skip    fprintf(stderr, "   -o <outfile>: output file (res/<pre>uAMMRES.sum)\n");
   fprintf(stderr, "   -n # nb1 ... nb# : NBs to try for\n");
   fprintf(stderr, "   -N # nb1 ... nb# : force exact NBs in search\n");
   fprintf(stderr, "   -r <nreg> : set max # of registers to try\n");
   fprintf(stderr, "   -b <nb>   : set initial block factor to try\n");
   fprintf(stderr, "   -v <verb> : set verbosity (1)\n");
   exit(ierr ? ierr : -1);
}

int *GetFlags(int nargs, char **args, char *PRE, 
              int *verb, int *NREG, int *NB)
{
   int i, j=0, n, k;
   char pre='d';
   int *nbs=NULL;
@skip   *FNOUT = NULL;
   *NB = 0;
   #ifdef ATL_GAS_x8664
      *NREG = 16;
   #elif defined(ATL_GAS_x8632)
      *NREG = 8;
   #elif defined(ATL_ARCH_IA64Itan) || defined(ATL_ARCH_IA64Itan)
      *NREG = 128;
   #else
      *NREG = 32;
   #endif
   *verb = 1;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      
      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
@beginskip
      case 'o':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *FNOUT = DupString(args[i]);
        break;
@endskip
      case 'n':
         j = 1;
      case 'N':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         n = atoi(args[i]);
         nbs = malloc((n+1)*sizeof(int));
         assert(nbs);
         nbs[0] = (j) ? n : -n;
         for (k=1; k <= n; k++)
         {
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
            nbs[k] = atoi(args[i]);
         }
         break;
      case 'r':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *NREG = atoi(args[i]);
         break;
      case 'v':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *verb = atoi(args[i]);
         break;
      case 'b':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *NB = atoi(args[i]);
         break;
   fprintf(stderr, "   -b <nb>   : set initial block factor to try\n");
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *PRE = pre;
@skip   if (*NB == 0)
@skip      *NB = (pre == 'd') ? 36 : 48;
@beginskip
   if (!(*FNOUT))
   {
      *FNOUT = DupString("res/duAMMRES.sum");
      (*FNOUT)[4] = pre;
   }
@endskip
   #ifdef ATL_AVX
      VEC = "avx";
      VLEN = (pre == 's') ? 8 : 4;
   #elif defined(ATL_SSE1)
      if (pre == 's')
      {
         VEC = "sse";
         VLEN = 4;
      }
      #ifdef ATL_SSE2
      else
      {
            VEC = "sse";
            VLEN = 2;
      }
      #endif
   #elif defined(ATL_AltiVec)  /* not implemented yet */
      if (pre == 's')
      {
         VEC = "gvec";
         VLEN = 4;
      }
   #endif
   if (!nbs)
   {
      nbs = malloc(19*sizeof(int));
      assert(nbs);
      nbs[0] = 17; nbs[1] = 4; nbs[2] = 6; nbs[3] = 8; 
      nbs[4] = 12; nbs[5] = 16; nbs[6] = 18; nbs[7] = 24;
      nbs[8] = 32; nbs[9] = 48; nbs[10] = 56; nbs[11] = 60;
      nbs[12] = 72; nbs[13] = 80; nbs[14] = 120; nbs[15] = 144;
      nbs[16] = 180; nbs[17] = 240; nbs[18] = 480;
   }
   return(nbs);
}

char *GenString(char pre, int lat, int nb, int mu, int nu, 
                int ku, char *rt)
{
   char *frm="make gen_amm_%s lat=%d mu=%d nu=%d ku=%d kb=%d vlen=%d rt=%s"; 
   char *ln;
   int l;
   l = strlen(frm) + strlen(VEC) + strlen(rt) + 8;
   ln = malloc(l*sizeof(char));
   assert(ln);
   sprintf(ln, frm, VEC, lat, mu*VLEN, nu, ku, nb, VLEN, rt);
   return(ln);
}

ATL_mmnode_t *GetNewGenNode(char pre, int nb, int lat, int mu, int nu, int ku)
{
   ATL_mmnode_t *np;
   char *ln;
   np = GetMMNode();
   np->rout = malloc(sizeof(char)*24);
   assert(np->rout);
   sprintf(np->rout, "ATL_gamm%dx%d_nb%d.c", mu, nu, nb);
   np->vlen = VLEN;
   np->nbB = np->mbB = np->kbB = nb;
   np->mu = mu*VLEN;
   np->nu = nu;
   np->ku = ku;
   np->muladd = (lat != 0);
   np->lat = lat;
   np->genstr = GenString(pre, lat, nb, mu, nu, ku, np->rout);
   return(np);
}

void FindDefMUNU(int verb, char pre, int nreg, int lat, int nb, int ku,
                 int *MU, int *NU)
{
   ATL_mmnode_t *mmp;
   double mf, mfB=0.0;
   int n, i, j, kb, muB=1, nuB=1;

   mmp = ReadMMFileWithPath(pre, "res", "gAMMMUNU.sum");
   if (mmp)
   {
      nb = mmp->kbB;
      if (mmp->mflop[0] < 0.0)
         mmp->mflop[0] = TimeMMKernel(verb, 1, mmp, pre, nb, nb, nb, 
                                      nb, nb, nb, 1, 0, -1);
      printf("READ IN BEST GENNED MU=%d, NU=%d, MFLOP=%.2f\n\n", 
             mmp->mu, mmp->nu, mmp->mflop[0]);
      *MU = mmp->mu / VLEN;
      assert(*MU);
      *NU = mmp->nu;
      return;
   }
/*
 * Try all near-square cases
 */
   mmp = GetMMNode();
   mmp->ku = ku;
   mmp->muladd = (lat != 0);
   mmp->lat = lat;
   mmp->rout = DupString("amm_munu.c");
   mmp->mbB = mmp->nbB = mmp->kbB = nb;
   printf("Finding best MUxNU case for nb=%d\n", nb);
   for (n=4; n < nreg; n++)
   {
      for (j=1; j*j < n; j++);
      i = n / j;
      if (nb%i || nb%j)
         continue;
      mmp->mu = i * VLEN;
      mmp->nu = j;
      if (mmp->genstr)
        free(mmp->genstr);
      mmp->genstr = GenString(pre, lat, nb, i, j, ku, mmp->rout);
      mf = TimeMMKernel(verb, 1, mmp, pre, nb, nb, nb, nb, nb, nb, 1, 0, -1);
      printf("   MU=%2d, NU=%2d, MFLOP=%.2f\n", i, j, mf);
      if (mf > mfB)
      {
         muB = i;
         nuB = j;
         mfB = mf;
      }
   }
/*
 * For x86, try 1-D cases since older machines are 2-operand assemblies
 */
   #if defined(ATL_GAS_x8664) || defined(ATL_GAS_x8664) 
   if (VEC[0] != 'a')  /* AVX is 3-operand */
   {
      printf("BEST NEAR-SQUARE CASE IS MU=%d, NU=%d, MFLOP=%.2f\n\n", 
             muB, nuB, mfB);
      printf("Finding best 1-D outer loop unrolling for nb=%d\n", nb);
      for (n=2; n < nreg; n++)
      {
         i = 1; j = n;
         if (nb % n)
            continue;
         mmp->mu = i;
         mmp->nu = j;
         if (mmp->genstr)
           free(mmp->genstr);
         mmp->genstr = GenString(pre, lat, nb, i, j, ku, mmp->rout);
         mf = TimeMMKernel(verb, 1, mmp, pre, nb, nb, nb, nb, nb, nb, 1, 0, -1);
         printf("   MU=%2d, NU=%2d, MFLOP=%.2f\n", i, j, mf);
         if (mf > mfB)
         {
            muB = i;
            nuB = j;
            mfB = mf;
         }
         i = n; j = 1;
         mmp->mu = i;
         mmp->nu = j;
         if (mmp->genstr)
           free(mmp->genstr);
         mmp->genstr = GenString(pre, lat, nb, i, j, ku, mmp->rout);
         mf = TimeMMKernel(verb, 1, mmp, pre, nb, nb, nb, nb, nb, nb, 1, 0, -1);
         printf("   MU=%2d, NU=%2d, MFLOP=%.2f\n", i, j, mf);
         if (mf > mfB)
         {
            muB = i;
            nuB = j;
            mfB = mf;
         }
      }
   }
   #endif
   mmp->mu = muB * VLEN;
   mmp->nu = nuB;
   mmp->mflop[0] = mfB;
   WriteMMFileWithPath(pre, "res", "gAMMMUNU.sum", mmp);
   printf("BEST CASE IS MU=%d, NU=%d, MFLOP=%.2f\n\n", 
          muB, nuB, mfB);
   *MU = muB;
   *NU = nuB;
}

void GetMUNUbyNB(int nb, int nreg, int *MU, int *NU)
{
   int mu=(*MU), nu=(*NU), vmu=mu*VLEN;

   assert(mu && nu && !(nb%VLEN));
   if (!(nb%vmu) && !(nb%nu))
      return;
   if (mu == 1 || nu == 1) /* handle 1-D cases by just inc/dec U */
   {
      int u = (mu == 1) ? nu : mu;
      while (u+u+1 <= nreg && nb%u)
         u++;
      if (u+u+1 > nreg)
         u--;
      while (nb%u)
         u--;
      if (mu == 1)
         *NU = u;
      else
         *MU = u;
      return;
   }
   if (nb%vmu)  /* mu can't handle NB */
   {
      int i;
/* 
 *    try increasing mu until we run out of registers
 */
      for (i=mu+1; i*nu+i+nu <= nreg; i++)
         if (!(nb%(i*VLEN)))
            break;
/*
 *    Try decreasing mu until it divides
 */
      if (nb%(i*VLEN) || i*nu+i+nu > nreg)
      {
         for (mu--; mu; mu--)
            if (!(nb%(mu*VLEN)))
               break;
      }
      else
         mu = i;
   }
   if (nb%nu)  /* nu can't handle NB */
   {
      int i;
/* 
 *    try increasing nu until we run out of registers
 */
      for (i=nu+1; i*mu+i+mu <= nreg; i++)
         if (!(nb%i))
            break;
/*
 *    Try decreasing nu until it divides
 */
      if (nb%i || i*mu+i+mu > nreg)
      {
         for (nu--; nu; nu--)
            if (!(nb%nu))
               break;
      }
      else
         nu = i;
   }
   *MU = mu;
   *NU = nu;
}

int FindNBInArray(int nb, int *nbs)
/*
 * RETURNS: location+1, or 0 if not found
 */
{
   int i, n = (nbs[0] > 0) ? nbs[0] : -nbs[0];
   for (i=1; i <= n; i++)
       if (nbs[i] == nb)
          return(i);
   return(0);
}
ATL_mmnode_t *CreateGenCasesFromNBs
(
   ATL_mmnode_t *mmb,   /* best user-contributed kernels */
   char pre,            /* precision: s/d */
   int *nbs,            /* list of desired NBs */
   int nreg,            /* upper bound on register use */
   int MU, int NU,      /* default M/N unrolling */
   int KU               /* -1 for fully unrolled, else unrolling factor */
)
/*
 * Generate a list of generated kernels, with the union of nb's in nbs
 * and mmb, and return the generated nodes for timing.
 */
{
   ATL_mmnode_t *mp, *umb=NULL, *mmp;
   int i, n = (nbs[0] > 0) ? nbs[0] : -nbs[0], ne=0, *enbs;
   enbs = malloc(sizeof(int)*(n+1));
   for (mp=mmb; mp; mp = mp->next)
      if (!FindNBInArray(mp->kbB, nbs))
         enbs[ne++] = mp->kbB;
/*
 * Create new queue for all NBs
 */
   i = 0; mp = mmb;
   do
   {
      ATL_mmnode_t *p;
      int nb, ku;
      int mu=MU, nu=NU;
      if (mmp)
      {
         if (i < ne)
         {
            nb = enbs[i];
            nb = Mmin(nb, mp->kbB);
            if (nb == enbs[i])
               i++;
         }
         else
            nb = mp->kbB;
         if (nb == mp->kbB)
            mp = mp->next;
      }
      else  /* only taking stuff rom enbs */
         nb = enbs[i++];
      ku = (KU == -1) ? nb : KU;
/*
 *    If NB is not a multiple of VLEN, drop down to scalar generation
 */
      if (nb%VLEN)
      {
         char *sp=VEC;
         int vl=VLEN;
         p = NULL;
/*
 *       For AVX, see if dropping to SSE will help
 */
         #if defined(ATL_AVX) && defined(ATL_SSE1) && defined(ATL_SSE2)
            
            VLEN >>= 1;
            if (VEC[0] == 'a' && !(nb%VLEN))
            {
               VEC = "sse";
               GetMUNUbyNB(nb, nreg, &mu, &nu);
               p = GetNewGenNode(pre, nb, 0, mu, nu, ku);
            }
         #endif
         if (!p)
         {
            VLEN=1;
            VEC = "scalar";
            GetMUNUbyNB(nb, nreg, &mu, &nu);
            p = GetNewGenNode(pre, nb, 0, mu, nu, ku);
         }
         VLEN = vl;
         VEC = sp;
      }
      else
      {
         GetMUNUbyNB(nb, nreg, &mu, &nu);
         p = GetNewGenNode(pre, nb, 0, mu, nu, ku);
      }
      if (umb)
      {
         mmp->next = p;
         mmp = p;
      }
      else
         umb = mmp = p;
   }
   while (mp || i < ne);
   free(enbs);
   return(umb);
}

ATL_mmnode_t *FindBestGenCases(int verb, char pre, int nreg, 
                               int *nbs, ATL_mmnode_t *ummb)
{
   ATL_mmnode_t *mp, *gmmU, *gmmb;
   int MU, NU;

   gmmb = ReadMMFileWithPath(pre, "res", "gAMMRES.sum");
   if (gmmb)
   {
      printf("Reading in generated cases for all NBs:\n");
      for (mp=gmmb; mp; mp = mp->next)
      {
         const int mu = (mp->vlen) ? mp->mu / mp->vlen : mp->mu;
         int nb = mp->kbB;
         if (mp->mflop[0] < 0.0)
            mp->mflop[0] = TimeMMKernel(verb, 1, mp, pre, nb, nb, nb,
                                         nb, nb, nb, 1, 0, -1);
         printf("  NB=%d, MU=%d, NU=%d, vlen=%d, MFLOP=%.2f\n", 
                nb, mu, mp->nu, mp->vlen, mp->mflop[0]);
      }
      printf("Done.\n\n");
      return(gmmb);
   }
/*
 * If vector operations are being used, make sure they work; compiler and
 * flag changes can mess them up, and in this case we'll fall back to
 * scalar generation.  Try to see if we can successfully test simplist
 * possible vector kernel, and fall back to scalar kernel if we can't
 */
   if (VLEN > 1)
   {
      mp = GetNewGenNode(pre, 32, 0, 1, 1, 1);
      if (MMKernelFailsTest(pre, 32, 32, 32, 1, mp))
      {
         printf("ERROR: VEC='%s' FAILED, genstr='%s'!\n", VEC, mp->genstr);
         KillMMNode(mp);
/*
 *       For AVX, try falling back to SSE
 */
         #ifdef ATL_AVX
            VEC="sse";
            VLEN = (pre == 's') ? 4:2;
            mp = GetNewGenNode(pre, 32, 0, 1, 1, 1);
            if (MMKernelFailsTest(pre, 32, 32, 32, 1, mp))
            {
               VEC="scalar";
               VLEN=1;
            }
         #else
            VEC="scalar";
            VLEN=1;
         #endif

      }
      free(mp);
/*
 *    For AVX, switch to SSE if AVX doesn't offer a performance advantage
 *    (as on AMD Dozer), since SSE smaller code size and requires less cleanup 
 */
      #ifdef ATL_AVX
         if (VEC[0] == 'a')  /* haven't already switched to sse */
         {
            double mfA, mfS;
            char *sp; 
            int vl;
            mp = GetNewGenNode(pre, 128, 0, 1, 4, 1);
            mfA = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                               1, 0, -1);
            KillMMNode(mp);
            vl = VLEN;
            sp = VEC;
            VEC = "sse";
            VLEN = (pre == 's') ? 4 : 2;
            mp = GetNewGenNode(pre, 128, 0, 1, 4, 1);
            mfS = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                               1, 0, -1);
            KillMMNode(mp);
            if (mfA < 1.05*mfS)
            {
               printf("USING SSE INSTEAD OF AVX, AVX=%.2f, SSE=%.2f\n", 
                      mfA, mfS);
            }
            else
            {
               printf("AVX GOOD, AVX=%.2f, SSE=%.2f\n", mfA, mfS);
               VEC=sp;
               VLEN=vl;
            }
         }
      #endif
   }
   printf("GENERATING WITH VEC='%s', VLEN=%d\n\n", VEC, VLEN);
/*
 * Find the best mu/nu for NB=120; we don't care if we overflow cache for
 * this timing, and 120 = LCM(2,3,4,5,6,8,12).  Use ku=1 so that large
 * problems don't have large K-driven advantage.
 */
   FindDefMUNU(verb, pre, nreg, 0, 120, 1, &MU, &NU);
   gmmb = CreateGenCasesFromNBs(ummb, pre, nbs, nreg, MU, NU, 1);
   if (verb > 1)
   {
      printf("\n");
      PrintMMNodes(stdout, gmmb);
      printf("\n");
   }
   printf("Finding generated cases for all NBs:\n");
   for (mp=gmmb; mp; mp = mp->next)
   {
      int mu;
      mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mp->mbB, mp->nbB, mp->kbB, 
                                  mp->kbB, mp->kbB, mp->kbB, 1, 0, -1);
      mu = (mp->vlen) ? mp->mu / mp->vlen : mp->mu;
      printf("   NB=%d, mu=%d, nu=%d, vlen=%d, MFLOPS=%.2f\n", 
             mp->kbB, mu, mp->nu, mp->vlen, mp->mflop[0]);
   }
   printf("Done.\n\n");
   WriteMMFileWithPath(pre, "res", "gAMMRES.sum", gmmb);
   return(gmmb);
}


ATL_mmnode_t *FindBestUserCases(int verb, char pre, int *nbs)
/*
 * RETURNS: list of the best user case for each supplied NB; if no user case
 *          works, special "generated" node is returned for later filling out.
 */
{
   ATL_mmnode_t *mmb, *mmp;
   mmb = ReadMMFileWithPath(pre, "res", "uAMMRES.sum");
/*
 * If final output file exists, then we need to rerun timings at worst
 */
   if (mmb)
   {
      for (mmp=mmb; mmp; mmp = mmp->next)
      {
         if (mmp->ID > 0 && mmp->mflop[0] < 0.0)
            mmp->mflop[0] = TimeMMKernel(verb, 0, mmp, pre, mmp->mbB, mmp->nbB,
                                         mmp->kbB, mmp->kbB, mmp->kbB, mmp->kbB,
                                         1, 0, -1);
         if (mmp->ID > 0)
            printf("USER KERNEL AT NB=%d gets MFLOP=%.2f\n",
                   mmp->kbB, mmp->mflop[0]);
         else
            printf("NO USER KERNEL FOR NB=%d\n", mmp->kbB);
      }
      printf("\n");
      return(mmb);
   }
/*
 * If answer isn't already known, read index file for queue of candidate kerns
 */
   mmb = ReadMMFileWithPath(pre, "AMMCASES", "amcases.idx");
   assert(mmb);
/*
 * Eliminate those kernels that can't work for any block size
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      if (FLAG_IS_SET(mmp->flag, MMF_KUISKB))
         mmp->mbB = mmp->nbB = mmp->kbB = mmp->ku;
      else
      {
         int m = Mylcm(mmp->mu, mmp->nu);
         m = (60/m)*m;
         if (mmp->kbmin)
            m = Mmax(m, mmp->kbmin);
         if (mmp->kbmax)
            m = Mmin(m, mmp->kbmax);
         mmp->mbB = mmp->nbB = mmp->kbB = m;
      }
   }
   mmb = DelBadMMKernels(pre, verb, mmb);
   assert(mmb);
   if (verb > 1)
   {
      printf("\nSURVIVING KERNELS:\n");
      PrintMMNodes(stdout, mmb);
   }
   mmp = FindBestForEachNB(verb, pre, mmb, nbs);
   KillAllMMNodes(mmb);
   free(nbs);
   WriteMMFileWithPath(pre, "res", "uAMMRES.sum", mmp);
   return(mmp);
}

ATL_mmnode_t *MergeAndWinnowCases
(
   int verb, 
   char pre, 
   ATL_mmnode_t *umb, /* queue of user cases */
   ATL_mmnode_t *gmb  /* genned cases, always include NBs of umb */
)
/*
 * Merges user and gmp cases, while getting rid of cases that get worse
 * performance than their smaller blocks; FREES umb and gmb
 * RETURNS: new merged and winnowed queue
 */
{
   ATL_mmnode_t *mmb=NULL, *mmp, *gmp, *ump=umb;
   for (gmp=gmb; gmp; gmp = gmp->next)
   {
      ATL_mmnode_t *p;
      if (ump)
      {
         if (ump->kbB == gmp->kbB)
         {
            if (gmp->mflop[0] >= ump->mflop[0])
               p = CloneMMNode(gmp);
            else
               p = CloneMMNode(ump);
            ump = ump->next;
         }
      }
      else
         p = CloneMMNode(gmp);
      p->next = NULL;
      if (mmb)
      {
/*
 *       If larger NB isn't faster than smaller one, kill it for nb >= 16
 */
         if (p->kbB >= 16 && mmp->mflop[0] > p->mflop[0])
            KillMMNode(p);
         else
         {
            mmp->next = p;
            mmp = p;
         }
      }
      else
         mmp = mmb = p;
   }
   KillAllMMNodes(umb);
   KillAllMMNodes(gmb);
   return(mmb);
}

int main(int nargs, char **args)
{
   char pre='d';
   int verb, nregs, nb;
   int *nbs;
   char *fnout;
   ATL_mmnode_t *mmb, *mmp;

   nbs = GetFlags(nargs, args, &pre, &verb, &nregs, &nb);
   if (verb)
   {
      int i;
      const int n = nbs[0]+1;
      printf("NBs = %3d", nbs[1]);
      for (i=2; i < n; i++)
         printf(", %3d", nbs[i]);
      printf("\n");
   }
   mmb = FindBestUserCases(verb, pre, nbs);
   mmp = FindBestGenCases(verb, pre, nregs, nbs, mmb);
   mmb = MergeAndWinnowCases(verb, pre, mmb, mmp);
   WriteMMFileWithPath(pre, "res", "eAMMRES.sum", mmb);
   KillAllMMNodes(mmb);
   exit(0);
}
@ROUT ATL_ammmABC
#include "atlas_misc.h"
/*
 * This routine loops over calls to the access-major matmul kernel given
 * in the arguments, using the NMK loop pattern, using the given blocking
 * parameters.  
 * alpha & beta are both applied by ablk2cmat.
 * It allocates an K*NB workspace for B, and an Mc*K workspace for A,
 * and a NB*NB workspace for C.
 */

typedef void (*mat2am_t)
   (ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT, TYPE*);
typedef void (*ablk2cmat_t)
   (ATL_CINT M, ATL_CINT N, const SCALAR al, const TYPE*A, 
    const SCALAR beta, TYPE*C, ATL_CINT ldc);
typedef void (*ammm_t)
   (ATL_CINT M, ATL_CINT N, ATL_CINT K, TYPE *A, TYPE *B, TYPE *C);
int Mjoin(PATL,ammmABC)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CINT M,
   ATL_CINT N,
   ATL_CINT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *B,
   ATL_CINT ldb,
   const SCALAR beta,
   const TYPE *C,
   ATL_CINT ldc,
   ATL_CINT MB,                 /* chosen M blocking for this problem */
   ATL_CINT NB,                 /* chosen N blocking for this problem */
   ATL_CINT KB,                 /* chosen K blocking for this problem */
   ATL_CINT mu,                 /* M unrolling used by kernels */
   ATL_CINT nu,                 /* N unrolling used by kernels */
   ATL_CINT ku,                 /* K unrolling used by non-cleanup kernels */
   ammm_t ammmk_b0,             /* amm beta=0 kernel to use */
   ammm_t ammmk_b1,             /* amm beta=1 kernel to use */
   ammm_t ammmk_ku1,            /* amm beta=1 for K-cleanup */
   mat2am_t A2am,               /* routine to translate A into access-major */
   mat2am_t B2am,               /* routine to translate B into access-major */
   ablk2cmat_t ablk2cmat,       /* put ammmk's C back to user's C */
)
{
   ATL_CINT Mf = (M/mu)*mu, mr = M-Mf, Nf = (N/nu)*nu, nr = N-Nf;
   ATL_CINT Kf = (K/ku)*ku, kr = K-Kf;
   ATL_CINT Mc = (mr) ? Mf + mr : Mf;  /* compute CEIL from FLOOR */
   ATL_CINT Nc = (nr) ? Nf + nr : Nf;
   ATL_CINT Kc = (kr) ? Kf + kr : Kf;
   ATL_CINT incBn = (TB == AtlasNoTrans) ldb*NB-Kf : NB-Kf*ldb;
   ATL_CINT incAm = (TA == AtlasNoTrans) ? MB - Kf*ldb : MB*ldb - Kf;
   ATL_INT i, j, k;
   void *vp;
   TYPE *pA, *pB, *c;
   int COPYA=1;

   if (K <= KB) 
      return(1);   /* don't handle rank-K update with this routine */
   vp = malloc(3*ATL_Cacchelen + sizeof(TYPE)*(Mc*K+K*NB+NB*NB));
   if (!vp)
      return(2);
   pB = ATL_AlignPtr(vp);
   pA = pB + K*NB;
   pA = ATL_AlignPtr(pA);
   c = pA + Mc*K;
   c = ATL_AlignPtr(c);

   for (j=0; j != Nc; j += NB)
   {
      ATL_CINT n = Mmin(NB, Nc-j), incb = n*nu*KB, n0 = Mmin(NB, N-j);
      int COPYB=1;
      TYPE *b = pB, *a = pA;

      for (i=0; i != Mc; i += MB)
      {
         ATL_CINT m = Mmin(MB, Mc-i), inca = m*mu*KB, m0 = Mmin(NB,M-j);

/* 
 *       Handle first block, known to always have a full KB, using _b0
 *       case to initialize workspace c
 */
         if (COPYA)
            A2am(m, KB, ATL_rone, A, lda, a);
         if (COPYB)
            B2am(KB, n, ATL_rone, B, ldb, b);
         ammmk_b0(m, n, KB, a, b, c);
         a += inca; b += incb;
/*
 *       Loop over all remaining blocks that can use ammmk_b1
 */
         for (k=KB; k < Kf; k += KB, a += inca, b += incb)
         {
            ATL_CINT kk = Mmin(KB, Kf-i);
/*
 *          If necessary, copy both A & B blocks to access-major format
 */
            if (COPYA)
            {
               A2am(m, kk, ATL_rone, A, lda, a);
               A += (TA == AtlasNoTrans) ? kk*lda : kk;
            }
            if (COPYB)
            {
               B2am(kk, n, ATL_rone, B, ldb, b);
               B += (TB == AtlasNoTrans) ? kk : kk*ldb;
            }
            ammmk_b1(m, n, kk, a, b, c);
         }
/*
 *       Handle K cleanup using the provided kernel
 */
         if (kr)
         {
            if (COPYA)
               A2am(m, kr, ATL_rone, A, lda, a);
            if (COPYB)
               B2am(kr, n, ATL_rone, B, ldb, b);
            ammmk_ku1(m, n, kr, a, b, c);
            a += kr*m;
         }
         A += incAm;
/*
 *       Write answer back out to user's C 
 */
         ablk2cmat(m0, n0, alpha, c, beta, C, ldc);
         C += m0;
         COPYB = 0;
         b = pB;
      }
      B += incBn;
      COPYA = 0;
   }
   free(vp);
   return(0);
}
