@ROUT ATL_utrmmR
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018 -def cwauth "Majedul Sujon" -def contrib "Rakib Hasan"
#include "atlas_misc.h"

/* cases: LN, UT, LT, UN ... LC/UC included */
#ifdef Upper_
   #ifdef Trans_
#include Mstr(Mjoin(ATLAS_PRE,utrmmR_LN.h)) /* LN & UT share same header */
      #ifdef Conj_
         #define ATL_utrmmR Mjoin(PATL,utrmmR_UC)
         #define RUC 1
      #else
         #define ATL_utrmmR Mjoin(PATL,utrmmR_UT)
         #define RUT 1
      #endif
   #else
#include Mstr(Mjoin(ATLAS_PRE,utrmmR_LT.h)) /* LT & UN share same header */
      #define ATL_utrmmR Mjoin(PATL,utrmmR_UN)
      #define RUN 1
   #endif
#else /* lower */
   #ifdef Trans_
#include Mstr(Mjoin(ATLAS_PRE,utrmmR_LT.h)) /* LT & UN share same header */
      #ifdef Conj_
         #define ATL_utrmmR Mjoin(PATL,utrmmR_LC)
         #define RLC 1
      #else
         #define ATL_utrmmR Mjoin(PATL,utrmmR_LT)
         #define RLT 1
      #endif
   #else
#include Mstr(Mjoin(ATLAS_PRE,utrmmR_LN.h)) /* LN & UT share same header */
      #define ATL_utrmmR Mjoin(PATL,utrmmR_LN)
      #define RLN 1
   #endif
#endif

int ATL_utrmmR
(
   const enum ATLAS_DIAG Diag,
   ATL_CSZT M,         /* it's actually M */
   ATL_CSZT N,         /* it's actually N*/
   const SCALAR alpha, 
   const TYPE *A,      /* A is always tri-matrix: here left one */ 
   ATL_CSZT lda,
   TYPE *X,            /* it's B: the output and full matrix*/
   ATL_CSZT ldx
)
{
   void *vp=NULL;
   TYPE *pt, *pr, *pc;
   ATL_SZT sz, szC, szT, szR;
   ATL_SZT szFull, szPan, szCorner;
   int tnu, tku, tuu, ntfu, tKr;
   const int MU = ATL_TRMMK_MU, 
             NU = ATL_TRMMK_NU, 
             KU = ATL_TRMMK_KU,
             VLEN = ATL_TRMMK_VLEN; 
   ATL_CSZT K = ((N+KU-1)/KU)*KU; 
   ATL_SZT nmu = (M+MU-1)/MU, nnu=(N+NU-1)/NU; 
   ATL_SZT mb=nmu*MU, nb=nnu*NU;
   ammkern_t trmmK_b0 = Mjoin(PATL,trmmK_b0);
   ammkern_t trmmK_b1 =  Mjoin(PATL,trmmK_b1);
   #ifdef TCPLX
      ammkern_t trmmK_bn = Mjoin(PATL,trmmK_bn);
      TYPE ONE[2] = {ATL_rone, ATL_rzero}, ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define NONE ATL_rnone
   #endif
   cm2am_t l2a; 
   tcm2am_t r2a; 
   ablk2cmat_t blk2c = Mjoin(PATL,trmm_blk2c_a1b0);
/*
 * Selecting copy routines...
 * multiplying with alpha in copy routines:
 *    MxM/2, MXN
 */
   if (SCALAR_IS_ONE(alpha))
   {
      #ifdef Upper_
         if (Diag == AtlasUnit)
            r2a = Mjoin(PATL,trmm_a2blk_Up_diagU_a1);
         else
            r2a = Mjoin(PATL,trmm_a2blk_Up_a1);
      #else
         if (Diag == AtlasUnit)
            r2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_a1);
         else
            r2a = Mjoin(PATL,trmm_a2blk_Lo_a1);
      #endif 
      l2a = Mjoin(PATL,trmm_b2blk_a1);
   }
   else
   {
      if (M > N/2) /* multiply alpha in tri-copy*/
      {
         l2a = Mjoin(PATL,trmm_b2blk_a1);
         if (SCALAR_IS_NONE(alpha))
         {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               r2a = Mjoin(PATL,trmm_a2blk_Up_diagU_aN);
            else
               r2a = Mjoin(PATL,trmm_a2blk_Up_aN);
         #else
            if (Diag == AtlasUnit)
               r2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_aN);
            else   
               r2a = Mjoin(PATL,trmm_a2blk_Lo_aN);
         #endif 
         }
         else /* alphaX, since alpha can't be 0 here */
         {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               r2a = Mjoin(PATL,trmm_a2blk_Up_diagU_aX);
            else   
               r2a = Mjoin(PATL,trmm_a2blk_Up_aX);
         #else
            if (Diag == AtlasUnit)
               r2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_aX);
            else   
               r2a = Mjoin(PATL,trmm_a2blk_Lo_aX);
         #endif 
         }
      }
      else /* multiply alpha in gemm copy */
      {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               r2a = Mjoin(PATL,trmm_a2blk_Up_diagU_a1);
            else
               r2a = Mjoin(PATL,trmm_a2blk_Up_a1);
         #else
            if (Diag == AtlasUnit)
               r2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_a1);
            else
               r2a = Mjoin(PATL,trmm_a2blk_Lo_a1);
         #endif 
         if (SCALAR_IS_NONE(alpha))
            l2a = Mjoin(PATL,trmm_b2blk_aN);
         else
            l2a = Mjoin(PATL,trmm_b2blk_aX);

      }
   }
/*
 * calculate and allocate memory for workspace 
 * NOTE: This calculation is used from Rakib's TRMM tester: trmmKtst.c
 */
   tnu = NU, tku = KU;
   tuu = Mmax(tnu, tku);
   /* first do full blocks */
   ntfu = N/tuu;
   tKr = N - ntfu*tuu;
   szFull = (ntfu*(ntfu+1)/2) * tuu * tuu;
   /* now the partial panel */
   #if ( (!defined(Upper_) && !defined(Trans_)) || \
            (defined(Upper_) && defined(Trans_)) )
      szPan = ((tKr+tku-1)/tku)*ntfu * tuu * tku;
   #else
      szPan = ((tKr+tnu-1)/tnu)*ntfu * tuu * tnu;
   #endif
   /* finally the partial block */
   szCorner = ((tKr + tnu - 1)/tnu) * ((tKr + tku - 1)/tku) * tnu * tku;
   szT = szFull + szPan + szCorner;
   szR = mb*K;
   szC = (((MU*NU+VLEN-1)/VLEN)*VLEN)*nmu*nnu;
   sz = ATL_MulBySize(szT + NU*KU + szR + MU*KU + szC + (MU+MU)*NU + 
                      3*ATL_Cachelen);
   if (sz < ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp) return(2);
   pt = ATL_AlignPtr(vp);
   pr = pt + (szT SHIFT);
   pr = ATL_AlignPtr(pr);
   pc = pr + (szR SHIFT);
   pc = ATL_AlignPtr(pc);
   #ifdef TCPLX
      l2a(N, M, alpha, X, ldx, pr, pr+szR);
      r2a(N, alpha, A, lda, pt, pt+szT);
      trmmK_b0(nmu, nnu, K, pr+szR, pt+szT, pc,     pr,     pt+szT, pc+szC);
      trmmK_b0(nmu, nnu, K, pr,     pt+szT, pc+szC, pr,     pt,     pc);
      trmmK_bn(nmu, nnu, K, pr,     pt,     pc,     pr+szR, pt,     pc+szC);
      trmmK_b1(nmu, nnu, K, pr+szR, pt,     pc+szC, pr+szR, pt+szT, pc);
      blk2c(M, N, ONE, pc, pc+szC, ZERO, X, ldx);
   #else
      l2a(N, M, alpha, X, ldx, pr);
      r2a(N, alpha, A, lda, pt);
      trmmK_b0(nmu, nnu, K, pr, pt, pc, pr, pt, pc);
      blk2c(M, N, ATL_rone, pc, ATL_rzero, X, ldx);
   #endif
   free(vp); 
   return(0);
}
@ROUT ATL_utrmmL
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018 -def cwauth "Majedul Sujon" -def contrib "Rakib Hasan"
#include "atlas_misc.h"
/* cases: LN, UT, LT, UN ... LC/UC included */
#ifdef Upper_
   #ifdef Trans_
#include Mstr(Mjoin(ATLAS_PRE,utrmmL_LN.h)) /* LN & UT share same header file*/
      #ifdef Conj_
         #define ATL_utrmmL Mjoin(PATL,utrmmL_UC)
         #define LUC 1
      #else
         #define ATL_utrmmL Mjoin(PATL,utrmmL_UT)
         #define LUT 1
      #endif
   #else
#include Mstr(Mjoin(ATLAS_PRE,utrmmL_LT.h)) /* LT & UN share same header file*/
      #define ATL_utrmmL Mjoin(PATL,utrmmL_UN)
      #define LUN 1
   #endif
#else /* lower */
   #ifdef Trans_
#include Mstr(Mjoin(ATLAS_PRE,utrmmL_LT.h))
      #ifdef Conj_
         #define ATL_utrmmL Mjoin(PATL,utrmmL_LC)
         #define LLC 1
      #else
         #define ATL_utrmmL Mjoin(PATL,utrmmL_LT)
         #define LLT 1
      #endif
   #else
#include Mstr(Mjoin(ATLAS_PRE,utrmmL_LN.h))
      #define ATL_utrmmL Mjoin(PATL,utrmmL_LN)
      #define LLN 1
   #endif
#endif

int ATL_utrmmL
(
   const enum ATLAS_DIAG Diag,
   ATL_CSZT M,         /* it's actually M */
   ATL_CSZT N,         /* it's actually N*/
   const SCALAR alpha, 
   const TYPE *A,      /* A is always tri-matrix: here left one */ 
   ATL_CSZT lda,
   TYPE *X,            /* it's B: the output and full matrix*/
   ATL_CSZT ldx
)
{
   void *vp=NULL;
   TYPE *pt, *pr, *pc;
   ATL_SZT sz, szC, szT, szR;
   ATL_SZT szFull, szPan, szCorner;
   int tmu, tku, tuu, ntfu, tKr;
   const int MU = ATL_TRMMK_MU, 
             NU = ATL_TRMMK_NU, 
             KU = ATL_TRMMK_KU,
             VLEN = ATL_TRMMK_VLEN; 
   ATL_CSZT K = ((M+KU-1)/KU)*KU; 
   ATL_SZT nmu = (M+MU-1)/MU, nnu=(N+NU-1)/NU; 
   ATL_SZT mb=nmu*MU, nb=nnu*NU;
   ammkern_t trmmK_b0 = Mjoin(PATL,trmmK_b0);
   ammkern_t trmmK_b1 =  Mjoin(PATL,trmmK_b1);
   #ifdef TCPLX
      ammkern_t trmmK_bn = Mjoin(PATL,trmmK_bn);
      TYPE ONE[2] = {ATL_rone, ATL_rzero}, ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define NONE ATL_rnone
   #endif
   tcm2am_t l2a; 
   cm2am_t r2a;
   ablk2cmat_t blk2c = Mjoin(PATL,trmm_blk2c_a1b0);
/*
 * Selecting copy routines...
 * multiplying with alpha in copy routines:
 *    MxM/2, MXN
 */
   if (SCALAR_IS_ONE(alpha))
   {
      #ifdef Upper_
         if (Diag == AtlasUnit)
            l2a = Mjoin(PATL,trmm_a2blk_Up_diagU_a1);
         else
            l2a = Mjoin(PATL,trmm_a2blk_Up_a1);
      #else
         if (Diag == AtlasUnit)
            l2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_a1);
         else
            l2a = Mjoin(PATL,trmm_a2blk_Lo_a1);
      #endif 
      r2a = Mjoin(PATL,trmm_b2blk_a1);
   }
   else
   {
      if (N > M/2) /* multiply alpha in tri-copy*/
      {
         r2a = Mjoin(PATL,trmm_b2blk_a1);
         if (SCALAR_IS_NONE(alpha))
         {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               l2a = Mjoin(PATL,trmm_a2blk_Up_diagU_aN);
            else
               l2a = Mjoin(PATL,trmm_a2blk_Up_aN);
         #else
            if (Diag == AtlasUnit)
               l2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_aN);
            else   
               l2a = Mjoin(PATL,trmm_a2blk_Lo_aN);
         #endif 
         }
         else /* alphaX, since alpha can't be 0 here */
         {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               l2a = Mjoin(PATL,trmm_a2blk_Up_diagU_aX);
            else
               l2a = Mjoin(PATL,trmm_a2blk_Up_aX);
         #else
            if (Diag == AtlasUnit)
               l2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_aX);
            else   
               l2a = Mjoin(PATL,trmm_a2blk_Lo_aX);
         #endif 
         }
      }
      else /* multiply alpha in gemm copy */
      {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               l2a = Mjoin(PATL,trmm_a2blk_Up_diagU_a1);
            else
               l2a = Mjoin(PATL,trmm_a2blk_Up_a1);
         #else
            if (Diag == AtlasUnit)
               l2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_a1);
            else
               l2a = Mjoin(PATL,trmm_a2blk_Lo_a1);
         #endif 
         if (SCALAR_IS_NONE(alpha))
            r2a = Mjoin(PATL,trmm_b2blk_aN);
         else
            r2a = Mjoin(PATL,trmm_b2blk_aX);
      }
   }
/*
 * calculate and allocate memory for workspace 
 * NOTE: This calculation is used from Rakib's TRMM tester: trmmKtst.c
 */
#if EXTRA_SPACE
   szT = mb * K;
#else
   tmu = MU, tku = KU;
   tuu = Mmax(tmu, tku);
   /* first do full blocks */
   ntfu = M/tuu;
   tKr = M - ntfu*tuu;
   szFull = (ntfu*(ntfu+1)/2) * tuu * tuu;
   #if ( (!defined(Upper_) && !defined(Trans_)) || \
         (defined(Upper_) && defined(Trans_)) )
      szPan = ((tKr+tmu-1)/tmu)*ntfu * tuu * tmu;
   #else
      szPan = ((tKr+tku-1)/tku)*ntfu * tuu * tku;
   #endif
   /* finally the partial block */
   szCorner = ((tKr + tmu - 1)/tmu) * ((tKr + tku - 1)/tku) * tmu * tku;
   szT = szFull + szPan + szCorner;
#endif
   szR = nb*K;
   szC = (((MU*NU+VLEN-1)/VLEN)*VLEN)*nmu*nnu; 
   sz = ATL_MulBySize(szT + MU*KU + szR + NU*KU + szC + (MU+MU)*NU + 
                      3*ATL_Cachelen);
   if (sz < ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp) return(2);
   pt = ATL_AlignPtr(vp);
   pr = pt + (szT SHIFT);
   pr = ATL_AlignPtr(pr);
   pc = pr + (szR SHIFT);
   pc = ATL_AlignPtr(pc);
   #ifdef TCPLX
      l2a(M, alpha, A, lda, pt, pt+szT);
      r2a(M, N, alpha, X, ldx, pr, pr+szR);
      trmmK_b0(nmu, nnu, K, pt+szT, pr+szR, pc,     pt,     pr+szR, pc+szC);
      trmmK_b0(nmu, nnu, K, pt,     pr+szR, pc+szC, pt,     pr,     pc);
      trmmK_bn(nmu, nnu, K, pt,     pr,     pc,     pt+szT, pr,     pc+szC);
      trmmK_b1(nmu, nnu, K, pt+szT, pr,     pc+szC, pt+szT, pr+szR, pc);
      blk2c(M, N, ONE, pc, pc+szC, ZERO, X, ldx);
   #else
      l2a(M, alpha, A, lda, pt);
      r2a(M, N, alpha, X, ldx, pr);
      trmmK_b0(nmu, nnu, K, pt, pr, pc, pt, pr, pc);
      blk2c(M, N, ONE, pc, ZERO, X, ldx);
   #endif
   free(vp); 
   return(0);
}
@ROUT ATL_tminfo
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018 -def cwauth "Majedul Sujon" 
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_lvl3.h"

#include Mstr(Mjoin(ATLAS_UPR,amm_kern.h))

/* cases: LN, UT, LT, UN ... LC/UC included */
#ifdef Right_
   #ifdef Upper_
      #ifdef Trans_
#include Mstr(Mjoin(ATLAS_PRE,utrmmR_LN.h)) /* LN & UT share same header file*/
         #ifdef Conj_
            #define ATL_tminfo Mjoin(PATL,tminfoR_UC)
         #else
            #define ATL_tminfo Mjoin(PATL,tminfoR_UT)
         #endif
      #else
#include Mstr(Mjoin(ATLAS_PRE,utrmmR_LT.h)) /* LT & UN share same header file*/
         #define ATL_tminfo Mjoin(PATL,tminfoR_UN)
      #endif
   #else /* lower */
      #ifdef Trans_
#include Mstr(Mjoin(ATLAS_PRE,utrmmR_LT.h))
         #ifdef Conj_
            #define ATL_tminfo Mjoin(PATL,tminfoR_LC)
         #else
            #define ATL_tminfo Mjoin(PATL,tminfoR_LT)
         #endif
      #else
#include Mstr(Mjoin(ATLAS_PRE,utrmmR_LN.h))
         #define ATL_tminfo Mjoin(PATL,tminfoR_LN)
      #endif
   #endif
#else /* left side */
   #ifdef Upper_
      #ifdef Trans_
#include Mstr(Mjoin(ATLAS_PRE,utrmmL_LN.h)) /* LN & UT share same header file*/
         #ifdef Conj_
            #define ATL_tminfo Mjoin(PATL,tminfoL_UC)
         #else
            #define ATL_tminfo Mjoin(PATL,tminfoL_UT)
         #endif
      #else
#include Mstr(Mjoin(ATLAS_PRE,utrmmL_LT.h)) /* LT & UN share same header file*/
         #define ATL_tminfo Mjoin(PATL,tminfoL_UN)
      #endif
   #else /* lower */
      #ifdef Trans_
#include Mstr(Mjoin(ATLAS_PRE,utrmmL_LT.h))
         #ifdef Conj_
            #define ATL_tminfo Mjoin(PATL,tminfoL_LC)
         #else
            #define ATL_tminfo Mjoin(PATL,tminfoL_LT)
         #endif
      #else
#include Mstr(Mjoin(ATLAS_PRE,utrmmL_LN.h))
         #define ATL_tminfo Mjoin(PATL,tminfoL_LN)
      #endif
   #endif
#endif

void ATL_tminfo
(
   tminfo_t *ip, 
   ipinfo_t *gip,
   const enum ATLAS_DIAG Diag,
   ATL_CSZT M, 
   ATL_CSZT N,
   const SCALAR alpha, 
   ATL_CSZT lda, 
   ATL_CSZT ldb
)
{
#ifdef TCPLX
   TYPE *alpL, *alpR, *alpC;
#else
   TYPE alpL, alpR, alpC;
#endif
   tcm2am_t *t2a = (tcm2am_t *)&(ip->t2blk);
   cm2am_t *r2a = (cm2am_t *)&(ip->r2blk);
   ablk2cmat_t *blk2c = (ablk2cmat_t *)&(ip->blk2c);
   
   ip->mu = ATL_TRMMK_MU;
   ip->nu = ATL_TRMMK_NU;
   ip->ku = ATL_TRMMK_KU;
   ip->vlen = ATL_TRMMK_VLEN;
   ip->kvec = ATL_TRMMK_KVEC;
   ip->kb = ATL_TRMM_KB; 
   ip->flg = 0;
   #ifdef Right_
      #ifdef Trans_
         ip->incA = lda SHIFT; 
      #else
         ip->incA = 1 SHIFT;
      #endif
   #else
      #ifdef Trans_
         ip->incA = 1 SHIFT;
      #else
         ip->incA = lda SHIFT;
      #endif
   #endif
/*
 * TRMM Kernel
 */
   ip->amm_b0 = Mjoin(PATL,trmmK_b0);
   ip->amm_b1 =  Mjoin(PATL,trmmK_b1);
   #ifdef TCPLX
      ip->amm_bn = Mjoin(PATL,trmmK_bn);
   #endif
/*
 * check whether the kernel matches with gemm
 */
   if (gip->mu == ip->mu && gip->nu == ip->nu 
         && gip->ku == ip->ku && gip->vlen == ip->vlen)
   {
/*
 *    check mdim of both kernels 
 */
      if (ip->kvec == ATL_AMM_KMAJOR(ATL_AMM_GetFLAG(gip->idxK)))
         ip->flg |= 1;
   }
/*
 * TRMM copy routines.... 
 */
   if (ip->flg & 1) /* trmm kernel similar to gemm */
   {
      alpC = gip->alpC;
      #ifdef Right_
         alpL = gip->alpB;
         alpR = gip->alpA;
      #else
         alpL = gip->alpA;
         alpR = gip->alpB;
      #endif
/*
 *    l2a 
 */
      #ifdef Upper_
         if (SCALAR_IS_ONE(alpL))
         {
            if (Diag == AtlasUnit)
               *t2a = Mjoin(PATL,trmm_a2blk_Up_diagU_a1);
            else
               *t2a = Mjoin(PATL,trmm_a2blk_Up_a1);
         }
         else
         {
            if (Diag == AtlasUnit)
               *t2a = SCALAR_IS_NONE(alpL)? Mjoin(PATL,trmm_a2blk_Up_diagU_aN): 
                  Mjoin(PATL,trmm_a2blk_Up_diagU_aX); 
            else
               *t2a = SCALAR_IS_NONE(alpL)? Mjoin(PATL,trmm_a2blk_Up_aN): 
                  Mjoin(PATL,trmm_a2blk_Up_aX); 
         }
      #else /* lower */
         if (SCALAR_IS_ONE(alpL))
         {
            if (Diag == AtlasUnit)
               *t2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_a1);
            else
               *t2a = Mjoin(PATL,trmm_a2blk_Lo_a1);
         }
         else
         {
            if (Diag == AtlasUnit)
               *t2a = SCALAR_IS_NONE(alpL)? Mjoin(PATL,trmm_a2blk_Lo_diagU_aN): 
                  Mjoin(PATL,trmm_a2blk_Lo_diagU_aX);
            else
               *t2a = SCALAR_IS_NONE(alpL)? Mjoin(PATL,trmm_a2blk_Lo_aN): 
                  Mjoin(PATL,trmm_a2blk_Lo_aX);
         }
      #endif
/*
 *    r2a: using gemm's alpha distribution  
 */
      if (SCALAR_IS_ONE(alpR))
         *r2a = Mjoin(PATL,trmm_b2blk_a1);
      else
         *r2a = SCALAR_IS_NONE(alpR) ? Mjoin(PATL,trmm_b2blk_aN) : 
            Mjoin(PATL,trmm_b2blk_aX);
/*
 *    blk2c: using gemm's alpha distribution
 *    NOTE: beta is always zero for trmm  
 */
      if (SCALAR_IS_ONE(alpC))
         *blk2c = Mjoin(PATL,trmm_blk2c_a1b0);
      else
         *blk2c = SCALAR_IS_NONE(alpR) ? Mjoin(PATL,trmm_blk2c_aNb0) : 
            Mjoin(PATL,trmm_blk2c_aXb0);
   }
/*
 * TRMM uses different kernel, no copies can be shared
 * so optimize copy routine considering TRMM 
 */
   else
   {
      *blk2c = Mjoin(PATL,trmm_blk2c_a1b0);
      if (SCALAR_IS_ONE(alpha))
      {
         #ifdef Upper_
            if (Diag == AtlasUnit)
               *t2a = Mjoin(PATL,trmm_a2blk_Up_diagU_a1);
            else
               *t2a = Mjoin(PATL,trmm_a2blk_Up_a1);
         #else
            if (Diag == AtlasUnit)
               *t2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_a1);
            else
               *t2a = Mjoin(PATL,trmm_a2blk_Lo_a1);
         #endif
         *r2a = Mjoin(PATL,trmm_b2blk_a1);
      }
      else  /* alpha is not one */
      {
   #ifdef Right_ 
      if (N > (M>>1)) /* multiply alpha in tri-copy*/
   #else
      if (M > (N>>1)) /* multiply alpha in tri-copy*/
   #endif
      {
         *r2a = Mjoin(PATL,trmm_b2blk_a1);
         if (SCALAR_IS_NONE(alpha))
         {
            #ifdef Upper_
               if (Diag == AtlasUnit)
                  *t2a = Mjoin(PATL,trmm_a2blk_Up_diagU_aN);
               else
                  *t2a = Mjoin(PATL,trmm_a2blk_Up_aN);
            #else
               if (Diag == AtlasUnit)
                  *t2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_aN);
               else
                  *t2a = Mjoin(PATL,trmm_a2blk_Lo_aN);
            #endif
         }
         else /* alphaX, since alpha can't be 0 here */
         {
            #ifdef Upper_
               if (Diag == AtlasUnit)
                  *t2a = Mjoin(PATL,trmm_a2blk_Up_diagU_aX);
               else
                  *t2a = Mjoin(PATL,trmm_a2blk_Up_aX);
            #else
               if (Diag == AtlasUnit)
                  *t2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_aX);
               else
                  *t2a = Mjoin(PATL,trmm_a2blk_Lo_aX);
            #endif
         }
      }
      else /* multiply alpha in gemm copy */
      {
            #ifdef Upper_
               if (Diag == AtlasUnit)
                  *t2a = Mjoin(PATL,trmm_a2blk_Up_diagU_a1);
               else
                  *t2a = Mjoin(PATL,trmm_a2blk_Up_a1);
            #else
               if (Diag == AtlasUnit)
                  *t2a = Mjoin(PATL,trmm_a2blk_Lo_diagU_a1);
               else
                  *t2a = Mjoin(PATL,trmm_a2blk_Lo_a1);
            #endif
            if (SCALAR_IS_NONE(alpha))
               *r2a = Mjoin(PATL,trmm_b2blk_aN);
            else
               *r2a = Mjoin(PATL,trmm_b2blk_aX);
         }
      }
   }
}
@ROUT ATL_trmm_alloc
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018 -def cwauth "Majedul Sujon" -def contrib "Rakib Hasan"
#include "atlas_misc.h"
#include "atlas_amm.h"

#ifdef Right_
   #define ATL_trmm_alloc Mjoin(PATL,trmmR_alloc)
#else
   #define ATL_trmm_alloc Mjoin(PATL,trmmL_alloc)
#endif

/* #define MEM_DEBUG 1*/
void* ATL_trmm_alloc
(   
   const ipinfo_t *ip,  /* gemm's ipinfo */ 
   tminfo_t *si,       /* trmm's ipinfo */ 
   ATL_CSZT N, 
   ATL_SZT *Tsz, 
   ATL_SZT *Rsz, 
   ATL_SZT *Csz,
   TYPE **bw,  /* workspace for TRMM: single B-block and result (C) in TRMM*/ 
   TYPE **L,   /* whole A-matrix */
   TYPE **R,   /* row/col panel of B (shared with TRMM if possible) */
   TYPE **w    /* workspace for the result of single blk (C in gemm)*/
)
{
   void *vp;
   size_t szL, szR, szW;
   const int mu = ip->mu, nu = ip->nu, ku = ip->ku;
   const int mb = ip->mb;
   const int nb = ip->nb;
   const int vlen = ip->vlen;
   const size_t nmb = (N + mb - 1) / mb;
   const size_t nnb = (N + nb-1) / nb;
   const unsigned int szA = ip->szA, szB = ip->szB, szC = ip->szC;

   const int tvlen = si->vlen;
   const int tmu = si->mu; 
   const int tnu = si->nu; 
   const int tku = si->ku; 
   const int tnmu = (mb+tmu-1)/tmu;
   const int tnnu = (nb+tnu-1)/tnu;

   int exsz;
   
   #ifdef Right_
   const int tnku = (nb+tku-1)/tku;
/*
 *    storage calculation for TRMM 
 */
      *Tsz = nb*nb; /* space for triangle A block in TRMM */
/*
 *    NOTE: Tsz needs to be multiple of gemm's vlen
 */
      *Tsz = ((*Tsz + vlen-1)/vlen)*vlen; /* make it mult of vlen */
      *Rsz = tmu*tnmu*tku*tnku; /* space for a B-block in TRMM */
      if (si->flg&1) /* no space needed for c in trmm if shared with gemm */
         *Csz = 0;
      else
         *Csz = (((tmu*tnu+tvlen-1)/tvlen)*tvlen)*tnmu*tnnu; 
/*
 *    bw : TRMM: B-copy +  result of C
 *    L:   Whole A-matrix minus diagonal blocks + space for diagoal blks in TRMM
 *         = nb*nb*(nnb-1)*(nnb>>1) + (*Tsz)*nnb 
 *    R:   B col-panel = mbnb*nnb  
 *    w:   workspace for C-result of single blk in GEMM = mbnb
 */
      szL = szB*(((nnb)*(nnb-1))>>1) + (*Tsz)*nnb; 
      szR = szA*nnb; 
      szW = Mmax(szC,mb*nb);
      exsz = tnu*tku + Mmax(nu*ku,tnu*tku) + (mu+mu)*nu;
   #else
   const int tnku = (mb+tku-1)/tku;
      *Tsz = mb*mb; /* workspace for triangle A block in TRMM */
      *Tsz = ((*Tsz + vlen-1)/vlen)*vlen; /* make it mult of vlen */
      *Rsz = tnu*tnnu*tku*tnku; /* workspace for a B-block in TRMM*/
      if (si->flg&1) /* no space needed for c in trmm if shared with gemm */
         *Csz = 0;
      else
         *Csz = (((tmu*tnu+tvlen-1)/tvlen)*tvlen)*tnmu*tnnu; /* size for C in TRMM*/
/*
 *    bw : TRMM: B-copy +  result of C 
 *    L:   Whole A-matrix minus diagonal blocks + space for diagoal blks in TRMM
 *         = mb*mb*(nmb-1)*(nmb>>1) + (*Tsz)*nmb 
 *    R:   B col-panel = mbnb*nmb  
 *    w:   workspace for C-result of single blk in GEMM = mbnb
 */
      szL = (szA*(((nmb-1)*nmb)>>1)) + (*Tsz)*nmb;
      szR = szB*nmb; 
      szW = Mmax(szC,mb*nb);
      exsz = tmu*tku + Mmax(mu*ku,tmu*tku) + (mu+mu)*nu;
   #endif
   vp = malloc( ATL_MulBySize( (*Rsz) + (*Csz) + szL + szR + szW + exsz )    
                  + 4*ATL_Cachelen );
   if (!vp) return(NULL); /* not enough memory */
   
   *bw = ATL_AlignPtr(vp);
   *L = (*bw) + (((*Rsz)+(*Csz)) SHIFT);
   *L = ATL_AlignPtr(*L);
   *R = (*L) + (szL SHIFT);
   *R = ATL_AlignPtr(*R);
   *w = (*R) + (szR SHIFT);
   *w = ATL_AlignPtr(*w);
   return(vp);
}
@BEGINSKIP
*
*  Bottom up approach: ATL_trmmL_LN_UT and ATL_trmmR_LT_UN
*  Top down approach:  ATL_trmmR_LN_UT and ATL_trmmL_LT_UN 
*  TODO: possible to use two routines in extract to generate all four cases.
*  Need to interchange between: NB & MB, A & B in kernel call, ib & jb and lots
*  of other variable. I will explore how to compact them later.
*
@ENDSKIP
@ROUT ATL_trmmL_LN_UT
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018 -def cwauth "Rakib Hasan" -def contrib "Majedul Sujon"
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_reflvl3.h"

#define trmmBlk Mjoin(PATL,trmmLLNBlk)
#define trmmL_LNUT Mjoin(PATL,trmmL_LNUT)

void trmmBlk
(
   tminfo_t *si,       /* trmm info */
   int flag,            /* 1: c-workspace shared with gemm */
   ATL_CSZT M,           
   ATL_CSZT N,          
   const SCALAR alpha, 
   const TYPE *A,       /* if non-NULL, base A ptr to copy */
   ATL_CSZT lda, 
   TYPE *B,             /* if non-NULL, base B ptr to copy */
   ATL_CSZT ldb, 
   TYPE *C,             /* if non-NULL, base C ptr to copy the result */
   ATL_CSZT ldc, 
   TYPE *wA,            /* workspace for A */ 
   TYPE *wB,            /* workspace for B */
   TYPE *rC,            /* real portion of wC (unused for real routines) */
   TYPE *wC,            /* workspace for C */ 
   ATL_UINT szA,        /* workspace size of iA */ 
   ATL_UINT szB         /* workspace size of iB, may vary based on sharing */
)
{
   const int mu = si->mu;
   const int nu = si->nu;
   const int ku = si->ku;
   ATL_CSZT nmu = (M + mu - 1) / mu;
   ATL_CSZT nnu = (N + nu - 1) / nu;
   ATL_CSZT K = ((M + ku - 1) / ku) * ku;
   tcm2am_t t2a = si->t2blk;
   cm2am_t r2a = si->r2blk;
   ablk2cmat_t blk2c = si->blk2c;
   ammkern_t trmmK_b0 = si->amm_b0;
   ammkern_t trmmK_b1 = si->amm_b1;
   #ifdef TCPLX
      ammkern_t trmmK_bn = si->amm_bn;
      TYPE *rA = wA + szA;
      TYPE *rB = wB + szB;
      TYPE ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ZERO ATL_rzero
   #endif
/*
 * Appropriate copy routines with alpha has been selected from tminfo
 * so, it's safe to pass alpha through all routines 
 */
   #ifdef TCPLX
      if (A) t2a(M, alpha, A, lda, rA, wA);
      if (B) r2a(M, N, alpha, B, ldb, rB, wB);
      if (flag&1) /* shared with gemm, so accumulate the result */
      {
         trmmK_bn(nmu, nnu, K, wA, wB, rC, rA, wB, wC);
         trmmK_b1(nmu, nnu, K, rA, wB, wC, rA, rB, rC);
      }
      else
      {
         trmmK_b0(nmu, nnu, K, wA, wB, rC, rA, wB, wC);
         trmmK_b0(nmu, nnu, K, rA, wB, wC, rA, rB, rC);
      }
      trmmK_bn(nmu, nnu, K, rA, rB, rC, wA, rB, wC);
      trmmK_b1(nmu, nnu, K, wA, rB, wC, wA, wB, rC);
      if (C) blk2c(M, N, alpha, rC, wC, ZERO, C, ldc);
   #else
      if (A) t2a(M, alpha, A, lda, wA);
      if (B) r2a(M, N, alpha, B, ldb, wB);
      if (flag&1) /* shared with gemm, so accumulate the result */
         trmmK_b1(nmu, nnu, K, wA, wB, rC, wA, wB, rC);
      else
         trmmK_b0(nmu, nnu, K, wA, wB, rC, wA, wB, rC);
      if (C) blk2c(M, N, alpha, rC, ZERO, C, ldc);
   #endif
}

int trmmL_LNUT
(
   ipinfo_t *ip,   /* ipinfo for gemm */ 
   tminfo_t *si,  /* ipinfo for trmm */
   ATL_CSZT M,       
   ATL_CSZT N, 
   const SCALAR alpha, 
   const TYPE *A,     
   ATL_CSZT lda, 
   TYPE *X, 
   ATL_CSZT ldx,     
   ATL_CSZT Tsz,   /* workspace size of single A Block for TRMM */
   ATL_CSZT Rsz,   /* workspace size of single B Block for TRMM */
   ATL_CSZT Csz,   /* workspace size of result for TRMM, 0 if shared with gemm*/ 
   TYPE *tbw,      /* workspace ptr for TRMM */ 
   TYPE *L,        /* workspace ptr for whole A matrix */ 
   TYPE *RW,       /* workspace ptr for B panel */
   TYPE *w         /* workspace ptr for C in gemm (may be shared with trmm) */
)
{
   #ifdef TCPLX
      TYPE ONE[2] = {ATL_rone, ATL_rzero};
      TYPE ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
   #endif
   ATL_SZT i, j;
   const int ainc = si->incA; 
   int tincb;
   unsigned int ib, jb, nfkblks, Mr;
   const int MV = 3; /* move A & B */
   TYPE *x, *l, *wL, *tcw;
   TYPE *rC, *wC, *wT, *rT;
   unsigned int NB, szA, szC, nmblks, incb;
   /*const int MB = ip->kb;*/
   const int MB = ip->mb;
   int flag = si->flg;
   
   #ifdef DEBUG 
   if (ip->mb != ip->kb)
   {
/*
 *    NOTE: MB may not be equal to KB when we have only one block  
 */
      fprintf(stderr, "MB is not equal to KB!!!\n");
   }
   #endif

   szA = ip->szA;
   szC = ip->szC;
   #ifdef TCPLX
      wC = w; 
      rC = wC + szC; 
   #else
      wC = rC = w;
   #endif
   if (flag&1) /* trmm shares c-space with gemm */
   {
      wT = wC; 
      rT = rC;
   }
   else /* not shared with gemm */
   {
      tcw = tbw + (Rsz SHIFT);  
      #ifdef TCPLX
         wT = tcw; 
         rT = tcw + Csz; 
      #else
         wT = rT = tcw;
      #endif
   }
   NB = ip->nb;
   nmblks = ip->nfmblks + ip->npmblks;
   nfkblks = (M-MB-1) / MB;
   Mr = M - (M/MB)*MB;
   if (!Mr) Mr = MB;
/*
 * NOTE: Gemm will always be called on full K-blks, 
 * only TRMM applied on partial k-blks. So, make KB0 and kb0 equal to kb
 */
   ip->KB0 = ip->kb0 = ip->kb;
/*
 * for each col panel Bcpan in B
 */
   for (j=0, jb=0, x=X; j < N; j += NB, jb++, x += (NB SHIFT)*ldx)
   {
      int mb, nb;
      const int DoCopyA = !j;
      TYPE *a, *b, *Ac = ((TYPE*)A), *xc = x, *xb, *rb;
      
      nb = Mmin((N-j), NB);
      mb = Mmin(Mr, M);
      
      incb = nb < NB ? ip->pszB : ip->szB; /* size of B workspace for panel */
      ip->nfkblks = nfkblks; /* reset nfkblks for the new panel */
      Ac += ((M - mb) SHIFT) * (lda+1);  /* A --> point to last diag blk */
      xc += ((M - mb) SHIFT);            /* B --> last blk of the panel */
/*
 *    for each block Bblk of Bcpan from bottom to top
 */
      for (i=M-mb, ib=1, l=L; i > 0; i -= MB, ib++)
      {
         a = DoCopyA ? (Ac - i*ainc) : NULL;
         b = (ib == 1) ? x : NULL;
/*
 *       gemm call: store tmp result to workspace, not copied out. 
 *       rC,wC has the result, not copied out to X
 */
         Mjoin(PATL,iploopsK)(ip, nmblks-ib, jb, a, b, xc, MV, l, RW, rC, wC, 
               ZERO, NULL);
         l += ((ip->nfkblks+1) SHIFT) * szA; /* point to A workspace for TRMM */
         wL = l;
         a = DoCopyA ? Ac : NULL; /* when need to copy, point to diagonal blk */
/*
 *       share B copies with gemm if both kernels use same mu,nu,ku,mdim and
 *       gemm already did the copy 
 *       share workspace for C as well to minimize extra blk2c copy  
 */
         if ((flag&1) && (ib!=1)) 
         {
            xb = NULL;
            rb = RW + ( ((i/MB) SHIFT)*incb);
            tincb = incb;
         }
         else /* can't share copies with gemm */
         {
            xb = xc;
            rb = tbw;
            tincb = Rsz;
         }
         trmmBlk(si, si->flg, mb, nb, alpha, a, lda, xb, ldx, xc, ldx, wL, rb, 
                 rT, wT, Tsz, tincb);
/*
 *       if no sharing, copy out w with blk2c_b1 
 *       NOTE: TRMM always copies the result to X 
 */   
         if (!(flag&1)) /* no sharing means need extra blk2c copy */
         {
            #ifdef TCPLX
               ip->blk2c_b1(mb, nb, ip->alpC, rC, wC, ONE, xc, ldx);
            #else
               ip->blk2c_b1(mb, nb, ip->alpC, rC, ONE, xc, ldx);
            #endif
         }
         l += (Tsz SHIFT); /* skip A-copy space for TRMM */
         mb = MB; /* for 1st iter, mb = mr, next on, it's MB */
         Ac -= (mb SHIFT) * (lda+1); /* point to next up diagonal */
         xc -= (mb SHIFT);           
         ip->nfkblks--; /* reduce number of k blocks for next gemm */
      }
      wL = l;
      a = DoCopyA ? Ac : NULL;
/*
 *    share B copies with gemm if possible 
 */
      if ((flag&1) && M > mb) /* inner loop execuites */
      {
         xb = NULL;
         /*rb = RW + ( ((i/MB) SHIFT)*incb) ;*/
         rb = RW; /* always first block at this point */
         tincb = incb;
      }
      else
      {
         xb = xc;
         rb = tbw;
         tincb = Rsz;
      }
/*
 *    TRMM only block, don't accumulate the result 
 */
      trmmBlk(si, 0, mb, nb, alpha, a, lda, xb, ldx, xc, ldx, wL, rb, rT, 
            wT, Tsz, tincb);
   }
   return(0);
}
@ROUT ATL_trmmL_LT_UN
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018 -def cwauth "Rakib Hasan" -def contrib "Majedul Sujon"
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_reflvl3.h"

#define trmmBlk Mjoin(PATL,trmmLLTBlk)
#define trmmL_LTUN Mjoin(PATL,trmmL_LTUN)

void trmmBlk
(
   tminfo_t *si,       /* trmm info */
   int flag,            /* 1: c-workspace shared with gemm */
   ATL_CSZT M,           
   ATL_CSZT N,          
   const SCALAR alpha, 
   const TYPE *A,       /* if non-NULL, base A ptr to copy */
   ATL_CSZT lda, 
   TYPE *B,             /* if non-NULL, base B ptr to copy */
   ATL_CSZT ldb, 
   TYPE *C,             /* if non-NULL, base C ptr to copy the result */
   ATL_CSZT ldc, 
   TYPE *wA,            /* workspace for A */ 
   TYPE *wB,            /* workspace for B */
   TYPE *rC,            /* real portion of wC (unused for real routines) */
   TYPE *wC,            /* workspace for C */ 
   ATL_CSZT szA,        /* workspace size of iA */ 
   ATL_CSZT szB         /* workspace size of iB, may vary based on sharing */
)
{
   const int mu = si->mu;
   const int nu = si->nu;
   const int ku = si->ku;
   ATL_CSZT nmu = (M + mu - 1) / mu;
   ATL_CSZT nnu = (N + nu - 1) / nu;
   ATL_CSZT K = ((M + ku - 1) / ku) * ku;
   tcm2am_t t2a = si->t2blk;
   cm2am_t r2a = si->r2blk;
   ablk2cmat_t blk2c = si->blk2c;
   ammkern_t trmmK_b0 = si->amm_b0;
   ammkern_t trmmK_b1 = si->amm_b1;
   #ifdef TCPLX
      ammkern_t trmmK_bn = si->amm_bn;
      TYPE *rA = wA + szA;
      TYPE *rB = wB + szB;
      TYPE ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ZERO ATL_rzero
   #endif
/*
 * Appropriate copy routines with alpha has been selected from tminfo
 * so, it's safe to pass alpha through all routines 
 */
   #ifdef TCPLX
      if (A) t2a(M, alpha, A, lda, rA, wA);
      if (B) r2a(M, N, alpha, B, ldb, rB, wB);
      if (flag&1) /* shared with gemm, so accumulate the result */
      {
         trmmK_bn(nmu, nnu, K, wA, wB, rC, rA, wB, wC);
         trmmK_b1(nmu, nnu, K, rA, wB, wC, rA, rB, rC);
      }
      else
      {
         trmmK_b0(nmu, nnu, K, wA, wB, rC, rA, wB, wC);
         trmmK_b0(nmu, nnu, K, rA, wB, wC, rA, rB, rC);
      }
      trmmK_bn(nmu, nnu, K, rA, rB, rC, wA, rB, wC);
      trmmK_b1(nmu, nnu, K, wA, rB, wC, wA, wB, rC);
      if (C) blk2c(M, N, alpha, rC, wC, ZERO, C, ldc);
   #else
      if (A) t2a(M, alpha, A, lda, wA);
      if (B) r2a(M, N, alpha, B, ldb, wB);
      if (flag&1) /* shared with gemm, so accumulate the result */
         trmmK_b1(nmu, nnu, K, wA, wB, rC, wA, wB, rC);
      else
         trmmK_b0(nmu, nnu, K, wA, wB, rC, wA, wB, rC);
      if (C) blk2c(M, N, alpha, rC, ZERO, C, ldc);
   #endif
}

int trmmL_LTUN
(
   ipinfo_t *ip,   /* ipinfo for gemm */ 
   tminfo_t *si,  /* ipinfo for trmm */
   ATL_CSZT M,       
   ATL_CSZT N, 
   const SCALAR alpha, 
   const TYPE *A,     
   ATL_CSZT lda, 
   TYPE *X, 
   ATL_CSZT ldx,     
   ATL_CSZT Tsz,   /* workspace size of single A Block for TRMM */
   ATL_CSZT Rsz,   /* workspace size of single B Block for TRMM */
   ATL_CSZT Csz,   /* workspace size of result for TRMM, 0 if shared with gemm*/ 
   TYPE *tbw,      /* workspace ptr for TRMM */ 
   TYPE *L,        /* workspace ptr for whole A matrix */ 
   TYPE *RW,       /* workspace ptr for B panel */
   TYPE *w         /* workspace ptr for C in gemm (may be shared with trmm) */
)
{
   #ifdef TCPLX
      TYPE ONE[2] = {ATL_rone, ATL_rzero};
      TYPE ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
   #endif
   ATL_SZT i, j;
   const int ainc = si->incA; 
   int tincb;
   unsigned int ib, jb, nfkblks, Mr;
   const int MV = 3; /* move A & B */
   TYPE *x, *l, *wL, *tcw;
   TYPE *rC, *wC, *rT, *wT;
   unsigned int NB, szA, szC, nmblks, incb;
   const int MB = ip->mb;
   int flag = si->flg;
  
   #ifdef DEBUG
      if (ip->mb != ip->kb)
      {
/*
 *       NOTE: MB may not be equal to KB when we have only one block  
 */
         fprintf(stderr, "MB is not equal to KB!!!\n");
      }
   #endif

   szA = ip->szA;
   szC = ip->szC;
   #ifdef TCPLX
      wC = w; 
      rC = wC + szC; 
   #else
      wC = rC = w;
   #endif
   if (flag&1) /* trmm shares c-space with gemm */
   {
      wT = wC; 
      rT = rC;
   }
   else /* not shared with gemm */
   {
      tcw = tbw + (Rsz SHIFT);
      #ifdef TCPLX
         wT = tcw; 
         rT = tcw + Csz; 
      #else
         wT = rT = tcw;
      #endif
   }
   NB = ip->nb;
   nmblks = ip->nfmblks + ip->npmblks;
   nfkblks = (M-MB-1) / MB;
   Mr = M - (M/MB)*MB;
   if (!Mr) Mr = MB;
/*
 * NOTE: Gemm will always be called on full K-blks, 
 * only TRMM applied on partial k-blks. So, make KB0 and kb0 equal to kb
 */
   ip->KB0 = ip->kb0 = ip->kb;

   for (j=0, jb=0, x=X; j < N; j += NB, jb++, x += (NB SHIFT)*ldx)
   {
      int mb, nb;
      const int DoCopyA = !j;
      TYPE *a, *b, *Ac = ((TYPE*)A), *xc = x, *xb, *rb; 

      nb = Mmin((N-j), NB);
      mb = Mmin(Mr, M);
      incb = nb < NB ? ip->pszB : ip->szB;
      ip->nfkblks = nfkblks; /* reset nfkblks for the new panel */

      for (i=mb, ib=1, l=L; i < M; i += MB, ib++)
      {
         a = DoCopyA ? (Ac + mb*ainc) : NULL;  
         b = (ib == 1) ? (xc + (mb SHIFT)) : NULL;
/*
 *       gemm call: store tmp result to workspace, not copied out. 
 *       rC,wC has the result, not copied out to X
 */
         Mjoin(PATL,iploopsK)(ip, nmblks-ib, jb, a, b, xc, MV, l, 
               RW+(ib-1)*(incb SHIFT), rC, wC, ZERO, NULL);
        
         l += ((ip->nfkblks+1) SHIFT) * szA;
         wL = l;
         a = DoCopyA ? Ac : NULL;
/*
 *       share B copies with gemm if both kernels use same mu,nu,ku,mdim and
 *       gemm already did the copy 
 *       share workspace for C as well to minimize extra blk2c copy  
 */
         if ((flag&1) && (ib!=1)) /* params same as gemm kernel */
         {
            xb = NULL;
            rb = RW + (ib-2)* (incb SHIFT);
            tincb = incb;
         }
         else /* can't share copies with gemm */
         {
            xb = xc;
            rb = tbw;
            tincb = Rsz;
         }
         trmmBlk(si, flag, mb, nb, alpha, a, lda, xb, ldx, xc, ldx, wL, rb, rT, 
               wT, Tsz, tincb);
/*
 *       if no sharing, copy out w with blk2c_b1 
 *       NOTE: TRMM always copies the result to X 
 */   
         if (!(flag&1))
         {
            #ifdef TCPLX
               ip->blk2c_b1(mb, nb, ip->alpC, rC, wC, ONE, xc, ldx);
            #else
               ip->blk2c_b1(mb, nb, ip->alpC, rC, ONE, xc, ldx);
            #endif
         }
         l += (Tsz SHIFT);
         Ac += (mb SHIFT) * (lda+1);
         xc += (mb SHIFT);
         mb = MB;
         ip->nfkblks--; /* reduce number of k blocks for next gemm */
      }
      wL = l;
      a = DoCopyA ? Ac : NULL;
/*
 *    share B copies with gemm if possible 
 */
      if ((flag&1) && M > mb) /* inner loop execuites */
      {
         xb = NULL;
         rb = RW + (ib-2)* (incb SHIFT) ; 
         tincb = incb;
      }
      else
      {
         xb = xc;
         rb = tbw;
         tincb = Rsz;
      }
/*
 *    TRMM only block, don't accumulate the result 
 */
      trmmBlk(si, 0, mb, nb, alpha, a, lda, xb, ldx, xc, ldx, wL, rb, rT, 
            wT, Tsz, tincb);
   }
   return(0);
}
@ROUT ATL_trmmR_LN_UT
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018 -def cwauth "Rakib Hasan" -def contrib "Majedul Sujon"
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_reflvl3.h"

#define trmmBlk Mjoin(PATL,trmmRLNBlk)
#define trmmR_LNUT Mjoin(PATL,trmmR_LNUT)

void trmmBlk
(
   tminfo_t *si,       /* trmm info */
   int flag,            /* 1: c-workspace shared with gemm */
   ATL_CSZT M,           
   ATL_CSZT N,          
   const SCALAR alpha, 
   const TYPE *A,       /* if non-NULL, base A ptr to copy */
   ATL_CSZT lda, 
   TYPE *B,             /* if non-NULL, base B ptr to copy */
   ATL_CSZT ldb, 
   TYPE *C,             /* if non-NULL, base C ptr to copy the result */
   ATL_CSZT ldc, 
   TYPE *wA,            /* workspace for A */ 
   TYPE *wB,            /* workspace for B */
   TYPE *rC,            /* real portion of wC (unused for real routines) */
   TYPE *wC,            /* workspace for C */ 
   ATL_CSZT szA,        /* workspace size of iA */ 
   ATL_CSZT szB         /* workspace size of iB, may vary based on sharing */
)
{
   const int mu = si->mu;
   const int nu = si->nu;
   const int ku = si->ku;
   ATL_CSZT nmu = (M + mu - 1) / mu;
   ATL_CSZT nnu = (N + nu - 1) / nu;
   ATL_CSZT K = ((N + ku - 1) / ku) * ku;
   tcm2am_t t2a = si->t2blk;
   cm2am_t r2a = si->r2blk;
   ablk2cmat_t blk2c = si->blk2c;
   ammkern_t trmmK_b0 = si->amm_b0;
   ammkern_t trmmK_b1 = si->amm_b1;
   #ifdef TCPLX
      ammkern_t trmmK_bn = si->amm_bn;
      TYPE *rA = wA + szA;
      TYPE *rB = wB + szB;
      TYPE ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ZERO ATL_rzero
   #endif
/*
 * Appropriate copies with alpha are selected from tminfo.. safe to pass alpha
 */
   #ifdef TCPLX 
      if (A) t2a(N, alpha, A, lda, rA, wA);
      if (B) r2a(N, M, alpha, B, ldc, rB, wB);
      if (flag&1)
      {
         trmmK_bn(nmu, nnu, K, wB, wA, rC, rB, wA, wC);
         trmmK_b1(nmu, nnu, K, rB, wA, wC, rB, rA, rC);
      }
      else
      {
         trmmK_b0(nmu, nnu, K, wB, wA, rC, rB, wA, wC);
         trmmK_b0(nmu, nnu, K, rB, wA, wC, rB, rA, rC);
      }
      trmmK_bn(nmu, nnu, K, rB, rA, rC, wB, rA, wC);
      trmmK_b1(nmu, nnu, K, wB, rA, wC, wB, wA, rC);
      if (C) blk2c(M, N, alpha, rC, wC, ZERO, C, ldc);
   #else
      if (A) t2a(N, alpha, A, lda, wA);
      if (B) r2a(N, M, alpha, B, ldb, wB);
      if (flag&1)
         trmmK_b1(nmu, nnu, K, wB, wA, rC, wB , wA, rC);
      else
         trmmK_b0(nmu, nnu, K, wB, wA, rC, wB , wA, rC);
      if (C) blk2c(M, N, alpha, rC, ZERO, C, ldc);
   #endif
}

int trmmR_LNUT
(
   ipinfo_t *ip,   /* ipinfo for gemm */ 
   tminfo_t *si,  /* ipinfo for trmm */
   ATL_CSZT M,       
   ATL_CSZT N, 
   const SCALAR alpha, 
   const TYPE *A,     
   ATL_CSZT lda, 
   TYPE *X, 
   ATL_CSZT ldx,     
   ATL_CSZT Tsz,   /* workspace size of single A Block for TRMM */
   ATL_CSZT Rsz,   /* workspace size of single B Block for TRMM */
   ATL_CSZT Csz,   /* workspace size of result for TRMM, 0 if shared with gemm*/ 
   TYPE *tbw,      /* workspace ptr for TRMM */ 
   TYPE *L,        /* workspace ptr for whole A matrix */ 
   TYPE *RW,       /* workspace ptr for B panel */
   TYPE *w         /* workspace ptr for C in gemm (may be shared with trmm) */
)
{
   #ifdef TCPLX
      TYPE ONE[2] = {ATL_rone, ATL_rzero};
      TYPE ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
   #endif
   ATL_SZT i, j;
   const int ainc = si->incA; 
   unsigned int ib, jb, nfkblks, Nr;
   const int MV = 3; /* move A & B */
   TYPE *x, *l, *wL, *tcw;
   TYPE *rC, *wC, *rT, *wT;
   unsigned int MB, szB, szC, nnblks, inca;
   const int NB = ip->nb; /* nb & kb should be same */
   int tincb;
   int flag = si->flg;
 
   #ifdef DEBUG
   if(ip->nb != ip->kb)
   {
/*
 *       NOTE: NB may not be equal to KB when we have only one block  
 */
         fprintf(stderr, "NB is not equal to KB!!!\n");
   }
   #endif
   szB = ip->szB;
   szC = ip->szC;
   #ifdef TCPLX
      wC = w; 
      rC = wC + szC; 
   #else
      wC = rC = w;
   #endif
   if (flag&1) /* trmm shares c-space with gemm */
   {
      wT = wC; 
      rT = rC;
   }
   else /* not shared with gemm */
   {
      tcw = tbw + (Rsz SHIFT);  
      #ifdef TCPLX
         wT = tcw; 
         rT = tcw + Csz; 
      #else
         wT = rT = tcw;
      #endif
   }
   MB = ip->mb;
   nnblks = ip->nfnblks + ip->npnblks;
   nfkblks = (N-NB-1) / NB;
   Nr = N - (N/NB)*NB;
   if (!Nr) Nr = NB;
/*
 * NOTE: Gemm will always be called on full K-blks, 
 * only TRMM applied on partial k-blks. So, make KB0 and kb0 equal to kb
 */
   ip->KB0 = ip->kb0 = ip->kb;

   for (i=0, ib=0, x=X; i < M; i += MB, ib++, x += (MB SHIFT))
   {
      int nb, mb;
      const int DoCopyA = !i;
      TYPE *a, *b, *d, *Ac = ((TYPE*)A), *xc = x, *rb, *xb;
      mb = Mmin((M-i), MB);
      nb = Mmin(Nr, N);
      inca = mb < MB ? ip->pszA : ip->szA; /* szA actually is for B*/
      ip->nfkblks = nfkblks; /* reset nfkblks for the new panel */

      for (j=nb, jb=1, l=L; j < N; j += NB, jb++)
      {
         a = DoCopyA ? (Ac+ nb*ainc) : NULL;
         b = (jb == 1) ? (xc + (nb SHIFT)*ldx) : NULL;
/*
 *       gemm call: store tmp result to workspace, not copied out. 
 *       rC,wC has the result, not copied out to X
 *       NOTE: since remainder is kept at the beginnig of N dimension, 
 *       it represents last blk in rowpan with respect to gemm (iploops)
 */
         Mjoin(PATL,iploopsK)(ip, ib, nnblks-jb, b, a, xc, MV, 
               RW+(jb-1)*(inca SHIFT), l, rC, wC, ZERO, NULL);
         l += ((ip->nfkblks+1) SHIFT) * szB;
         wL = l;
         a = DoCopyA ? Ac : NULL;
/*
 *       share B copies with gemm if both kernels use same mu,nu,ku,mdim and
 *       gemm already did the copy 
 *       share workspace for C as well to minimize extra blk2c copy  
 */
         if ((flag&1) && (jb!=1))
         {
            xb = NULL;
            rb = RW + (jb-2)* (inca SHIFT) ;
            tincb = inca;
         }
         else
         {
            xb = xc; 
            rb = tbw;
            tincb = Rsz;
         }
         trmmBlk(si, flag, mb, nb, alpha, a, lda, xb, ldx, xc, ldx, wL, rb, rT, 
               wT, Tsz, tincb);
/*
 *       if no sharing, copy out w with blk2c_b1 
 *       NOTE: TRMM always copies the result to X 
 */   
         if (!(flag&1))
         {
            #ifdef TCPLX 
               ip->blk2c_b1(mb, nb, ip->alpC, rC, wC, ONE, xc, ldx);
            #else
               ip->blk2c_b1(mb, nb, ip->alpC, rC, ONE, xc, ldx);
            #endif
         }
         l += (Tsz SHIFT);
         Ac += (nb SHIFT) * (lda+1);
         xc += (nb SHIFT) * ldx;
         nb = NB;
         ip->nfkblks--; /* reduce number of k blocks for next gemm */
      }
      wL = l;
      a = DoCopyA ? Ac : NULL;
/*
 *    share B copies with gemm if possible 
 */
      if ((flag&1) && (N>nb))
      {
            xb = NULL;
            rb = RW + (jb-2)* (inca SHIFT) ;
            tincb = inca; /* inca actually for B*/
      }
      else
      {
         xb = xc;
         rb = tbw;
         tincb = Rsz;
      }
/*
 *    TRMM only block, don't accumulate the result 
 */
      trmmBlk(si, 0, mb, nb, alpha, a, lda, xb, ldx, xc, ldx, wL, rb, rT, wT, 
            Tsz, tincb);
   }
   return(0);
}
@ROUT ATL_trmmR_LT_UN
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018 -def cwauth "Rakib Hasan" -def contrib "Majedul Sujon"
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_reflvl3.h"

#define trmmBlk Mjoin(PATL,trmmRLTBlk) 
#define trmmR_LTUN Mjoin(PATL,trmmR_LTUN)

void trmmBlk
(
   tminfo_t *si,       /* trmm info */
   int flag,            /* 1: c-workspace shared with gemm */
   ATL_CSZT M,           
   ATL_CSZT N,          
   const SCALAR alpha, 
   const TYPE *A,       /* if non-NULL, base A ptr to copy */
   ATL_CSZT lda, 
   TYPE *B,             /* if non-NULL, base B ptr to copy */
   ATL_CSZT ldb, 
   TYPE *C,             /* if non-NULL, base C ptr to copy the result */
   ATL_CSZT ldc, 
   TYPE *wA,            /* workspace for A */ 
   TYPE *wB,            /* workspace for B */
   TYPE *rC,            /* real portion of wC (unused for real routines) */
   TYPE *wC,            /* workspace for C */ 
   ATL_CSZT szA,        /* workspace size of iA */ 
   ATL_CSZT szB         /* workspace size of iB, may vary based on sharing */
)
{
   const int mu = si->mu;
   const int nu = si->nu;
   const int ku = si->ku;
   ATL_CSZT nmu = (M + mu - 1) / mu;
   ATL_CSZT nnu = (N + nu - 1) / nu;
   ATL_CSZT K = ((N + ku - 1) / ku) * ku;
   tcm2am_t t2a = si->t2blk;
   cm2am_t r2a = si->r2blk;
   ablk2cmat_t blk2c = si->blk2c;
   ammkern_t trmmK_b0 = si->amm_b0;
   ammkern_t trmmK_b1 = si->amm_b1;
   #ifdef TCPLX
      ammkern_t trmmK_bn = si->amm_bn;
      TYPE *rA = wA + szA;
      TYPE *rB = wB + szB;
      TYPE ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ZERO ATL_rzero
   #endif
/*
 * Appropriate copies with alpha are selected from tminfo.. safe to pass alpha
 */
   #ifdef TCPLX 
      if (A) t2a(N, alpha, A, lda, rA, wA);
      if (B) r2a(N, M, alpha, B, ldc, rB, wB);
      if (flag&1)
      {
         trmmK_bn(nmu, nnu, K, wB, wA, rC, rB, wA, wC);
         trmmK_b1(nmu, nnu, K, rB, wA, wC, rB, rA, rC);
      }
      else
      {
         trmmK_b0(nmu, nnu, K, wB, wA, rC, rB, wA, wC);
         trmmK_b0(nmu, nnu, K, rB, wA, wC, rB, rA, rC);
      }
      trmmK_bn(nmu, nnu, K, rB, rA, rC, wB, rA, wC);
      trmmK_b1(nmu, nnu, K, wB, rA, wC, wB, wA, rC);
      if (C) blk2c(M, N, alpha, rC, wC, ZERO, C, ldc);
   #else
      if (A) t2a(N, alpha, A, lda, wA);
      if (B) r2a(N, M, alpha, B, ldb, wB);
      if (flag&1)
         trmmK_b1(nmu, nnu, K, wB, wA, rC, wB , wA, rC);
      else
         trmmK_b0(nmu, nnu, K, wB, wA, rC, wB , wA, rC);
      if (C) blk2c(M, N, alpha, rC, ZERO, C, ldc);
   #endif
}

int trmmR_LTUN
(
   ipinfo_t *ip,   /* ipinfo for gemm */ 
   tminfo_t *si,  /* ipinfo for trmm */
   ATL_CSZT M,       
   ATL_CSZT N, 
   const SCALAR alpha, 
   const TYPE *A,     
   ATL_CSZT lda, 
   TYPE *X, 
   ATL_CSZT ldx,     
   ATL_CSZT Tsz,   /* workspace size of single A Block for TRMM */
   ATL_CSZT Rsz,   /* workspace size of single B Block for TRMM */
   ATL_CSZT Csz,   /* workspace size of result for TRMM, 0 if shared with gemm*/ 
   TYPE *tbw,      /* workspace ptr for TRMM */ 
   TYPE *L,        /* workspace ptr for whole A matrix */ 
   TYPE *RW,       /* workspace ptr for B panel */
   TYPE *w         /* workspace ptr for C in gemm (may be shared with trmm) */
)
{
   #ifdef TCPLX
      TYPE ONE[2] = {ATL_rone, ATL_rzero};
      TYPE ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
   #endif
   ATL_SZT i, j;
   const int ainc = si->incA;
   int flag = si->flg;
   unsigned int ib, jb, nfkblks, Nr;
   const int MV = 3; /* move A & B */
   TYPE *x, *l, *wL, *tcw;
   TYPE *rC, *wC, *rT, *wT;
   unsigned int MB, szB, szC, nnblks, inca;
   const int NB = ip->nb;
   int tincb;
  
   #ifdef DEBUG 
      if(ip->nb != ip->kb)
      {
/*
 *       NOTE: NB may not be equal to KB when we have only one block  
 */
         fprintf(stderr, "NB is not equal to KB!!!\n");
      }
   #endif
   szB = ip->szB;
   szC = ip->szC;
   #ifdef TCPLX
      wC = w; 
      rC = wC + szC; 
   #else
      wC = rC = w;
   #endif
   if (flag&1) /* trmm shares c-space with gemm */
   {
      wT = wC; 
      rT = rC;
   }
   else /* not shared with gemm */
   {
      tcw = tbw + (Rsz SHIFT);  
      #ifdef TCPLX
         wT = tcw; 
         rT = tcw + Csz; 
      #else
         wT = rT = tcw;
      #endif
   }
   MB = ip->mb;
   nnblks = ip->nfnblks + ip->npnblks;
   nfkblks = (N-NB-1) / NB;
   Nr = N - (N/NB)*NB;
   if (!Nr) Nr = NB;
/*
 * NOTE: Gemm will always be called on full K-blks, 
 * only TRMM applied on partial k-blks. So, make KB0 and kb0 equal to kb
 */
   ip->KB0 = ip->kb0 = ip->kb;

   for (i=0, ib=0, x=X; i < M; i += MB, ib++, x += (MB SHIFT))
   {
      int nb, mb;
      const int DoCopyA = !i;
      TYPE *a, *b, *d, *Ac = ((TYPE*)A), *xc = x, *xb, *rb;
      mb = Mmin((M-i), MB);
      nb = Mmin(Nr, N);
      inca = mb < MB ? ip->pszA : ip->szA;
      ip->nfkblks = nfkblks; /* reset nfkblks for the new panel */
      Ac += ((N - nb) SHIFT) * (lda+1);
      xc += ((N - nb) SHIFT) * ldx;

      for (j=N-nb, jb=1, l=L; j > 0; j -= NB, jb++)
      {
         a = DoCopyA ? (Ac - j*ainc) : NULL;
         b = (jb == 1) ? x : NULL;
/*
 *       gemm call: store tmp result to workspace, not copied out.
 *       rC,wC has the result, not copied out to X
 */
         Mjoin(PATL,iploopsK)(ip, ib, nnblks-jb, b, a, xc, MV, RW, 
                              l, rC, wC, ZERO, NULL);
         l += ((ip->nfkblks+1) SHIFT) * szB;
         wL = l;
         a = DoCopyA ? Ac : NULL;
/*
 *       share B copies with gemm if both kernels use same mu,nu,ku,mdim and
 *       gemm already did the copy 
 *       share workspace for C as well to minimize extra blk2c copy  
 */
         if ((flag&1) && (jb!=1))
         {
            xb = NULL;
            rb = RW + ( ((j/NB)*inca) SHIFT) ;
            tincb = inca;
         }
         else
         {
            xb = xc; 
            rb = tbw;
            tincb = Rsz;
         }
         trmmBlk(si, flag, mb, nb, alpha, a, lda, xb, ldx, xc, ldx, wL, rb, rT, 
               wT, Tsz, tincb);
/*
 *       if no sharing, copy out w with blk2c_b1 
 *       NOTE: TRMM always copies the result to X 
 */   
         if (!(flag&1))
         {
            #ifdef TCPLX
               ip->blk2c_b1(mb, nb, ip->alpC, rC, wC, ONE, xc, ldx);
            #else
               ip->blk2c_b1(mb, nb, ip->alpC, rC, ONE, xc, ldx);
            #endif
         }
         
         l += (Tsz SHIFT);
         nb = NB;
         Ac -= (nb SHIFT) * (lda+1);
         xc -= (nb SHIFT) * ldx;
         ip->nfkblks--; /* reduce number of k blocks for next gemm */
      }
      wL = l;
      a = DoCopyA ? Ac : NULL;
/*
 *    share B copies with gemm if possible 
 */
      if ((flag&1) && (N>nb))
      {
         xb = NULL;
         rb = RW + ( ((j/NB)*inca) SHIFT) ;
         tincb = inca;
      }
      else
      {
         xb = xc; 
         rb = tbw;
         tincb = Rsz;
      }
/*
 *    TRMM only block, don't accumulate the result 
 */
      trmmBlk(si, 0, mb, nb, alpha, a, lda, xb, ldx, xc, ldx, wL, rb, rT, wT,
            Tsz, tincb);
   }
   return(0);
}
@ROUT ATL_iptrmm
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018 -def cwauth "Majedul Sujon"
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_lvl3.h" 

#ifdef Right_
   #include Mstr(Mjoin(ATLAS_PRE,trmmRU_view.h)) 
   #define INCR 1
   #define ATL_iptrmm Mjoin(PATL,iptrmmR)
   #define ATL_trmm_ST Mjoin(PATL,trmmR_ST)
   #define ATL_trmm_alloc Mjoin(PATL,trmmR_alloc)
   #define ATL_tminfoLN Mjoin(PATL,tminfoR_LN)
   #define ATL_tminfoLT Mjoin(PATL,tminfoR_LT)
   #define ATL_tminfoUN Mjoin(PATL,tminfoR_UN)
   #define ATL_tminfoUT Mjoin(PATL,tminfoR_UT)
   #ifdef TCPLX 
      #define ATL_tminfoLC Mjoin(PATL,tminfoR_LC)
      #define ATL_tminfoUC Mjoin(PATL,tminfoR_UC)
   #endif
   #define ATL_trmm_LNUT Mjoin(PATL,trmmR_LNUT)
   #define ATL_trmm_LTUN Mjoin(PATL,trmmR_LTUN)
#else
   #include Mstr(Mjoin(ATLAS_PRE,trmmLU_view.h)) 
   #define INCR ldb
   #define ATL_iptrmm Mjoin(PATL,iptrmmL)
   #define ATL_trmm_ST Mjoin(PATL,trmmL_ST)
   #define ATL_trmm_alloc Mjoin(PATL,trmmL_alloc)
   #define ATL_tminfoLN Mjoin(PATL,tminfoL_LN)
   #define ATL_tminfoLT Mjoin(PATL,tminfoL_LT)
   #define ATL_tminfoUN Mjoin(PATL,tminfoL_UN)
   #define ATL_tminfoUT Mjoin(PATL,tminfoL_UT)
   #ifdef TCPLX 
      #define ATL_tminfoLC Mjoin(PATL,tminfoL_LC)
      #define ATL_tminfoUC Mjoin(PATL,tminfoL_UC)
   #endif
   #define ATL_trmm_LNUT Mjoin(PATL,trmmL_LNUT)
   #define ATL_trmm_LTUN Mjoin(PATL,trmmL_LTUN)
#endif
int ATL_iptrmm
(
   ATL_UINT bv,  /* 0:Right, 1:Upper, 2:TransA, 3: Conj, 4:NonUnit */
   ATL_CSZT               NT,  /* number of diagonals in triangle */
   ATL_CSZT               NR,  /* number of right hand sides */
   const SCALAR           alpha,
   const TYPE             *A,
   ATL_CSZT               lda,
   TYPE                   *B,
   ATL_CSZT               ldb
)
{
/*
 * Handle degerated cases 
 */
   if (NT == 1)
   {
      if (bv&16)   /* if non-unit, work to do, else nothing to do at M=1! */
      #ifdef TCPLX
      {
         TYPE scl[2], tmp;
         *scl = *A;
         tmp = A[1];
         scl[1] = (bv&8) ? -tmp : tmp;
         if (!SCALAR_IS_ONE(alpha))
         {
            TYPE ra, ia;
            ra = scl[0] * alpha[0] - scl[1] * alpha[1];
            ia = scl[1] * alpha[0] + scl[0] * alpha[1];
            scl[0] = ra; scl[1] = ia;
         }
         Mjoin(PATL,scal)(NR, scl, B, INCR);
      }
      #else
         Mjoin(PATL,scal)(NR, alpha * *A, B, INCR);
      #endif
      else if (!SCALAR_IS_ONE(alpha))  /* unit may still need to scale! */
         Mjoin(PATL,scal)(NR, alpha, B, INCR);
      return(0);
   }
/*
 * if NT (KB) is not greater than MAX_KB, apply trmm_ST code 
 */
#ifdef Right_
   else if (NT <= ATL_VIEW_MAX_KB && NR <= ATL_VIEW_MAX_MB)
#else
   else if (NT <= ATL_VIEW_MAX_KB && NR <= ATL_VIEW_MAX_NB)
#endif
      return(ATL_trmm_ST(bv, NT, NR, alpha, A, lda, B, ldb));
/*
 * NT (KB) is large, so apply outer loop for trmm
 */
   else 
   {
      int res;
      unsigned int ctu; /* Conj Trans Upper*/
      ATL_SZT Tsz, Rsz, Csz; /* workspace size for TRMM */
      TYPE *BW, *L, *R, *w;
      void *vp=NULL;
      ipinfo_t gip;
      tminfo_t si;
   #ifdef TCPLX
      TYPE ONE[2] = {ATL_rone, ATL_rzero};
      TYPE ZERO[2] = {ATL_rzero, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
   #endif
      enum ATLAS_TRANS TA;
      #ifdef TCPLX
         if ((bv&12)==12)
            TA = AtlasConjTrans;
         else
      #endif
      TA = (bv&4) ? AtlasTrans:AtlasNoTrans;
/*
 *    Get ipinfo for the GEMM
 */
      if (bv & 1) /* Right*/
         Mjoin(PATL,ipnekInfo)(&gip, AtlasNoTrans, TA, NR, NT, NT, ldb, lda, ldb, 
                               alpha, ZERO);
      else  /* Left */
         Mjoin(PATL,ipmekInfo)(&gip, TA, AtlasNoTrans, NT,NR,NT, lda, ldb, ldb, 
                               alpha, ZERO);
/*
 *    select tminfo and one of four variation of outer loops
 */
      void (*tminfo) (tminfo_t *ip, ipinfo_t *gip, const enum ATLAS_DIAG Diag, 
            ATL_CSZT N, ATL_CSZT R, const SCALAR alpha, ATL_CSZT lda, 
            ATL_CSZT ldb);
      int (*ammtrmm)(ipinfo_t *ip, tminfo_t *si,  
            ATL_CSZT M, ATL_CSZT N, const SCALAR alpha, const TYPE *A, 
            ATL_CSZT lda, TYPE *X, ATL_CSZT ldx, ATL_CSZT Tsz, ATL_CSZT Rsz,
            ATL_CSZT Csz, TYPE *tbw, TYPE *L, TYPE *R, TYPE *w );
      
      ctu = (bv>>1)&7; /* masked three bits responsible for Conj Trans Upper*/
      if (!ctu)
         tminfo = ATL_tminfoLN;
      else if (ctu == 2)
         tminfo = ATL_tminfoLT;
      #ifdef TCPLX
         else if (ctu == 6)
            tminfo = ATL_tminfoLC;
      #endif
      else if (ctu == 1)
         tminfo = ATL_tminfoUN;
      else if (ctu == 3)
         tminfo = ATL_tminfoUT;
      #ifdef TCPLX
      else if (ctu == 7)
         tminfo = ATL_tminfoUC;
      #endif
      else /* unknown trmm case! */
           ATL_assert(0);
      if (!ctu || ctu==3 || ctu == 7)
         ammtrmm = ATL_trmm_LNUT;
      else
         ammtrmm = ATL_trmm_LTUN;
/*
 *    Get TRMM info 
 */
      if (bv&1)
         tminfo(&si, &gip, (bv&16)?AtlasNonUnit:AtlasUnit, NR, NT, alpha, lda, 
               ldb);
      else
         tminfo(&si, &gip, (bv&16)?AtlasNonUnit:AtlasUnit, NT, NR, alpha, lda, 
               ldb);
/*
 *    allocate workspace for trmm outer loop 
 */
      vp = ATL_trmm_alloc(&gip, &si, NT, &Tsz, &Rsz, &Csz, &BW, &L, &R, &w);
      if (!vp)
         return(1); /* not enough memory, reucrse again  */
/*
 *    apply trmm outer-loop
 */
      if (bv & 1)
         res = ammtrmm(&gip, &si, NR, NT, alpha, A, lda, B, ldb, Tsz, Rsz, Csz, 
               BW, L, R, w);
      else
         res = ammtrmm(&gip, &si, NT, NR, alpha, A, lda, B, ldb, Tsz, Rsz, Csz, 
               BW, L, R, w);
      
      free(vp);
      return(res);
   }
   return(0);
}
@ROUT ATL_trmm_ST
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018 -def cwauth "Majedul Sujon"
#include "atlas_misc.h"
#include "atlas_lvl3.h"
#ifdef Right_
   #define ATL_trmm_ST Mjoin(PATL,trmmR_ST)
   #define ATL_utrmm_LN Mjoin(PATL,utrmmR_LN)
   #define ATL_utrmm_LT Mjoin(PATL,utrmmR_LT)
   #define ATL_utrmm_UN Mjoin(PATL,utrmmR_UN)
   #define ATL_utrmm_UT Mjoin(PATL,utrmmR_UT)
   #ifdef TCPLX
      #define ATL_utrmm_LC Mjoin(PATL,utrmmR_LC)
      #define ATL_utrmm_UC Mjoin(PATL,utrmmR_UC)
   #endif
#else
    #define ATL_trmm_ST Mjoin(PATL,trmmL_ST)
   #define ATL_utrmm_LN Mjoin(PATL,utrmmL_LN)
   #define ATL_utrmm_LT Mjoin(PATL,utrmmL_LT)
   #define ATL_utrmm_UN Mjoin(PATL,utrmmL_UN)
   #define ATL_utrmm_UT Mjoin(PATL,utrmmL_UT)
   #ifdef TCPLX
      #define ATL_utrmm_LC Mjoin(PATL,utrmmL_LC)
      #define ATL_utrmm_UC Mjoin(PATL,utrmmL_UC)
   #endif
#endif
/*#define DEBUG 1*/
/*
 * This is basically a wrapper function to TRMM of small triangle 
 */
int ATL_trmm_ST
(
   ATL_UINT bv,  /* 0:Right, 1:Upper, 2:TransA, 3: Conj, 4:NonUnit */
   ATL_CSZT               NT,  /* number of diagonals in triangle */
   ATL_CSZT               NR,  /* number of right hand sides */
   const SCALAR           alpha,
   const TYPE             *A,
   ATL_CSZT               lda,
   TYPE                   *B,
   ATL_CSZT               ldb
)
{
   unsigned int ctu; /* bits for conj-trans-upper */
   int res;
/*
 * prototypes for trmm micro-kernels
 */
   int (*utrmm)(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
      
   int ATL_utrmm_LN(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
   int ATL_utrmm_UT(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
   int ATL_utrmm_LT(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
   int ATL_utrmm_UN(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
   #ifdef TCPLX
   int ATL_utrmm_UC(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
   int ATL_utrmm_LC(const enum ATLAS_DIAG,ATL_CINT N, ATL_CINT R,
         const SCALAR alpha, const TYPE *A, ATL_CSZT lda,TYPE *X, ATL_CSZT ldx);
   #endif
/*
 *       C T U
 * LNUT  0 0 0 -- LN = 0
 *       0 1 1 -- UT = 3
 *       1 1 1 -- UC = 7
 *
 * LTUN  0 1 0 -- LT = 2
 *       1 1 0 -- LC = 6
 *       0 0 1 -- UN = 1
 *
 */
      ctu = (bv >> 1) & 7;
 
      if (!ctu)
         utrmm = ATL_utrmm_LN;
      else if (ctu == 2)
         utrmm = ATL_utrmm_LT;
      #ifdef TCPLX
         else if (ctu == 6)
            utrmm = ATL_utrmm_LC;
      #endif
      else if (ctu == 1)
         utrmm = ATL_utrmm_UN;
      else if (ctu == 3)
         utrmm = ATL_utrmm_UT;
      #ifdef TCPLX
      else if (ctu == 7)
         utrmm = ATL_utrmm_UC;
      #endif
      else
      {
           fprintf(stderr,"**** Unknown TRMM case!!\n");
           /*assert(0);*/
           return(1);
      }
   if (bv & 1)
      res = utrmm((bv&16)?AtlasNonUnit:AtlasUnit, NR, NT, alpha, A, lda, B, ldb);
   else
      res = utrmm((bv&16)?AtlasNonUnit:AtlasUnit, NT, NR, alpha, A, lda, B, ldb);
   return(res);
}
@ROUT ATL_trmm
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018 -def contrib "Majedul Sujon"
#include "atlas_misc.h"
#include "atlas_level3.h"
#include "atlas_lvl3.h"
#if 0
   #define USEREF 1
   #include "atlas_reflevel3.h"
#endif
static unsigned int trmm_recR
/*
 * RETURNS: recursion depth (starting from 0)
 */
(
   const int             bv,    /* 0:Right,1:Upper,2:TransA,3:Conj, 4:NonUnit */
   ATL_CSZT               N,    /* size of triangle, will recur on this dim */
   ATL_CSZT               NRHS, /* don't recur on RHS */
   const SCALAR           alpha,
   const TYPE             *T,
   ATL_CSZT               ldt,
   ATL_CSZT               rincT, /* rowinc: 1/2 for NoTrans, else ldt2 */
   ATL_CSZT               cincT, /* colinc: ldt2 for NoTrans, else 1/2 */
   TYPE                   *Z,
   ATL_CSZT               ldz
)
{
   unsigned int iret=0;
   if (Mjoin(PATL,iptrmmR)(bv, N, NRHS, alpha, T, ldt, Z, ldz))
   {
      #ifdef TCPLX
         enum ATLAS_TRANS TB;
         const TYPE none[2] = {ATL_rnone, ATL_rzero};
         const TYPE one[2]  = {ATL_rone,  ATL_rzero};
      #else
         #define none ATL_rnone
         #define one ATL_rone
         const enum ATLAS_TRANS TB = (bv&4) ? AtlasTrans : AtlasNoTrans;
      #endif
      ATL_CSZT NL = (N>>1), NR = N - NL;
      const TYPE *T0, *T1;
      TYPE *C, *Z0;
      const TYPE *B;
      ATL_UINT LNUT;        /* is this LN or UT case? */

      #ifdef TCPLX
         if (bv&4)
            TB = (bv&8) ? AtlasConjTrans : AtlasTrans;
         else
            TB = (bv&8) ? AtlasConj : AtlasNoTrans;
      #endif
      LNUT = (bv&6);             /* get Upper(2) and Trans(4) bits */
      LNUT = (!LNUT)|(LNUT==6);  /* is this LN or UT case? */
      if (LNUT)                  /* LN or UT case */
      {
         T0 = T + NR*((ldt+1)SHIFT);
         T1 = T;
         B = T + NR*rincT;
         Z0 = Z + NR*(ldz SHIFT);
         C = Z;
      }
      else                       /* LT or UN case */
      {
         Z0 = Z;
         T0 = T;
         B = T + NL*rincT;
         C = Z + NL*(ldz SHIFT);
         T1 = B + NL*cincT;
      }
     
      iret += trmm_recR(bv, NR, NRHS, alpha, T1, ldt, rincT, cincT, C, ldz);
      Mjoin(PATL,gemm)(AtlasNoTrans, TB, NRHS, NR, NL, alpha, Z0, ldz, B, ldt,
                       one, C, ldz);
      iret = 2 + trmm_recR(bv, NL, NRHS, alpha, T0, ldt, rincT, cincT, Z0,ldz);
      return(iret);
   }
   return(iret);
}

static unsigned int trmm_recL
/*
 * RETURNS: recursion depth (starting from 0)
 */
(
   const int             bv,    /* 0:Right,1:Upper,2:TransA,3:Conj, 4:NonUnit */
   ATL_CSZT               N,    /* size of triangle, will recur on this dim */
   ATL_CSZT               NRHS, /* don't recur on RHS */
   const SCALAR           alpha,
   const TYPE             *T,
   ATL_CSZT               ldt,
   ATL_CSZT               rincT, /* rowinc: 1/2 for NoTrans, else ldt2 */
   ATL_CSZT               cincT, /* colinc: ldt2 for NoTrans, else 1/2 */
   TYPE                   *Z,
   ATL_CSZT               ldz
)
{
   unsigned int iret=0;
   if (Mjoin(PATL,iptrmmL)(bv, N, NRHS, alpha, T, ldt, Z, ldz))
   {
      #ifdef TCPLX
         enum ATLAS_TRANS TA;
         const TYPE none[2] = {ATL_rnone, ATL_rzero};
         const TYPE one[2]  = {ATL_rone,  ATL_rzero};
      #else
         #define none ATL_rnone
         #define one ATL_rone
         const enum ATLAS_TRANS TA = (bv&4) ? AtlasTrans : AtlasNoTrans;
      #endif
      ATL_CSZT NL = (N>>1), NR = N - NL;
      const TYPE *T0, *T1;
      TYPE *C, *Z0;
      const TYPE *A, *B;
      ATL_UINT LNUT;        /* is this LN or UT case? */

      #ifdef TCPLX
         if (bv&4)
            TA = (bv&8) ? AtlasConjTrans : AtlasTrans;
         else
            TA = (bv&8) ? AtlasConj : AtlasNoTrans;
      #endif
      LNUT = (bv&6);             /* get Upper(2) and Trans(4) bits */
      LNUT = (!LNUT)|(LNUT==6);  /* is this LN or UT case? */
      if (LNUT)                  /* LN or UT case */
      {
         T0 = T;
         A = T + NR*rincT;
         Z0 = Z;
         C = Z + (NR SHIFT);
         T1 = A + NR*cincT;
      }
      else                       /* LT or UN case */
      {
         T0 = T + NL*((ldt+1)SHIFT);
         T1 = T;
         A = T + NL*rincT;
         C = Z;
         Z0 = Z + (NL SHIFT);
      }
      iret = 2 + trmm_recL(bv, NL, NRHS, alpha, T1, ldt, rincT, cincT, C, ldz);
      Mjoin(PATL,gemm)(TA, AtlasNoTrans, NL, NRHS, NR, alpha, A, ldt, Z0, ldz,
                          one, C, ldz);
      iret += trmm_recL(bv, NR, NRHS, alpha, T0, ldt, rincT, cincT, Z0,ldz);
      return(iret);
   }
   return(iret);
}
void Mjoin(PATL,trmm)
(
   const enum ATLAS_SIDE  SD,
   const enum ATLAS_UPLO  UL,
   const enum ATLAS_TRANS TA,
   const enum ATLAS_DIAG  DI,
   ATL_CSZT               M,
   ATL_CSZT               N,
   const SCALAR           alpha,
   const TYPE             *A,
   ATL_CSZT               lda,
   TYPE                   *B,
   ATL_CSZT               ldb
)
/*
 * Purpose
 * =======
 * ATL_trmm matrix operation
 *    B = alpha * op( A ) * X ,   or  B = alpha * X * op( A ),
 *
 * where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 * non-unit, upper or lower triangular matrix and op( A ) is one of
 *    op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ).
 *
 * The matrix X is overwritten on B.
 */
{
   #ifdef USEREF
   Mjoin(PATL,reftrmm)(SD, UL, TA, DI, M, N, alpha, A, lda, B, ldb);
   return;
   #endif
   ATL_SZT incR, incC;
   ATL_UINT r, bv = (SD == AtlasRight) ? 1 : 0;
            /* 0:Right, 1:Upper, 2:TransA, 3: Conj, 4:NonUnit */

   if (!M || !N)  /* if either array is of size 0 */
      return;     /* return as there is nothing to do */
   if (SCALAR_IS_ZERO(alpha))                   /* alpha == 0 means */
   {
      Mjoin(PATL,gescal)(M, N, alpha, B, ldb);  /* only need to scale B */
      return;
   }
   if (UL == AtlasUpper)
   {
      bv |= 2;
      incR = lda SHIFT;
      incC = 1 SHIFT;
   }
   else
   {
      incR = 1 SHIFT;
      incC = lda SHIFT;
   }
   #ifdef TCPLX
      if (TA == AtlasConjTrans)
         bv |= (8|4);
      else
         bv |= TA == (AtlasTrans) ? 4 : 0;
   #else
      bv |= (TA == AtlasNoTrans) ? 0:4;
   #endif
   bv |= (DI == AtlasNonUnit) ? 16 : 0;
/*
 * LEFT: op(A) * X = alpha * B, A is MxM, X is MxN, B is MxN
 */
   if (SD == AtlasLeft)
      r = trmm_recL(bv, M, N, alpha, A, lda, incR, incC, B, ldb);
   else
      r = trmm_recR(bv, N, M, alpha, A, lda, incR, incC, B, ldb);
}
@ROUT trmmgen
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018 -def cwauth "Majedul Sujon"
#include "atlas_mmgen.h"
#include "atlas_type.h"

void GenTrCopyHeader(FILE *fp, char pre, char sd, char up0, char ta0, char up,
      char ta, ATL_mmnode_t *mp)
{
/*
 * Acopy always TRMM copy
 * LN: TT2blk-Lo
 * UT: TN2blk-Up
 * two additional cases: unit-diagonal, conjugate
 *
 * NOTE:
 *
 * format:
 *    ATL_da2blk_trmm_LLN_Lo_a1               ATL_dcpFromATt_Lo_a1_1x24_0
 */
/*
 * selecting correct copies from table:
 *    S  U  T  kernels   cpyA    cpB
 *    ---------------------------------
 *    L  L  N    TRMM=1   tAT,L   AN
 *    L  L  T    TRMM=2   tAN,L   AN
 *    L  U  N    TRMM=2   tAT,U   AN
 *    L  U  T    TRMM=1   tAN,U   AN
 *    R  L  N    TRMM=3    AT    tAN,L
 *    R  L  T    TRMM=4    AT    tAT,L
 *    R  U  N    TRMM=4    AT    tAN,U
 *    R  U  T    TRMM=3    AT    tAT,U
 *
 */
   int i, j;
   char *uplo;
   char *uld; /* _DiaU */
   const char al[3] = {'1', 'N', 'X'};
   unsigned int UR, kvec;
   const char uls[2] = {'L', 'U'};
   const char tas[2] = {'N', 'T'};
   char at, tta;

   kvec = FLAG_IS_SET(mp->flag, MMF_KVEC) ? mp->vlen:0;
   uplo = (up == 'L')? "Lo" : "Up";
   if (sd == 'L')
   {
      at = (ta == 'N')? 'T' : 'N';
      UR = mp->mu;
   }
   else  /* R */
   {
      at = ta;
      UR = mp->nu;
   }
   for (j=0 ; j < 2; j++)
   {
      if (j == 1)
      {
         uld = "diagU_";
         fprintf(fp, "/*\n* Unit Diagonal \n*/\n");
      }
      else
         uld = "";

      for (i=0; i < 3; i++)
      {
/*
 *       copy name format
 *       ATL_<pre>cp[Into,From]A[N,T][g,k,y,r,s]_aX_<ku>x<nu>_<kvec>
 */
         if (pre == 'c' || pre == 'z')
         {
            tta = (at == 'N')? 'C' : 'H';
            fprintf(fp, "#ifdef Conj_\n");
            fprintf(fp,
                    "#define ATL_%ca2blk_trmm_%c%c%c_%s_%sa%c "
                    "ATL_%ccpFromA%ct_%s_%sa%c_%ux%u_%u\n",
                    pre, sd, up0, ta0, uplo, uld, al[i],
                    pre, tta, uplo, uld, al[i], mp->ku, UR, kvec);
            fprintf(fp, "#else\n");
         }
         fprintf(fp,
                 "#define ATL_%ca2blk_trmm_%c%c%c_%s_%sa%c "
                 "ATL_%ccpFromA%ct_%s_%sa%c_%ux%u_%u\n",
                 pre, sd, up0, ta0, uplo, uld, al[i],
                 pre, at, uplo, uld, al[i], mp->ku, UR, kvec);
         if (pre == 'c' || pre == 'z')
            fprintf(fp, "#endif\n");

         fprintf(fp, "void ATL_%ca2blk_trmm_%c%c%c_%s_%sa%c", pre, sd, up0, ta0,
                 uplo, uld, al[i]);
         if (pre == 'd' || pre == 's')
            fprintf(fp, "(ATL_CSZT,const TYPE,const TYPE*,ATL_CSZT,TYPE*);\n");
         else
            fprintf(fp, 
                 "(ATL_CSZT,const TYPE*,const TYPE*, ATL_CSZT,TYPE*,TYPE*);\n");

         fprintf(fp, "#ifndef ATL_%ctrmm_a2blk_%s_%sa%c\n   #define "
                 "ATL_%ctrmm_a2blk_%s_%sa%c "
                 "ATL_%ca2blk_trmm_%c%c%c_%s_%sa%c\n#endif\n",
                 pre, uplo, uld, al[i],  pre, uplo, uld, al[i],  pre, sd, up0,
                 ta0, uplo, uld, al[i]);
      }
   }

}

void GenTrmmHead(char pre, char *outd, char sd, char up, char ta,
      ATL_mmnode_t *mp)
{
   char *of;
   FILE *fp;
   int i, flg, k, L;
   char *uplo;
   const char *st[5] = {"VLEN", "KVEC", "MU", "NU", "KU"};
   char uld [6]; /* _DiaU */
   const char be[3] = {'0', '1', 'n'};
   const char al[3] = {'1', 'N', 'X'};
   unsigned int UR, kvec;
   const char uls[2] = {'L', 'U'};
   const char tas[2] = {'N', 'T'};
   char at;
   ATL_cpnode_t *cb;

   L = strlen(outd) + 24;
   of = malloc(L);
   assert(of);
/*
 * LN represents both LN and UT case  
 */
   if (ta == 'N')
      k = sprintf(of, "%s/atlas_%cutrmm%c_LN.h", outd, pre, sd);
   else
      k = sprintf(of, "%s/atlas_%cutrmm%c_LT.h", outd, pre, sd);
   assert(k<L);
   fp = fopen(of, "w");
   assert(fp);
   free(of);
/*
 * inclusion guard
 */
   fprintf(fp, "#ifndef ATLAS_%cTRMM%c_%c%c_H\n",
           toupper(pre), toupper(sd), toupper(up), toupper(ta));
   fprintf(fp, "   #define ATLAS_%cTRMM%c_%c%c_H 1\n\n",
           toupper(pre), toupper(sd), toupper(up), toupper(ta));

   fprintf(fp, "#include \"atlas_amm.h\"\n");
/*
 * data
 */
   assert(mp);
   fprintf(fp, "#define ATL_TRMM_%c%c%c_KB %d\n", sd, up, ta, mp->kbB);
   fprintf(fp, "#define ATL_TRMMK_%c%c%c_VLEN %d\n", sd, up, ta, mp->vlen);
   kvec = FLAG_IS_SET(mp->flag, MMF_KVEC) ? mp->vlen:0;
   fprintf(fp, "#define ATL_TRMMK_%c%c%c_KVEC %u\n", sd, up, ta, kvec);
   fprintf(fp, "#define ATL_TRMMK_%c%c%c_MU %d\n", sd, up, ta, mp->mu);
   fprintf(fp, "#define ATL_TRMMK_%c%c%c_NU %d\n", sd, up, ta, mp->nu);
   fprintf(fp, "#define ATL_TRMMK_%c%c%c_KU %d\n", sd, up, ta, mp->ku);

   for (i=0; i<5; i++)
   {
      fprintf(fp, "#ifndef ATL_TRMMK_%s\n", st[i]);
      fprintf(fp, "   #define ATL_TRMMK_%s ATL_TRMMK_%c%c%c_%s\n", st[i], sd, 
              up, ta, st[i]);
      fprintf(fp, "#endif\n");
   }
   fprintf(fp, "#ifndef ATL_TRMM_KB\n");
   fprintf(fp, "   #define ATL_TRMM_KB ATL_TRMM_%c%c%c_KB\n", sd, up, ta);
   fprintf(fp, "#endif\n");
/*
 * kernel info
 */
   fprintf(fp, "/*\n* TRMM KERNEL INFO\n*/\n");
   for (i=0; i < 3; i++)
   {
      fprintf(fp,
              "void ATL_%ctrmmK_%c%c%c_b%c("
              "ATL_CSZT,ATL_CSZT,ATL_CSZT,const TYPE*,const TYPE*, \n",
              pre, sd, up, ta, be[i]);
      fprintf(fp,
              "                            TYPE*, "
              "const TYPE*, const TYPE*, const TYPE*);\n");
      fprintf(fp, "#ifndef ATL_%ctrmmK_b%c\n", pre, be[i]);
      fprintf(fp, "   #define ATL_%ctrmmK_b%c ATL_%ctrmmK_%c%c%c_b%c\n", pre,
              be[i], pre, sd, up, ta, be[i]);
      fprintf(fp, "#endif\n");
   }
/*
 * blk2C 
 * NOTE: we need copy routines for all alpha 
 */
   fprintf(fp, "/*\n* BLK2C COPY\n*/\n");
   flg = (1<<CPF_CBLK);
   flg |= (pre == 'd' || pre == 's') ? (1<<CPF_REAL):0;
   flg |= (pre == 'c' || pre == 's') ? (1<<CPF_SINGLE):0;
   cb = GetCopyNodeFromMM(flg, mp, NULL);
   assert(cb);
/*
 * blk2c copy is same as gemm... so we need gemm style blk2c copy
 * so, disable trmm flag for this specific copy routine
 */
   cb->flag &= ~(1<<CPF_TRMM);
   cb->flag |= (1<<CPF_BE0);
   for (i=0; i < 3; i++)
   {
      if (al[i] == '1')
      {
         cb->flag &= ~((1<<CPF_ALN)|(1<<CPF_ALX));
         cb->flag |= (1<<CPF_AL1);
      }
      else if (al[i] == 'N')
      {
         cb->flag &= ~((1<<CPF_ALX)|(1<<CPF_AL1));
         cb->flag |= (1<<CPF_ALN);
      }
      else if (al[i] == 'X')
      {
         cb->flag &= ~((1<<CPF_ALN)|(1<<CPF_AL1));
         cb->flag |= (1<<CPF_ALX);
      }
      if(i) free(cb->rout);
      cb->rout = GetCopyName(cb, 0);
      fprintf(fp, "#define ATL_%cblk2c_trmm_%c%c%c_a%cb0 %s\n",
              pre, sd, up, ta, al[i], cb->rout);
      fprintf(fp, "void ATL_%cblk2c_trmm_%c%c%c_a%cb0", pre, sd, up, ta, al[i]);
      if (pre == 'd' || pre == 's')
         fprintf(fp,
                 "(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const SCALAR,"
                 "TYPE*, ATL_CSZT);\n");
      else
         fprintf(fp,
                 "(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const TYPE*,"
                 "const SCALAR,TYPE*, ATL_CSZT);\n");
      fprintf(fp, "#ifndef ATL_%ctrmm_blk2c_a%cb0\n   #define "
              "ATL_%ctrmm_blk2c_a%cb0 ATL_%cblk2c_trmm_%c%c%c_a%cb0\n#endif\n",
              pre, al[i], pre, al[i], pre, sd, up, ta, al[i]);
   }
   KillAllCopyNodes(cb);
/*
 * NOTE: depending on the side, Acopy and Bcopy changes
 * side = left: Acopy is trmm copy and Bcopy is gemm copy
 * side = right:Acopy is gemm copy and Bcopy is trmm copy although trmm copy is
 * a2blk and gemm copy is b2blk in header file
 */
/*
 * Bcopy: always gemm copy
 */
   fprintf(fp, "/*\n* B2BLK COPY\n*/\n");
   flg = 0;
   if (sd == 'R')
   {
      flg |= (1<<CPF_ABLK);
      flg |= (1<<CPF_TRANS);
   }

   flg |= (1<<CPF_TOBLK); /* b2blk*/
   flg |= (pre == 'd' || pre == 's') ? (1<<CPF_REAL):0;
   flg |= (pre == 'c' || pre == 's') ? (1<<CPF_SINGLE):0;
   cb = GetCopyNodeFromMM(flg, mp, NULL);
   assert(cb);
   cb->flag &= ~(1<<CPF_TRMM);
   for (i=0; i < 3; i++)
   {
      if (al[i] == '1')
      {
         cb->flag &= ~((1<<CPF_ALN)|(1<<CPF_ALX));
         cb->flag |= (1<<CPF_AL1);
      }
      else if (al[i] == 'N')
      {
         cb->flag &= ~((1<<CPF_ALX)|(1<<CPF_AL1));
         cb->flag |= (1<<CPF_ALN);
      }
      else if (al[i] == 'X')
      {
         cb->flag &= ~((1<<CPF_ALN)|(1<<CPF_AL1));
         cb->flag |= (1<<CPF_ALX);
      }
      if(i) free(cb->rout);
      cb->rout = GetCopyName(cb, 0);
      fprintf(fp, "#define ATL_%cb2blk_trmm_%c%c%c_a%c %s\n",
              pre, sd, up, ta, al[i], cb->rout);
      fprintf(fp, "void ATL_%cb2blk_trmm_%c%c%c_a%c", pre, sd, up, ta, al[i]);
         if (pre == 'd' || pre == 's')
            fprintf(fp,
            "(ATL_CSZT,ATL_CSZT,const TYPE,const TYPE*,ATL_CSZT,TYPE*);\n");
         else
            fprintf(fp, "(ATL_CSZT,ATL_CSZT,const TYPE*,const TYPE*,"
                        "ATL_CSZT,TYPE*,TYPE*);\n");
         fprintf(fp, "#ifndef ATL_%ctrmm_b2blk_a%c\n   #define "
         "ATL_%ctrmm_b2blk_a%c ATL_%cb2blk_trmm_%c%c%c_a%c\n#endif\n",
            pre, al[i],  pre, al[i],  pre, sd, up, ta, al[i]);
   }
   KillAllCopyNodes(cb);
/*
 * In eaqch header file, we have two options.
 * LN/UT and LT/UN
 */
   fprintf(fp, "/*\n* A2BLK COPY\n*/\n");
   if (ta == 'N')
   {
      GenTrCopyHeader(fp, pre, sd, 'L', 'N', 'L', 'N', mp);
      GenTrCopyHeader(fp, pre, sd, 'L', 'N', 'U', 'T', mp);
   }
   else /* LT UN case */
   {
      GenTrCopyHeader(fp, pre, sd, 'L', 'T', 'L', 'T', mp);
      GenTrCopyHeader(fp, pre, sd, 'L', 'T', 'U', 'N', mp);
   }
   fprintf(fp, "#endif\n");
}


void GenMicroTrmm(char pre, char *outd, char sd, char up, char ta,
                           ATL_mmnode_t *mb)
{
   int i, L;
   int trmmid=0;
   int mu=mb->mu, nu=mb->nu;
   char *ln, *mk;
   char rt[256];

   L = strlen(outd) + 256;
   ln = malloc(L);
   assert(ln);
/*
 * TRMM=1 (left lower), 2 (left upper), 3 (right lower), 4 (right upper).
 * Transform:
 *    LLN : 1           RLN : 3
 *    LLT : 2           RLT : 4
 *    LUN : 2           RUN : 4
 *    LUT : 1           RUT:  3
 *
 *    transpose reverses the upper/lower
 */
   if (sd == 'R')
      trmmid = 2;
   if (ta == 'N')
      trmmid += (up=='L')? 1 : 2;
   else
      trmmid += (up=='L')? 2 : 1;

   i = sprintf(rt, "%s/ATL_%ctrmmK_%c%c%c_%ux%ux%u.c", outd, pre, sd, up, ta,
               mb->mu, mb->nu, mb->ku);
   assert(i<256);
   if (mb->rout) free(mb->rout);
   mb->rout = DupString(rt);

   mk = MMGetGenString(pre, mb);
   i = sprintf(ln, "%s TRMM=%d", mk, trmmid);
   /*printf("genstr = %s\n", ln);*/
   free(mk);
   assert(i < L);
   assert(!Sys2File(ln, NULL));
   free(ln);
}

void AddCopyDirective(FILE *fp, char *nam, char pre, char alc, unsigned int UR)
{
   int i, k;
   int sz;
   char *cpn, *ccpn;

   sz = strlen(nam);
   sz += 10; /* might be added: diagU_, [up,lo]_*/
   cpn = malloc(sz);
   assert(cpn);
/*
 * split the string at a1/aX/aN
 */
   assert(nam);
   k = strlen(nam);
   for (i=0; i < k; i++, nam++)
   {
      if (*nam == 'a')
      {
         assert(*(nam+1)!='\0'); /* assumption: must consists of a[1,N,X] */
         if ( *(nam+1) == '1' || *(nam+1) == 'N' || *(nam+1) == 'X')
            break;
      }
      cpn[i] = *nam;
   }
   cpn[i] = '\0';
/*
 * for conj: convert ATt to AHt, ANt to ACt
 */
   if (pre == 'z' || pre == 'c')
   {
      ccpn = malloc(sz);
      assert(ccpn);
      strcpy(ccpn, cpn);
      k = strlen(ccpn);
      for (i=0; i < k-2; i++)
      {
         if (ccpn[i] == 'A' && ccpn[i+1] == 'N' && ccpn[i+2] == 't')
            ccpn[i+1] = 'C';
         else if (ccpn[i] == 'A' && ccpn[i+1] == 'T' && ccpn[i+2] == 't')
            ccpn[i+1] = 'H';
      }
   }

   fprintf(fp, "#ifdef SCALAR\n  #undef SCALAR\n#endif\n");
   fprintf(fp, "#ifdef TYPE\n  #undef TYPE\n#endif\n");
   fprintf(fp, "#ifdef SREAL\n  #undef SREAL\n#endif\n");
   fprintf(fp, "#ifdef DREAL\n  #undef DREAL\n#endif\n");
   fprintf(fp, "#ifdef SCPLX\n  #undef SCPLX\n#endif\n");
   fprintf(fp, "#ifdef DCPLX\n  #undef DCPLX\n#endif\n");
   fprintf(fp, "#ifdef ALPHA1\n  #undef ALPHA1\n#endif\n");
   fprintf(fp, "#ifdef ALPHAN\n  #undef ALPHAN\n#endif\n");
   fprintf(fp, "#ifdef ALPHAN1\n  #undef ALPHAN1\n#endif\n");
   fprintf(fp, "#ifdef ALPHAX\n  #undef ALPHAX\n#endif\n");
   fprintf(fp, "#ifdef BETA1\n  #undef BETA1\n#endif\n");
   fprintf(fp, "#ifdef BETAN\n  #undef BETAN\n#endif\n");
   fprintf(fp, "#ifdef BETAN1\n  #undef BETAN1\n#endif\n");
   fprintf(fp, "#ifdef BETAX\n  #undef BETAX\n#endif\n");
/*
 * directives for type
 */
   if (pre == 's')
   {
      fprintf(fp, "#define SREAL 1\n");
      fprintf(fp, "#define TYPE float\n");
      fprintf(fp, "#define SCALAR TYPE\n");
   }
   else if (pre == 'd')
   {
      fprintf(fp, "#define DREAL 1\n");
      fprintf(fp, "#define TYPE double\n");
      fprintf(fp, "#define SCALAR TYPE\n");
   }
   else if (pre == 'c')
   {
      fprintf(fp, "#define SCPLX 1\n");
      fprintf(fp, "#define TYPE float\n");
      fprintf(fp, "#define SCALAR TYPE*\n");
   }
   else if (pre == 'z')
   {
      fprintf(fp, "#define DCPLX 1\n");
      fprintf(fp, "#define TYPE double\n");
      fprintf(fp, "#define SCALAR TYPE*\n");
   }
   else
   {
      printf("UNKNOWN TYPE\n");
      assert(0);
   }
/*
 * directives alpha
 */
   if (alc == '1')
      fprintf(fp, "#define ALPHA1 1\n");
   else if (alc == 'X')
      fprintf(fp, "#define ALPHAX 1\n");
   else if (alc == 'N')
   {
      fprintf(fp, "#define ALPHAN 1\n");
      fprintf(fp, "#define ALPHAN1 1\n");
   }
/*
 * UR &
 */
   fprintf(fp, "#define ATL_NU %u\n", UR);
   fprintf(fp, "\n#ifdef UnitDiag_\n");
   fprintf(fp, "   #ifdef Upper_\n");
   if (pre == 'z' || pre == 'c')
   {
      fprintf(fp, "      #ifdef Conj_\n");
      fprintf(fp, "         #define ATL_USERCPMM %sUp_diagU_%s\n", ccpn, nam);
      fprintf(fp, "      #else\n");
   }
   fprintf(fp, "         #define ATL_USERCPMM %sUp_diagU_%s\n", cpn, nam);
   if (pre == 'z' || pre == 'c') fprintf(fp, "      #endif\n");
   fprintf(fp, "   #else\n");
   if (pre == 'z' || pre == 'c')
   {
      fprintf(fp, "      #ifdef Conj_\n");
      fprintf(fp, "         #define ATL_USERCPMM %sLo_diagU_%s\n", ccpn, nam);
      fprintf(fp, "      #else\n");
   }
   fprintf(fp, "         #define ATL_USERCPMM %sLo_diagU_%s\n", cpn, nam);
   if (pre == 'z' || pre == 'c') 
      fprintf(fp, "      #endif\n");
   fprintf(fp, "   #endif\n");
   fprintf(fp, "#else\n");
   fprintf(fp, "   #ifdef Upper_\n");
   if (pre == 'z' || pre == 'c')
   {
      fprintf(fp, "      #ifdef Conj_\n");
      fprintf(fp, "         #define ATL_USERCPMM %sUp_%s\n", ccpn, nam);
      fprintf(fp, "      #else\n");
   }
   fprintf(fp, "         #define ATL_USERCPMM %sUp_%s\n", cpn, nam);
   if (pre == 'z' || pre == 'c') 
      fprintf(fp, "      #endif\n");
   fprintf(fp, "   #else\n");
   if (pre == 'z' || pre == 'c')
   {
      fprintf(fp, "      #ifdef Conj_\n");
      fprintf(fp, "         #define ATL_USERCPMM %sLo_%s\n", ccpn, nam);
      fprintf(fp, "      #else\n");
   }
   fprintf(fp, "         #define ATL_USERCPMM %sLo_%s\n", cpn, nam);
   if (pre == 'z' || pre == 'c') 
      fprintf(fp, "      #endif\n");
   fprintf(fp, "   #endif\n");
   fprintf(fp, "#endif\n\n");
   
   if (pre == 'z' || pre == 'c') 
      free(ccpn);
   free(cpn);
}

void GenTrCopy(ATL_mmnode_t *mp, ATL_cpnode_t *cb, char *outd, char pre, 
      char sd, char up, char ta)
{
   int i, k, L;
   int UR, kvec;
   char *ln, *cpg;
   char rt[256];
   const char al[3] = {'1', 'N', 'X'};
   char tta;
   FILE *fp;

   L = strlen(outd) + 256;
   ln = malloc(L);
   assert(ln);

   cb->flag &= ~(1<<CPF_TRANS);
/*
 * for Left TRMM: we need tAT when ta=N and tAN when ta=T
 * since we generate the copyname by our own, tta needs to reflect that
 */
   #if 0
   if (sd == 'L')
      cb->flag |= (ta=='N') ? (1<<CPF_TRANS) : 0;
   else
      cb->flag |= (ta=='T') ? (1<<CPF_TRANS) : 0;
   #else 
   if (sd == 'L') 
      tta = (ta=='N')? 'T' : 'N';
   else
      tta = ta;
      cb->flag |= (tta=='T') ? (1<<CPF_TRANS) : 0;
   #endif
/*
 * NOTE: we don't need up/lo as the parameter for TRMM-copy anymore
 */
   /*if (up == 'L')
      cb->flag |= (1<<CPF_LOWER);
   else
      cb->flag &= ~(1<<CPF_LOWER);
   */
   UR = (sd=='L')? mp->mu : mp->nu;
   kvec = FLAG_IS_SET(mp->flag, MMF_KVEC) ? mp->vlen:0;

   for (i=0; i < 3; i++)
   {
      if (al[i] == '1')
      {
         cb->flag &= ~((1<<CPF_ALN)|(1<<CPF_ALX));
         cb->flag |= (1<<CPF_AL1);
      }
      else if (al[i] == 'N')
      {
         cb->flag &= ~((1<<CPF_ALX)|(1<<CPF_AL1));
         cb->flag |= (1<<CPF_ALN);
      }
      else if (al[i] == 'X')
      {
         cb->flag &= ~((1<<CPF_ALN)|(1<<CPF_AL1));
         cb->flag |= (1<<CPF_ALX);
      }
#if 0
      cpg = GetCopyName(cb, 0);
#else
      cpg = malloc(64*sizeof(char));
      assert(cpg);
      sprintf(cpg, "ATL_%ccpFromA%ct_a%c_%ux%u_%u", pre, tta, al[i], mp->ku,
             UR, kvec);
#endif
      k = sprintf(rt, "%s/%s.c", outd, cpg);
      assert(k<256);
/*
 *    add copy directives at the start of the source file
 */
      fp = fopen(rt, "w");
      assert(fp);
      AddCopyDirective(fp, cpg, pre, al[i], cb->nu);/*always nu ifnot CPF_CBLK*/
      fclose(fp);
      free(cpg);
      if (cb->rout) free(cb->rout);
      cb->rout = DupString("ATL_tmp.c");
      cpg = GetCopyGenStr(cb);
      k = sprintf(ln, "%s", cpg);
      free(cpg);
      assert(k < L);
      assert(!Sys2File(ln, NULL));
/*
 *    append files
 */
      k = sprintf(ln, "cat %s  >> %s", cb->rout, rt);
      assert(k < L);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN CMD: '%s'\n", ln);
         assert(0);
      }
   }
   free(ln);
}

void GenCopyTrmm(char pre, char *outd, char sd, char up, char ta,
                           ATL_mmnode_t *mb)
/*
 * LN/UT: tAT-L, tAN-U
 * LT/UN: tAN-L, tAT-U
 */
{
   int i, L, flg;
   char *ln, *rt;
   ATL_cpnode_t *cb;

/*
 * copy name format
 *    ATL_<pre>cp[Into,From]A[N,T][g,k,y,r,s,t]_aX_<ku>x<nu>_<kvec>
 */
   flg = (1<<CPF_TOBLK);
   flg |= (pre == 'd' || pre == 's') ? (1<<CPF_REAL):0;
   flg |= (pre == 'c' || pre == 's') ? (1<<CPF_SINGLE):0;
   if (sd == 'L')
      flg |= (1<<CPF_ABLK);

   cb = GetCopyNodeFromMM(flg, mb, NULL);
   assert(cb);
   cb->flag |= (1<<CPF_TRMM); /* set TRMM flag */
/*
 * up is always 'L'... ta can be 'N' or 'T'
 *
 * LN/UT: tAT-L, tAN-U
 * LT/UN: tAN-L, tAT-U
 */
   /*printf("Case: %c%c%c\n", sd, up, ta);*/
   if (ta == 'N')
   {
      GenTrCopy(mb, cb, outd, pre, sd, 'L', 'N');
      GenTrCopy(mb, cb, outd, pre, sd, 'U', 'T');
   }
   else
   {
      GenTrCopy(mb, cb, outd, pre, sd, 'L', 'T');
      GenTrCopy(mb, cb, outd, pre, sd, 'U', 'N');
   }
   KillAllCopyNodes(cb);
}

void GenMakeTrmm(char pre, char *outd, char up, char *sds, char *tas,
                 ATL_mmnode_t **MBs)
{
   int k, i, UR;
   FILE *fp;
   char *fn, *typ, *comp, *sp, *flgs;
   const char be[3] = {'0', '1', 'n'};
   const char al[3] = {'1', 'N', 'X'};
   int bi, ai, kvec;
   char tta;

   k = strlen(outd) + 24;
   fn = malloc(k);
   assert(fn);
   i = sprintf(fn, "%s/Makefile", outd);
   fp = fopen(fn, "w");
   assert(fp);
   free(fn);
   fprintf(fp, "include ../Make.inc\n");
   fprintf(fp, "CDEFS2=$(CDEFS)\n\n");

   fprintf(fp, "lib : %clib.grd\n", pre);
   fprintf(fp, "all : %clib.grd\n", pre);
   fprintf(fp, "clean : %cclean\n\n", pre);

   fprintf(fp, "obj = ");
   if (pre == 'c' || pre == 's')
   {
      comp = "$(SKC)";
      flgs = "$(SKCFLAGS)";
   }
   else
   {
      comp = "$(DKC)";
      flgs = "$(DKCFLAGS)";
   }
   if (pre == 'z')
      typ = "DCPLX";
   else if (pre == 'c')
      typ = "SCPLX";
   else if (pre == 's')
      typ = "SREAL";
   else
      typ = "DREAL";

   for (k=0; k < 2; k++)  /* 0: objname, 1: target*/
   {
/*
 *    kernels
 */
      int s, di;
      for (s=i=0; s < 2; s++)
      {
         int it;
         char sd=sds[s];
         for (it=0; it < 2; it++)
         {
            ATL_mmnode_t *mp;
            char ta = tas[it];
            for (mp=MBs[i++]; mp; mp=mp->next)
            {
               for (bi=0; bi < 3; bi++)
               {
                  if (!k)
                     fprintf(fp, "\\\n      ATL_%ctrmmK_%c%c%c_b%c.o ",
                             pre, sd, up, ta, be[bi]);
                  else /* target phase */
                  {
                     fprintf(fp, "ATL_%ctrmmK_%c%c%c_b%c.o :"
                             " ATL_%ctrmmK_%c%c%c_%ux%ux%u.c $(deps)\n",
                              pre, sd, up, ta, be[bi],
                              pre, sd, up, ta, mp->mu, mp->nu, mp->ku);
                     fprintf(fp, "\t%s $(CDEFS2) -D%s=1 -DBETA%c=1 \\\n", comp,
                           typ, (be[bi]=='n')?'N':be[bi]);
                     sp = "        ";
                     if (FLAG_IS_SET(mp->flag, MMF_MVA))
                     {
                        fprintf(fp, "%s-DATL_MOVEA", sp);
                        sp = " ";
                     }
                     if (FLAG_IS_SET(mp->flag, MMF_MVB))
                     {
                        fprintf(fp, "%s-DATL_MOVEB", sp);
                        sp = " ";
                     }
                     if (FLAG_IS_SET(mp->flag, MMF_MVC))
                     {
                        fprintf(fp, "%s-DATL_MOVEC", sp);
                        sp = " ";
                     }
                     fprintf(fp, " \\\n        %s \\\n", flgs);
                     fprintf(fp,
                     "        -DATL_USERMM=ATL_%ctrmmK_%c%c%c_b%c \\\n"
                     "        -c -o ATL_%ctrmmK_%c%c%c_b%c.o \\\n",
                             pre, sd, up, ta, be[bi],
                             pre, sd, up, ta, be[bi]);
                     fprintf(fp, "        ATL_%ctrmmK_%c%c%c_%ux%ux%u.c \n",
                             pre, sd, up, ta, mp->mu, mp->nu, mp->ku);
                  }
               }
            }
         }
      }
/*
 *    copies
 *    e.g., ATL_zcpFromACt_Up_diagU_a1_1x4_0
 */
      for (di=0; di < 2; di++)
      {
         char *dia = di ? "_diagU": "";
         for (s=i=0; s < 2; s++)
         {
            int it;
            char sd=sds[s];
            for (it=0; it < 2; it++)
            {
               ATL_mmnode_t *mp;
               char ta = tas[it];
               for (mp=MBs[i++]; mp; mp=mp->next)
               {
                  UR = (sd=='L')? mp->mu : mp->nu;
                  kvec = FLAG_IS_SET(mp->flag, MMF_KVEC) ? mp->vlen:0;
                  for (ai=0; ai < 3; ai++)
                  {
                     int ul;
                     for (ul=0; ul < 2; ul++)
                     {
                        int c;
                        const int NCNJ = ((pre == 'c' || pre == 'z')) ? 2:1; 
                        for (c=0; c < NCNJ; c++)
                        {
                           if (c)
                              tta = (ta == 'N')? 'C' : 'H';
                           else
                              tta = ta;
                           if (!k)
                           {
                              fprintf(fp,
                              "\\\n      ATL_%ccpFromA%ct_%s%s_a%c_%ux%u_%u.o ",
                                 pre, tta, (ul?"Up":"Lo"), dia, al[ai], mp->ku,
                                 UR, kvec);
                           }
                           else
                           {
                              fprintf(fp, 
                                      "ATL_%ccpFromA%ct_%s%s_a%c_%ux%u_%u.o :"
                                      " ATL_%ccpFromA%ct_a%c_%ux%u_%u.c\n",
                                      pre, tta, (ul?"Up":"Lo"), dia, al[ai],
                                      mp->ku, UR, kvec,
                                      pre, ta, al[ai], mp->ku, UR, kvec);

                              fprintf(fp, "\t%s $(CDEFS2) %s", comp, flgs);
                              if (di)
                                 fprintf(fp, " -DUnitDiag_=1");
                              if (ul)
                                 fprintf(fp, " -DUpper_=1");
                              else
                                 fprintf(fp, " -DLower_=1");
                              if (c)
                                 fprintf(fp, " -DConj_=1");
                              fprintf(fp,
                              " \\\n\t-c ATL_%ccpFromA%ct_a%c_%ux%u_%u.c \\\n",
                                      pre, ta, al[ai], mp->ku, UR, kvec);
                              fprintf(fp,
                              "\t-o ATL_%ccpFromA%ct_%s%s_a%c_%ux%u_%u.o\n",
                                      pre, tta, (ul?"Up":"Lo"), dia, al[ai], 
                                      mp->ku, UR, kvec);
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      if (!k)
      {
         fprintf(fp, "\n\n%clib : %clib.grd\n", pre, pre);
         fprintf(fp, "%clib.grd : $(obj)\n", pre);
         fprintf(fp, "\t$(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(obj)\n");
         fprintf(fp, "\t$(RANLIB) $(ATLASlib)\n\ttouch %clib.grd\n\n", pre);
      }
   }
   fclose(fp);
}

void GenAllTrmm(char pre, char *outd)
{
   int L, i, s;
   char sds[2] = {'L', 'R'};
   char tas[2] = {'N', 'T'};
   char ups[2] = {'L', 'U'};
   char *od;
   char fn[16];
   ATL_mmnode_t *MBs[4];
#if 1
/*
 * Delete and the re-create <pre>UTRSM subdir
 */
   L = strlen(outd) + 8 + 7;
   od = malloc(L);
   assert(od);
   i = sprintf(od, "rm -rf %s/%cUTRMM", outd, pre);
   assert(i < L);
   Sys2File(od, NULL);
   od[0]='m'; od[1]='k'; od[2]='d'; od[3]='i'; od[4]='r'; od[5]=' ';
   assert(!Sys2File(od, NULL));
#endif
   strcpy(fn, "trmmKSU.sum");

   for (i=s=0; s < 2; s++)
   {
      char sd=sds[s];
      int it;
      for (it=0; it < 2; it++)
      {
         char ta = tas[it];
         char up = ups[it];
         ATL_mmnode_t *mb;
         fn[5] = sd;
         fn[6] = up;
         mb = ReadMMFileWithPath(pre, "res", fn);
         if (!mb)
            fprintf(stderr, "Problem with file='res/%c%s'!\n", pre, fn);
         assert(mb);
         mb->blask = ATL_KTRMM; /* forced to TRMM */
         MBs[i] = mb;
         GenMicroTrmm(pre, od+7, sd, 'L', ta, mb);
         GenCopyTrmm(pre, od+7, sd, 'L', ta, mb);
         GenTrmmHead(pre, od+7, sd, 'L', ta, mb);
         i++;
      }
   }
   GenMakeTrmm(pre, od+7, 'L', sds, tas, MBs);
   for (i=0; i < 4; i++)
      KillAllMMNodes(MBs[i]);
   free(od);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   /*fprintf(stderr,
"This will create the <pre>UTRMM subdir in <outdir>, and populate it with\n"
"all utrmm kernels and their Makefile.\n");*/
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr,"USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -o <path>: what directory to output all files to?\n");
   fprintf(stderr, "   -p [s,d]: set type/precision prefix (d) \n"
           "      s/d will generate for complex (c/z) as well\n");

   exit(ierr ? ierr : -1);
}

char *GetFlags(int nargs, char **args, char *PRE)
{
   FILE *fpin=stdin;
   ATL_mmnode_t *mb=NULL, *bkb=NULL, *mp;
   char *outd=NULL;
   int i;
   char pre='d';

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         outd = DupString(args[i]);
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (!outd)
      outd = DupString("tmp");

   *PRE = pre;
   return(outd);
}

int main(int nargs, char **args)
{
   char *outd;
   char pre;
   outd = GetFlags(nargs, args, &pre);
   GenAllTrmm(pre, outd);
   free(outd);
   return(0);
}
@ROUT !
