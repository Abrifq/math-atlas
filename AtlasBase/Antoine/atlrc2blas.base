@skip ==================================================================
@skip ATLAS / Level 2 BLAS recursive kernels                        AP00
@skip Last modification : 08/01/09 by RCW
@skip -- Removed unused her/syr/her2/syr2 kernels from build targets
@skip ==================================================================
@skip File layout:
@skip
@skip rc2_inc,
@skip ATL_sbmvL,   ATL_hbmvL,   ATL_sbmvU,   ATL_hbmvU,
@skip ATL_spmvL,   ATL_hpmvL,   ATL_spmvU,   ATL_hpmvU,
@skip ATL_symvL,   ATL_hemvL,   ATL_symvU,   ATL_hemvU,
@skip ATL_sprL,    ATL_hprL,    ATL_sprU,    ATL_hprU,
@skip ATL_syrL,    ATL_herL,    ATL_syrU,    ATL_herU,
@skip ATL_spr2L,   ATL_hpr2L,   ATL_spr2U,   ATL_hpr2U,
@skip ATL_syr2L,   ATL_her2L,   ATL_syr2U,   ATL_her2U,
@skip ATL_tbmvLN,  ATL_tbmvLC,  ATL_tbmvUN,  ATL_tbmvUC,
@skip ATL_tbmvLT,  ATL_tbmvLH,  ATL_tbmvUT,  ATL_tbmvUH,
@skip ATL_tbmvLNN, ATL_tbmvLNU, ATL_tbmvLCN, ATL_tbmvLCU,
@skip ATL_tbmvLTN, ATL_tbmvLTU, ATL_tbmvLHN, ATL_tbmvLHU,
@skip ATL_tbmvUNN, ATL_tbmvUNU, ATL_tbmvUCN, ATL_tbmvUCU,
@skip ATL_tbmvUTN, ATL_tbmvUTU, ATL_tbmvUHN, ATL_tbmvUHU,
@skip ATL_tpmvLN,  ATL_tpmvLC,  ATL_tpmvUN,  ATL_tpmvUC,
@skip ATL_tpmvLT,  ATL_tpmvLH,  ATL_tpmvUT,  ATL_tpmvUH,
@skip ATL_tpmvLNN, ATL_tpmvLNU, ATL_tpmvLCN, ATL_tpmvLCU,
@skip ATL_tpmvLTN, ATL_tpmvLTU, ATL_tpmvLHN, ATL_tpmvLHU,
@skip ATL_tpmvUNN, ATL_tpmvUNU, ATL_tpmvUCN, ATL_tpmvUCU,
@skip ATL_tpmvUTN, ATL_tpmvUTU, ATL_tpmvUHN, ATL_tpmvUHU,
@skip ATL_trmvLN,  ATL_trmvLC,  ATL_trmvUN,  ATL_trmvUC,
@skip ATL_trmvLT,  ATL_trmvLH,  ATL_trmvUT,  ATL_trmvUH,
@skip ATL_trmvLNN, ATL_trmvLNU, ATL_trmvLCN, ATL_trmvLCU,
@skip ATL_trmvLTN, ATL_trmvLTU, ATL_trmvLHN, ATL_trmvLHU,
@skip ATL_trmvUNN, ATL_trmvUNU, ATL_trmvUCN, ATL_trmvUCU,
@skip ATL_trmvUTN, ATL_trmvUTU, ATL_trmvUHN, ATL_trmvUHU,
@skip ATL_tbsvLN,  ATL_tbsvLC,  ATL_tbsvUN,  ATL_tbsvUC,
@skip ATL_tbsvLT,  ATL_tbsvLH,  ATL_tbsvUT,  ATL_tbsvUH,
@skip ATL_tbsvLNN, ATL_tbsvLNU, ATL_tbsvLCN, ATL_tbsvLCU,
@skip ATL_tbsvLTN, ATL_tbsvLTU, ATL_tbsvLHN, ATL_tbsvLHU,
@skip ATL_tbsvUNN, ATL_tbsvUNU, ATL_tbsvUCN, ATL_tbsvUCU,
@skip ATL_tbsvUTN, ATL_tbsvUTU, ATL_tbsvUHN, ATL_tbsvUHU,
@skip ATL_tpsvLN,  ATL_tpsvLC,  ATL_tpsvUN,  ATL_tpsvUC,
@skip ATL_tpsvLT,  ATL_tpsvLH,  ATL_tpsvUT,  ATL_tpsvUH,
@skip ATL_tpsvLNN, ATL_tpsvLNU, ATL_tpsvLCN, ATL_tpsvLCU,
@skip ATL_tpsvLTN, ATL_tpsvLTU, ATL_tpsvLHN, ATL_tpsvLHU,
@skip ATL_tpsvUNN, ATL_tpsvUNU, ATL_tpsvUCN, ATL_tpsvUCU,
@skip ATL_tpsvUTN, ATL_tpsvUTU, ATL_tpsvUHN, ATL_tpsvUHU,
@skip ATL_trsvLN,  ATL_trsvLC,  ATL_trsvUN,  ATL_trsvUC,
@skip ATL_trsvLT,  ATL_trsvLH,  ATL_trsvUT,  ATL_trsvUH,
@skip ATL_trsvLNN, ATL_trsvLNU, ATL_trsvLCN, ATL_trsvLCU,
@skip ATL_trsvLTN, ATL_trsvLTU, ATL_trsvLHN, ATL_trsvLHU,
@skip ATL_trsvUNN, ATL_trsvUNU, ATL_trsvUCN, ATL_trsvUCU,
@skip ATL_trsvUTN, ATL_trsvUTU, ATL_trsvUHN, ATL_trsvUHU,
@skip atlas_kernel2.h,          Make.l2aux.
@skip ==================================================================
@skip Global define statements
@skip
@extract -addkeys -b @(BASEdir)include/atlas.inc lan=C type=none
@skip ==================================================================
@skip Specific define statements
@skip
@define RC2_INCLUDE @-addkeys -b @(srcdir)/atlrc2blas.base rout=rc2_inc@
@skip ==================================================================
@skip
@rout rc2_inc
@extract @(INCLUDE)
#include "atlas_misc.h"
#include "atlas_mv.h"
#include "atlas_r1.h"
#include "atlas_level1.h"
#include "atlas_kernel2.h"
#include "atlas_reflvl2.h"
#include "atlas_lvl2.h"
@skip
@skip ==================================================================
@skip
@rout ATL_sbmvL
@define sh @sb@
@rout ATL_hbmvL
@define sh @hb@
@rout ATL_sbmvL ATL_hbmvL
@define rname @Mjoin( PATL, @(sh)mvL )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const int                  N,
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const SCALAR               BETA,
   TYPE                       * Y
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*gbmvT)( const int, const int, const int,
                              const int, const SCALAR, const TYPE *, const int,
                              const TYPE *, const int, const SCALAR, TYPE *,
                              const int );
   void                       (*gbmvN)( const int, const int, const int, 
                              const int, const SCALAR, const TYPE *, const int,
                              const TYPE *, const int, const SCALAR, TYPE *,
                              const int );
#ifdef TREAL
#define    one                ATL_rone
#define    lda2               LDA
   TYPE                       beta0;
#else
   const TYPE                 * beta0, one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2 = (LDA << 1);
#endif
   int                        j, ja, jan, jb, kl, ku, m, ma, mb, na, nb;
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartSBMV( A, LDA, &mb, &nb );
 
   beta0 = BETA;
@rout ATL_sbmvL
   gbmvT = Mjoin( PATL, gbmvT_a1_x1_b1_y1 );
@rout ATL_hbmvL
   gbmvT = Mjoin( PATL, gbmvC_a1_x1_b1_y1 );
@rout ATL_sbmvL ATL_hbmvL
   if(      SCALAR_IS_ZERO( beta0 ) ) gbmvN = Mjoin( PATL, gbmvN_a1_x1_b0_y1 );
   else if( SCALAR_IS_ONE ( beta0 ) ) gbmvN = Mjoin( PATL, gbmvN_a1_x1_b1_y1 );
   else                               gbmvN = Mjoin( PATL, gbmvN_a1_x1_bX_y1 );
 
   for( j = 0; j < N; j += nb )
   {
      jb = N - j; jb = Mmin( jb, nb );

      Mjoin( PATL, ref@(sh)mvL )( jb, K, one, A+j*lda2, LDA, X+(j SHIFT), 1,
                               beta0, Y+(j SHIFT), 1 );
      if( ( m = ( N - ( jan = j + jb ) ) ) != 0 )
      {
         ja = jb - K; ja = j + Mmax( ja, 0 ); ma = Mmin( m, K );
         ku = na = jan - ja; kl = K - ku; kl = Mmax( kl, 0 );
         gbmvT( na, ma, kl, ku, one, A+ja*lda2, LDA, X+(jan SHIFT), 1, one,
                Y+(ja  SHIFT), 1 );
         gbmvN( ma, na, kl, ku, one, A+ja*lda2, LDA, X+(ja  SHIFT), 1, beta0,
                Y+(jan SHIFT), 1 );
         if( ( m > ma ) && !( SCALAR_IS_ONE( beta0 ) ) )
            Mjoin( PATL, scal )( m - ma, beta0, Y+((jan+ma) SHIFT), 1 );
         beta0 = one; gbmvN = Mjoin( PATL, gbmvN_a1_x1_b1_y1 );
      }
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_sbmvU
@define sh @sb@
@rout ATL_hbmvU
@define sh @hb@
@rout ATL_sbmvU ATL_hbmvU
@define rname @Mjoin( PATL, @(sh)mvU )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const int                  N,
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const SCALAR               BETA,
   TYPE                       * Y
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*gbmvT)( const int, const int, const int,
                              const int, const SCALAR, const TYPE *, const int,
                              const TYPE *, const int, const SCALAR, TYPE *,
                              const int );
   void                       (*gbmvN)( const int, const int, const int,
                              const int, const SCALAR, const TYPE *, const int,
                              const TYPE *, const int, const SCALAR, TYPE *,
                              const int );
#ifdef TREAL
#define    one                ATL_rone
#define    lda2               LDA
   TYPE                       beta0;
#else
   const TYPE                 * beta0, one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2 = (LDA << 1);
#endif
   int                        ia, ian, jb, kl, ku, ma, mb, na, nb;
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartSBMV( A, LDA, &mb, &nb );

   beta0 = BETA;

   if(      SCALAR_IS_ZERO( beta0 ) )
   {
      gbmvN = Mjoin( PATL, gbmvN_a1_x1_b0_y1 );
@rout ATL_sbmvU
      gbmvT = Mjoin( PATL, gbmvT_a1_x1_b0_y1 );
@rout ATL_hbmvU
      gbmvT = Mjoin( PATL, gbmvC_a1_x1_b0_y1 );
@rout ATL_sbmvU ATL_hbmvU
   }
   else if( SCALAR_IS_ONE ( beta0 ) )
   {
      gbmvN = Mjoin( PATL, gbmvN_a1_x1_b1_y1 );
@rout ATL_sbmvU
      gbmvT = Mjoin( PATL, gbmvT_a1_x1_b1_y1 );
@rout ATL_hbmvU
      gbmvT = Mjoin( PATL, gbmvC_a1_x1_b1_y1 );
@rout ATL_sbmvU ATL_hbmvU
   } 
   else
   {
      gbmvN = Mjoin( PATL, gbmvN_a1_x1_bX_y1 );
@rout ATL_sbmvU
      gbmvT = Mjoin( PATL, gbmvT_a1_x1_bX_y1 );
@rout ATL_hbmvU
      gbmvT = Mjoin( PATL, gbmvC_a1_x1_bX_y1 );
@rout ATL_sbmvU ATL_hbmvU
   }

   for( ian = ( ( N - 1 ) / nb ) * nb; ian >= 0; ian -= nb )
   {
      jb = N - ian; jb = Mmin( jb, nb );

      if( ian != 0 )
      {
         ia = ian - K; ia = Mmax( ia, 0 ); ma = ian - ia; na = Mmin( jb, K );
         kl = ma  - 1; kl = Mmax( kl, 0 ); ku = K - 1 - kl; ku = Mmax( ku, 0 );
         gbmvT( na, ma, kl, ku, one, A+ian*lda2, LDA, X+(ia  SHIFT), 1, beta0,
                Y+(ian SHIFT), 1 );
         gbmvN( ma, na, kl, ku, one, A+ian*lda2, LDA, X+(ian SHIFT), 1, beta0,
                Y+(ia  SHIFT), 1 );
         if( !( SCALAR_IS_ONE( beta0 ) ) )
         {
            if( jb > na )
               Mjoin( PATL, scal )( jb-na, beta0, Y+((ian+na) SHIFT), 1 );
            if( ia > 0  ) Mjoin( PATL, scal )( ia, beta0, Y, 1 );
         }
         beta0 = one;
      }
      Mjoin( PATL, ref@(sh)mvU )( jb, K, one, A+ian*lda2, LDA, X+(ian SHIFT), 1,
                               beta0, Y+(ian SHIFT), 1 );
      gbmvN = Mjoin( PATL, gbmvN_a1_x1_b1_y1 );
@rout ATL_sbmvU
      gbmvT = Mjoin( PATL, gbmvT_a1_x1_b1_y1 );
@rout ATL_hbmvU
      gbmvT = Mjoin( PATL, gbmvC_a1_x1_b1_y1 );
@rout ATL_sbmvU ATL_hbmvU
      beta0 = one;
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_spmvL
@define sh @sp@
@rout ATL_hpmvL
@define sh @hp@
@rout ATL_spmvL ATL_hpmvL
@define rname @Mjoin( PATL, @(sh)mvL )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const SCALAR               BETA,
   TYPE                       * Y
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*gpmvT)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
   void                       (*gpmvN)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
#ifdef TREAL
#define    one                ATL_rone
   TYPE                       beta0;
#else
   const TYPE                 * beta0, one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * A0, * x0, * y0;
   int                        j, jb, jbs, lda = LDA, m, mb, nb;
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartSPMV( A, LDA, &mb, &nb );
 
   beta0 = BETA; x0 = (TYPE *)(X); y0 = (TYPE *)(Y);
@rout ATL_spmvL
   gpmvT = Mjoin( PATL, gpmvLT_a1_x1_b1_y1 );
@rout ATL_hpmvL
   gpmvT = Mjoin( PATL, gpmvLC_a1_x1_b1_y1 );
@rout ATL_spmvL ATL_hpmvL
   if(      SCALAR_IS_ZERO( beta0 ) ) gpmvN = Mjoin( PATL, gpmvLN_a1_x1_b0_y1 );
   else if( SCALAR_IS_ONE ( beta0 ) ) gpmvN = Mjoin( PATL, gpmvLN_a1_x1_b1_y1 );
   else                               gpmvN = Mjoin( PATL, gpmvLN_a1_x1_bX_y1 );
 
   for( j = 0; j < N; j += nb )
   {
      jb = N - j; jb = Mmin( jb, nb );
      Mjoin( PATL, ref@(sh)mvL )( jb, one, A, lda, X, 1, beta0, Y, 1 );
 
      if( ( m = N-j-jb ) != 0 )
      {
         jbs = (jb SHIFT); A0 = (TYPE *)(A) + jbs; X += jbs; Y += jbs;
         gpmvT( jb, m, one, A0, lda, X,  1, one,   y0, 1 );
         gpmvN( m, jb, one, A0, lda, x0, 1, beta0, Y,  1 );
         beta0 = one; gpmvN = Mjoin( PATL, gpmvLN_a1_x1_b1_y1 );
         MLpnext( jb, A, lda ); x0 = (TYPE *)(X); y0 = (TYPE *)(Y);
      }
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_spmvU
@define sh @sp@
@rout ATL_hpmvU
@define sh @hp@
@rout ATL_spmvU ATL_hpmvU
@define rname @Mjoin( PATL, @(sh)mvU )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const SCALAR               BETA,
   TYPE                       * Y
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*gpmvT)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
   void                       (*gpmvN)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
#ifdef TREAL
#define    one                ATL_rone
   TYPE                       beta0;
#else
   const TYPE                 * beta0, one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * A0, * x0, * y0;
   int                        j, jb, jbs, lda = LDA, m, mb, nb;
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartSPMV( A, N, &mb, &nb );
 
   beta0 = BETA;
   if(      SCALAR_IS_ZERO( beta0 ) )
   {
      gpmvN = Mjoin( PATL, gpmvUN_a1_x1_b0_y1 );
@rout ATL_spmvU
      gpmvT = Mjoin( PATL, gpmvUT_a1_x1_b0_y1 );
@rout ATL_hpmvU
      gpmvT = Mjoin( PATL, gpmvUC_a1_x1_b0_y1 );
@rout ATL_spmvU ATL_hpmvU
   }
   else if( SCALAR_IS_ONE ( beta0 ) )
   {
      gpmvN = Mjoin( PATL, gpmvUN_a1_x1_b1_y1 );
@rout ATL_spmvU
      gpmvT = Mjoin( PATL, gpmvUT_a1_x1_b1_y1 );
@rout ATL_hpmvU
      gpmvT = Mjoin( PATL, gpmvUC_a1_x1_b1_y1 );
@rout ATL_spmvU ATL_hpmvU
   }
   else
   {
      gpmvN = Mjoin( PATL, gpmvUN_a1_x1_bX_y1 );
@rout ATL_spmvU
      gpmvT = Mjoin( PATL, gpmvUT_a1_x1_bX_y1 );
@rout ATL_hpmvU
      gpmvT = Mjoin( PATL, gpmvUC_a1_x1_bX_y1 );
@rout ATL_spmvU ATL_hpmvU
   } 

   MUpnext( N, A, lda ); 
   x0 = (TYPE *)(X); X += (N SHIFT); y0 = (TYPE *)(Y); Y += (N SHIFT);
 
   for( j = 0; j < N; j += nb )
   {
      jb = N - j; jb = Mmin( jb, nb ); jbs = (jb SHIFT);
      MUpprev( jb, A, lda ); X -= jbs; Y -= jbs;
 
      if( ( m = N-j-jb ) != 0 )
      {
         A0 = (TYPE *)(A) - (m SHIFT);
         gpmvT( jb, m, one, A0, lda, x0, 1, beta0, Y,  1 );
         gpmvN( m, jb, one, A0, lda, X,  1, beta0, y0, 1 ); beta0 = one;
      }
      Mjoin( PATL, ref@(sh)mvU )( jb, one, A, lda, X, 1, beta0, Y, 1 );
      gpmvN = Mjoin( PATL, gpmvUN_a1_x1_b1_y1 ); beta0 = one;
@rout ATL_spmvU
      gpmvT = Mjoin( PATL, gpmvUT_a1_x1_b1_y1 );
@rout ATL_hpmvU
      gpmvT = Mjoin( PATL, gpmvUC_a1_x1_b1_y1 );
@rout ATL_spmvU ATL_hpmvU
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_symvL
@define sh @sy@
@rout ATL_hemvL
@define sh @he@
@rout ATL_symvL ATL_hemvL
@define rname @Mjoin( PATL, @(sh)mvL )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const SCALAR               BETA,
   TYPE                       * Y
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*gemvT)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
   void                       (*gemvN)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
#ifdef TREAL
#define    one                ATL_rone
   TYPE                       beta0;  
#else
   const TYPE                 * beta0, one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * A0, * x0, * y0;
   int                        j, jb, jbs, m, mb, nb;
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartSYMV( A, LDA, &mb, &nb );

   beta0 = BETA; x0 = (TYPE *)(X); y0 = (TYPE *)(Y);
@rout ATL_symvL
   gemvT = Mjoin( PATL, gemvT_a1_x1_b1_y1 );
@rout ATL_hemvL
   gemvT = Mjoin( PATL, gemvC_a1_x1_b1_y1 );
@rout ATL_symvL ATL_hemvL
   if(      SCALAR_IS_ZERO( beta0 ) ) gemvN = Mjoin( PATL, gemvS_a1_x1_b0_y1 );
   else if( SCALAR_IS_ONE ( beta0 ) ) gemvN = Mjoin( PATL, gemvS_a1_x1_b1_y1 );
   else                               gemvN = Mjoin( PATL, gemvS_a1_x1_bX_y1 );

   for( j = 0; j < N; j += nb )
   {
      jb = N - j; jb = Mmin( jb, nb );
      Mjoin( PATL, ref@(sh)mvL )( jb, one, A, LDA, X, 1, beta0, Y, 1 );
      if( ( m = N-j-jb ) != 0 )
      {
         jbs = (jb SHIFT); A0 = (TYPE *)(A) + jbs; X += jbs; Y += jbs;
         gemvT( jb, m, one, A0, LDA, X,  1, one,   y0, 1 );
         gemvN( m, jb, one, A0, LDA, x0, 1, beta0, Y,  1 );
         beta0 = one; gemvN = Mjoin( PATL, gemvS_a1_x1_b1_y1 );
         MLrnext( jb, A, LDA ); x0 = (TYPE *)(X); y0 = (TYPE *)(Y);
      }
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_symvU
@define sh @sy@
@rout ATL_hemvU
@define sh @he@
@rout ATL_symvU ATL_hemvU
@define rname @Mjoin( PATL, @(sh)mvU )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   const TYPE                 * X,
   const SCALAR               BETA,
   TYPE                       * Y
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*gemvT)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
   void                       (*gemvN)( const int, const int, const SCALAR,
                              const TYPE *, const int, const TYPE *, const int,
                              const SCALAR, TYPE *, const int );
#ifdef TREAL
#define    one                ATL_rone
   TYPE                       beta0;
#else
   const TYPE                 * beta0, one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * A0, * x0, * y0;
   int                        j, jb, jbs, m, mb, nb;
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartSYMV( A, LDA, &mb, &nb );
 
   beta0 = BETA;
   if(      SCALAR_IS_ZERO( beta0 ) )
   {
      gemvN = Mjoin( PATL, gemvS_a1_x1_b0_y1 );
@rout ATL_symvU
      gemvT = Mjoin( PATL, gemvT_a1_x1_b0_y1 );
@rout ATL_hemvU
      gemvT = Mjoin( PATL, gemvC_a1_x1_b0_y1 );
@rout ATL_symvU ATL_hemvU
   }
   else if( SCALAR_IS_ONE ( beta0 ) )
   {
      gemvN = Mjoin( PATL, gemvS_a1_x1_b1_y1 );
@rout ATL_symvU
      gemvT = Mjoin( PATL, gemvT_a1_x1_b1_y1 );
@rout ATL_hemvU
      gemvT = Mjoin( PATL, gemvC_a1_x1_b1_y1 );
@rout ATL_symvU ATL_hemvU
   }
   else
   {
      gemvN = Mjoin( PATL, gemvS_a1_x1_bX_y1 );
@rout ATL_symvU
      gemvT = Mjoin( PATL, gemvT_a1_x1_bX_y1 );
@rout ATL_hemvU
      gemvT = Mjoin( PATL, gemvC_a1_x1_bX_y1 );
@rout ATL_symvU ATL_hemvU
   }

   MUrnext( N, A, LDA );
   x0 = (TYPE *)(X); X += (N SHIFT); y0 = (TYPE *)(Y); Y += (N SHIFT);

   for( j = 0; j < N; j += nb )
   {
      jb = N - j; jb = Mmin( jb, nb ); jbs = (jb SHIFT);
      MUrprev( jb, A, LDA ); X -= jbs; Y -= jbs;
      if( ( m = N-j-jb ) != 0 )
      {
         A0 = (TYPE *)(A) - (m SHIFT);
         gemvT( jb, m, one, A0, LDA, x0, 1, beta0, Y,  1 );
         gemvN( m, jb, one, A0, LDA, X,  1, beta0, y0, 1 ); beta0 = one;
      }
      Mjoin( PATL, ref@(sh)mvU )( jb, one, A, LDA, X, 1, beta0, Y, 1 );
      gemvN = Mjoin( PATL, gemvS_a1_x1_b1_y1 );
@rout ATL_symvU
      gemvT = Mjoin( PATL, gemvT_a1_x1_b1_y1 );
@rout ATL_hemvU
      gemvT = Mjoin( PATL, gemvC_a1_x1_b1_y1 );
@rout ATL_symvU ATL_hemvU
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_sprL
@define sh @sp@
@rout ATL_hprL
@define sh @hp@
@rout ATL_sprL ATL_hprL
@define rname @Mjoin( PATL, @(sh)rL )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
#ifdef TREAL
#define    MinN_@(sh)rL    16
#else
#define    MinN_@(sh)rL     8
#endif
 
@rout ATL_hprL
/*
 * Workaround for icc bug on IA64Itan2
 */
#ifdef ATL_IntelIccBugs
#pragma optimize("", off);
#endif
@rout ATL_sprL ATL_hprL
void @(rname)
(
   const int                  N,
   const TYPE                 * X,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
   register TYPE              t0;
   int                        i, iaij, j, jaj, jy, lda = LDA, n1, n1s, n2;
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   register TYPE              t0_i, t0_r;
   const int                  incy2 = 2 * INCY;
   int                        i, iaij, ix, j, jaj, jy, lda = LDA,
                              lda2 = (LDA << 1), n1, n1s, n2;
#endif
@rout ATL_sprL
#ifdef TREAL
#define   gpr      Mjoin( PATL, gpr1L_a1_x1_yX  )
#else
#define   gpr      Mjoin( PATL, gpr1uL_a1_x1_yX )
#endif
@rout ATL_hprL
#define   gpr      Mjoin( PATL, gpr1cL_a1_x1_yX )
@rout ATL_sprL ATL_hprL
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_@(sh)rL )
   {
@rout ATL_sprL
#ifdef TREAL
      for( j = 0, jaj = 0, jy = 0; j < N; j++, jy += INCY )
      {
         t0 = Y[jy];
         for( i = j, iaij = jaj; i < N; i++, iaij++ ) { A[iaij] += X[i] * t0; }
         jaj += lda; lda -= 1;
      }
#else
      for( j = 0, jaj = 0, jy = 0; j < N; j++, jy += incy2, X += 2 )
      {
         t0_r = Y[jy]; t0_i = Y[jy+1];
         for( i = j, iaij = jaj, ix = 0; i < N; i++, iaij += 2, ix += 2 )
         {
            A[iaij  ] += X[ix] * t0_r - X[ix+1] * t0_i;
            A[iaij+1] += X[ix] * t0_i + X[ix+1] * t0_r;
         }
         jaj += lda2; lda2 -= 2;
      }
#endif
@rout ATL_hprL
      for( j = 0, jaj = 0, jy = 0; j < N; j++, jy += incy2, X += 2 )
      {
         t0_r    = Y[jy]; t0_i = -Y[jy+1];
         A[jaj] += (*X) * t0_r - X[1] * t0_i; A[jaj+1]  = ATL_rzero;
 
         for( i = j+1, iaij = jaj+2, ix = 2; i < N; i++, iaij += 2, ix += 2 )
         {
            A[iaij  ] += X[ix] * t0_r - X[ix+1] * t0_i;
            A[iaij+1] += X[ix] * t0_i + X[ix+1] * t0_r;
         }
         jaj += lda2; lda2 -= 2;
      }
@rout ATL_sprL ATL_hprL
   }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, @(sh)rL )( n1, X, Y, INCY, A, lda ); X += n1s;
      gpr(  n2, n1, one, X, 1, Y, INCY, A + n1s, lda ); Y += n1s * INCY;
      MLpnext( n1, A, lda ); Mjoin( PATL, @(sh)rL )( n2, X, Y, INCY, A, lda );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_sprU
@define sh @sp@
@rout ATL_hprU
@define sh @hp@
@rout ATL_sprU ATL_hprU
@define rname @Mjoin( PATL, @(sh)rU )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
#ifdef TREAL
#define    MinN_@(sh)rU    16
#else
#define    MinN_@(sh)rU     8
#endif
 
@rout ATL_hprU
/*
 * Workaround for icc bug on IA64Itan2
 */
#ifdef ATL_IntelIccBugs
#pragma optimize("", off);
#endif
@rout ATL_sprU ATL_hprU
void @(rname)
(
   const int                  N,
   const TYPE                 * X,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
   register TYPE              t0;
   int                        i, iaij, j, jaj, jy, lda = LDA, n1, n1s, n2;
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   register TYPE              t0_i, t0_r;
   const int                  incy2 = 2 * INCY;
   int                        i, iaij, ix, j, jaj, jy, lda = LDA,
                              lda2 = (LDA SHIFT), n1, n1s, n2;
#endif
@rout ATL_sprU
#ifdef TREAL
#define   gpr      Mjoin( PATL, gpr1U_a1_x1_yX  )
#else
#define   gpr      Mjoin( PATL, gpr1uU_a1_x1_yX )
#endif
@rout ATL_hprU
#define   gpr      Mjoin( PATL, gpr1cU_a1_x1_yX )
@rout ATL_sprU ATL_hprU
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_@(sh)rU )
   {
@rout ATL_sprU
#ifdef TREAL
      for( j = 0, jaj = 0, jy = 0; j < N; j++, jy += INCY )
      {
         t0 = Y[jy];
         for( i = 0, iaij = jaj; i <= j; i++, iaij++ ) { A[iaij] += X[i] * t0; }
         jaj += lda; lda += 1;
      }
#else
      for( j = 0, jaj = 0, jy = 0; j < N; j++, jy += incy2 )
      {
         t0_r = Y[jy]; t0_i = Y[jy+1];
         for( i = 0, iaij = jaj, ix = 0; i <= j; i++, iaij += 2, ix += 2 )
         {
            A[iaij  ] += X[ix] * t0_r - X[ix+1] * t0_i;
            A[iaij+1] += X[ix] * t0_i + X[ix+1] * t0_r;
         }
         jaj += lda2; lda2 += 2;
      }
#endif
@rout ATL_hprU
      for( j = 0, jaj = 0, jy = 0; j < N; j++, jy += incy2 )
      {
         t0_r = Y[jy]; t0_i = -Y[jy+1];
         for( i = 0, iaij = jaj, ix = 0; i < j; i++, iaij += 2, ix += 2 )
         {
            A[iaij  ] += X[ix] * t0_r - X[ix+1] * t0_i;
            A[iaij+1] += X[ix] * t0_i + X[ix+1] * t0_r;
         }
         A[iaij  ] += X[ix] * t0_r - X[ix+1] * t0_i;
         A[iaij+1]  = ATL_rzero;
         jaj += lda2; lda2 += 2;
      }
@rout ATL_sprU ATL_hprU
   }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, @(sh)rU )( n1, X, Y, INCY, A, lda );
      MUpnext( n1, A, lda ); Y += n1s * INCY;
      gpr( n1, n2, one, X, 1, Y, INCY, A - n1s, lda ); X += n1s;
      Mjoin( PATL, @(sh)rU )( n2, X, Y, INCY, A, lda );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_syrL
@define sh @sy@
@rout ATL_herL
@define sh @he@
@rout ATL_syrL ATL_herL
@define rname @Mjoin( PATL, @(sh)rL )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_@(sh)rL    16
#else
#define    MinN_@(sh)rL     8
#endif
 
@rout ATL_herL
/*
 * Workaround for icc bug on IA64Itan2
 */
#ifdef ATL_IntelIccBugs
#pragma optimize("", off);
#endif
@rout ATL_syrL ATL_herL
void @(rname)
(
   const int                  N,
   const TYPE                 * X,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
   register TYPE              t0;
   int                        i, j, jy, n1, n1s, n2;
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   register TYPE              t0_i, t0_r;
   const int                  incy2 = 2 * INCY, ldap12 = ( (LDA + 1) SHIFT);
   int                        i, iax, j, jy, n1, n1s, n2;
#endif
@rout ATL_syrL
#ifdef TREAL
#define   ger      Mjoin( PATL, ger1_a1_x1_yX  )
#else
#define   ger      Mjoin( PATL, ger1u_a1_x1_yX )
#endif
@rout ATL_herL
#define   ger      Mjoin( PATL, ger1c_a1_x1_yX )
@rout ATL_syrL ATL_herL
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_@(sh)rL )
   {
@rout ATL_syrL
#ifdef TREAL
      for( j = 0, jy = 0; j < N; j++, jy += INCY, A += LDA )
      { t0 = Y[jy]; for( i = j; i < N; i++ ) { A[i] += X[i] * t0; } }
#else
      for( j = 0, jy = 0; j < N; j++, jy += incy2, A += ldap12, X += 2 )
      {
         t0_r = Y[jy]; t0_i = Y[jy+1];
         for( i = j, iax = 0; i < N; i++, iax += 2 )
         {
            A[iax  ] += X[iax] * t0_r - X[iax+1] * t0_i;
            A[iax+1] += X[iax] * t0_i + X[iax+1] * t0_r;
         }
      }
#endif
@rout ATL_herL
      for( j = 0, jy = 0; j < N; j++, jy += incy2, A += ldap12, X += 2 )
      {
         t0_r  = Y[jy]; t0_i = -Y[jy+1];
         (*A) += (*X) * t0_r - X[1] * t0_i;
         A[1]  = ATL_rzero;
         for( i = j+1, iax = 2; i < N; i++, iax += 2 )
         {
            A[iax  ] += X[iax] * t0_r - X[iax+1] * t0_i;
            A[iax+1] += X[iax] * t0_i + X[iax+1] * t0_r;
         }
      }
@rout ATL_syrL ATL_herL
   }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, @(sh)rL )( n1, X, Y, INCY, A, LDA ); X += n1s;
      ger( n2, n1, one, X, 1, Y, INCY, A + n1s, LDA );  Y += n1s * INCY;
      MLrnext( n1, A, LDA ); Mjoin( PATL, @(sh)rL )( n2, X, Y, INCY, A, LDA );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_syrU
@define sh @sy@
@rout ATL_herU
@define sh @he@
@rout ATL_syrU ATL_herU
@define rname @Mjoin( PATL, @(sh)rU )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
#ifdef TREAL
#define    MinN_@(sh)rU    16
#else
#define    MinN_@(sh)rU     8
#endif
 
@rout ATL_herU
/*
 * Workaround for icc bug on IA64Itan2
 */
#ifdef ATL_IntelIccBugs
#pragma optimize("", off);
#endif
@rout ATL_syrU ATL_herU
void @(rname)
(
   const int                  N,
   const TYPE                 * X,
   const TYPE                 * Y,
   const int                  INCY,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
   register TYPE              t0;
   int                        i, j, jy, n1, n1s, n2;
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   register TYPE              t0_i, t0_r;
   const int                  incy2 = 2 * INCY, lda2 = (LDA SHIFT);
   int                        i, iax, j, jy, n1, n1s, n2;
#endif
@rout ATL_syrU
#ifdef TREAL
#define   ger      Mjoin( PATL, ger1_a1_x1_yX  )
#else
#define   ger      Mjoin( PATL, ger1u_a1_x1_yX )
#endif
@rout ATL_herU
#define   ger      Mjoin( PATL, ger1c_a1_x1_yX )
@rout ATL_syrU ATL_herU
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_@(sh)rU )
   {
@rout ATL_syrU
#ifdef TREAL
      for( j = 0, jy = 0; j < N; j++, jy += INCY, A += LDA )
      { t0 = Y[jy]; for( i = 0; i <= j; i++ ) { A[i] += X[i] * t0; } }
#else
      for( j = 0, jy = 0; j < N; j++, jy += incy2, A += lda2 )
      {
         t0_r = Y[jy]; t0_i = Y[jy+1];
         for( i = 0, iax = 0; i <= j; i++, iax += 2 )
         {
            A[iax  ] += X[iax] * t0_r - X[iax+1] * t0_i;
            A[iax+1] += X[iax] * t0_i + X[iax+1] * t0_r;
         }
      }
#endif 
@rout ATL_herU
      for( j = 0, jy = 0; j < N; j++, jy += incy2, A += lda2 )
      {
         t0_r = Y[jy]; t0_i = -Y[jy+1];
         for( i = 0, iax = 0; i < j; i++, iax += 2 )
         {
            A[iax  ] += X[iax] * t0_r - X[iax+1] * t0_i;
            A[iax+1] += X[iax] * t0_i + X[iax+1] * t0_r;
         }
         A[iax  ] += X[iax] * t0_r - X[iax+1] * t0_i;
         A[iax+1]  = ATL_rzero;
      }
@rout ATL_syrU ATL_herU
   }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, @(sh)rU )( n1, X, Y, INCY, A, LDA );
      MUrnext( n1, A, LDA ); Y += n1s * INCY;
      ger( n1, n2, one, X, 1, Y, INCY, A - n1s, LDA ); X += n1s;
      Mjoin( PATL, @(sh)rU )( n2, X, Y, INCY, A, LDA );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_spr2L
@define sh @sp@
@rout ATL_hpr2L
@define sh @hp@
@rout ATL_spr2L ATL_hpr2L
@define rname @Mjoin( PATL, @(sh)r2L )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const int                  N,
   const TYPE                 * X,
   const TYPE                 * Y,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * A0, * x0, * y0;
   int                        j, jb, jbs, lda = LDA, m, mb, nb;
@rout ATL_spr2L
#ifdef TREAL
#define   gpr      Mjoin( PATL, gpr1L_a1_x1_yX  )
#else
#define   gpr      Mjoin( PATL, gpr1uL_a1_x1_yX )
#endif
@rout ATL_hpr2L
#define   gpr      Mjoin( PATL, gpr1cL_a1_x1_yX )
@rout ATL_spr2L ATL_hpr2L
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartP1( A, LDA, mb, nb );
   if (!mb) mb = N;
   if (!nb) nb = N;
 
   x0 = (TYPE *)(X); y0 = (TYPE *)(Y);
 
   for( j = 0; j < N; j += nb )
   {
      jb = N - j; jb = Mmin( jb, nb );
      Mjoin( PATL, ref@(sh)r2L )( jb, one, X, 1, Y, 1, A, lda );
      if( ( m = N-j-jb ) != 0 )
      {
         jbs = (jb SHIFT); A0 = (TYPE *)(A) + jbs; X += jbs; Y += jbs;
         gpr( m, jb, one, X, 1, y0, 1, A0, lda );
         gpr( m, jb, one, Y, 1, x0, 1, A0, lda );
         MLpnext( jb, A, lda ); x0 = (TYPE *)(X); y0 = (TYPE *)(Y);
      }
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_spr2U
@define sh @sp@
@rout ATL_hpr2U
@define sh @hp@
@rout ATL_spr2U ATL_hpr2U
@define rname @Mjoin( PATL, @(sh)r2U )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const int                  N,
   const TYPE                 * X,
   const TYPE                 * Y,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * A0, * x0, * y0;
   int                        j, jb, jbs, lda = LDA, m, mb, nb;
@rout ATL_spr2U
#ifdef TREAL
#define   gpr      Mjoin( PATL, gpr1U_a1_x1_yX  )
#else
#define   gpr      Mjoin( PATL, gpr1uU_a1_x1_yX )
#endif
@rout ATL_hpr2U
#define   gpr      Mjoin( PATL, gpr1cU_a1_x1_yX )
@rout ATL_spr2U ATL_hpr2U
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartP1( A, N, mb, nb );
   if (!mb) mb = N;
   if (!nb) nb = N;
 
   MUpnext( N, A, lda );
   x0 = (TYPE *)(X); X += (N SHIFT); y0 = (TYPE *)(Y); Y += (N SHIFT);
 
   for( j = 0; j < N; j += nb )
   {
      jb = N - j; jb = Mmin( jb, nb ); jbs = (jb SHIFT);
      MUpprev( jb, A, lda ); X -= jbs; Y -= jbs;
 
      if( ( m = N-j-jb ) != 0 )
      {
         A0 = (TYPE *)(A) - (m SHIFT);
         gpr( m, jb, one, x0, 1, Y, 1, A0, lda );
         gpr( m, jb, one, y0, 1, X, 1, A0, lda );
      }
      Mjoin( PATL, ref@(sh)r2U )( jb, one, X, 1, Y, 1, A, lda );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_syr2L
@define sh @sy@
@rout ATL_her2L
@define sh @he@
@rout ATL_syr2L ATL_her2L
@define rname @Mjoin( PATL, @(sh)r2L )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

void @(rname)
(
   const int                  N,
   const TYPE                 * X,
   const TYPE                 * Y,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * x0, * y0;
   int                        j, jb, jbs, m, mb, nb;
@rout ATL_syr2L
#ifdef TREAL
#define   ger      Mjoin( PATL, ger1_a1_x1_yX  )
#else
#define   ger      Mjoin( PATL, ger1u_a1_x1_yX )
#endif
@rout ATL_her2L
#define   ger      Mjoin( PATL, ger1c_a1_x1_yX )
@rout ATL_syr2L ATL_her2L
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartR1( A, LDA, mb, nb );

   x0 = (TYPE *)(X); y0 = (TYPE *)(Y);
 
   for( j = 0; j < N; j += nb )
   {
      jb = N - j; jb = Mmin( jb, nb );
      Mjoin( PATL, ref@(sh)r2L )( jb, one, X, 1, Y, 1, A, LDA );
      if( ( m = N-j-jb ) != 0 )
      {
         jbs = (jb SHIFT); X += jbs; Y += jbs;
         ger( m, jb, one, X, 1, y0, 1, A + jbs, LDA );
         ger( m, jb, one, Y, 1, x0, 1, A + jbs, LDA );
         MLrnext( jb, A, LDA ); x0 = (TYPE *)(X); y0 = (TYPE *)(Y);
      }
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_syr2U
@define sh @sy@
@rout ATL_her2U
@define sh @he@
@rout ATL_syr2U ATL_her2U
@define rname @Mjoin( PATL, @(sh)r2U )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

void @(rname)
(
   const int                  N,
   const TYPE                 * X,
   const TYPE                 * Y,
   TYPE                       * A,
   const int                  LDA
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * A0, * x0, * y0;
   int                        j, jb, jbs, m, mb, nb;
@rout ATL_syr2U
#ifdef TREAL
#define   ger      Mjoin( PATL, ger1_a1_x1_yX  )
#else
#define   ger      Mjoin( PATL, ger1u_a1_x1_yX )
#endif
@rout ATL_her2U
#define   ger      Mjoin( PATL, ger1c_a1_x1_yX )
@rout ATL_syr2U ATL_her2U
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartR1( A, LDA, mb, nb );
 
   MUrnext( N, A, LDA );
   x0 = (TYPE *)(X); X += (N SHIFT); y0 = (TYPE *)(Y); Y += (N SHIFT);
 
   for( j = 0; j < N; j += nb )
   {
      jb = N - j; jb = Mmin( jb, nb ); jbs = (jb SHIFT);
      MUrprev( jb, A, LDA ); X -= jbs; Y -= jbs;
      if( ( m = N-j-jb ) != 0 )
      {
         A0 = (TYPE *)(A) - (m SHIFT);
         ger( m, jb, one, x0, 1, Y, 1, A0, LDA );
         ger( m, jb, one, y0, 1, X, 1, A0, LDA );
      }
      Mjoin( PATL, ref@(sh)r2U )( jb, one, X, 1, Y, 1, A, LDA );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef sh
@skip
@skip ==================================================================
@skip
@rout ATL_tbmvLN
@define suf @LN@
@rout ATL_tbmvLC
@define suf @LC@
@rout ATL_tbmvLN ATL_tbmvLC
@define rname @Mjoin( PATL, tbmv@(suf) )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*tbmv0)( const int, const int, const TYPE *,
                              const int, TYPE * );
#ifdef TREAL
#define    lda2               LDA
#define    one                ATL_rone
#else
   TYPE                       one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
#ifdef ATL_AXPYMV
   int                        ja, jan, kl, ku, ma, mb, mb1, na, nb;
#else
   int                        ja, jan, kl, ku, m, ma, mb, n1, na, nb, nb1;
#endif
@rout ATL_tbmvLN
#define    gbmv0              Mjoin( PATL, gbmvN_a1_x1_b1_y1  )
@rout ATL_tbmvLC
#define    gbmv0              Mjoin( PATL, gbmvNc_a1_x1_b1_y1  )
@rout ATL_tbmvLN ATL_tbmvLC
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVN( A, LDA, &mb, &nb );
 
   if( DIAG == AtlasNonUnit ) tbmv0 = Mjoin( PATL, tbmv@(suf)N );
   else                       tbmv0 = Mjoin( PATL, tbmv@(suf)U );

#ifdef ATL_AXPYMV
   mb1  = N - ( ( N - 1 ) / mb ) * mb;
 
   for( jan = N - mb; jan > 0; jan -= mb )
   {
      ja = jan - K; ja = Mmax( ja, 0 ); ma = Mmin( mb, K );
      ku = na = jan - ja;  kl = K - ku; kl = Mmax( kl, 0 );
      tbmv0( mb, K, A+jan*lda2, LDA, X+(jan SHIFT) );
      gbmv0( ma, na, kl, ku, one, A+ja*lda2, LDA, X+(ja SHIFT), 1, one,
             X+(jan SHIFT), 1 );
   }
   tbmv0( mb1, K, A, LDA, X );
#else
   nb1  = N - ( n1  = ( ( N - 1 ) / nb ) * nb );
 
   tbmv0( nb1, K, A + n1*lda2, LDA, X+(n1 SHIFT) );
 
   for( m = nb1, jan = n1; m < N; m += nb )
   {
      ja = nb - K; ja = jan - nb + Mmax( ja, 0 ); ma = Mmin( m, K );
      ku = na = jan - ja; kl = K - ku; kl = Mmax( kl, 0 );
      gbmv0( ma, na, kl, ku, one, A+ja*lda2, LDA, X+(ja SHIFT), 1, one,
             X+(jan SHIFT), 1 );
      jan -= nb; tbmv0( nb, K, A+jan*lda2, LDA, X+(jan SHIFT) );
   }
#endif
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbmvUN
@define suf @UN@
@rout ATL_tbmvUC
@define suf @UC@
@rout ATL_tbmvUN ATL_tbmvUC
@define rname @Mjoin( PATL, tbmv@(suf) )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*tbmv0)( const int, const int, const TYPE *,
                              const int, TYPE * );
#ifdef TREAL
#define    one                ATL_rone
#define    lda2               LDA
#else
   const int                  lda2   = ( LDA SHIFT );
   TYPE                       one[2] = { ATL_rone, ATL_rzero };
#endif
#ifdef ATL_AXPYMV
   int                        ia, ian, j, kl, ku, ma, mb, mb1, n, na, nb;
#else
   int                        ia, ian, kl, ku, ma, mb, na, nb, nb1;
#endif
@rout ATL_tbmvUN
#define    gbmv0              Mjoin( PATL, gbmvN_a1_x1_b1_y1  )
@rout ATL_tbmvUC
#define    gbmv0              Mjoin( PATL, gbmvNc_a1_x1_b1_y1  )
@rout ATL_tbmvUN ATL_tbmvUC
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVN( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) tbmv0 = Mjoin( PATL, tbmv@(suf)N );
   else                       tbmv0 = Mjoin( PATL, tbmv@(suf)U );

#ifdef ATL_AXPYMV
   mb1  = N - ( ( N - 1 ) / mb ) * mb;

   for( n = N - mb, j = 0; n > 0; n -= mb, j += mb )
   {
      ian = j + mb; ia = mb - K; ia = j + Mmax( ia, 0 ); ma = ian - ia;
      na = N - ian; na = Mmin( na, K ); kl = ma - 1; kl = Mmax( kl, 0 );
      ku = K - 1 - kl; ku = Mmax( ku, 0 );
      tbmv0( mb, K, A+j*lda2, LDA, X+(j SHIFT) );
      gbmv0( ma, na, kl, ku, one, A+ian*lda2, LDA, X+(ian SHIFT), 1, one,
             X+(ia SHIFT), 1 );
   }
   tbmv0( mb1, K, A+j*lda2, LDA, X+(j SHIFT) );
#else
   nb1  = N - ( ( N - 1 ) / nb ) * nb;

   tbmv0( nb1, K, A, LDA, X );

   for( ian = nb1; ian < N; ian += nb )
   {
      ia = ian - K; ia = Mmax( ia, 0 ); ma = ian - ia;  na = Mmin( nb, K );
      kl = ma - 1; kl = Mmax( kl, 0 ); ku = K - 1 - kl; ku = Mmax( ku, 0 ); 
      gbmv0( ma, na, kl, ku, one, A+ian*lda2, LDA, X+(ian SHIFT), 1, one,
             X+(ia SHIFT), 1 );
      tbmv0( nb, K, A+ian*lda2, LDA, X+(ian SHIFT) );
   }
#endif
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbmvLT
@define suf @LT@
@rout ATL_tbmvLH
@define suf @LH@
@rout ATL_tbmvLT ATL_tbmvLH
@define rname @Mjoin( PATL, tbmv@(suf) )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    lda2               LDA
#define    one                ATL_rone
#else
   TYPE                       one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
   int                        ja, jan, kl, ku, ma, mb, mb1, na, nb;
   void                       (*tbmv0)( const int, const int, const TYPE *,
                              const int, TYPE * );
@rout ATL_tbmvLT
#define    gbmv0              Mjoin( PATL, gbmvT_a1_x1_b1_y1  )
@rout ATL_tbmvLH
#define    gbmv0              Mjoin( PATL, gbmvC_a1_x1_b1_y1  )
@rout ATL_tbmvLT ATL_tbmvLH
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVT( A, LDA, &mb, &nb );
 
   if( DIAG == AtlasNonUnit ) tbmv0 = Mjoin( PATL, tbmv@(suf)N );
   else                       tbmv0 = Mjoin( PATL, tbmv@(suf)U );
 
   mb1  = N - ( ( N - 1 ) / mb ) * mb;
 
   tbmv0( mb1, K, A, LDA, X );

   for( jan = mb1; jan < N; jan += mb )
   {
      ja = jan - K; ja = Mmax( ja, 0 ); ma = Mmin( mb, K );
      ku = na = jan - ja;  kl = K - ku; kl = Mmax( kl, 0 );
      gbmv0( na, ma, kl, ku, one, A+ja*lda2, LDA, X+(jan SHIFT), 1, one,
             X+(ja SHIFT), 1 );
      tbmv0( mb, K, A+jan*lda2, LDA, X+(jan SHIFT) );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbmvUT
@define suf @UT@
@rout ATL_tbmvUH
@define suf @UH@
@rout ATL_tbmvUT ATL_tbmvUH
@define rname @Mjoin( PATL, tbmv@(suf) )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*tbmv0)( const int, const int, const TYPE *,
                              const int, TYPE * );
#ifdef TREAL
#define    one                ATL_rone
#define    lda2               LDA
#else
   TYPE                       one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
   int                        ia, ian, j, kl, ku, m1, ma, mb, mb1, na, nb;
@rout ATL_tbmvUT
#define    gbmv0              Mjoin( PATL, gbmvT_a1_x1_b1_y1  )
@rout ATL_tbmvUH
#define    gbmv0              Mjoin( PATL, gbmvC_a1_x1_b1_y1  )
@rout ATL_tbmvUT ATL_tbmvUH
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVT( A, LDA, &mb, &nb );
 
   if( DIAG == AtlasNonUnit ) tbmv0 = Mjoin( PATL, tbmv@(suf)N );
   else                       tbmv0 = Mjoin( PATL, tbmv@(suf)U );

   mb1  = N - ( m1 = ( ( N - 1 ) / mb ) * mb );

   tbmv0( mb1, K, A+m1*lda2, LDA, X+(m1 SHIFT) );
 
   for( j = m1 - mb; j >= 0; j -= mb )
   {
      ian = j + mb; ia = mb - K; ia = j + Mmax( ia, 0 ); ma = ian - ia;
      na = N - ian; na = Mmin( na, K ); kl = ma - 1; kl = Mmax( kl, 0 );
      ku = K - 1 - kl; ku = Mmax( ku, 0 );
      gbmv0( na, ma, kl, ku, one, A+ian*lda2, LDA, X+(ia SHIFT), 1, one,
             X+(ian SHIFT), 1 );
      tbmv0( mb, K, A+j*lda2, LDA, X+(j SHIFT) );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbmvLNN
@define suf    @LNN@
@rout ATL_tbmvLNU
@define suf    @LNU@
@rout ATL_tbmvLCN
@define suf    @LCN@
@rout ATL_tbmvLCU
@define suf    @LCU@
@rout ATL_tbmvLNN ATL_tbmvLNU ATL_tbmvLCN ATL_tbmvLCU
@define rname @Mjoin( PATL, tbmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tbmv@(suf)      16
#else
#define    MinN_tbmv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#define    lda2               LDA
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA << 1 );
#endif
   int                        ja, kl, ku, ma, na, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tbmv@(suf) )
   { Mjoin( PATL, reftbmv@(suf) )( N, K, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, tbmv@(suf) )( n2, K, A+n1*lda2, LDA, X+n1s );
      ja = n1 - K; ja = Mmax( ja, 0 ); ma = Mmin( n2, K );
      ku = na = n1 - ja;  kl = K - ku; kl = Mmax( kl, 0 );
@rout ATL_tbmvLNN ATL_tbmvLNU
      Mjoin( PATL, gbmvN_a1_x1_b1_y1 )( ma, na, kl, ku, one, A+ja*lda2, LDA,
                                        X+(ja SHIFT), 1, one, X+n1s, 1 );
@rout ATL_tbmvLCN ATL_tbmvLCU
      Mjoin( PATL, gbmvNc_a1_x1_b1_y1 )( ma, na, kl, ku, one, A+ja*lda2, LDA,
                                         X+(ja SHIFT), 1, one, X+n1s, 1 );
@rout ATL_tbmvLNN ATL_tbmvLNU ATL_tbmvLCN ATL_tbmvLCU
      Mjoin( PATL, tbmv@(suf) )( n1, K, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbmvUNN
@define suf    @UNN@
@rout ATL_tbmvUNU
@define suf    @UNU@
@rout ATL_tbmvUCN
@define suf    @UCN@
@rout ATL_tbmvUCU
@define suf    @UCU@
@rout ATL_tbmvUNN ATL_tbmvUNU ATL_tbmvUCN ATL_tbmvUCU
@define rname @Mjoin( PATL, tbmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tbmv@(suf)      16
#else
#define    MinN_tbmv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#define    lda2               LDA
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA << 1 );
#endif
   int                        ia, kl, ku, ma, na, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tbmv@(suf) )
   { Mjoin( PATL, reftbmv@(suf) )( N, K, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, tbmv@(suf) )( n1, K, A, LDA, X ); 
      ia = n1 - K; ia = Mmax( ia, 0 ); ma = n1 - ia;    na = Mmin( n2, K );
      kl = ma - 1; kl = Mmax( kl, 0 ); ku = K - 1 - kl; ku = Mmax( ku, 0 );
@rout ATL_tbmvUNN ATL_tbmvUNU
      Mjoin( PATL, gbmvN_a1_x1_b1_y1 )( ma, na, kl, ku, one, A+n1*lda2, LDA,
                                        X+n1s, 1, one, X+(ia SHIFT), 1 );
@rout ATL_tbmvUCN ATL_tbmvUCU
      Mjoin( PATL, gbmvNc_a1_x1_b1_y1 )( ma, na, kl, ku, one, A+n1*lda2, LDA,
                                         X+n1s, 1, one, X+(ia SHIFT), 1 );
@rout ATL_tbmvUNN ATL_tbmvUNU ATL_tbmvUCN ATL_tbmvUCU
      Mjoin( PATL, tbmv@(suf) )( n2, K, A+n1*lda2, LDA, X+n1s ); 
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbmvLTN
@define suf    @LTN@
@rout ATL_tbmvLTU
@define suf    @LTU@
@rout ATL_tbmvLHN
@define suf    @LHN@
@rout ATL_tbmvLHU
@define suf    @LHU@
@rout ATL_tbmvLTN ATL_tbmvLTU ATL_tbmvLHN ATL_tbmvLHU
@define rname @Mjoin( PATL, tbmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tbmv@(suf)      16
#else
#define    MinN_tbmv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#define    lda2               LDA
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA << 1 );
#endif
   int                        ja, kl, ku, ma, na, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tbmv@(suf) )
   { Mjoin( PATL, reftbmv@(suf) )( N, K, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, tbmv@(suf) )( n1, K, A, LDA, X );
      ja = n1 - K; ja = Mmax( ja, 0 ); ma = Mmin( n2, K );
      ku = na = n1 - ja;  kl = K - ku; kl = Mmax( kl, 0 );
@rout ATL_tbmvLTN ATL_tbmvLTU
      Mjoin( PATL, gbmvT_a1_x1_b1_y1 )( na, ma, kl, ku, one, A+ja*lda2, LDA,
                                        X+n1s, 1, one, X+(ja SHIFT), 1 );
@rout ATL_tbmvLHN ATL_tbmvLHU
      Mjoin( PATL, gbmvC_a1_x1_b1_y1 )( na, ma, kl, ku, one, A+ja*lda2, LDA,
                                        X+n1s, 1, one, X+(ja SHIFT), 1 );
@rout ATL_tbmvLTN ATL_tbmvLTU ATL_tbmvLHN ATL_tbmvLHU
      Mjoin( PATL, tbmv@(suf) )( n2, K, A+n1*lda2, LDA, X+n1s );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbmvUTN
@define suf    @UTN@
@rout ATL_tbmvUTU
@define suf    @UTU@
@rout ATL_tbmvUHN
@define suf    @UHN@
@rout ATL_tbmvUHU
@define suf    @UHU@
@rout ATL_tbmvUTN ATL_tbmvUTU ATL_tbmvUHN ATL_tbmvUHU
@define rname @Mjoin( PATL, tbmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tbmv@(suf)      16
#else
#define    MinN_tbmv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#define    lda2               LDA
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA << 1 );
#endif
   int                        ia, kl, ku, ma, na, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tbmv@(suf) )
   { Mjoin( PATL, reftbmv@(suf) )( N, K, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, tbmv@(suf) )( n2, K, A+n1*lda2, LDA, X+n1s );
      ia = n1 - K; ia = Mmax( ia, 0 ); ma = n1 - ia;    na = Mmin( n2, K );
      kl = ma - 1; kl = Mmax( kl, 0 ); ku = K - 1 - kl; ku = Mmax( ku, 0 );
@rout ATL_tbmvUTN ATL_tbmvUTU
      Mjoin( PATL, gbmvT_a1_x1_b1_y1 )( na, ma, kl, ku, one, A+n1*lda2, LDA,
                                        X+(ia SHIFT), 1, one, X+n1s, 1 );
@rout ATL_tbmvUHN ATL_tbmvUHU
      Mjoin( PATL, gbmvC_a1_x1_b1_y1 )( na, ma, kl, ku, one, A+n1*lda2, LDA,
                                        X+(ia SHIFT), 1, one, X+n1s, 1 );
@rout ATL_tbmvUTN ATL_tbmvUTU ATL_tbmvUHN ATL_tbmvUHU
      Mjoin( PATL, tbmv@(suf) )( n1, K, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpmvLN
@define suf @LN@
@rout ATL_tpmvLC
@define suf @LC@
@rout ATL_tpmvLN ATL_tpmvLC
@define rname @Mjoin( PATL, tpmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   TYPE                       one[2] = { ATL_rone, ATL_rzero };
#endif
#ifdef ATL_AXPYMV
   TYPE                       * A0, * x0;
   int                        incX, lda, lda0, mb, mb1, n, nb;
#else
   TYPE                       * x0;
   int                        incX, lda, m, mb, n1, nb, nb1;
#endif
   void                       (*tpmv0)( const int, const TYPE *, const int,
                              TYPE * );
@rout ATL_tpmvLN
#define    gpmv0              Mjoin( PATL, gpmvLN_a1_x1_b1_y1  )
@rout ATL_tpmvLC
#define    gpmv0              Mjoin( PATL, gpmvLNc_a1_x1_b1_y1  )
@rout ATL_tpmvLN ATL_tpmvLC
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVN( A, LDA, &mb, &nb );
 
   if( DIAG == AtlasNonUnit ) tpmv0 = Mjoin( PATL, tpmv@(suf)N );
   else                       tpmv0 = Mjoin( PATL, tpmv@(suf)U );
 
#ifdef ATL_AXPYMV
   mb1  = N - ( ( N - 1 ) / mb ) * mb; incX = (mb SHIFT); x0 = X;
   lda = lda0 = LDA; A0 = (TYPE *)(A); MLpnext( N, A, lda );
 
   for( n = N - mb, X += ((N-mb) SHIFT); n > 0; n -= mb, X -= incX )
   {
      MLpprev( mb, A, lda ); tpmv0( mb, A, lda, X );
      gpmv0( mb, n, one, A0 + (n SHIFT), lda0, x0, 1, one, X, 1 );
   }
   tpmv0( mb1, A0, lda0, x0 );
#else
   nb1  = N - ( n1  = ( ( N - 1 ) / nb ) * nb );
   incX = (nb SHIFT); x0 = ( X += (n1 SHIFT) );
   lda = LDA; MLpnext( n1, A, lda ); tpmv0( nb1, A, lda, X ); x0 = X; X -= incX; 
   for( m = nb1; m < N; m += nb, X -= incX, x0 -= incX )
   {
      MLpprev( nb, A, lda );
      gpmv0( m, nb, one, A + (nb SHIFT), lda, X, 1, one, x0, 1 );
      tpmv0( nb, A, lda, X );
   }
#endif
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpmvUN
@define suf @UN@
@rout ATL_tpmvUC
@define suf @UC@
@rout ATL_tpmvUN ATL_tpmvUC
@define rname @Mjoin( PATL, tpmv@(suf) )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   TYPE                       one[2] = { ATL_rone, ATL_rzero };
#endif
#ifdef ATL_AXPYMV
   TYPE                       * A0, * x0;
   int                        incX, lda, lda0, mb, mb1, n, nb;
#else
   TYPE                       * x0;
   int                        incX, lda,       m, mb, nb, nb1;
#endif
   void                       (*tpmv0)( const int, const TYPE *, const int,
                              TYPE * );
@rout ATL_tpmvUN
#define    gpmv0              Mjoin( PATL, gpmvUN_a1_x1_b1_y1  )
@rout ATL_tpmvUC
#define    gpmv0              Mjoin( PATL, gpmvUNc_a1_x1_b1_y1  )
@rout ATL_tpmvUN ATL_tpmvUC
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVN( A, LDA, &mb, &nb );
 
   if( DIAG == AtlasNonUnit ) tpmv0 = Mjoin( PATL, tpmv@(suf)N );
   else                       tpmv0 = Mjoin( PATL, tpmv@(suf)U );
 
#ifdef ATL_AXPYMV
   mb1 = N - ( ( N - 1 ) / mb ) * mb; incX = (mb SHIFT);
   lda = lda0 = LDA; A0 = (TYPE *)(A); MUpnext( mb, A0, lda0 );
 
   for( n  = N - mb, x0 = X + incX; n > 0; n -= mb, X += incX, x0 += incX )
   {
      tpmv0( mb, A, lda, X );
      gpmv0( mb, n, one, A0 - incX, lda0, x0, 1, one, X, 1 );
      lda = lda0; A = A0; MUpnext( mb, A0, lda0 );
   }
   tpmv0( mb1, A, lda, X );
#else
   nb1 = N - ( ( N - 1 ) / nb ) * nb; incX = (nb SHIFT); x0 = X; lda = LDA;
   tpmv0( nb1, A, lda, X ); X += (nb1 SHIFT); MUpnext( nb1, A, lda );
 
   for( m = nb1; m < N; m += nb, X += incX )
   {
      gpmv0( m, nb, one, A - (m SHIFT), lda, X, 1, one, x0, 1 );
      tpmv0(  nb, A, lda, X );
      MUpnext( nb, A, lda );
   }
#endif
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpmvLT
@define suf @LT@
@rout ATL_tpmvLH
@define suf @LH@
@rout ATL_tpmvLT ATL_tpmvLH
@define rname @Mjoin( PATL, tpmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*tpmv0)( const int, const TYPE *, const int,
                              TYPE * );
#ifdef TREAL
#define    one                ATL_rone
#else
   TYPE                       one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * A0, * x0 = X;
   int                        incX, lda, lda0, mb, mb1, n, nb;
@rout ATL_tpmvLT
#define    gpmv0              Mjoin( PATL, gpmvLT_a1_x1_b1_y1  )
@rout ATL_tpmvLH
#define    gpmv0              Mjoin( PATL, gpmvLC_a1_x1_b1_y1  )
@rout ATL_tpmvLT ATL_tpmvLH
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVT( A, LDA, &mb, &nb );
 
   if( DIAG == AtlasNonUnit ) tpmv0 = Mjoin( PATL, tpmv@(suf)N );
   else                       tpmv0 = Mjoin( PATL, tpmv@(suf)U );
 
   mb1  = N - ( ( N - 1 ) / mb ) * mb; incX = (mb SHIFT);
   lda = lda0 = LDA; A0 = (TYPE *)(A);
   tpmv0( mb1, A, lda, X ); MLpnext( mb1, A, lda ); X += (mb1 SHIFT);
 
   for( n = mb1; n < N; n += mb, X += incX )
   {
      gpmv0( n, mb, one, A0 + (n SHIFT), lda0, X, 1, one, x0, 1 );
      tpmv0( mb, A, lda, X ); MLpnext( mb, A, lda );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpmvUT
@define suf @UT@
@rout ATL_tpmvUH
@define suf @UH@
@rout ATL_tpmvUT ATL_tpmvUH
@define rname @Mjoin( PATL, tpmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*tpmv0)( const int, const TYPE *, const int,
                              TYPE * );
#ifdef TREAL
#define    one                ATL_rone
#else
   TYPE                       one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * A0, * x0;
   int                        incX, lda, lda0, m1, mb, mb1, n, nb;
@rout ATL_tpmvUT
#define    gpmv0              Mjoin( PATL, gpmvUT_a1_x1_b1_y1  )
@rout ATL_tpmvUH
#define    gpmv0              Mjoin( PATL, gpmvUC_a1_x1_b1_y1  )
@rout ATL_tpmvUT ATL_tpmvUH
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVT( A, LDA, &mb, &nb );
 
   if( DIAG == AtlasNonUnit ) tpmv0 = Mjoin( PATL, tpmv@(suf)N );
   else                       tpmv0 = Mjoin( PATL, tpmv@(suf)U );
 
   mb1 = N - ( m1 = ( ( N - 1 ) / mb ) * mb ); incX = (mb SHIFT);
   lda = LDA; MUpnext( m1, A, lda );
   X += (m1 SHIFT); x0 = X;
   tpmv0( mb1, A, lda, X ); X -= incX;

   lda0 = lda; A0 = (TYPE *)(A) - incX;
 
   for( n = mb1; n < N; n += mb, X -= incX, x0 -= incX )
   {
      gpmv0( n, mb, one, A0, lda0, X, 1, one, x0, 1 );
      MUpprev( mb, A, lda ); tpmv0( mb, A, lda, X );

      lda0 = lda; A0 = (TYPE *)(A) - incX;
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpmvLNN
@define suf @LNN@
@rout ATL_tpmvLNU
@define suf @LNU@
@rout ATL_tpmvLCN
@define suf @LCN@
@rout ATL_tpmvLCU
@define suf @LCU@
@rout ATL_tpmvLNN ATL_tpmvLNU ATL_tpmvLCN ATL_tpmvLCU
@define rname @Mjoin( PATL, tpmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tpmv@(suf)      16
#else
#define    MinN_tpmv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * x0;
   int                        lda = LDA, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tpmv@(suf) )
   { Mjoin( PATL, reftpmv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      MLpnext( n1, A, lda ); x0 = X + n1s;
      Mjoin( PATL, tpmv@(suf) )( n2, A, lda, x0 ); MLpprev( n1, A, lda );
@rout ATL_tpmvLNN ATL_tpmvLNU
      Mjoin( PATL, gpmvLN_a1_x1_b1_y1 )( n2, n1, one, A + n1s, lda, X, 1,
                                         one, x0, 1 );
@rout ATL_tpmvLCN ATL_tpmvLCU
      Mjoin( PATL, gpmvLNc_a1_x1_b1_y1 )( n2, n1, one, A + n1s, lda, X, 1,
                                          one, x0, 1 );
@rout ATL_tpmvLNN ATL_tpmvLNU ATL_tpmvLCN ATL_tpmvLCU
      Mjoin( PATL, tpmv@(suf) )( n1, A, lda, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpmvLTN
@define suf @LTN@
@rout ATL_tpmvLTU
@define suf @LTU@
@rout ATL_tpmvLHN
@define suf @LHN@
@rout ATL_tpmvLHU
@define suf @LHU@
@rout ATL_tpmvLTN ATL_tpmvLTU ATL_tpmvLHN ATL_tpmvLHU
@define rname @Mjoin( PATL, tpmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tpmv@(suf)      16
#else
#define    MinN_tpmv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * x0;
   int                        lda = LDA, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tpmv@(suf) )
   { Mjoin( PATL, reftpmv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, tpmv@(suf) )( n1, A, lda, X ); x0 = X; X += n1s;
@rout ATL_tpmvLTN ATL_tpmvLTU
      Mjoin( PATL, gpmvLT_a1_x1_b1_y1 )( n1, n2, one, A + n1s, lda, X, 1,
                                         one, x0, 1 );
@rout ATL_tpmvLHN ATL_tpmvLHU
      Mjoin( PATL, gpmvLC_a1_x1_b1_y1 )( n1, n2, one, A + n1s, lda, X, 1,
                                         one, x0, 1 );
@rout ATL_tpmvLTN ATL_tpmvLTU ATL_tpmvLHN ATL_tpmvLHU
      MLpnext( n1, A, lda ); Mjoin( PATL, tpmv@(suf) )( n2, A, lda, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout ATL_tpmvUNN
@define suf @UNN@
@rout ATL_tpmvUNU
@define suf @UNU@
@rout ATL_tpmvUCN
@define suf @UCN@
@rout ATL_tpmvUCU
@define suf @UCU@
@rout ATL_tpmvUNN ATL_tpmvUNU ATL_tpmvUCN ATL_tpmvUCU
@define rname @Mjoin( PATL, tpmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tpmv@(suf)      16
#else
#define    MinN_tpmv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * x0;
   int                        lda = LDA, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tpmv@(suf) )
   { Mjoin( PATL, reftpmv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, tpmv@(suf) )( n1, A, lda, X );
      x0 = X; MUpnext( n1, A, lda ); X += n1s;
@rout ATL_tpmvUNN ATL_tpmvUNU
      Mjoin( PATL, gpmvUN_a1_x1_b1_y1 )( n1, n2, one, A - n1s, lda, X, 1,
                                         one, x0, 1 );
@rout ATL_tpmvUCN ATL_tpmvUCU
      Mjoin( PATL, gpmvUNc_a1_x1_b1_y1 )( n1, n2, one, A - n1s, lda, X, 1,
                                          one, x0, 1 );
@rout ATL_tpmvUNN ATL_tpmvUNU ATL_tpmvUCN ATL_tpmvUCU
      Mjoin( PATL, tpmv@(suf) )( n2, A, lda, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpmvUTN
@define suf @UTN@
@rout ATL_tpmvUTU
@define suf @UTU@
@rout ATL_tpmvUHN
@define suf @UHN@
@rout ATL_tpmvUHU
@define suf @UHU@
@rout ATL_tpmvUTN ATL_tpmvUTU ATL_tpmvUHN ATL_tpmvUHU
@define rname @Mjoin( PATL, tpmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tpmv@(suf)      16
#else
#define    MinN_tpmv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * x0;
   int                        lda = LDA, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tpmv@(suf) )
   { Mjoin( PATL, reftpmv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      MUpnext( n1, A, lda ); x0 = X + n1s;
      Mjoin( PATL, tpmv@(suf) )( n2, A, lda, x0 );
@rout ATL_tpmvUTN ATL_tpmvUTU
      Mjoin( PATL, gpmvUT_a1_x1_b1_y1 )( n2, n1, one, A - n1s, lda, X, 1,
                                         one, x0, 1 );
@rout ATL_tpmvUHN ATL_tpmvUHU
      Mjoin( PATL, gpmvUC_a1_x1_b1_y1 )( n2, n1, one, A - n1s, lda, X, 1,
                                         one, x0, 1 );
@rout ATL_tpmvUTN ATL_tpmvUTU ATL_tpmvUHN ATL_tpmvUHU
      MUpprev( n1, A, lda ); Mjoin( PATL, tpmv@(suf) )( n1, A, lda, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trmvLN
@define suf @LN@
@rout ATL_trmvLC
@define suf @LC@
@rout ATL_trmvLN ATL_trmvLC
@define rname @Mjoin( PATL, trmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#define    lda2               LDA
#else
   TYPE                       one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
   TYPE                       * A0, * x0;
#ifdef ATL_AXPYMV
   int                        incA, incX, mb, mb1, n, nb;
#else
   int                        incA, incX, m, mb, n1, nb, nb1;
#endif
   void                       (*trmv0)( const int, const TYPE *, const int,
                              TYPE * );  
@rout ATL_trmvLN
#define    gemv0              Mjoin( PATL, gemvN_a1_x1_b1_y1  )
@rout ATL_trmvLC
#define    gemv0              Mjoin( PATL, gemvNc_a1_x1_b1_y1  )
@rout ATL_trmvLN ATL_trmvLC
@extract @(EXECUTABLE_STATEMENT) 
   ATL_GetPartMVN( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) trmv0 = Mjoin( PATL, trmv@(suf)N );
   else                       trmv0 = Mjoin( PATL, trmv@(suf)U );

#ifdef ATL_AXPYMV
   mb1  = N - ( ( N - 1 ) / mb ) * mb;
   incA = incX = (mb SHIFT); A0 = (TYPE *)(A);  x0 = X;
 
   for( n  = N - mb, A += ((N-mb) SHIFT), X += ((N-mb) SHIFT); n > 0;
        n -= mb,     A -= incA,           X -= incX )
   {
      trmv0( mb, A+n*lda2, LDA, X );
      gemv0( mb, n, one, A, LDA, x0, 1, one, X, 1 );
   }
   trmv0( mb1, A0, LDA, x0 );
#else
   nb1  = N - ( n1  = ( ( N - 1 ) / nb ) * nb );
   incA = nb * lda2 + ( incX = (nb SHIFT) );

   x0 = ( X += (n1 SHIFT) ); A += (n1 SHIFT) + n1 * lda2; 
 
   trmv0( nb1, A, LDA, X );
   x0 = X; X -= incX; A -= incA; A0 = (TYPE *)(A) + incX;
 
   for( m = nb1; m < N; m += nb, A0 -= incA, A -= incA, X -= incX, x0 -= incX )
   {
      gemv0( m, nb, one, A0, LDA, X, 1, one, x0, 1 );
      trmv0( nb, A, LDA, X );
   }
#endif
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trmvUN
@define suf @UN@
@rout ATL_trmvUC
@define suf @UC@
@rout ATL_trmvUN ATL_trmvUC
@define rname @Mjoin( PATL, trmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#define    lda2               LDA
#else
   TYPE                       one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
   TYPE                       * A0, * x0;
#ifdef ATL_AXPYMV
   int                        incA,        incX, mb, mb1, n, nb;
#else
   int                        incA0, incA, incX, m, mb, nb, nb1;
#endif
   void                       (*trmv0)( const int, const TYPE *, const int,
                              TYPE * );  
@rout ATL_trmvUN
#define    gemv0              Mjoin( PATL, gemvN_a1_x1_b1_y1  )
@rout ATL_trmvUC
#define    gemv0              Mjoin( PATL, gemvNc_a1_x1_b1_y1  )
@rout ATL_trmvUN ATL_trmvUC
@extract @(EXECUTABLE_STATEMENT) 
   ATL_GetPartMVN( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) trmv0 = Mjoin( PATL, trmv@(suf)N );
   else                       trmv0 = Mjoin( PATL, trmv@(suf)U );

#ifdef ATL_AXPYMV
   mb1  = N - ( ( N - 1 ) / mb ) * mb;
   incA = mb * lda2 + ( incX = (mb SHIFT) );
 
   for( n  = N - mb, A0 = (TYPE *)(A) + mb * lda2, x0 = X + incX; n > 0;
        n -= mb, A0 += incA, A += incA, X += incX, x0 += incX )
   {
      trmv0( mb, A, LDA, X );
      gemv0( mb, n, one, A0, LDA, x0, 1, one, X, 1 );
   }
   trmv0( mb1, A, LDA, X );
#else
   nb1  = N - ( ( N - 1 ) / nb ) * nb;
   incA = ( incA0 = nb * lda2 ) + ( incX = (nb SHIFT) );  x0 = X;
 
   trmv0( nb1, A, LDA, X );
   X += (nb1 SHIFT); A0 = (TYPE *)(A += nb1 * lda2); A += (nb1 SHIFT);
   for( m = nb1; m < N; m += nb, A0 += incA0, A += incA, X += incX )
   {
      gemv0( m, nb, one, A0, LDA, X, 1, one, x0, 1 );
      trmv0( nb, A, LDA, X );
   }
#endif
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trmvLT
@define suf @LT@
@rout ATL_trmvLH
@define suf @LH@
@rout ATL_trmvLT ATL_trmvLH
@define rname @Mjoin( PATL, trmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#define    lda2               LDA
#else
   TYPE                       one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
   TYPE                       * A0, * x0 = X;
   int                        incA0, incA, incX, mb, mb1, n, nb;
   void                       (*trmv0)( const int, const TYPE *, const int,
                              TYPE * );  
@rout ATL_trmvLT
#define    gemv0              Mjoin( PATL, gemvT_a1_x1_b1_y1  )
@rout ATL_trmvLH
#define    gemv0              Mjoin( PATL, gemvC_a1_x1_b1_y1  )
@rout ATL_trmvLT ATL_trmvLH
@extract @(EXECUTABLE_STATEMENT) 
   ATL_GetPartMVT( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) trmv0 = Mjoin( PATL, trmv@(suf)N );
   else                       trmv0 = Mjoin( PATL, trmv@(suf)U );

   mb1  = N - ( ( N - 1 ) / mb ) * mb;
   incA = ( incA0 = ( incX  = (mb SHIFT) ) ) + mb * lda2;
 
   trmv0( mb1, A, LDA, X );
   A0 = (TYPE *)( A += (mb1 SHIFT) ); A += mb1 * lda2; X += (mb1 SHIFT);

   for( n = mb1; n < N; n += mb, A0 += incA0, A += incA, X += incX )
   {
      gemv0( n, mb, one, A0, LDA, X, 1, one, x0, 1 );
      trmv0( mb, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trmvUT
@define suf @UT@
@rout ATL_trmvUH
@define suf @UH@
@rout ATL_trmvUT ATL_trmvUH
@define rname @Mjoin( PATL, trmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#define    lda2               LDA
#else
   TYPE                       one[2] = { ATL_rone, ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
   TYPE                       * A0, * x0;
   int                        incA, incX, m1, mb, mb1, n, nb;
   void  (*trmv0)( const int, const TYPE *, const int, TYPE * );  
@rout ATL_trmvUT
#define    gemv0              Mjoin( PATL, gemvT_a1_x1_b1_y1  )
@rout ATL_trmvUH
#define    gemv0              Mjoin( PATL, gemvC_a1_x1_b1_y1  )
@rout ATL_trmvUT ATL_trmvUH
@extract @(EXECUTABLE_STATEMENT) 
   ATL_GetPartMVT( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) trmv0 = Mjoin( PATL, trmv@(suf)N );
   else                       trmv0 = Mjoin( PATL, trmv@(suf)U );

   mb1  = N - ( m1 = ( ( N - 1 ) / mb ) * mb );
   incA = ( incX  = (mb SHIFT) ) + mb * lda2;

   A += (m1 SHIFT) + m1 * lda2; X += (m1 SHIFT);
   A0 = (TYPE *)(A) - incX;     x0 = X;
 
   trmv0( mb1, A, LDA, X ); X -= incX; A -= incA;
   for( n = mb1; n < N; n += mb, A0 -= incA, A -= incA, X -= incX, x0 -= incX )
   {
      gemv0( n, mb, one, A0, LDA, X, 1, one, x0, 1 );
      trmv0( mb, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trmvLNN
@define suf @LNN@
@rout ATL_trmvLNU
@define suf @LNU@
@rout ATL_trmvLCN
@define suf @LCN@
@rout ATL_trmvLCU
@define suf @LCU@
@rout ATL_trmvLNN ATL_trmvLNU ATL_trmvLCN ATL_trmvLCU
@define rname @Mjoin( PATL, trmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_trmv@(suf)      16
#else
#define    MinN_trmv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * x0;
   int                        n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_trmv@(suf) )
   { Mjoin( PATL, reftrmv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      MLrnext( n1, A, LDA ); x0 = X + n1s;
      Mjoin( PATL, trmv@(suf) )( n2, A, LDA, x0 ); MLrprev( n1, A, LDA );
@rout ATL_trmvLNN ATL_trmvLNU
      Mjoin( PATL, gemvN_a1_x1_b1_y1 )(  n2, n1, one, A + n1s, LDA, X, 1,
                                         one, x0, 1 );
@rout ATL_trmvLCN ATL_trmvLCU
      Mjoin( PATL, gemvNc_a1_x1_b1_y1 )( n2, n1, one, A + n1s, LDA, X, 1,
                                         one, x0, 1 );
@rout ATL_trmvLNN ATL_trmvLNU ATL_trmvLCN ATL_trmvLCU
      Mjoin( PATL, trmv@(suf) )( n1, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trmvLTN
@define suf @LTN@
@rout ATL_trmvLTU
@define suf @LTU@
@rout ATL_trmvLHN
@define suf @LHN@
@rout ATL_trmvLHU
@define suf @LHU@
@rout ATL_trmvLTN ATL_trmvLTU ATL_trmvLHN ATL_trmvLHU
@define rname @Mjoin( PATL, trmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_trmv@(suf)      16
#else
#define    MinN_trmv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * x0;
   int                        n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_trmv@(suf) )
   { Mjoin( PATL, reftrmv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, trmv@(suf) )( n1, A, LDA, X ); x0 = X; X += n1s;
@rout ATL_trmvLTN ATL_trmvLTU
      Mjoin( PATL, gemvT_a1_x1_b1_y1 )( n1, n2, one, A + n1s, LDA, X, 1,
                                        one, x0, 1 );
@rout ATL_trmvLHN ATL_trmvLHU
      Mjoin( PATL, gemvC_a1_x1_b1_y1 )( n1, n2, one, A + n1s, LDA, X, 1,
                                        one, x0, 1 );
@rout ATL_trmvLTN ATL_trmvLTU ATL_trmvLHN ATL_trmvLHU
      MLrnext( n1, A, LDA ); Mjoin( PATL, trmv@(suf) )( n2, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@skip
@skip ==================================================================
@skip
@rout ATL_trmvUNN
@define suf @UNN@
@rout ATL_trmvUNU
@define suf @UNU@
@rout ATL_trmvUCN
@define suf @UCN@
@rout ATL_trmvUCU
@define suf @UCU@
@rout ATL_trmvUNN ATL_trmvUNU ATL_trmvUCN ATL_trmvUCU
@define rname @Mjoin( PATL, trmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_trmv@(suf)      16
#else
#define    MinN_trmv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * x0;
   int                        n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_trmv@(suf) )
   { Mjoin( PATL, reftrmv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, trmv@(suf) )( n1, A, LDA, X ); 
      x0 = X; MUrnext( n1, A, LDA ); X += n1s;
@rout ATL_trmvUNN ATL_trmvUNU
      Mjoin( PATL, gemvN_a1_x1_b1_y1 )(  n1, n2, one, A - n1s, LDA, X, 1,
                                         one, x0, 1 );
@rout ATL_trmvUCN ATL_trmvUCU
      Mjoin( PATL, gemvNc_a1_x1_b1_y1 )( n1, n2, one, A - n1s, LDA, X, 1,
                                         one, x0, 1 );
@rout ATL_trmvUNN ATL_trmvUNU ATL_trmvUCN ATL_trmvUCU
      Mjoin( PATL, trmv@(suf) )( n2, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trmvUTN
@define suf @UTN@
@rout ATL_trmvUTU
@define suf @UTU@
@rout ATL_trmvUHN
@define suf @UHN@
@rout ATL_trmvUHU
@define suf @UHU@
@rout ATL_trmvUTN ATL_trmvUTU ATL_trmvUHN ATL_trmvUHU
@define rname @Mjoin( PATL, trmv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_trmv@(suf)      16
#else
#define    MinN_trmv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    one                ATL_rone
#else
   const TYPE                 one[2] = { ATL_rone, ATL_rzero };
#endif
   TYPE                       * x0;
   int                        n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_trmv@(suf) )
   { Mjoin( PATL, reftrmv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      MUrnext( n1, A, LDA ); x0 = X + n1s;
      Mjoin( PATL, trmv@(suf) )( n2, A, LDA, x0 );
@rout ATL_trmvUTN ATL_trmvUTU
      Mjoin( PATL, gemvT_a1_x1_b1_y1 )( n2, n1, one, A - n1s, LDA, X, 1,
                                        one, x0, 1 );
@rout ATL_trmvUHN ATL_trmvUHU
      Mjoin( PATL, gemvC_a1_x1_b1_y1 )( n2, n1, one, A - n1s, LDA, X, 1,
                                        one, x0, 1 );
@rout ATL_trmvUTN ATL_trmvUTU ATL_trmvUHN ATL_trmvUHU
      MUrprev( n1, A, LDA ); Mjoin( PATL, trmv@(suf) )( n1, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbsvLN
@define suf @LN@
@rout ATL_tbsvLC
@define suf @LC@
@rout ATL_tbsvLN ATL_tbsvLC
@define rname @Mjoin( PATL, tbsv@(suf) )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*tbsv0)( const int, const int, const TYPE *,
                              const int, TYPE * );
#ifdef TREAL
#define    lda2               LDA
#define    one                ATL_rone
#define    none               ATL_rnone
#else
   TYPE                       none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
#ifdef ATL_AXPYMV
   int                        ja, jan, kl, ku, ma, mb, mb1, na, nb;
#else
   int                        j, ja, jan, kl, ku, m, ma, mb, na, nb, nb1;
#endif
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVN( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) tbsv0 = Mjoin( PATL, tbsv@(suf)N );
   else                       tbsv0 = Mjoin( PATL, tbsv@(suf)U );

#ifdef ATL_AXPYMV
   mb1  = N - ( ( N - 1 ) / mb ) * mb;

   tbsv0( mb1, K, A, LDA, X );
 
   for( jan = mb1; jan < N; jan += mb )
   {
      ja = jan - K; ja = Mmax( ja, 0 ); ma = Mmin( mb, K );
      ku = na = jan - ja;  kl = K - ku; kl = Mmax( kl, 0 );
@rout ATL_tbsvLN
      Mjoin( PATL, gbmv )( AtlasNoTrans, ma, na, kl, ku, none, A+ja*lda2,
                           LDA, X+(ja SHIFT), 1, one, X+(jan SHIFT), 1 );
@rout ATL_tbsvLC
      Mjoin( PATL, gbmv )( AtlasConj,    ma, na, kl, ku, none, A+ja*lda2,
                           LDA, X+(ja SHIFT), 1, one, X+(jan SHIFT), 1 );
@rout ATL_tbsvLN ATL_tbsvLC
      tbsv0( mb, K, A+jan*lda2, LDA, X+(jan SHIFT) );
   }
#else
   nb1  = N - ( ( N - 1 ) / nb ) * nb;

   for( m = N - nb, j = 0; m > 0; m -= nb, j += nb )
   {
      jan = j + nb; ja = nb - K; ja = j + Mmax( ja, 0 ); ma = Mmin( m, K );
      ku = na = jan - ja; kl = K - ku; kl = Mmax( kl, 0 );
      tbsv0( nb, K, A+j*lda2, LDA, X+(j SHIFT) );
@rout ATL_tbsvLN
      Mjoin( PATL, gbmv )( AtlasNoTrans, ma, na, kl, ku, none, A+ja*lda2,
                           LDA, X+(ja SHIFT), 1, one, X+(jan SHIFT), 1 );
@rout ATL_tbsvLC
      Mjoin( PATL, gbmv )( AtlasConj,    ma, na, kl, ku, none, A+ja*lda2,
                           LDA, X+(ja SHIFT), 1, one, X+(jan SHIFT), 1 );
@rout ATL_tbsvLN ATL_tbsvLC
   }
   tbsv0( nb1, K, A+j*lda2, LDA, X+(j SHIFT) );
#endif
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbsvLT
@define suf @LT@
@rout ATL_tbsvLH
@define suf @LH@
@rout ATL_tbsvLT ATL_tbsvLH
@define rname @Mjoin( PATL, tbsv@(suf) )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*tbsv0)( const int, const int, const TYPE *,
                              const int, TYPE * );
#ifdef TREAL
#define    lda2               LDA
#define    one                ATL_rone
#define    none               ATL_rnone
#else
   TYPE                       none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
   int                        ja, jan, kl, ku, ma, mb, mb1, na, nb;
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVT( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) tbsv0 = Mjoin( PATL, tbsv@(suf)N );
   else                       tbsv0 = Mjoin( PATL, tbsv@(suf)U );

   mb1  = N - ( ( N - 1 ) / mb ) * mb;
 
   for( jan = N - mb; jan > 0; jan -= mb )
   {
      ja = jan - K; ja = Mmax( ja, 0 ); ma = Mmin( mb, K );
      ku = na = jan - ja;  kl = K - ku; kl = Mmax( kl, 0 );
      tbsv0( mb, K, A+jan*lda2, LDA, X+(jan SHIFT) );
@rout ATL_tbsvLT
      Mjoin( PATL, gbmv )( AtlasTrans,     na, ma, kl, ku, none, A+ja*lda2,
                           LDA, X+(jan SHIFT), 1, one, X+(ja SHIFT), 1 );
@rout ATL_tbsvLH
      Mjoin( PATL, gbmv )( AtlasConjTrans, na, ma, kl, ku, none, A+ja*lda2,
                           LDA, X+(jan SHIFT), 1, one, X+(ja SHIFT), 1 );
@rout ATL_tbsvLT ATL_tbsvLH
   }
   tbsv0( mb1, K, A, LDA, X );
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbsvUN
@define suf @UN@
@rout ATL_tbsvUC
@define suf @UC@
@rout ATL_tbsvUN ATL_tbsvUC
@define rname @Mjoin( PATL, tbsv@(suf) )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*tbsv0)( const int, const int, const TYPE *,
                              const int, TYPE * );
#ifdef TREAL
#define    lda2               LDA
#define    one                ATL_rone
#define    none               ATL_rnone
#else
   TYPE                       none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
#ifdef ATL_AXPYMV
   int                        ia, ian, j, kl, ku, m1, ma, mb, mb1, n, na, nb;
#else
   int                        ia, ian, kl, ku, ma, mb, na, nb, nb1;
#endif
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVN( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) tbsv0 = Mjoin( PATL, tbsv@(suf)N );
   else                       tbsv0 = Mjoin( PATL, tbsv@(suf)U );

#ifdef ATL_AXPYMV
   mb1  = N - ( m1 = ( ( N - 1 ) / mb ) * mb );

   tbsv0( mb1, K, A+m1*lda2, LDA, X+(m1 SHIFT) );
 
   for( n = mb1, j = m1 - mb; n < N; n += mb, j -= mb )
   {
      ian = j + mb; ia = mb - K; ia = j + Mmax( ia, 0 ); ma = ian - ia;
      na = N - ian; na = Mmin( na, K ); kl = ma - 1; kl = Mmax( kl, 0 );
      ku = K - 1 - kl; ku = Mmax( ku, 0 );
@rout ATL_tbsvUN
      Mjoin( PATL, gbmv )( AtlasNoTrans, ma, na, kl, ku, none, A+ian*lda2,
                           LDA, X+(ian SHIFT), 1, one, X+(ia SHIFT), 1 );
@rout ATL_tbsvUC
      Mjoin( PATL, gbmv )( AtlasConj,    ma, na, kl, ku, none, A+ian*lda2,
                           LDA, X+(ian SHIFT), 1, one, X+(ia SHIFT), 1 );
@rout ATL_tbsvUN ATL_tbsvUC
      tbsv0( mb, K, A+j*lda2, LDA, X+(j SHIFT) );
   }
#else
   nb1 = N - ( ( N - 1 ) / nb ) * nb;
 
   for( ian = N - nb; ian > 0; ian -= nb )
   {
      ia = ian - K; ia = Mmax( ia, 0 ); ma = ian - ia;  na = Mmin( nb, K );
      kl = ma - 1; kl = Mmax( kl, 0 ); ku = K - 1 - kl; ku = Mmax( ku, 0 );
      tbsv0( nb, K, A+ian*lda2, LDA, X+(ian SHIFT) );
@rout ATL_tbsvUN
      Mjoin( PATL, gbmv )( AtlasNoTrans, ma, na, kl, ku, none, A+ian*lda2,
                           LDA, X+(ian SHIFT), 1, one, X+(ia SHIFT), 1 );
@rout ATL_tbsvUC
      Mjoin( PATL, gbmv )( AtlasConj,    ma, na, kl, ku, none, A+ian*lda2,
                           LDA, X+(ian SHIFT), 1, one, X+(ia SHIFT), 1 );
@rout ATL_tbsvUN ATL_tbsvUC
   }
   tbsv0( nb1, K, A, LDA, X );
#endif
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbsvUT
@define suf @UT@
@rout ATL_tbsvUH
@define suf @UH@
@rout ATL_tbsvUT ATL_tbsvUH
@define rname @Mjoin( PATL, tbsv@(suf) )@
@extract @(VER_ATLAS_SRC)
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*tbsv0)( const int, const int, const TYPE *,
                              const int, TYPE * );
#ifdef TREAL
#define    lda2               LDA
#define    one                ATL_rone
#define    none               ATL_rnone
#else
   TYPE                       none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
   const int                  lda2   = ( LDA SHIFT );
#endif
   int                        ia, ian, j, kl, ku, ma, mb, mb1, n, na, nb;
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVT( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) tbsv0 = Mjoin( PATL, tbsv@(suf)N );
   else                       tbsv0 = Mjoin( PATL, tbsv@(suf)U );

   mb1  = N - ( ( N - 1 ) / mb ) * mb;
 
   for( n = N - mb, j = 0; n > 0; n -= mb, j += mb )
   {
      ian = j + mb; ia = mb - K; ia = j + Mmax( ia, 0 ); ma = ian - ia;
      na = N - ian; na = Mmin( na, K ); kl = ma - 1; kl = Mmax( kl, 0 );
      ku = K - 1 - kl; ku = Mmax( ku, 0 );
      tbsv0( mb, K, A+j*lda2, LDA, X+(j SHIFT) );
@rout ATL_tbsvUT
      Mjoin( PATL, gbmv )( AtlasTrans,     na, ma, kl, ku, none, A+ian*lda2,
                           LDA, X+(ia SHIFT), 1, one, X+(ian SHIFT), 1 );
@rout ATL_tbsvUH
      Mjoin( PATL, gbmv )( AtlasConjTrans, na, ma, kl, ku, none, A+ian*lda2,
                           LDA, X+(ia SHIFT), 1, one, X+(ian SHIFT), 1 );
@rout ATL_tbsvUT ATL_tbsvUH
   }
   tbsv0( mb1, K, A+j*lda2, LDA, X+(j SHIFT) );
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbsvLNN
@define suf    @LNN@
@define trans  @AtlasNoTrans@
@rout ATL_tbsvLNU
@define suf    @LNU@
@define trans  @AtlasNoTrans@
@rout ATL_tbsvLCN
@define suf    @LCN@
@define trans  @AtlasConj@
@rout ATL_tbsvLCU
@define suf    @LCU@
@define trans  @AtlasConj@
@rout ATL_tbsvLNN ATL_tbsvLNU ATL_tbsvLCN ATL_tbsvLCU
@define rname @Mjoin( PATL, tbsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tbsv@(suf)      16
#else
#define    MinN_tbsv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#define    lda2               LDA
#else
   const TYPE                 none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
   const int                  lda2   = ( LDA << 1 );
#endif
   int                        ja, kl, ku, ma, na, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tbsv@(suf) )
   { Mjoin( PATL, reftbsv@(suf) )( N, K, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, tbsv@(suf) )( n1, K, A, LDA, X );
      ja = n1 - K; ja = Mmax( ja, 0 ); ma = Mmin( n2, K );
      ku = na = n1 - ja;  kl = K - ku; kl = Mmax( kl, 0 );
      Mjoin( PATL, gbmv )( @(trans), ma, na, kl, ku, none, A+ja*lda2, LDA,
                           X+(ja SHIFT), 1, one, X+n1s, 1 );
      Mjoin( PATL, tbsv@(suf) )( n2, K, A+n1*lda2, LDA, X+n1s );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef trans
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbsvLTN
@define suf    @LTN@
@define trans  @AtlasTrans@
@rout ATL_tbsvLTU
@define suf    @LTU@
@define trans  @AtlasTrans@
@rout ATL_tbsvLHN
@define suf    @LHN@
@define trans  @AtlasConjTrans@
@rout ATL_tbsvLHU
@define suf    @LHU@
@define trans  @AtlasConjTrans@
@rout ATL_tbsvLTN ATL_tbsvLTU ATL_tbsvLHN ATL_tbsvLHU
@define rname @Mjoin( PATL, tbsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tbsv@(suf)      16
#else
#define    MinN_tbsv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#define    lda2               LDA
#else
   const TYPE                 none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
   const int                  lda2   = ( LDA << 1 );
#endif
   int                        ja, kl, ku, ma, na, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tbsv@(suf) )
   { Mjoin( PATL, reftbsv@(suf) )( N, K, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, tbsv@(suf) )( n2, K, A+n1*lda2, LDA, X+n1s );
      ja = n1 - K; ja = Mmax( ja, 0 ); ma = Mmin( n2, K );
      ku = na = n1 - ja;  kl = K - ku; kl = Mmax( kl, 0 );
      Mjoin( PATL, gbmv )( @(trans), na, ma, kl, ku, none, A+ja*lda2, LDA,
                           X+n1s, 1, one, X+(ja SHIFT), 1 );
      Mjoin( PATL, tbsv@(suf) )( n1, K, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef trans
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbsvUNN
@define suf    @UNN@
@define trans  @AtlasNoTrans@
@rout ATL_tbsvUNU
@define suf    @UNU@
@define trans  @AtlasNoTrans@
@rout ATL_tbsvUCN
@define suf    @UCN@
@define trans  @AtlasConj@
@rout ATL_tbsvUCU
@define suf    @UCU@
@define trans  @AtlasConj@
@rout ATL_tbsvUNN ATL_tbsvUNU ATL_tbsvUCN ATL_tbsvUCU
@define rname @Mjoin( PATL, tbsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tbsv@(suf)      16
#else
#define    MinN_tbsv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#define    lda2               LDA
#else
   const TYPE                 none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
   const int                  lda2   = ( LDA << 1 );
#endif
   int                        ia, kl, ku, ma, na, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tbsv@(suf) )
   { Mjoin( PATL, reftbsv@(suf) )( N, K, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, tbsv@(suf) )( n2, K, A+n1*lda2, LDA, X+n1s );
      ia = n1 - K; ia = Mmax( ia, 0 ); ma = n1 - ia;    na = Mmin( n2, K );
      kl = ma - 1; kl = Mmax( kl, 0 ); ku = K - 1 - kl; ku = Mmax( ku, 0 );
      Mjoin( PATL, gbmv )( @(trans), ma, na, kl, ku, none, A+n1*lda2, LDA,
                           X+n1s, 1, one, X+(ia SHIFT), 1 );
      Mjoin( PATL, tbsv@(suf) )( n1, K, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef trans
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tbsvUTN
@define suf    @UTN@
@define trans  @AtlasTrans@
@rout ATL_tbsvUTU
@define suf    @UTU@
@define trans  @AtlasTrans@
@rout ATL_tbsvUHN
@define suf    @UHN@
@define trans  @AtlasConjTrans@
@rout ATL_tbsvUHU
@define suf    @UHU@
@define trans  @AtlasConjTrans@
@rout ATL_tbsvUTN ATL_tbsvUTU ATL_tbsvUHN ATL_tbsvUHU
@define rname @Mjoin( PATL, tbsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tbsv@(suf)      16
#else
#define    MinN_tbsv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const int                  K,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#define    lda2               LDA
#else
   const TYPE                 none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
   const int                  lda2   = ( LDA << 1 );
#endif
   int                        ia, kl, ku, ma, na, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tbsv@(suf) )
   { Mjoin( PATL, reftbsv@(suf) )( N, K, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, tbsv@(suf) )( n1, K, A, LDA, X );
      ia = n1 - K; ia = Mmax( ia, 0 ); ma = n1 - ia;    na = Mmin( n2, K );
      kl = ma - 1; kl = Mmax( kl, 0 ); ku = K - 1 - kl; ku = Mmax( ku, 0 );
      Mjoin( PATL, gbmv )( @(trans), na, ma, kl, ku, none, A+n1*lda2, LDA,
                           X+(ia SHIFT), 1, one, X+n1s, 1 );
      Mjoin( PATL, tbsv@(suf) )( n2, K, A+n1*lda2, LDA, X+n1s );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef trans
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpsvLN
@define suf @LN@
@rout ATL_tpsvLC
@define suf @LC@
@rout ATL_tpsvLN ATL_tpsvLC
@define rname @Mjoin( PATL, tpsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void  (*tpsv0)( const int, const TYPE *, const int, TYPE * );
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#else
   TYPE                       none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
#endif
#ifdef ATL_AXPYMV
   TYPE                       * A0, * x0;
   int                        incX, lda = LDA, mb, mb1, n, nb;
#else
   TYPE                       * x0;
   int                        incX, lda = LDA, m, mb, nb, nb1;
#endif
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVN( A, N, &mb, &nb );
 
   if( DIAG == AtlasNonUnit ) tpsv0 = Mjoin( PATL, tpsv@(suf)N );
   else                       tpsv0 = Mjoin( PATL, tpsv@(suf)U );

#ifdef ATL_AXPYMV
   mb1 = N - ( ( N - 1 ) / mb ) * mb;
   incX = (mb SHIFT); x0 = X; X += (mb1 SHIFT); A0 = (TYPE *)(A);
 
   tpsv0( mb1, A, lda, x0 ); MLpnext( mb1, A, lda );

   for( n = mb1; n < N; n += mb, X += incX )
   {
@rout ATL_tpsvLN
      Mjoin( PATL, gpmv )( AtlasLower, AtlasNoTrans, mb, n, none,
                           A0 + (n SHIFT), LDA, x0, 1, one, X, 1 );
@rout ATL_tpsvLC
      Mjoin( PATL, gpmv )( AtlasLower, AtlasConj,    mb, n, none,
                           A0 + (n SHIFT), LDA, x0, 1, one, X, 1 );
@rout ATL_tpsvLN ATL_tpsvLC
      tpsv0( mb, A, lda, X ); MLpnext( mb, A, lda );
   }
#else
   nb1  = N - ( ( N - 1 ) / nb ) * nb; incX = (nb SHIFT); x0 = X + (nb SHIFT);
 
   for( m = N - nb; m > 0; m -= nb, x0 += incX, X += incX )
   {
      tpsv0( nb, A, lda, X );
@rout ATL_tpsvLN
      Mjoin( PATL, gpmv )( AtlasLower, AtlasNoTrans, m, nb, none,
                           A + incX, lda, X, 1, one, x0, 1 );
@rout ATL_tpsvLC
      Mjoin( PATL, gpmv )( AtlasLower, AtlasConj,    m, nb, none,
                           A + incX, lda, X, 1, one, x0, 1 );
@rout ATL_tpsvLN ATL_tpsvLC
      MLpnext( nb, A, lda );
   }
   tpsv0( nb1, A, lda, X );
#endif
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpsvLT
@define suf @LT@
@rout ATL_tpsvLH
@define suf @LH@
@rout ATL_tpsvLT ATL_tpsvLH
@define rname @Mjoin( PATL, tpsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void  (*tpsv0)( const int, const TYPE *, const int, TYPE * );
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#else
   TYPE                       none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
#endif
   TYPE                       * A0, * x0;
   int                        incX, lda = LDA, mb, mb1, n, nb;
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVT( A, N, &mb, &nb );

   if( DIAG == AtlasNonUnit ) tpsv0 = Mjoin( PATL, tpsv@(suf)N );
   else                       tpsv0 = Mjoin( PATL, tpsv@(suf)U );

   mb1  = N - ( ( N - 1 ) / mb ) * mb; incX = (mb SHIFT); x0 = X;
   A0 = (TYPE *)(A); MLpnext( N-mb, A, lda );
 
   for( n  = N - mb, X += ((N-mb) SHIFT); n > 0; n -= mb, X -= incX )
   {
      tpsv0( mb, A, lda, X ); MLpprev( mb, A, lda );
@rout ATL_tpsvLT
      Mjoin( PATL, gpmv )( AtlasLower, AtlasTrans,     n, mb, none,
                           A0 + (n SHIFT), LDA, X, 1, one, x0, 1 );
@rout ATL_tpsvLH
      Mjoin( PATL, gpmv )( AtlasLower, AtlasConjTrans, n, mb, none,
                           A0 + (n SHIFT), LDA, X, 1, one, x0, 1 );
@rout ATL_tpsvLT ATL_tpsvLH
   }
   tpsv0( mb1, A0, LDA, x0 );
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpsvUN
@define suf @UN@
@rout ATL_tpsvUC
@define suf @UC@
@rout ATL_tpsvUN ATL_tpsvUC
@define rname @Mjoin( PATL, tpsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*tpsv0)( const int, const TYPE *, const int,
                              TYPE * );
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#else
   TYPE                       none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
#endif
#ifdef ATL_AXPYMV
   TYPE                       * x0;
   int                        incX, lda = LDA, m1, mb, mb1, n, nb;
#else
   TYPE                       * A0, * x0;
   int                        incX, lda = LDA, m, mb, nb, nb1;
#endif
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVN( A, N, &mb, &nb );

   if( DIAG == AtlasNonUnit ) tpsv0 = Mjoin( PATL, tpsv@(suf)N );
   else                       tpsv0 = Mjoin( PATL, tpsv@(suf)U );

#ifdef ATL_AXPYMV
   mb1  = N - ( m1 = ( ( N - 1 ) / mb ) * mb ); incX = (mb SHIFT);
   X += (m1 SHIFT); x0 = X; MUpnext( m1, A, lda );
   tpsv0( mb1, A, lda, X ); X -= incX;

   for( n  = mb1; n < N; n += mb, X -= incX, x0 -= incX )
   {
@rout ATL_tpsvUN
      Mjoin( PATL, gpmv )( AtlasUpper, AtlasNoTrans, mb, n, none,
                           A - incX, lda, x0, 1, one, X, 1 );
@rout ATL_tpsvUC
      Mjoin( PATL, gpmv )( AtlasUpper, AtlasConj,    mb, n, none,
                           A - incX, lda, x0, 1, one, X, 1 );
@rout ATL_tpsvUN ATL_tpsvUC
      MUpprev( mb, A, lda ); tpsv0( mb, A, lda, X );
   }
#else
   nb1  = N - ( ( N - 1 ) / nb ) * nb; incX = (nb SHIFT); x0 = X;
   A0 = (TYPE *)(A); MUpnext( N-nb, A, lda );
 
   for( m = N - nb, X += ((N-nb) SHIFT); m > 0; m -= nb, X -= incX )
   { 
      tpsv0( nb, A, lda, X );
@rout ATL_tpsvUN
      Mjoin( PATL, gpmv )( AtlasUpper, AtlasNoTrans, m, nb, none,
                           A - (m SHIFT), lda, X, 1, one, x0, 1 );
@rout ATL_tpsvUC
      Mjoin( PATL, gpmv )( AtlasUpper, AtlasConj,    m, nb, none,
                           A - (m SHIFT), lda, X, 1, one, x0, 1 );
@rout ATL_tpsvUN ATL_tpsvUC
      MUpprev( nb, A, lda );
   }
   tpsv0( nb1, A0, LDA, x0 );
#endif
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpsvUT
@define suf @UT@
@rout ATL_tpsvUH
@define suf @UH@
@rout ATL_tpsvUT ATL_tpsvUH
@define rname @Mjoin( PATL, tpsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*tpsv0)( const int, const TYPE *, const int,
                              TYPE * );
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#else
   TYPE                       none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
#endif
   TYPE                       * x0;
   int                        incX, lda = LDA, mb, mb1, n, nb;
@extract @(EXECUTABLE_STATEMENT) 
   ATL_GetPartMVT( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) tpsv0 = Mjoin( PATL, tpsv@(suf)N );
   else                       tpsv0 = Mjoin( PATL, tpsv@(suf)U );

   mb1  = N - ( ( N - 1 ) / mb ) * mb; incX = (mb SHIFT);
 
   for( n  = N - mb, x0 = X + incX; n > 0; n -= mb, X += incX, x0 += incX )
   {
      tpsv0( mb, A, lda, X ); MUpnext( mb, A, lda );
@rout ATL_tpsvUT
      Mjoin( PATL, gpmv )( AtlasUpper, AtlasTrans,     n, mb, none,
                           A - (mb SHIFT), lda, X, 1, one, x0, 1 );
@rout ATL_tpsvUH
      Mjoin( PATL, gpmv )( AtlasUpper, AtlasConjTrans, n, mb, none,
                           A - (mb SHIFT), lda, X, 1, one, x0, 1 );
@rout ATL_tpsvUT ATL_tpsvUH
   }
   tpsv0( mb1, A, lda, X );
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpsvLNN
@define suf @LNN@
@define trans  @AtlasNoTrans@
@rout ATL_tpsvLNU
@define suf @LNU@
@define trans  @AtlasNoTrans@
@rout ATL_tpsvLCN
@define suf @LCN@
@define trans  @AtlasConj@
@rout ATL_tpsvLCU
@define suf @LCU@
@define trans  @AtlasConj@
@rout ATL_tpsvLNN ATL_tpsvLNU ATL_tpsvLCN ATL_tpsvLCU
@define rname @Mjoin( PATL, tpsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tpsv@(suf)      16
#else
#define    MinN_tpsv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#else
   const TYPE                 none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
#endif
   TYPE                       * x0;
   int                        lda = LDA, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tpsv@(suf) )
   { Mjoin( PATL, reftpsv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, tpsv@(suf) )( n1, A, lda, X ); x0 = X; X += n1s;
      Mjoin( PATL, gpmv )( AtlasLower, @(trans), n2, n1, none, A + n1s,
                           lda, x0, 1, one, X, 1 );
      MLpnext( n1, A, lda ); Mjoin( PATL, tpsv@(suf) )( n2, A, lda, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef trans
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpsvLTN
@define suf @LTN@
@define trans  @AtlasTrans@
@rout ATL_tpsvLTU
@define suf @LTU@
@define trans  @AtlasTrans@
@rout ATL_tpsvLHN
@define suf @LHN@
@define trans  @AtlasConjTrans@
@rout ATL_tpsvLHU
@define suf @LHU@
@define trans  @AtlasConjTrans@
@rout ATL_tpsvLTN ATL_tpsvLTU ATL_tpsvLHN ATL_tpsvLHU
@define rname @Mjoin( PATL, tpsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tpsv@(suf)      16
#else
#define    MinN_tpsv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#else
   const TYPE                 none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
#endif
   TYPE                       * x0;
   int                        lda = LDA, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tpsv@(suf) )
   { Mjoin( PATL, reftpsv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      x0 = X + n1s; MLpnext( n1, A, lda );
      Mjoin( PATL, tpsv@(suf) )( n2, A, lda, x0 ); MLpprev( n1, A, lda );
      Mjoin( PATL, gpmv )( AtlasLower, @(trans), n1, n2, none, A + n1s,
                           lda, x0, 1, one, X, 1 );
      Mjoin( PATL, tpsv@(suf) )( n1, A, lda, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef trans
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpsvUNN
@define suf @UNN@
@define trans  @AtlasNoTrans@
@rout ATL_tpsvUNU
@define suf @UNU@
@define trans  @AtlasNoTrans@
@rout ATL_tpsvUCN
@define suf @UCN@
@define trans  @AtlasConj@
@rout ATL_tpsvUCU
@define suf @UCU@
@define trans  @AtlasConj@
@rout ATL_tpsvUNN ATL_tpsvUNU ATL_tpsvUCN ATL_tpsvUCU
@define rname @Mjoin( PATL, tpsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tpsv@(suf)      16
#else
#define    MinN_tpsv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#else
   const TYPE                 none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
#endif
   TYPE                       * x0;
   int                        lda = LDA, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tpsv@(suf) )
   { Mjoin( PATL, reftpsv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      MUpnext( n1, A, lda ); x0 = X + n1s;
      Mjoin( PATL, tpsv@(suf) )( n2, A, lda, x0 );
      Mjoin( PATL, gpmv )( AtlasUpper, @(trans), n1, n2, none, A - n1s,
                           lda, x0, 1, one, X, 1 );
      MUpprev( n1, A, lda ); Mjoin( PATL, tpsv@(suf) )( n1, A, lda, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef trans
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_tpsvUTN
@define suf @UTN@
@define trans  @AtlasTrans@
@rout ATL_tpsvUTU
@define suf @UTU@
@define trans  @AtlasTrans@
@rout ATL_tpsvUHN
@define suf @UHN@
@define trans  @AtlasConjTrans@
@rout ATL_tpsvUHU
@define suf @UHU@
@define trans  @AtlasConjTrans@
@rout ATL_tpsvUTN ATL_tpsvUTU ATL_tpsvUHN ATL_tpsvUHU
@define rname @Mjoin( PATL, tpsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_tpsv@(suf)      16
#else
#define    MinN_tpsv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#else
   const TYPE                 none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
#endif
   TYPE                       * x0;
   int                        lda = LDA, n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_tpsv@(suf) )
   { Mjoin( PATL, reftpsv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, tpsv@(suf) )( n1, A, lda, X );
      MUpnext( n1, A, lda ); x0 = X; X += n1s;
      Mjoin( PATL, gpmv )( AtlasUpper, @(trans), n2, n1, none, A - n1s,
                           lda, x0, 1, one, X, 1 );
      Mjoin( PATL, tpsv@(suf) )( n2, A, lda, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef trans
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trsvLN
@define suf @LN@
@rout ATL_trsvLC
@define suf @LC@
@rout ATL_trsvLN ATL_trsvLC
@define rname @Mjoin( PATL, trsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*trsv0)( const int, const TYPE *, const int,
                              TYPE * );
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#define    lda2               LDA
   TYPE                       * A0, * x0;
#else
   TYPE                       none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
   TYPE                       * A0, * x0;
   const int                  lda2    = ( LDA SHIFT );
#endif
#ifdef ATL_AXPYMV
   int                        incA, incA0, incX, mb, mb1, n, nb;
#else
   int                        incA, incX, m, mb, nb, nb1;
#endif
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVN( A, LDA, &mb, &nb );
 
   if( DIAG == AtlasNonUnit ) trsv0 = Mjoin( PATL, trsv@(suf)N );
   else                       trsv0 = Mjoin( PATL, trsv@(suf)U );

#ifdef ATL_AXPYMV
   mb1  = N - ( ( N - 1 ) / mb ) * mb;
   incA = mb * lda2 + ( incA0 = incX = (mb SHIFT) );
   A0   = (TYPE *)(A) + (mb1 SHIFT); x0 = X; X += (mb1 SHIFT);
 
   trsv0( mb1, A, LDA, x0 );
   for( n = mb1, A += (mb1 SHIFT) + mb1 * lda2; n < N;
        n += mb, A0 += incA0, A += incA, X += incX )
   {
@rout ATL_trsvLN
      Mjoin( PATL, gemv )( AtlasNoTrans, mb, n, none, A0, LDA, x0, 1,
                           one, X, 1 );
@rout ATL_trsvLC
      Mjoin( PATL, gemv )( AtlasConj,    mb, n, none, A0, LDA, x0, 1,
                           one, X, 1 );
@rout ATL_trsvLN ATL_trsvLC
      trsv0( mb, A, LDA, X );
   }
#else
   nb1  = N - ( ( N - 1 ) / nb ) * nb;
   incA = nb * lda2 + ( incX = (nb SHIFT) );
   A0   = (TYPE *)(A) + (nb SHIFT); x0 = X + (nb SHIFT);
 
   for( m = N - nb; m > 0;
        m -= nb, A0 += incA, A += incA, x0 += incX, X += incX )
   {
      trsv0( nb, A, LDA, X );
@rout ATL_trsvLN
      Mjoin( PATL, gemv )( AtlasNoTrans, m, nb, none, A0, LDA, X, 1,
                           one, x0, 1 );
@rout ATL_trsvLC
      Mjoin( PATL, gemv )( AtlasConj,    m, nb, none, A0, LDA, X, 1,
                           one, x0, 1 );
@rout ATL_trsvLN ATL_trsvLC
   }
   trsv0( nb1, A, LDA, X );
#endif
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trsvLT
@define suf @LT@
@rout ATL_trsvLH
@define suf @LH@
@rout ATL_trsvLT ATL_trsvLH
@define rname @Mjoin( PATL, trsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*trsv0)( const int, const TYPE *, const int,
                              TYPE * );
   TYPE                       * A0, * x0;
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#define    lda2               LDA
#else
   TYPE                       none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
   const int                  lda2    = ( LDA SHIFT );
#endif
   int                        incA, incX, mb, mb1, n, nb;
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVT( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) trsv0 = Mjoin( PATL, trsv@(suf)N );
   else                       trsv0 = Mjoin( PATL, trsv@(suf)U );

   mb1  = N - ( ( N - 1 ) / mb ) * mb;
   incA = incX = (mb SHIFT); A0 = (TYPE *)(A); x0 = X;
 
   for( n  = N - mb, A += ((N-mb) SHIFT), X += ((N-mb) SHIFT); n > 0;
        n -= mb,     A -= incA,           X -= incX )
   {
      trsv0( mb, A+n*lda2, LDA, X );
@rout ATL_trsvLT
      Mjoin( PATL, gemv )( AtlasTrans,     mb, n, none, A, LDA, X, 1,
                           one, x0, 1 );
@rout ATL_trsvLH
      Mjoin( PATL, gemv )( AtlasConjTrans, mb, n, none, A, LDA, X, 1,
                           one, x0, 1 );
@rout ATL_trsvLT ATL_trsvLH
   }
   trsv0( mb1, A0, LDA, x0 );
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trsvUN
@define suf @UN@
@rout ATL_trsvUC
@define suf @UC@
@rout ATL_trsvUN ATL_trsvUC
@define rname @Mjoin( PATL, trsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*trsv0)( const int, const TYPE *, const int,
                              TYPE * );
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#define    lda2               LDA
   TYPE                       * A0, * x0;
#else
   TYPE                       none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
   TYPE                       * A0, * x0;
   const int                  lda2    = ( LDA SHIFT );
#endif
#ifdef ATL_AXPYMV
   int                        incA, incX, m1, mb, mb1, n, nb;
#else
   int                        incA, incX, m, mb, nb, nb1;
#endif
@extract @(EXECUTABLE_STATEMENT)
   ATL_GetPartMVN( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) trsv0 = Mjoin( PATL, trsv@(suf)N );
   else                       trsv0 = Mjoin( PATL, trsv@(suf)U );

#ifdef ATL_AXPYMV
   mb1  = N - ( m1 = ( ( N - 1 ) / mb ) * mb );
   incA = ( incX  = (mb SHIFT) ) + mb * lda2;
 
   A += (m1 SHIFT) + m1 * lda2; X += (m1 SHIFT);
   A0 = (TYPE *)(A) - incX;     x0 = X;

   trsv0( mb1, A, LDA, X ); X -= incX; A -= incA;
   for( n  = mb1; n < N; n += mb, A0 -= incA, A -= incA, X -= incX, x0 -= incX )
   {
@rout ATL_trsvUN
      Mjoin( PATL, gemv )( AtlasNoTrans, mb, n, none, A0, LDA, x0, 1,
                           one, X, 1 );
@rout ATL_trsvUC
      Mjoin( PATL, gemv )( AtlasConj, mb, n, none, A0, LDA, x0, 1,
                           one, X, 1 );
@rout ATL_trsvUN ATL_trsvUC
      trsv0( mb, A, LDA, X );
   }
#else
   nb1  = N - ( ( N - 1 ) / nb ) * nb;
   incA = nb * lda2; incX = (nb SHIFT); A0 = (TYPE *)(A);  x0 = X;
 
   for( m  = N - nb, A += (N-nb) * lda2, X += ((N-nb) SHIFT); m > 0;
        m -= nb,     A -= incA,          X -= incX )
   { 
      trsv0( nb, A+(m SHIFT), LDA, X );
@rout ATL_trsvUN
      Mjoin( PATL, gemv )( AtlasNoTrans, m, nb, none, A, LDA, X, 1,
                           one, x0, 1 );
@rout ATL_trsvUC
      Mjoin( PATL, gemv )( AtlasConj,    m, nb, none, A, LDA, X, 1,
                           one, x0, 1 );
@rout ATL_trsvUN ATL_trsvUC
   }
   trsv0( nb1, A0, LDA, x0 );
#endif
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trsvUT
@define suf @UT@
@rout ATL_trsvUH
@define suf @UH@
@rout ATL_trsvUT ATL_trsvUH
@define rname @Mjoin( PATL, trsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)
 
void @(rname)
(
   const enum ATLAS_DIAG      DIAG,
   const int                  N,         /* N > 0 assumed */
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
   void                       (*trsv0)( const int, const TYPE *, const int,
                              TYPE * );
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#define    lda2               LDA
   TYPE                       * A0, * x0;
#else
   TYPE                       none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
   TYPE                       * A0, * x0;
   const int                  lda2    = ( LDA SHIFT );
#endif
   int                        incA, incX, mb, mb1, n, nb;
@extract @(EXECUTABLE_STATEMENT) 
   ATL_GetPartMVT( A, LDA, &mb, &nb );

   if( DIAG == AtlasNonUnit ) trsv0 = Mjoin( PATL, trsv@(suf)N );
   else                       trsv0 = Mjoin( PATL, trsv@(suf)U );

   mb1  = N - ( ( N - 1 ) / mb ) * mb;
   incA = mb * lda2 + ( incX = (mb SHIFT) );
 
   for( n  = N - mb, A0 = (TYPE *)(A) + mb * lda2, x0 = X + incX; n > 0;
        n -= mb, A0 += incA, A += incA, X += incX, x0 += incX )
   {
      trsv0( mb, A, LDA, X );
@rout ATL_trsvUT
      Mjoin( PATL, gemv )( AtlasTrans,     mb, n, none, A0, LDA, X, 1,
                           one, x0, 1 );
@rout ATL_trsvUH
      Mjoin( PATL, gemv )( AtlasConjTrans, mb, n, none, A0, LDA, X, 1,
                           one, x0, 1 );
@rout ATL_trsvUT ATL_trsvUH
   }
   trsv0( mb1, A, LDA, X );
@extract @(END_OF_ROUTINE)
@undef rname
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trsvLNN
@define suf    @LNN@
@define trans  @AtlasNoTrans@
@rout ATL_trsvLNU
@define suf    @LNU@
@define trans  @AtlasNoTrans@
@rout ATL_trsvLCN
@define suf    @LCN@
@define trans  @AtlasConj@
@rout ATL_trsvLCU
@define suf    @LCU@
@define trans  @AtlasConj@
@rout ATL_trsvLNN ATL_trsvLNU ATL_trsvLCN ATL_trsvLCU
@define rname @Mjoin( PATL, trsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_trsv@(suf)      16
#else
#define    MinN_trsv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#else
   const TYPE                 none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
#endif
   TYPE                       * x0;
   int                        n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_trsv@(suf) )
   { Mjoin( PATL, reftrsv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, trsv@(suf) )( n1, A, LDA, X ); x0 = X; X += n1s;
      Mjoin( PATL, gemv )( @(trans), n2, n1, none, A + n1s, LDA,
                           x0, 1, one, X, 1 );
      MLrnext( n1, A, LDA ); Mjoin( PATL, trsv@(suf) )( n2, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef trans
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trsvLTN
@define suf    @LTN@
@define trans  @AtlasTrans@
@rout ATL_trsvLTU
@define suf    @LTU@
@define trans  @AtlasTrans@
@rout ATL_trsvLHN
@define suf    @LHN@
@define trans  @AtlasConjTrans@
@rout ATL_trsvLHU
@define suf    @LHU@
@define trans  @AtlasConjTrans@
@rout ATL_trsvLTN ATL_trsvLTU ATL_trsvLHN ATL_trsvLHU
@define rname @Mjoin( PATL, trsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_trsv@(suf)      16
#else
#define    MinN_trsv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#else
   const TYPE                 none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
#endif
   TYPE                       * x0;
   int                        n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_trsv@(suf) )
   { Mjoin( PATL, reftrsv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      MLrnext( n1, A, LDA ); x0 = X + n1s;
      Mjoin( PATL, trsv@(suf) )( n2, A, LDA, x0 ); MLrprev( n1, A, LDA ); 
      Mjoin( PATL, gemv )( @(trans), n1, n2, none, A + n1s, LDA,
                           x0, 1, one, X, 1 );
      Mjoin( PATL, trsv@(suf) )( n1, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef trans
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trsvUNN
@define suf    @UNN@
@define trans  @AtlasNoTrans@
@rout ATL_trsvUNU
@define suf    @UNU@
@define trans  @AtlasNoTrans@
@rout ATL_trsvUCN
@define suf    @UCN@
@define trans  @AtlasConj@
@rout ATL_trsvUCU
@define suf    @UCU@
@define trans  @AtlasConj@
@rout ATL_trsvUNN ATL_trsvUNU ATL_trsvUCN ATL_trsvUCU
@define rname @Mjoin( PATL, trsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_trsv@(suf)      16
#else
#define    MinN_trsv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#else
   const TYPE                 none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
#endif
   TYPE                       * x0;
   int                        n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_trsv@(suf) )
   { Mjoin( PATL, reftrsv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      MUrnext( n1, A, LDA ); x0 = X + n1s;
      Mjoin( PATL, trsv@(suf) )( n2, A, LDA, x0 );
      Mjoin( PATL, gemv )( @(trans), n1, n2, none, A - n1s, LDA,
                           x0, 1, one, X, 1 );
      MUrprev( n1, A, LDA ); Mjoin( PATL, trsv@(suf) )( n1, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef trans
@undef suf
@skip
@skip ==================================================================
@skip
@rout ATL_trsvUTN
@define suf    @UTN@
@define trans  @AtlasTrans@
@rout ATL_trsvUTU
@define suf    @UTU@
@define trans  @AtlasTrans@
@rout ATL_trsvUHN
@define suf    @UHN@
@define trans  @AtlasConjTrans@
@rout ATL_trsvUHU
@define suf    @UHU@
@define trans  @AtlasConjTrans@
@rout ATL_trsvUTN ATL_trsvUTU ATL_trsvUHN ATL_trsvUHU
@define rname @Mjoin( PATL, trsv@(suf) )@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
@extract @(RC2_INCLUDE)

#ifdef TREAL
#define    MinN_trsv@(suf)      16
#else
#define    MinN_trsv@(suf)       8
#endif
 
void @(rname)
(
   const int                  N,
   const TYPE                 * A,
   const int                  LDA,
   TYPE                       * X
)
{
@extract @(ATLAS_RC2_COMMENT)
@extract @(LOCAL_VARIABLE)
#ifdef TREAL
#define    none               ATL_rnone
#define    one                ATL_rone
#else
   const TYPE                 none[2] = { ATL_rnone, ATL_rzero },
                              one [2] = { ATL_rone,  ATL_rzero };
#endif
   TYPE                       * x0;
   int                        n1, n1s, n2;
@extract @(EXECUTABLE_STATEMENT)
   if( N <= MinN_trsv@(suf) )
   { Mjoin( PATL, reftrsv@(suf) )( N, A, LDA, X, 1 ); }
   else
   {
      n2 = N - ( n1 = ( N >> 1 ) ); n1s = (n1 SHIFT);
      Mjoin( PATL, trsv@(suf) )( n1, A, LDA, X );
      x0 = X; MUrnext( n1, A, LDA ); X += n1s;
      Mjoin( PATL, gemv )( @(trans), n2, n1, none, A - n1s, LDA,
                           x0, 1, one, X, 1 );
      Mjoin( PATL, trsv@(suf) )( n2, A, LDA, X );
   }
@extract @(END_OF_ROUTINE)
@undef rname
@undef trans
@undef suf
@skip
@skip ==================================================================
@skip
@rout atlas_kernel2.h
@define rname @atlas_kernel2.h@
@extract @(VER_ATLAS_SRC) -def contributor "@(clint)"
#ifndef ATLAS_KERNEL2_H
#define ATLAS_KERNEL2_H
/*
 * =====================================================================
 * Macro function definitions
 * =====================================================================
 */
#define    ATL_GetPartSBMV    ATL_GetPartSYMV
#define    ATL_GetPartSPMV    ATL_GetPartSYMV
#define    ATL_GetPartP1      ATL_GetPartR1

#define MLpprev( n_, a_, lda_ ) \
 { a_ -= ( (((n_) * (lda_)) + (((n_)*((n_)+1)) >> 1)) SHIFT ); lda_ += (n_); }
#define MUpprev( n_, a_, lda_ ) \
 { a_ -= ( (((n_) * (lda_)) - (((n_)*((n_)-1)) >> 1)) SHIFT ); lda_ -= (n_); }
#define MLpnext( n_, a_, lda_ ) \
 { a_ += ( (((n_) * (lda_)) - (((n_)*((n_)-1)) >> 1)) SHIFT ); lda_ -= (n_); }
#define MUpnext( n_, a_, lda_ ) \
 { a_ += ( (((n_) * (lda_)) + (((n_)*((n_)+1)) >> 1)) SHIFT ); lda_ += (n_); }

#define MLrprev( n_, a_, lda_ ) \
 { a_ -= ( ((n_) * ((lda_)+1)) SHIFT ); }
#define MUrprev( n_, a_, lda_ ) \
 { a_ -= ( ((n_) * ((lda_)+1)) SHIFT ); }
#define MLrnext( n_, a_, lda_ ) \
 { a_ += ( ((n_) * ((lda_)+1)) SHIFT ); }
#define MUrnext( n_, a_, lda_ ) \
 { a_ += ( ((n_) * ((lda_)+1)) SHIFT ); }
/*
 * =====================================================================
 * Recursive Level 2 BLAS function prototypes
 * =====================================================================
 */
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s
      @define sca_in_    @const float@
      @define rsca_in_   @const float@
      @define mat_in_    @const float *,          const int@
      @define mat_out_   @float *,                const int@
      @define pmat_in_   @const float *@
      @define pmat_out_  @float *@
      @define vec_in_    @const float *,          const int@
      @define vec_out_   @float *,                const int@
      @define ve1_in_    @const float *@
      @define ve1_out_   @float *      @
   @ptyp_ d
      @define sca_in_    @const double@
      @define rsca_in_   @const double@
      @define mat_in_    @const double *,         const int@
      @define mat_out_   @double *,               const int@
      @define pmat_in_   @const double *@
      @define pmat_out_  @double *@
      @define vec_in_    @const double *,         const int@
      @define vec_out_   @double *,               const int@
      @define ve1_in_    @const double *@
      @define ve1_out_   @double *      @
   @ptyp_ s d
      @multidef rout_
         gbmvN_a1_x1_b0_y1       gbmvT_a1_x1_b0_y1
         gbmvN_a1_x1_b1_y1       gbmvT_a1_x1_b1_y1
         gbmvN_a1_x1_bX_y1       gbmvT_a1_x1_bX_y1
         gpmvLN_a1_x1_b0_y1      gpmvLT_a1_x1_b0_y1
         gpmvLN_a1_x1_b1_y1      gpmvLT_a1_x1_b1_y1
         gpmvLN_a1_x1_bX_y1      gpmvLT_a1_x1_bX_y1
         gpmvUN_a1_x1_b0_y1      gpmvUT_a1_x1_b0_y1
         gpmvUN_a1_x1_b1_y1      gpmvUT_a1_x1_b1_y1
         gpmvUN_a1_x1_bX_y1      gpmvUT_a1_x1_bX_y1
         gpr1L_a1_x1_yX          gpr1U_a1_x1_yX
         gpr     gprL    gprU    gpmv
         sbmvL   sbmvU   spmvL   spmvU   symvL   symvU
         sprL    sprU    syrL    syrU    
         spr2L   spr2U   syr2L   syr2U
         tbmvUN  tbmvUT  tbmvLN  tbmvLT
         tbmvUNN tbmvUTN tbmvUNU tbmvUTU tbmvLNN tbmvLTN tbmvLNU tbmvLTU
         tpmvUN  tpmvUT  tpmvLN  tpmvLT
         tpmvUNN tpmvUTN tpmvUNU tpmvUTU tpmvLNN tpmvLTN tpmvLNU tpmvLTU
         trmvUN  trmvUT  trmvLN  trmvLT
         trmvUNN trmvUTN trmvUNU trmvUTU trmvLNN trmvLTN trmvLNU trmvLTU
         tbsvUN  tbsvUT  tbsvLN  tbsvLT
         tbsvUNN tbsvUTN tbsvUNU tbsvUTU tbsvLNN tbsvLTN tbsvLNU tbsvLTU
         tpsvUN  tpsvUT  tpsvLN  tpsvLT
         tpsvUNN tpsvUTN tpsvUNU tpsvUTU tpsvLNN tpsvLTN tpsvLNU tpsvLTU
         trsvUN  trsvUT  trsvLN  trsvLT
         trsvUNN trsvUTN trsvUNU trsvUTU trsvLNN trsvLTN trsvLNU trsvLTU
      @endmultidef
   @ptyp_ c
      @define sca_in_    @const float *@
      @define rsca_in_   @const float@
      @define mat_in_    @const float *,          const int@
      @define mat_out_   @float *,                const int@
      @define pmat_in_   @const float *@
      @define pmat_out_  @float *@
      @define vec_in_    @const float *,          const int@
      @define vec_out_   @float *,                const int@
      @define ve1_in_    @const float *@
      @define ve1_out_   @float *      @
   @ptyp_ z
      @define sca_in_    @const double *@
      @define rsca_in_   @const double@
      @define mat_in_    @const double *,         const int@
      @define mat_out_   @double *,               const int@
      @define pmat_in_   @const double *@
      @define pmat_out_  @double *@
      @define vec_in_    @const double *,         const int@
      @define vec_out_   @double *,               const int@
      @define ve1_in_    @const double *@
      @define ve1_out_   @double *      @
   @ptyp_ c z
      @multidef rout_
         gbmvN_a1_x1_b0_y1       gbmvT_a1_x1_b0_y1
         gbmvC_a1_x1_b0_y1       gbmvNc_a1_x1_b0_y1
         gbmvN_a1_x1_bXi0_y1     gbmvT_a1_x1_bXi0_y1
         gbmvC_a1_x1_bXi0_y1     gbmvNc_a1_x1_bXi0_y1
         gbmvN_a1_x1_b1_y1       gbmvT_a1_x1_b1_y1
         gbmvC_a1_x1_b1_y1       gbmvNc_a1_x1_b1_y1
         gbmvN_a1_x1_bX_y1       gbmvT_a1_x1_bX_y1
         gbmvC_a1_x1_bX_y1       gbmvNc_a1_x1_bX_y1
         gpmvLN_a1_x1_b0_y1      gpmvLT_a1_x1_b0_y1
         gpmvLC_a1_x1_b0_y1      gpmvLNc_a1_x1_b0_y1
         gpmvLN_a1_x1_bXi0_y1    gpmvLT_a1_x1_bXi0_y1
         gpmvLC_a1_x1_bXi0_y1    gpmvLNc_a1_x1_bXi0_y1
         gpmvLN_a1_x1_b1_y1      gpmvLT_a1_x1_b1_y1
         gpmvLC_a1_x1_b1_y1      gpmvLNc_a1_x1_b1_y1
         gpmvLN_a1_x1_bX_y1      gpmvLT_a1_x1_bX_y1
         gpmvLC_a1_x1_bX_y1      gpmvLNc_a1_x1_bX_y1
         gpmvUN_a1_x1_b0_y1      gpmvUT_a1_x1_b0_y1
         gpmvUC_a1_x1_b0_y1      gpmvUNc_a1_x1_b0_y1
         gpmvUN_a1_x1_bXi0_y1    gpmvUT_a1_x1_bXi0_y1
         gpmvUC_a1_x1_bXi0_y1    gpmvUNc_a1_x1_bXi0_y1
         gpmvUN_a1_x1_b1_y1      gpmvUT_a1_x1_b1_y1
         gpmvUC_a1_x1_b1_y1      gpmvUNc_a1_x1_b1_y1
         gpmvUN_a1_x1_bX_y1      gpmvUT_a1_x1_bX_y1
         gpmvUC_a1_x1_bX_y1      gpmvUNc_a1_x1_bX_y1
         gpr1cL_a1_x1_yX         gpr1cU_a1_x1_yX
         gpr1uL_a1_x1_yX         gpr1uU_a1_x1_yX
         gprc    gprcL   gprcU   gpru    gpruL   gpruU   gpmv
         hbmvL   hbmvU   hpmvL   hpmvU   hemvL   hemvU   
         hprL    hprU    herL    herU    
         hpr2L   hpr2U   her2L   her2U
         tbmvUN  tbmvUT  tbmvUC  tbmvUH  tbmvLN  tbmvLT  tbmvLC  tbmvLH
         tbmvUNN tbmvUTN tbmvUCN tbmvUHN tbmvUNU tbmvUTU tbmvUCU tbmvUHU
         tbmvLNN tbmvLTN tbmvLCN tbmvLHN tbmvLNU tbmvLTU tbmvLCU tbmvLHU
         tpmvUN  tpmvUT  tpmvUC  tpmvUH  tpmvLN  tpmvLT  tpmvLC  tpmvLH
         tpmvUNN tpmvUTN tpmvUCN tpmvUHN tpmvUNU tpmvUTU tpmvUCU tpmvUHU
         tpmvLNN tpmvLTN tpmvLCN tpmvLHN tpmvLNU tpmvLTU tpmvLCU tpmvLHU
         trmvUN  trmvUT  trmvUC  trmvUH  trmvLN  trmvLT  trmvLC  trmvLH
         trmvUNN trmvUTN trmvUCN trmvUHN trmvUNU trmvUTU trmvUCU trmvUHU
         trmvLNN trmvLTN trmvLCN trmvLHN trmvLNU trmvLTU trmvLCU trmvLHU
         tbsvUN  tbsvUT  tbsvUC  tbsvUH  tbsvLN  tbsvLT  tbsvLC  tbsvLH
         tbsvUNN tbsvUTN tbsvUCN tbsvUHN tbsvUNU tbsvUTU tbsvUCU tbsvUHU
         tbsvLNN tbsvLTN tbsvLCN tbsvLHN tbsvLNU tbsvLTU tbsvLCU tbsvLHU
         tpsvUN  tpsvUT  tpsvUC  tpsvUH  tpsvLN  tpsvLT  tpsvLC  tpsvLH
         tpsvUNN tpsvUTN tpsvUCN tpsvUHN tpsvUNU tpsvUTU tpsvUCU tpsvUHU
         tpsvLNN tpsvLTN tpsvLCN tpsvLHN tpsvLNU tpsvLTU tpsvLCU tpsvLHU
         trsvUN  trsvUT  trsvUC  trsvUH  trsvLN  trsvLT  trsvLC  trsvLH
         trsvUNN trsvUTN trsvUCN trsvUHN trsvUNU trsvUTU trsvUCU trsvUHU
         trsvLNN trsvLTN trsvLCN trsvLHN trsvLNU trsvLTU trsvLCU trsvLHU
      @endmultidef
   @ptyp_ !
   @whiledef rout_
      @addkeys prou_=@(rout_)
void       ATL_@(pre_)@(rout_)
(
      @prou_ gbmvN_a1_x1_b0_y1   gbmvT_a1_x1_b0_y1
  const int,              const int,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gbmvC_a1_x1_b0_y1   gbmvNc_a1_x1_b0_y1
  const int,              const int,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gbmvN_a1_x1_bXi0_y1 gbmvT_a1_x1_bXi0_y1
  const int,              const int,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gbmvC_a1_x1_bXi0_y1 gbmvNc_a1_x1_bXi0_y1
  const int,              const int,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gbmvN_a1_x1_b1_y1   gbmvT_a1_x1_b1_y1
  const int,              const int,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gbmvC_a1_x1_b1_y1   gbmvNc_a1_x1_b1_y1
  const int,              const int,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gbmvN_a1_x1_bX_y1   gbmvT_a1_x1_bX_y1
  const int,              const int,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gbmvC_a1_x1_bX_y1   gbmvNc_a1_x1_bX_y1
  const int,              const int,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvLN_a1_x1_b0_y1   gpmvLT_a1_x1_b0_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvLC_a1_x1_b0_y1   gpmvLNc_a1_x1_b0_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvLN_a1_x1_bXi0_y1 gpmvLT_a1_x1_bXi0_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvLC_a1_x1_bXi0_y1 gpmvLNc_a1_x1_bXi0_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvLN_a1_x1_b1_y1   gpmvLT_a1_x1_b1_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvLC_a1_x1_b1_y1   gpmvLNc_a1_x1_b1_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvLN_a1_x1_bX_y1   gpmvLT_a1_x1_bX_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvLC_a1_x1_bX_y1   gpmvLNc_a1_x1_bX_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvUN_a1_x1_b0_y1   gpmvUT_a1_x1_b0_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvUC_a1_x1_b0_y1   gpmvUNc_a1_x1_b0_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvUN_a1_x1_bXi0_y1 gpmvUT_a1_x1_bXi0_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvUC_a1_x1_bXi0_y1 gpmvUNc_a1_x1_bXi0_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvUN_a1_x1_b1_y1   gpmvUT_a1_x1_b1_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvUC_a1_x1_b1_y1   gpmvUNc_a1_x1_b1_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvUN_a1_x1_bX_y1   gpmvUT_a1_x1_bX_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmvUC_a1_x1_bX_y1   gpmvUNc_a1_x1_bX_y1
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpmv
  const enum ATLAS_UPLO,  const enum ATLAS_TRANS,
  const int,              const int,
  @(sca_in_),
  @(mat_in_),
  @(vec_in_),
  @(sca_in_),
  @(vec_out_)
      @prou_ gpr1L_a1_x1_yX gpr1U_a1_x1_yX
  const int,              const int,
  @(sca_in_),
  @(vec_in_),
  @(vec_in_),
  @(mat_out_)
      @prou_ gpr1cL_a1_x1_yX gpr1cU_a1_x1_yX gpr1uL_a1_x1_yX gpr1uU_a1_x1_yX
  const int,              const int,
  @(sca_in_),
  @(vec_in_),
  @(vec_in_),
  @(mat_out_)
      @prou_ gpru gprU
         @ptyp_ c z
  const enum ATLAS_UPLO,
         @ptyp_ !
  const int,              const int,
  @(sca_in_),
  @(vec_in_),
  @(vec_in_),
  @(mat_out_)
      @prou_ gpr
  const enum ATLAS_UPLO,
      @prou_ gprL gpr
  const int,              const int,
  @(sca_in_),
  @(vec_in_),
  @(vec_in_),
  @(mat_out_)
      @prou_ gprc
  const enum ATLAS_UPLO,
      @prou_ gprcL gprcU gpruL gpruU gprc
  const int,              const int,
  @(sca_in_),
  @(vec_in_),
  @(vec_in_),
  @(mat_out_)
      @prou_ tbmvUN tbmvUT tbmvUC tbmvUH tbmvLN tbmvLT tbmvLC tbmvLH
  const enum ATLAS_DIAG,
  const int,              const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ tpmvUN tpmvUT tpmvUC tpmvUH tpmvLN tpmvLT tpmvLC tpmvLH
  const enum ATLAS_DIAG,
  const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ trmvUN trmvUT trmvUC trmvUH trmvLN trmvLT trmvLC trmvLH
  const enum ATLAS_DIAG,
  const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ tbsvUN tbsvUT tbsvUC tbsvUH tbsvLN tbsvLT tbsvLC tbsvLH
  const enum ATLAS_DIAG,
  const int,              const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ tpsvUN tpsvUT tpsvUC tpsvUH tpsvLN tpsvLT tpsvLC tpsvLH
  const enum ATLAS_DIAG,
  const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ trsvUN trsvUT trsvUC trsvUH trsvLN trsvLT trsvLC trsvLH
  const enum ATLAS_DIAG,
  const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ tbmvUNN tbmvUTN tbmvUCN tbmvUHN tbmvUNU tbmvUTU tbmvUCU tbmvUHU
  const int,              const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ tbmvLNN tbmvLTN tbmvLCN tbmvLHN tbmvLNU tbmvLTU tbmvLCU tbmvLHU
  const int,              const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ tpmvUNN tpmvUTN tpmvUCN tpmvUHN tpmvUNU tpmvUTU tpmvUCU tpmvUHU
  const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ tpmvLNN tpmvLTN tpmvLCN tpmvLHN tpmvLNU tpmvLTU tpmvLCU tpmvLHU
  const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ trmvUNN trmvUTN trmvUCN trmvUHN trmvUNU trmvUTU trmvUCU trmvUHU
  const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ trmvLNN trmvLTN trmvLCN trmvLHN trmvLNU trmvLTU trmvLCU trmvLHU
  const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ tbsvUNN tbsvUTN tbsvUCN tbsvUHN tbsvUNU tbsvUTU tbsvUCU tbsvUHU
  const int,              const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ tbsvLNN tbsvLTN tbsvLCN tbsvLHN tbsvLNU tbsvLTU tbsvLCU tbsvLHU
  const int,              const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ tpsvUNN tpsvUTN tpsvUCN tpsvUHN tpsvUNU tpsvUTU tpsvUCU tpsvUHU
  const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ tpsvLNN tpsvLTN tpsvLCN tpsvLHN tpsvLNU tpsvLTU tpsvLCU tpsvLHU
  const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ trsvUNN trsvUTN trsvUCN trsvUHN trsvUNU trsvUTU trsvUCU trsvUHU
  const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ trsvLNN trsvLTN trsvLCN trsvLHN trsvLNU trsvLTU trsvLCU trsvLHU
  const int,
  @(mat_in_),
  @(ve1_out_)
      @prou_ sbmvL sbmvU
  const int,              const int,
      @prou_ spmvL spmvU symvL symvU
  const int,
      @prou_ sbmvL sbmvU spmvL spmvU symvL symvU
  @(mat_in_),
  @(ve1_in_),
  @(sca_in_),
  @(ve1_out_)
      @prou_ hbmvL hbmvU
  const int,              const int,
      @prou_ hpmvL hpmvU hemvL hemvU
  const int,
      @prou_ hbmvL hbmvU hpmvL hpmvU hemvL hemvU
  @(mat_in_),
  @(ve1_in_),
  @(sca_in_),
  @(ve1_out_)
      @prou_ hprL hprU herL herU sprL sprU  syrL syrU
  const int,
  @(ve1_in_),
  @(vec_in_),
  @(mat_out_)
      @prou_ hpr2L hpr2U her2L her2U spr2L spr2U syr2L syr2U
  const int,
  @(ve1_in_),
  @(ve1_in_),
  @(mat_out_)
      @prou_ !
      @killkeys prou_
);
 
   @endwhile
   @undef sca_in_
   @undef rsca_in_
   @undef mat_in_
   @undef mat_out_
   @undef pmat_in_
   @undef pmat_out_
   @undef vec_in_
   @undef vec_out_
   @undef ve1_in_
   @undef ve1_out_
   @killkeys ptyp_
@endwhile

#endif
/*
 * End of @(rname)
 */
@undef rname
@skip
@skip ==================================================================
@skip
@rout Make.l2aux
@extract @(VER_ATLAS_MAK)
#
include Make.inc
mySRCdir = $(SRCdir)/src/blas/level2/kernel
#
########################################################################
#
INC2dep     = \
   $(INCSdir)/atlas_misc.h      $(INCSdir)/atlas_kernel2.h \
   $(INCSdir)/atlas_lvl2.h      $(INCSdir)/atlas_mv.h      \
   $(INCSdir)/atlas_r1.h        $(INCSdir)/atlas_reflvl2.h \
   $(INCSdir)/atlas_reflevel2.h
#
## Object files ########################################################
# 
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
@up@(pre_)RBLAS2 = \
   @declare "   " y y
      @ptyp_ s d
         @multidef rout_
@skip syrL syrU syr2L   syr2U
            sbmvL   sbmvU   spmvL   spmvU   symvL   symvU
            sprL    sprU    spr2L   spr2U
            tbmvUN  tbmvUT  tbmvLN  tbmvLT
            tbmvUNN tbmvUTN tbmvUNU tbmvUTU tbmvLNN tbmvLTN tbmvLNU tbmvLTU
            tpmvUN  tpmvUT  tpmvLN  tpmvLT
            tpmvUNN tpmvUTN tpmvUNU tpmvUTU tpmvLNN tpmvLTN tpmvLNU tpmvLTU
            trmvUN  trmvUT  trmvLN  trmvLT
            trmvUNN trmvUTN trmvUNU trmvUTU trmvLNN trmvLTN trmvLNU trmvLTU
            tbsvUN  tbsvUT  tbsvLN  tbsvLT
            tbsvUNN tbsvUTN tbsvUNU tbsvUTU tbsvLNN tbsvLTN tbsvLNU tbsvLTU
            tpsvUN  tpsvUT  tpsvLN  tpsvLT
            tpsvUNN tpsvUTN tpsvUNU tpsvUTU tpsvLNN tpsvLTN tpsvLNU tpsvLTU
            trsvUN  trsvUT  trsvLN  trsvLT
            trsvUNN trsvUTN trsvUNU trsvUTU trsvLNN trsvLTN trsvLNU trsvLTU
         @endmultidef
      @ptyp_ c z
         @multidef rout_
@skip herL    herU   her2L   her2U
            hbmvL   hbmvU   hpmvL   hpmvU   hemvL   hemvU
            hprL    hprU    hpr2L   hpr2U
            tbmvUN  tbmvUT  tbmvUC  tbmvUH  tbmvLN  tbmvLT  tbmvLC  tbmvLH
            tbmvUNN tbmvUTN tbmvUCN tbmvUHN tbmvUNU tbmvUTU tbmvUCU tbmvUHU
            tbmvLNN tbmvLTN tbmvLCN tbmvLHN tbmvLNU tbmvLTU tbmvLCU tbmvLHU
            tpmvUN  tpmvUT  tpmvUC  tpmvUH  tpmvLN  tpmvLT  tpmvLC  tpmvLH
            tpmvUNN tpmvUTN tpmvUCN tpmvUHN tpmvUNU tpmvUTU tpmvUCU tpmvUHU
            tpmvLNN tpmvLTN tpmvLCN tpmvLHN tpmvLNU tpmvLTU tpmvLCU tpmvLHU
            trmvUN  trmvUT  trmvUC  trmvUH  trmvLN  trmvLT  trmvLC  trmvLH
            trmvUNN trmvUTN trmvUCN trmvUHN trmvUNU trmvUTU trmvUCU trmvUHU
            trmvLNN trmvLTN trmvLCN trmvLHN trmvLNU trmvLTU trmvLCU trmvLHU
            tbsvUN  tbsvUT  tbsvUC  tbsvUH  tbsvLN  tbsvLT  tbsvLC  tbsvLH
            tbsvUNN tbsvUTN tbsvUCN tbsvUHN tbsvUNU tbsvUTU tbsvUCU tbsvUHU
            tbsvLNN tbsvLTN tbsvLCN tbsvLHN tbsvLNU tbsvLTU tbsvLCU tbsvLHU
            tpsvUN  tpsvUT  tpsvUC  tpsvUH  tpsvLN  tpsvLT  tpsvLC  tpsvLH
            tpsvUNN tpsvUTN tpsvUCN tpsvUHN tpsvUNU tpsvUTU tpsvUCU tpsvUHU
            tpsvLNN tpsvLTN tpsvLCN tpsvLHN tpsvLNU tpsvLTU tpsvLCU tpsvLHU
            trsvUN  trsvUT  trsvUC  trsvUH  trsvLN  trsvLT  trsvLC  trsvLH
            trsvUNN trsvUTN trsvUCN trsvUHN trsvUNU trsvUTU trsvUCU trsvUHU
            trsvLNN trsvLTN trsvLCN trsvLHN trsvLNU trsvLTU trsvLCU trsvLHU
         @endmultidef
      @ptyp_ !
      @whiledef rout_
         ATL_@(pre_)@(rout_).o
      @endwhile
   @enddeclare
   @killkeys ptyp_
#
@endwhile
## Targets #############################################################
#
all   : lib
#
lvl2  : lib
#
lib   : slib dlib clib zlib
#
@whiledef pre_ z c d s
@(pre_)lvl2 : @(pre_)lib
@endwhile
#
@whiledef pre_ z c d s
@(pre_)lib  : @(pre_)lib.grd @(pre_)refblas2
@endwhile
#
@whiledef pre_ z c d s
@(pre_)refblas2:
	( cd ../../reference/level2; $(MAKE) @(pre_)lib )
@endwhile
#
@whiledef p_ z c d s
@(p_)lib.grd  : $(@up@(p_)RBLAS2)
	@(arch) @(archflgs) @(atllib) $(@up@(p_)RBLAS2)
	@(ranlib) @(atllib)
	touch @(p_)lib.grd
#
@endwhile
########################################################################
#
@multidef upr_ d s d s
@whiledef pre_ z c d s
   @addkeys ptyp_=@(pre_)
   @ptyp_ s d
      @multidef rout_
         sbmvL   sbmvU   spmvL   spmvU   symvL   symvU
         sprL    sprU    syrL    syrU    spr2L   spr2U   syr2L   syr2U
         tbmvUN  tbmvUT  tbmvLN  tbmvLT
         tbmvUNN tbmvUTN tbmvUNU tbmvUTU tbmvLNN tbmvLTN tbmvLNU tbmvLTU
         tpmvUN  tpmvUT  tpmvLN  tpmvLT
         tpmvUNN tpmvUTN tpmvUNU tpmvUTU tpmvLNN tpmvLTN tpmvLNU tpmvLTU
         trmvUN  trmvUT  trmvLN  trmvLT
         trmvUNN trmvUTN trmvUNU trmvUTU trmvLNN trmvLTN trmvLNU trmvLTU
         tbsvUN  tbsvUT  tbsvLN  tbsvLT
         tbsvUNN tbsvUTN tbsvUNU tbsvUTU tbsvLNN tbsvLTN tbsvLNU tbsvLTU
         tpsvUN  tpsvUT  tpsvLN  tpsvLT
         tpsvUNN tpsvUTN tpsvUNU tpsvUTU tpsvLNN tpsvLTN tpsvLNU tpsvLTU
         trsvUN  trsvUT  trsvLN  trsvLT
         trsvUNN trsvUTN trsvUNU trsvUTU trsvLNN trsvLTN trsvLNU trsvLTU
      @endmultidef
      @define cdefs @-D@up@(upr_)REAL@
   @ptyp_ c z
      @multidef rout_
         hbmvL   hbmvU   hpmvL   hpmvU   hemvL   hemvU
         hprL    hprU    herL    herU    hpr2L   hpr2U   her2L   her2U
         tbmvUN  tbmvUT  tbmvUC  tbmvUH  tbmvLN  tbmvLT  tbmvLC  tbmvLH
         tbmvUNN tbmvUTN tbmvUCN tbmvUHN tbmvUNU tbmvUTU tbmvUCU tbmvUHU
         tbmvLNN tbmvLTN tbmvLCN tbmvLHN tbmvLNU tbmvLTU tbmvLCU tbmvLHU
         tpmvUN  tpmvUT  tpmvUC  tpmvUH  tpmvLN  tpmvLT  tpmvLC  tpmvLH
         tpmvUNN tpmvUTN tpmvUCN tpmvUHN tpmvUNU tpmvUTU tpmvUCU tpmvUHU
         tpmvLNN tpmvLTN tpmvLCN tpmvLHN tpmvLNU tpmvLTU tpmvLCU tpmvLHU
         trmvUN  trmvUT  trmvUC  trmvUH  trmvLN  trmvLT  trmvLC  trmvLH
         trmvUNN trmvUTN trmvUCN trmvUHN trmvUNU trmvUTU trmvUCU trmvUHU
         trmvLNN trmvLTN trmvLCN trmvLHN trmvLNU trmvLTU trmvLCU trmvLHU
         tbsvUN  tbsvUT  tbsvUC  tbsvUH  tbsvLN  tbsvLT  tbsvLC  tbsvLH
         tbsvUNN tbsvUTN tbsvUCN tbsvUHN tbsvUNU tbsvUTU tbsvUCU tbsvUHU
         tbsvLNN tbsvLTN tbsvLCN tbsvLHN tbsvLNU tbsvLTU tbsvLCU tbsvLHU
         tpsvUN  tpsvUT  tpsvUC  tpsvUH  tpsvLN  tpsvLT  tpsvLC  tpsvLH
         tpsvUNN tpsvUTN tpsvUCN tpsvUHN tpsvUNU tpsvUTU tpsvUCU tpsvUHU
         tpsvLNN tpsvLTN tpsvLCN tpsvLHN tpsvLNU tpsvLTU tpsvLCU tpsvLHU
         trsvUN  trsvUT  trsvUC  trsvUH  trsvLN  trsvLT  trsvLC  trsvLH
         trsvUNN trsvUTN trsvUCN trsvUHN trsvUNU trsvUTU trsvUCU trsvUHU
         trsvLNN trsvLTN trsvLCN trsvLHN trsvLNU trsvLTU trsvLCU trsvLHU
      @endmultidef
      @define cdefs @-D@up@(upr_)CPLX@
   @ptyp_ !
   @whiledef rout_
      @define rpre_ @ATL_@(rout_)@
      @define rsrc_ @$(mySRCdir)/@(rpre_).c@
      @define robj_ @ATL_@(pre_)@(rout_).o@
@24l@(robj_) : @(rsrc_) $(INC2dep)
@(CCcomp) @(cdefs) @(rsrc_)
      @undef rpre_
      @undef rsrc_
      @undef robj_
   @endwhile
   @undef cdefs
   @killkeys ptyp_
   @undef upr_
#
@endwhile
########################################################################
#
@whiledef pre_ z c d s
@(pre_)clean           :
	( cd ../../reference/level2; $(MAKE) @(pre_)clean )
	rm -f $(@up@(pre_)RBLAS2) @(pre_)*.grd
#
@endwhile
clean            :
	( cd ../../reference/level2; $(MAKE)  clean )
	rm -f *.o *.grd
#
########################################################################
@rout !
@skip
@skip ==================================================================
@skip
@undef RC2_INCLUDE
@skip
@skip ==================================================================
@skip
