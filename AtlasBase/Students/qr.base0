@extract -b @(topd)/gen.inc what=crsetup
@ROUT ATL_gelqr ATL_geqlr ATL_gerqr
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "Anthony M. Castaldo, R. Clint Whaley"
@ROUT ATL_geqrr
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "R. Clint Whaley, Anthony M. Castaldo"
@ROUT ATL_gelqr ATL_geqlr ATL_gerqr ATL_geqrr

#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"
#include "atlas_lvl3.h"
#if defined(ATL_NCPU) && ATL_NCPU > 1
   #include "atlas_tcacheedge.h"
#else
   #include "atlas_cacheedge.h"
#endif

#ifdef CacheEdge
   #if CacheEdge > 4194304 || CacheEdge == 0
      #define LA_CE 262144
   #else
      #define LA_CE 262144
   #endif
#else
   #define LA_CE 262144
#endif
@ROUT ATL_geqr2
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DGEQR2( M, N, A, LDA, TAU, WORK, INFO )
 *
 * ATL_geqr2.c :
 * int ATL_geqr2( const int M, const int N, TYPE *A, int LDA,
 *                                                      TYPE  *TAU, TYPE *WORK)
 *     NOTE :a)   ATL_geqr2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *           b) This routine will not validate the input parameters.
 *  Purpose
 *  =======
 *
 *  ATL_geqr2  computes a QR factorization of a real/complex  m by n matrix A:
 *  A = Q * R.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output) array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, the elements on and above the diagonal of the array
 *          contain the min(m,n) by n upper trapezoidal matrix R (R is
 *          upper triangular if m >= n); the elements below the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q
 *          (unitary matrix incase of complex precision )  as a
 *          product of elementary reflectors (see Further Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace)  array, dimension (N)
 *
 *  INFO    (output) INTEGER
 *          = 0: successful exit
 *          < 0: if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(1) H(2) . . . H(k), where k = min(m,n).
 *                                             (for Real/Complex Precision)
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'                 (for Real Precision)
 *     H(i) = I - tau * v * conjugate(v)'      (for Complex  Precision)
 *
 *  where tau is a real/complex  scalar, and v is a real/complex vector with
 *  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
 *  and tau in TAU(i).
 *
 -----------------------------------------------------------------------------*/
#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"


int ATL_geqr2( const int M, const int N, TYPE *A, int LDA, TYPE  *TAU,
                                                               TYPE *WORK)
{
   int lda2 = LDA  SHIFT;                       /* for complex LDA*2          */

   #ifdef TREAL
       const TYPE ONE = ATL_rone;
       TYPE AII ;
       TYPE TAUVAL ;
   #else
       const TYPE ONE[2] = {ATL_rone, ATL_rzero};
       TYPE AII[2];
       TYPE TAUVAL[2] ;
   #endif


   int i, k;


   k = (M < N)?M:N;                              /* k is min(M,N)             */

   for (i=0; i<k; i++)
   {
      /*
       *        Generate elementary reflector H(i) to annihilate A(i+1:m,i)
       */
      int t=((i+1)<(M-1))?(i+1):(M-1);        /* t = min(i+1, M-1)            */
      ATL_larfp((M-i), (A+(i SHIFT)+i*lda2),
                            (A+(t SHIFT)+i*lda2), 1, (TAU+(i SHIFT)) );

      if (i < (N-1))                         /* If not last column,           */
      {
         /*
          *           Apply H(i) to A(i:m,i+1:n) from the left
          */
         #ifdef TREAL
             AII = A[i+i*lda2];
             A[i+i*lda2] = ONE;
             TAUVAL = TAU[i];
         #else
             AII[0] = A[(i SHIFT)+i*lda2];
             AII[1] = A[(i SHIFT)+i*lda2 + 1];

             A[(i SHIFT)+i*lda2] = ONE[0];
             A[(i SHIFT)+i*lda2 + 1] = ONE[1];

             TAUVAL[0] = TAU[i SHIFT];
             TAUVAL[1] = 0.0 -TAU[(i SHIFT) + 1];    //Conjugate
         #endif


         ATL_larf(CblasLeft, M-i, N-i-1, (A+(i SHIFT)+i*lda2), 1, TAUVAL ,
                      ( A+(i SHIFT)+(i+1)*lda2 ) , LDA, WORK);

         /* Reassign the values of A[i]                                       */
         #ifdef TREAL
             A[(i SHIFT)+i*lda2] = AII;
         #else
             A[(i SHIFT) +i*lda2] = AII[0];
             A[(i SHIFT) +i*lda2 + 1] = AII[1];
         #endif
      }
   }  /*  end of for */
   return(0);
} /* END AL_geqr2 */
@ROUT ATL_gerq2
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *     SUBROUTINE DGERQ2( M, N, A, LDA, TAU, WORK, INFO )
 *
 * ATL_gerq2.c :
 * int ATL_gerq2( const int M, const int N, TYPE *A, int LDA,
 *                                                      TYPE  *TAU, TYPE *WORK)
 *     NOTE :a)   ATL_gerq2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *           b) This routine will not validate the input parameters.
 *  Purpose
 *  =======
 *
 *  ATL_gerq2  computes a QR factorization of a real/complex  m by n matrix A:
 *  A = Q * R.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output)  array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, if m <= n, the upper triangle of the subarray
 *          A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
 *          if m >= n, the elements on and above the (m-n)-th subdiagonal
 *          contain the m by n upper trapezoidal matrix R; the remaining
 *          elements, with the array TAU, represent the orthogonal matrix
 *          (unitary matrix incase of complex precision )  as a
 *          as a product of elementary reflectors (see Further
 *          Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace) DOUBLE PRECISION array, dimension (M)
 *
 *  INFO    (output) INTEGER
 *          = 0: successful exit
 *          < 0: if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(1) H(2) . . . H(k), where k = min(m,n).    (for Real precison)
 *     Q = H(1)' H(2)' . . . H(k)', where k = min(m,n). (for Complex Precison)
 *         (Note : Conjugate Transpose of H is taken above)
 *
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'                 (for Real Precision)
 *     H(i) = I - tau * v * conjugate(v)'      (for Complex  Precision)
 *
 *  where tau is a real scalar, and v is a real vector with
 *  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
 *  A(m-k+i,1:n-k+i-1), and tau in TAU(i).
 *
 *----------------------------------------------------------------------------*/

#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"


int ATL_gerq2( const int M, const int N, TYPE *A, int LDA, TYPE  *TAU,
                                                               TYPE *WORK)
{
   int lda2 = LDA  SHIFT;                       /* for complex LDA*2          */

   #ifdef TREAL
       const TYPE ONE = ATL_rone;
       TYPE AII ;
       TYPE TAUVAL ;
   #else
       const TYPE ONE[2] = {ATL_rone, ATL_rzero};
       TYPE AII[2];
       TYPE TAUVAL[2] ;
   #endif


   int i, K;


   K = (M < N)?M:N;                              /* k is min(M,N)             */

   for (i=K-1; i>=0 ; i--)
   {
      /*
       *        Generate elementary reflector H(i) to annihilate
       *        A(m-k+i,1:n-k+i-1)
       */
      #ifdef TCPLX
         /* Applicable only to Complex Numbers                                */
         ATL_lacgv(N-K+i+1, (A + ((M-K+i) SHIFT)), LDA);

      #endif
      ATL_larfp( (N-K+i+1),                      /* size of elementary vector */
                 (A +((M-K+i) SHIFT) + (N-K+i)*lda2 ),
                        (A + ((M-K+i) SHIFT)), LDA, (TAU+(i SHIFT)) );

      /*
       *   Apply H(i) to A(1:m-k+i-1,1:n-k+i) from the right
       */

      #ifdef TREAL
          AII = *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 );
           *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = ONE;
          TAUVAL = TAU[i];
      #else
//          AII[0] = A[(i SHIFT)+i*lda2];
//          AII[1] = A[(i SHIFT)+i*lda2 + 1];
          AII[0] = *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 );
          AII[1] = *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 + 1 );

//          A[(i SHIFT)+i*lda2] = ONE[0];
//          A[(i SHIFT)+i*lda2 + 1] = ONE[1];
          *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = ONE[0];
          *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 + 1 ) = ONE[1];

          TAUVAL[0] = TAU[i SHIFT];
          TAUVAL[1] = TAU[(i SHIFT) + 1];
      #endif

      ATL_larf(CblasRight, M-K+i,                 /* Number of Rows of Aremainder    */
                    N-K+i+1,               /* Number of Columns of Aremainder */
                   (A+((M-K+i) SHIFT)),    /* Pointer to V vector             */
                    LDA, TAUVAL ,
                   ( A ) , LDA, WORK);     /* C Matrix to larf                */
//      ATL_larf('R', M-K+i-1,             /* Number of Rows of Aremainder    */
//                    N-K+i,               /* Number of Columns of Aremainder */
//                   (A+((M-K+i) SHIFT)), LDA, TAUVAL ,
//                   ( A ) , LDA, WORK);

      /* Reassign the values of A[i]                                           */
      #ifdef TREAL
          *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = AII;
      #else
//          A[(i SHIFT) +i*lda2] = AII[0];
//          A[(i SHIFT) +i*lda2 + 1] = AII[1];
          *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = AII[0];
          *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 + 1 ) = AII[1];
      #endif

      #ifdef TCPLX
         ATL_lacgv(N-K+i, (A + ((M-K+i) SHIFT)), LDA);
      #endif

   }  /*  end of for */

   return(0);
} /* END AL_gerq2 */
@ROUT ATL_geql2
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DGEQL2( M, N, A, LDA, TAU, WORK, INFO )
 *
 * ATL_geql2.c :
 *
 * int ATL_geql2( const int M, const int N, TYPE *A, int LDA,
 *                                                      TYPE  *TAU, TYPE *WORK)
 *     NOTE :a)  ATL_geql2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *           b) This routine will not validate the input parameters.
 *
 *
 *  Purpose
 *  =======
 *
 *  ATL_geql2 computes a QL factorization of a real/complex m by n matrix A:
 *  A = Q * L.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output) array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, if m >= n, the lower triangle of the subarray
 *          A(m-n+1:m,1:n) contains the n by n lower triangular matrix L;
 *          if m <= n, the elements on and below the (n-m)-th
 *          superdiagonal contain the m by n lower trapezoidal matrix L;
 *          the remaining elements, with the array TAU, represent the
 *          orthogonal matrix Q ((unitary matrix incase of complex precision )
 *          as a product of elementary reflectors (see Further Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace) array, dimension (N)
 *
 *  INFO    (output) INTEGER
 *          = 0: successful exit
 *          < 0: if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(k) . . . H(2) H(1), where k = min(m,n).
 *                                             (for Real/Complex Precisions)
 *
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'                 (for Real Precision)
 *     H(i) = I - tau * v * conjugate(v)'      (for Complex  Precision)
 *
 *
 *  where tau is a real scalar, and v is a real vector with
 *  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
 *  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
 *-----------------------------------------------------------------------------*/

#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

int ATL_geql2( const int M, const int N, TYPE *A, int LDA, TYPE  *TAU,
                                                               TYPE *WORK)
{
   int lda2 = LDA  SHIFT;                       /* for complex LDA*2          */

   #ifdef TREAL
       const TYPE ONE = ATL_rone;
       TYPE AII ;
       TYPE TAUVAL ;
   #else
       const TYPE ONE[2] = {ATL_rone, ATL_rzero};
       TYPE AII[2];
       TYPE TAUVAL[2] ;
   #endif


   int i, K;


   K = (M < N)?M:N;                              /* k is min(M,N)             */

   for (i=K-1; i>=0; i--)
   {

      /*        Generate elementary reflector H(i) to annihilate
       *        A(1:m-k+i-1,n-k+i)
       */
      ATL_larfp( (M-K+i+1),                      /* size of elementary vector */
                 (A +((M-K+i) SHIFT) + (N-K+i)*lda2 ),     /* alpha           */
                 (A + ((N-K+i)*lda2 )),          /* pointer to V vector       */
                 1,                              /* lda of V                  */
                 (TAU+(i SHIFT)) );

      /*
       *   Apply H(i) to A(1:m-k+i,1:n-k+i-1) from the left
       */

      #ifdef TREAL
          AII = *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 );
           *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = ONE;
          TAUVAL = TAU[i];
      #else
          AII[0] = *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 );
          AII[1] = *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 + 1 );

          *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = ONE[0];
          *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 + 1 ) = ONE[1];

          TAUVAL[0] = TAU[i SHIFT];
          TAUVAL[1] = 0.0 - TAU[(i SHIFT) + 1];  /* Conjugate for complex     */
      #endif

      ATL_larf(CblasLeft, M-K+i+1,               /* Number of Rows of Aremainder    */
                    N-K+i,                 /* Number of Columns of Aremainder */
                   (A + ((N-K+i)*lda2 )),  /* pointer to V                    */
                    1, TAUVAL ,
                   ( A ) , LDA, WORK);     /* C Matrix to larf                */

      /* Reassign the values of A[i]                                           */
      #ifdef TREAL
          *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = AII;
      #else
          *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 ) = AII[0];
          *(A + ((M-K+i) SHIFT)  + (N-K+i)*lda2 + 1 ) = AII[1];
      #endif

   }  /*  end of for */

   return(0);
} /* END AL_geql2 */


@ROUT ATL_gelq2
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DGELQ2( M, N, A, LDA, TAU, WORK, INFO )
 *
 * ATL_gelq2.c :
 * int ATL_gelq2( const int M, const int N, TYPE *A, int LDA,
 *                                                      TYPE  *TAU, TYPE *WORK)
 *     NOTE :a)   ATL_gelq2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *           b) This routine will not validate the input parameters.
 *  Purpose
 *  =======
 *
 *  ATL_gelq2  computes an LQ factorization of a real m by n matrix A:
 *  A = L * Q.
 *
 *  Arguments
 *  =========
 *
 *          (unitary matrix incase of complex precision )  as a
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output) array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, the elements on and below the diagonal of the array
 *          contain the m by min(m,n) lower trapezoidal matrix L (L is
 *          lower triangular if m <= n); the elements above the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q
 *          (unitary matrix incase of complex precision )  as a
 *          product of elementary reflectors (see Further Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace) DOUBLE PRECISION array, dimension (M)
 *
 *  INFO    (output) INTEGER
 *          = 0: successful exit
 *          < 0: if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(k) . . . H(2) H(1), where k = min(m,n).    ( for Real precision)
 *     Q = H(1)' H(2)' . . . H(k)', where k = min(m,n). ( for Complex Precison)
 *         (Note : Conjugate Transpose of H is taken above)
 *
 *
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'
 *
 *  where tau is a real/complex scalar, and v is a real/complex vector with
 *  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
 *  and tau in TAU(i).
 *
  -----------------------------------------------------------------------------*/
#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"


int ATL_gelq2( const int M, const int N, TYPE *A, int LDA, TYPE  *TAU,
                                                               TYPE *WORK)
{
   int lda2 = LDA  SHIFT;                       /* for complex LDA*2          */

   #ifdef TREAL
       const TYPE ONE = ATL_rone;
       TYPE AII ;
       TYPE TAUVAL ;
   #else
       const TYPE ONE[2] = {ATL_rone, ATL_rzero};
       TYPE AII[2];
       TYPE TAUVAL[2] ;
   #endif


   int i, K;


   K = (M < N)?M:N;                              /* k is min(M,N)             */

   for (i=0; i<K; i++)
   {
      /*
       *        Generate elementary reflector H(i) to annihilate A(i,i+1:n)
       */
      #ifdef TCPLX
         /* Applicable only to Complex Numbers : Make Conjugate               */
         ATL_lacgv(N-i, (A+(i SHIFT)+i*lda2), LDA);   /*  V vextor            */
      #endif
      int t=((i+1)<(N-1))?(i+1):(N-1);        /* t = min(i+1, N-1)            */
      ATL_larfp( (N-i),                       /* Size of Elementary vector    */
                 (A+(i SHIFT) + i*lda2),      /* alpha                        */
                 (A+ (i SHIFT) + (t*lda2) ),
                 LDA,
                 (TAU+(i SHIFT)) );

      if (i < (M-1))                         /* If not last column,           */
      {
         /*
          *      Apply H(i) to A(i+1:m,i:n) from the right
          *
          */
         #ifdef TREAL
             AII = A[i+i*lda2];
             A[i+i*lda2] = ONE;
             TAUVAL = TAU[i];
         #else
             AII[0] = A[(i SHIFT)+i*lda2];
             AII[1] = A[(i SHIFT)+i*lda2 + 1];

             A[(i SHIFT)+i*lda2] = ONE[0];
             A[(i SHIFT)+i*lda2 + 1] = ONE[1];

             TAUVAL[0] = TAU[i SHIFT];
             TAUVAL[1] = TAU[(i SHIFT) + 1];
         #endif


         ATL_larf(CblasRight, M-i-1, N-i,
                      (A+(i SHIFT)+i*lda2),      /* V vector                  */
                      LDA,
                      TAUVAL ,
                      ( A+ ((i+1) SHIFT) + i*lda2 ) , LDA, WORK);

         /* Reassign the values of A[i]                                       */
         #ifdef TREAL
             A[(i SHIFT)+i*lda2] = AII;
         #else
             A[(i SHIFT) +i*lda2] = AII[0];
             A[(i SHIFT) +i*lda2 + 1] = AII[1];
         #endif
      }
      #ifdef TCPLX
         /* Applicable only to Complex Numbers : Make Conjugate            */
         ATL_lacgv(N-i, (A+(i SHIFT)+i*lda2), LDA);   /*  V vextor         */
      #endif
   }  /*  end of for */

   return(0);
} /* END AL_gelq2 */
@ROUT ATL_geqrf
#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

#ifdef  SREAL
     #define MYOPT LASreal
#endif
#ifdef  DREAL
    #define MYOPT  LADreal
#endif
#ifdef  SCPLX
    #define MYOPT  LAScplx
#endif
#ifdef  DCPLX
    #define MYOPT  LADcplx
#endif


int ATL_geqrf(ATL_CINT M, ATL_CINT N, TYPE  *A, ATL_CINT lda, TYPE  *TAU,
               TYPE *WORK, ATL_CINT LWORK)
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DGEQRF( M, N, A, LDA, TAU, WORK, LWORK, INFO )
 *
 * ATL_gerqf.c :
 * int ATL_geqrf(int M, int N, TYPE  *A, int LDA, TYPE  *TAU,
 *              TYPE *WORK, int LWORK)
 *
 *  Purpose
 *  =======
 *
 *  ATL_geqrf  computes a QR factorization of a real/complex M-by-N matrix A:
 *  A = Q * R.
 *
 *  Compared to LAPACK, here, a recursive pannel factorization is implemented.
 *  Refer ATL_geqrr.c andd ATL_larft.c for details.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output) array, dimension (LDA,N)
 *          On entry, the M-by-N matrix A.
 *          On exit, the elements on and above the diagonal of the array
 *          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
 *          upper triangular if m >= n); the elements below the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q as a
 *          product of min(m,n) elementary reflectors (see Further
 *          Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace/output) array, dimension (MAX(1,LWORK))
 *          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK.  LWORK >= max(1,N).
 *          For optimum performance LWORK >= N*NB, where NB is
 *          the optimal blocksize.
 *
 *          If LWORK = -1, then a workspace query is assumed; the routine
 *          only calculates the optimal size of the WORK array, returns
 *          this value as the first entry of the WORK array, and no error
 *          message related to LWORK is issued .
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(1) H(2) . . . H(k), where k = min(m,n).
 *
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'                  (For Real precision)
 *     H(i) = I - tau * v * conjugate(v)'       (For Complex precision)
 *
 *  where tau is a real/complex scalar, and v is a real/complex vector with
 *  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
 *  and tau in TAU(i).
 *
 *----------------------------------------------------------------------------*/
{
   ATL_CINT minMN = Mmin(M, N), maxMN = Mmax(M, N);
   ATL_INT n, nb, j;
   TYPE  *ws_QR2,  *ws_T, *ws_larfb;   /* Workspace for QR2,T, larfb          */
   void *vp=NULL;

   nb = ATL_ilaenv(LAIS_OPT_NB, LAgeqrf, MYOPT, M, N, -1, -1);

/*
 * If it is a workspace query, return the size of work required.
 *    wrksz = wrksz of ATL_larfb + ATL_larft + ATL_geqr2
 * RCW Q: Why can't LARFB & GEQR2 workspaces be overlapped?
 */
   if (LWORK < 0)
   {
      *WORK = ( maxMN*nb + nb*nb + maxMN )  ;
      return(0);
   } 
   else if (M < 1 || N < 1)  /* quick return if no work to do */
      return(0);
/*
 * If the user gives us too little space, see if we can allocate it ourselves
 */
   else if (LWORK < (maxMN*nb + nb*nb + maxMN))
   {
      vp = malloc(ATL_MulBySize(maxMN*nb + nb*nb + maxMN) + ATL_Cachelen);
      if (!vp)
         return(-7);
       WORK = ATL_AlignPtr(vp);
   }

/*
 * Assign workspace areas for ATL_larft, ATL_geqr2, ATL_larfb
 * RCW Q: Why can't LARFB & GEQR2 workspaces be overlapped?
 */
   ws_T = WORK;                         /* T at begining of work */
   ws_QR2 = WORK +(nb SHIFT)*nb;        /* After T Work space             */
   ws_larfb = ws_QR2 + (maxMN SHIFT);   /* After workspace for T and QR2  */

/*
 * Leave one iteration to be done outside loop, so we don't build T
 * Any loop iterations are therefore known to be of size nb (no partial blocks)
 */
   n = (minMN / nb) * nb;
   if (n == minMN)
      n -= Mmin(nb, minMN);
   
   for (j=0; j < n; j += nb)
   {
      ATL_assert(!ATL_geqrr(M-j, nb, A+(j SHIFT)*(lda+1), lda, TAU+(j SHIFT),
                            ws_QR2, ws_T, nb, ws_larfb, 1));
      if (j+nb < N)  /* if there are more cols left to right, update them */
      {
/*
 *       ======================================================================
 *       Form the triangular factor of the block reflector
 *          H = H(i) H(i+1) . . . H(i+ib-1)
 *       After geqrr, ws_T contains 'T', the nb x nb triangular factor 'T'
 *       of the block reflector. It is an output used in the next call, dlarfb.
 *          H = Id - Y*T*Y', with Id=(M-j)x(M-j), Y=(M-j)xNB.
 *
 *       Apply H' to A(j:m,j+nb:N) from the left 
 *       
 *       The ws_T array used above is an input to dlarfb; it is 'T' in
 *       that routine, and LDT x K (translates here to LDWORK x NB).
 *       WORK is an LDWORK x NB workspace (not input or output).
 * RCW: LDWORK is not defined!
 *       ======================================================================
 */
         ATL_larfb(CblasLeft, CblasTrans, LAForward, LAColumnStore,
                   M-j, N-j-nb, nb, A+(j SHIFT)*(lda+1), lda, ws_T, nb,
                   A+(j SHIFT)+((j+nb)SHIFT)*lda, lda, ws_larfb, N);
      }
   }
/*
 * Last panel has no need to build T
 */
   nb = minMN - n;
   ATL_assert(!ATL_geqrr(M-n, N-n, A+(n SHIFT)*(lda+1), lda, TAU+(n SHIFT),
                         ws_QR2, ws_T, nb, ws_larfb, 0));
@beginskip
   if (I < K)
   {
      IINFO = ATL_geqr2(M-I, N-I,
              (A+(I SHIFT)+I*LDA2), LDA, (TAU+(I SHIFT)),
               ws_QR2);
   }
@endskip

   if (vp)
      free(vp);
   return(0);
} /* END ATL_dgeqrF */

@ROUT ATL_geqrr
int ATL_geqrr(int M, int N, TYPE *A, int LDA, TYPE  *TAU,
               TYPE *ws_QR2, TYPE *ws_T, int LDT,
               TYPE *WORKM, int buildT)
/*-----------------------------------------------------------------------------
 * This is a recursive implementation of ATL_dgeqrf.c; it performs a QR
 * factorization of a panel (M > N) with a bottom level of ATL_geqr2. The
 * recursion is on columns only; it divides by 2 until it reaches a
 * stopping point; at which time it calls ATL_geqr2 to complete a sub-panel,
 * ATL_larft and ATL_larfb to propagate the results, etc.
 *
 * ATL_geqrr.c :
 * int ATL_geqrr(int M, int N, TYPE *A, int LDA, TYPE  *TAU,
 *               TYPE *ws_QR2, TYPE *ws_T, int LDT,
 *               TYPE *WORKM, int buildT)
 *      NOTE :   ATL_geqr2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *  Purpose
 *  =======
 *
 *  ATL_geqrr computes a QR factorization of a real M-by-N matrix A:
 *  A = Q * R.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output)  array, dimension (LDA,N)
 *          On entry, the M-by-N matrix A.
 *          On exit, the elements on and above the diagonal of the array
 *          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
 *          upper triangular if m >= n); the elements below the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q as a
 *          product of min(m,n) elementary reflectors (see Further
 *          Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *          If LDA == 0, returns work sizes in *WORKV and *WORKM.
 *
 *  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORKM   Work space matrix, double precision matrix at least M rows by
 *          N columns; the amount used by larft and larfb.
 *
 *  buildT  If non-zero, dgeqrr will build in ws_T the complete T necessary
 *          for the original panel it is passed;
 *          such that Q= I - transpose(Y) * T * Y.
 *          If zero, ws_T will contain only those elements of T necessary to
 *          complete the panel.
 -----------------------------------------------------------------------------*/
{

   int I, left, right, INFO, IINFO, lbuilt, rbuilt;
   int LDA2 = LDA SHIFT;                        /* for complex LDA *2         */
   int LDT2 = LDT SHIFT;                        /* for complex LDT *2         */

   if (M < 1 || N < 1) return(0);               /* Nothing to do.             */
/*
 * Choose a smart recursive column partitioning based on N:
 * The mapping from this routs dim:GEMM is : right:M, left:N, K:M-left
 * For big probs, max M & K by making left small & a mult of NB.
 * For small problems, make M a multiple of MU (many x86 have NU=1 anyway!).
 */
   if (N >= NB+NB) /* big prob, put remainder on right */
   {
      left = ATL_MulByNB(ATL_DivByNB(N>>1));
      right = N - left;
   }
   else  /* small prob, keep M mult of MU (MU more critical than NU) */
   {
      right = ((N>>1)/ATL_mmMU)*ATL_mmMU;
      left = N - right;
   }
/*
 * Stop recursion if problem cache contained, or no more benefit from L3BLAS
 */
   if (ATL_MulBySize(M)*N <= LA_CE || N <= 4 || !left || !right)
   {
      ATL_geqr2(M, N, A, LDA, TAU, ws_QR2);
      if (buildT)
         ATL_larft(LAForward, LAColumnStore, M, N, A, LDA,
                    TAU, ws_T, LDT);
      return(0);
   }

/*
 * Factor left half, using same workspaces as we'll eventually use for right.
 * We always build T so that we can multiply by Q for the right side update
 */
   ATL_geqrr(M, left, A, LDA, TAU, ws_QR2, ws_T, LDT, WORKM, 1);

/*
 * Adjust right according to T:  apply H' to A[0:(M-1), left:(N-1)].
 */
   ATL_larfb(CblasLeft, CblasTrans,            /* From left, Transposed,  */
              LAForward, LAColumnStore,        /* Forward, Columnwise.    */
              M,                               /* Update area is M rows,  */
              right,                           /* 'right' columns,        */
              left,                            /* V is 'left' columns.    */
              A, LDA,                          /* V array (inside A)      */
              ws_T, LDT,                       /* T array (in work space) */
              A+(left*LDA2), LDA,              /* Array to update.        */
              WORKM, N);                       /* Workspace, leading dim. */

/*
 * Now factor updated right
 */
   ATL_geqrr(M-left, right, A+(left SHIFT)*(LDA+1), LDA, TAU+(left SHIFT),
             ws_QR2, ws_T+(left SHIFT)*(LDT+1), LDT, WORKM, buildT);

/*
 * If we are building T, the left side was completely built above, and the
 * right-hand side is partially built by the recursion.  We need to fill in
 * the upper right quarter of T, which is left x right in size, using the
 * formula -T1 * (Y1^T * Y2) * T2.
 */
   if (buildT)
      ATL_larft_block(LAForward, LAColumnStore, M, N, left, right,
                      A, LDA, ws_T, LDT);

   return(0);
} /* END ATL_geqrr */

@ROUT ATL_geqlf
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DGEQLF( M, N, A, LDA, TAU, WORK, LWORK, INFO )
 *
 * ATL_gerqf.c :
 * int ATL_geqlf(int M, int N, TYPE  *A, int LDA, TYPE  *TAU,
 *              TYPE *WORK, int LWORK)
 *
 *  Purpose
 *  =======
 *
 *  ATL_geqlf computes a QL factorization of a real/complex m by n matrix A:
 *  A = Q * L.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output) array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, if m >= n, the lower triangle of the subarray
 *          A(m-n+1:m,1:n) contains the n by n lower triangular matrix L;
 *          if m <= n, the elements on and below the (n-m)-th
 *          superdiagonal contain the m by n lower trapezoidal matrix L;
 *          the remaining elements, with the array TAU, represent the
 *          orthogonal matrix Q ((unitary matrix incase of complex precision )
 *          as a product of elementary reflectors (see Further Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORK    (workspace/output) array, dimension (MAX(1,LWORK))
 *          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK.  LWORK >= max(1,N).
 *          For optimum performance LWORK >= N*NB, where NB is the
 *          optimal blocksize.
 *
 *          If LWORK = -1, then a workspace query is assumed; the routine
 *          only calculates the optimal size of the WORK array, returns
 *          this value as the first entry of the WORK array, and no error
 *          message related to LWORK is issued by XERBLA.
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(k) . . . H(2) H(1), where k = min(m,n).
 *                                             (for Real/Complex Precisions)
 *
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'                 (for Real Precision)
 *     H(i) = I - tau * v * conjugate(v)'      (for Complex  Precision)
 *
 *
 *  where tau is a real scalar, and v is a real vector with
 *  v(m-k+i+1:m) = 0 and v(m-k+i) = 1; v(1:m-k+i-1) is stored on exit in
 *  A(1:m-k+i-1,n-k+i), and tau in TAU(i).
 *-----------------------------------------------------------------------------*/

#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

#ifdef  SREAL
     #define MYOPT LASreal
#endif
#ifdef  DREAL
    #define MYOPT  LADreal
#endif
#ifdef  SCPLX
    #define MYOPT  LAScplx
#endif
#ifdef  DCPLX
    #define MYOPT  LADcplx
#endif

void ATL_printMat
   (char *mat, const int M, const int N, TYPE *A, const int lda0)
{

   #ifdef TREAL
         #define SHIFTL
   #else
         #define SHIFTL << 1
   #endif

   const int lda = lda0 SHIFTL;
   int i, j;

   for (i=0; i != M; i++)
   {
      #ifdef TREAL
         for (j=0; j != N; j++) printf("%f  ",A[i+j*lda]);
      #else
         for (j=0; j != N; j++)
            printf("(%f,%f)  ",A[2*i+j*lda], A[1+2*i+j*lda]);
      #endif
      printf("\n");
   }
}




int ATL_geqlf(int M, int N, TYPE  *A, int LDA, TYPE  *TAU,
               TYPE *WORK, int LWORK)
{
   int LQUERY, I, IB, IINFO, IWS, K, LDWORK, NB, NBMIN, LoopNB, NX, NEWN;
   int INFO, MAXMN;
   int origN = N;
   int i, LDA2, NB2, buildT;

   int NBOVERRIDE= 8;

   TYPE  *ws_LQ2,  *ws_T, *ws_larfb;   /* Workspace for LQ2,T, larfb          */

   /* Get NB  */
   NB = ATL_ilaenv(LAIS_OPT_NB, LAgeqlf, MYOPT, M, N, -1, -1);

   MAXMN = (M<N)?N:M;                  /* Get Max     */
   INFO = 0;

   if (LWORK < 0)                     /* Query logic  */
   {
      /* Retun the size of work space required. This needs to be allocated    */
      /* by the caller                                                        */
      /* Work = Workspace for ATL_larfb + WS for ATL_larft + WS for ATL_geqr2 */


      //Temporary Logic
      if (NB < NBOVERRIDE  ) NB = NBOVERRIDE;

      *WORK = ( MAXMN*NB + NB*NB + MAXMN )  ;
      return(0);
   } else if (LWORK < (MAXMN*NB + NB*NB + MAXMN))
   {
      /* Check for the size of workspace allocated by the caller              */
      fprintf(stderr, "ATL_geqr2 Error LWORK SHORT! LWORK=%i, MAXMN*NB=%i. \n",
      LWORK, MAXMN*NB);
      fflush(stderr);
   }


   /*
    *     Quick return if possible
    */
   if (M < 0) INFO = -1;
   else if (N < 0) INFO = -2;
   else if (LDA < M) INFO = -4;
   if (INFO != 0)
   {
      fprintf(stderr, "ERROR, RF, INFO=%i.\n", -INFO);
      return(INFO);
   }

   K = (M<N)?M:N;                      /* Get min */
   if (K == 0)
   {
      return(INFO);
   }

@beginskip
   NBMIN = 2;
   /* Get NX  */
   NX = ATL_ilaenv(LAIS_NBXOVER, LAgeqlf, MYOPT, M, N, -1, -1);

   if (NX < 0) NX=0;
   //TODO :     remove this  hardcoding  later
   NBMIN = 1;
   if (NB < NBOVERRIDE  ) NB = NBOVERRIDE;
   NX = 0;
@endskip
   NX = 0; NBMIN=2;

   /* Make the Workspace for ATL_larft and ATL_geqr2 and ATL_larfb            */
   ws_T = WORK;                             /* T workspace to begining of work*/
   ws_LQ2 = (WORK +(NB SHIFT)*NB );         /* After T Work space             */
   ws_larfb =  (WORK +(NB SHIFT)*NB
                     +  (MAXMN SHIFT) );    /* After workspace for T and LQ2  */

   /* Initialize I to K-NB             */
   I = K-NB;


   LDA2 = LDA SHIFT;                             /* for Complex LDA *2        */
   NB2  = NB SHIFT;                              /* for complex NB  *2        */

//   if (NB >= NBMIN && NB < K && NX < K)   //TO DO remoove the bottom
   if (NB >= NBMIN && NB <= K && NX < K)
   {
      /*
       *        Use blocked code initially
       */
//      while (I < K-NX)
      for( I =K-NB; I >= NX; I = I-NB)
      {
//         LoopNB = NB;
         /**********************************************/
         /* If not enough left for LoopNB, do leftover.*/
         /**********************************************/
//         IB = (NEWN < LoopNB)?NEWN:LoopNB;  /* Find min but check this condiotoin SIJU                        */
//         if ( IB == 0) IB = NB; /* To take care of special case when I = 0    */

         IB = NB;


         /* Compute the QL factorization of the current block                 */
         /*           A(1:m-k+i+ib-1,n-k+i:n-k+i+ib-1)                        */

         buildT = 1;                        /* Set it for time being .        */
         IINFO = ATL_geqlr( M-K+I+IB, IB, (A + (N-K+I)*LDA2) ,
                                LDA, (TAU + ( I SHIFT)),
                                ws_LQ2, ws_T, NB, ws_larfb, buildT);

         if (N-K+I > 0)
         {

            /* Form the triangular factor of the block reflector              */
            /*   H = H(i+ib-1) . . . H(i+1) H(i)                              */
            /*                                                                */
            /*  After geqrr, ws_T contains 'T', the IB x IB triangular        */
            /*  factor 'T' of the block reflector. It is an output used       */
            /*  in the next call, dlarfb.                                     */
            /*  H = Id - Y*T*Y', with Id=(M-I)x(M-I), Y=(M-I)xIB. SIJU check this */
            /*                                                                */
            /*  Apply H' to A(i:m,i+ib:n) from the left                       */
            /*  Apply H' to A(1:m-k+i+ib-1,1:n-k+i-1) from the left SIJU check this is it not from right    */

            /*                                                                */
            /*  The ws_T array used above is an input to dlarfb; it is        */
            /*  'T' in that routine, and LDT x K (translates here to          */
            /*  LDWORK x IB). The  use of WORK is an array that               */
            /*  must be LDWORK x K (IB = K), but is not an output.            */

               ATL_larfb(CblasLeft, CblasTrans, LABackward, LAColumnStore,
                   M-K+I+IB, N-K+I, IB,
                  (A+(N-K+I)*LDA2),              /* POinter to V or Y matrix */
                          LDA, ws_T, NB ,
                          A,                      /* A -Remainder            */
                          LDA, ws_larfb, N);
         }

         //I = I + IB;
      } /* END WHILE I <= K-NX */
   }

   /*   Use unblocked code to factor the last or only block.                  */
   if ((I+NB) > 0)
   {

      I = I + NB;
      IINFO = ATL_geql2(M-K+I, N-K+I,
              (A), LDA, (TAU),
               ws_LQ2);
   }
   return(INFO);
} /* END ATL_dgeqlf */

@ROUT ATL_geqlr
/*-----------------------------------------------------------------------------
 * This is a recursive implementation of ATL_dgeqrf.c; it performs a QL
 * factorization of a panel (M > N) with a bottom level of ATL_geql2. The
 * recursion is on columns only; it divides by 2 until it reaches a
 * stopping point; at which time it calls ATL_geql2 to complete a sub-panel,
 * ATL_larft and ATL_larfb to propagate the results, etc.
 *
 * ATL_geqlr.c :
 * int ATL_geqlr(int M, int N, TYPE *A, int LDA, TYPE  *TAU,
 *               TYPE *ws_LQ2, TYPE *ws_T, int LDT,
 *               TYPE *WORKM, int buildT)
 *      NOTE :   ATL_geql2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *  Purpose
 *  =======
 *
 *  ATL_geqlr computes a QL factorization of a real M-by-N matrix A:
 *  A = Q * R.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output)  array, dimension (LDA,N)
 *          On entry, the M-by-N matrix A.
 *          On exit, the elements on and above the diagonal of the array
 *          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
 *          upper triangular if m >= n); the elements below the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q as a
 *          product of min(m,n) elementary reflectors (see Further
 *          Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *          If LDA == 0, returns work sizes in *WORKV and *WORKM.
 *
 *  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORKM   Work space matrix, double precision matrix at least M rows by
 *          N columns; the amount used by larft and larfb.
 *
 *  buildT  If non-zero, dgeqlr will build in ws_T the complete T necessary
 *          for the original panel it is passed;
 *          such that Q= I - transpose(Y) * T * Y.
 *          If zero, ws_T will contain only those elements of T necessary to
 *          complete the panel.
 -----------------------------------------------------------------------------*/

#ifndef NBQLF2
    #define   NBQLF2 3
#endif

int ATL_geqlr(int M, int N, TYPE *A, int LDA, TYPE  *TAU,
               TYPE *ws_LQ2, TYPE *ws_T, int LDT,
               TYPE *WORKM, int buildT)
{

   int I, left, right, INFO, IINFO, lbuilt, rbuilt;
   int LDA2 = LDA SHIFT;                        /* for complex LDA *2         */
   int LDT2 = LDT SHIFT;                        /* for complex LDT *2         */


   if (N == 0) return;                          /* Nothing to do.             */

@skip   if (N <= NBQLF2)                             /* If we hit stopping point,  */
/*
 * Stop recursion if problem cache contained, or no more benefit from L3BLAS
 */
   if (ATL_MulBySize(M)*N <= LA_CE || N <= 4)
   {
      ATL_geql2(M, N, A, LDA, TAU, ws_LQ2);

      if (buildT)
      {
         ATL_larft(LABackward, LAColumnStore, M, N, A, LDA,
                    TAU, ws_T, LDT);            /* Build the T matrix.        */
      }

      return(0);                                /* All okay.                  */
   }

//   left = (N>>3)<<2;                           /* Find left half, 0 mod 4.  */
   left = (N>>2)<<1;                           /* This one is just for testing remove TODO  */
   if (left ==0)                               /* If nothing left on left,  */
   {
      ATL_geql2(M, N, A, LDA, TAU, ws_LQ2);

      if (buildT)
      {
         ATL_larft(LABackward, LAColumnStore, M, N, A, LDA,
                    TAU, ws_T, LDT);            /* Build the T matrix.        */
      }

      return(0);                                /* Built no part of T.        */
   }

   right = N - left;                            /* Find the right half.        */

   /*---------------------------------------------------------------*/
   /* On the right half, we use the same workspaces.                 */
   /* Because we know we have a left hand side we must always      */
   /* build T, so we can multiply by Q before doing the left side. */
   /*---------------------------------------------------------------*/
   ATL_geqlr(M, right,(A+(left*LDA2)), LDA, (TAU+(left SHIFT)), ws_LQ2,
             ( ws_T+(left SHIFT)+left*LDT2), LDT,  /* Build T at T[left,left].*/
              WORKM, 1);

   /*---------------------------------------------------------------*/
   /* Now we must adjust the left hand side according to our T.    */
   /* We must apply H'                                             */
   /*---------------------------------------------------------------*/
   // SIJU SIJU   code below not corrected


   ATL_larfb(CblasLeft, CblasTrans,            /* From left, Transposed,  */
              LABackward, LAColumnStore,       /* Forward, Columnwise.    */
              M,                               /* Update area is M rows,  */
              left,                            /* 'left' columns (remainder) */
              right,                           /* V is 'right' columns.    */
              (A +(left*LDA2))  , LDA,        /* V array (inside A)      */
//              ws_T, LDT,                       /* T array (in work space) */
             ( ws_T+(left SHIFT)+left*LDT2), LDT,  /* Build T at T[left,left].*/
              A, LDA,              /* Array to update.        */
              WORKM, N);                       /* Workspace, leading dim. */

   /*---------------------------------------------------------------*/
   /* On the left  half, we must adjust all pointers.               */
   /*---------------------------------------------------------------*/
   ATL_geqlr(M-right, left,              /* Shorter columns.        */
              (A), LDA,     /* A at A[0,0].      */
              (TAU),                  /* TAU at TAU[left].       */
              ws_LQ2,                              /* No returned values.     */
             ( ws_T), LDT,  /* Build T at T[left,left].*/
              WORKM, buildT);                      /* No returned values.     */

   /*---------------------------------------------------------------*/
   /* If we build T, the right side must be completely built, and    */
   /* the left side should be partially built. We need to fill in  */
   /* the lower  left  hand block, 'right' rows by 'left' columns.   */
   /* The formula is -T2 * (Y2^T * Y1) * T1.                        */
   /* The routine is in ATL_larft.c.                               */
   /*---------------------------------------------------------------*/

   if (buildT)
   {
      ATL_larft_block(LABackward, LAColumnStore,M, N, left, right,
         A, LDA, ws_T, LDT);                    /* compute upper corner.   */
   }

   return(0);
} /* END ATL_geqlr */

@ROUT ATL_gelqf
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *     SUBROUTINE DGELQF( M, N, A, LDA, TAU, WORK, LWORK, INFO )
 *
 * ATL_gerqf.c :
 * int ATL_gelqf(int M, int N, TYPE  *A, int LDA, TYPE  *TAU,
 *              TYPE *WORK, int LWORK)
 *     NOTE :a)   ATL_gelqf.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *           b) This routine will not validate the input parameters.
 *  Purpose
 *  =======
 *
 *  ATL_gelqf  computes an LQ factorization of a real m by n matrix A:
 *  A = L * Q.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output) array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, the elements on and below the diagonal of the array
 *          contain the m by min(m,n) lower trapezoidal matrix L (L is
 *          lower triangular if m <= n); the elements above the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q
 *          (unitary matrix incase of complex precision )  as a
 *          product of elementary reflectors (see Further Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *
 *  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
 *          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK.  LWORK >= max(1,M).
 *          For optimum performance LWORK >= M*NB, where NB is the
 *          optimal blocksize.
 *
 *          If LWORK = -1, then a workspace query is assumed; the routine
 *          only calculates the optimal size of the WORK array, returns
 *          this value as the first entry of the WORK array, and no error
 *          message related to LWORK is issued by XERBLA.
 *
 *  INFO    (output) INTEGER
 *          = 0:  successful exit
 *          < 0:  if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(k) . . . H(2) H(1), where k = min(m,n).    ( for Real precision)
 *     Q = H(1)' H(2)' . . . H(k)', where k = min(m,n). ( for Complex Precison)
 *         (Note : Conjugate Transpose of H is taken above)
 *
 *
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'
 *
 *  where tau is a real/complex scalar, and v is a real/complex vector with
 *  v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
 *  and tau in TAU(i).
 *
 *----------------------------------------------------------------------------*/
#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

#ifdef  SREAL
     #define MYOPT LASreal
#endif
#ifdef  DREAL
    #define MYOPT  LADreal
#endif
#ifdef  SCPLX
    #define MYOPT  LAScplx
#endif
#ifdef  DCPLX
    #define MYOPT  LADcplx
#endif


int ATL_gelqf(int M, int N, TYPE  *A, int LDA, TYPE  *TAU,
               TYPE *WORK, int LWORK)
{
   int LQUERY, I, IB, IINFO, IWS, K, LDWORK, NB, NBMIN, LoopNB, NX, NEWN;
   int INFO, MAXMN;
   int origN = N;
   int i, LDA2, NB2, buildT;

   int NBOVERRIDE= 8;

   TYPE  *ws_LQ2,  *ws_T, *ws_larfb;   /* Workspace for LQ2,T, larfb          */

   /* Get NB  */
   NB = ATL_ilaenv(LAIS_OPT_NB, LAgelqf, MYOPT, M, N, -1, -1);

   MAXMN = (M<N)?N:M;                  /* Get Max     */
   INFO = 0;

   if (LWORK < 0)                     /* Query logic  */
   {
      /* Retun the size of work space required. This needs to be allocated    */
      /* by the caller                                                        */
      /* Work = Workspace for ATL_larfb + WS for ATL_larft + WS for ATL_gelqf2 */


      //Temporary Logic
      if (NB < NBOVERRIDE  ) NB = NBOVERRIDE;

      *WORK = ( MAXMN*NB + NB*NB + MAXMN )  ;
      return(0);
   } else if (LWORK < (MAXMN*NB + NB*NB + MAXMN))
   {
      /* Check for the size of workspace allocated by the caller              */
      fprintf(stderr, "ATL_gelqf2 Error LWORK SHORT! LWORK=%i, MAXMN*NB=%i. \n",
      LWORK, MAXMN*NB);
      fflush(stderr);
   }


   /*
    *     Quick return if possible
    */
   if (M < 0) INFO = -1;
   else if (N < 0) INFO = -2;
   else if (LDA < M) INFO = -4;
   if (INFO != 0)
   {
      fprintf(stderr, "ERROR, RF, INFO=%i.\n", -INFO);
      return(INFO);
   }

   K = (M<N)?M:N;                      /* Get min */
   if (K == 0)
   {
      return(INFO);
   }

@beginskip
   NBMIN = 2;
   /* Get NX  */
   NX = ATL_ilaenv(LAIS_NBXOVER, LAgelqf, MYOPT, M, N, -1, -1);

   if (NX < 0) NX=0;
   //TODO :     remove this  hardcoding  later
   NBMIN = 1;
   if (NB < NBOVERRIDE  ) NB = NBOVERRIDE;
   NX = 0;
@endskip
   NX = 0; NBMIN = 1;

   /* Make the Workspace for ATL_larft and ATL_gelqf2 and ATL_larfb            */
   ws_T = WORK;                             /* T workspace to begining of work*/
   ws_LQ2 = (WORK +(NB SHIFT)*NB );         /* After T Work space             */
   ws_larfb =  (WORK +(NB SHIFT)*NB
                     +  (MAXMN SHIFT) );    /* After workspace for T and LQ2  */

   /* Initialize I to zero             */
   I = 0;


   LDA2 = LDA SHIFT;                             /* for Complex LDA *2        */
   NB2  = NB SHIFT;                              /* for complex NB  *2        */

   if (NB >= NBMIN && NB < K && NX < K)
   {
      /*
       *        Use blocked code initially
       */
      for ( I =0; I< (K -NX) ; I= I+IB)
      {
         NEWN = K-I;

         LoopNB = NB;
         /**********************************************/
         /* If not enough left for LoopNB, do leftover.*/
         /**********************************************/
         IB = (NEWN < LoopNB)?NEWN:LoopNB;  /* Find min                       */

         /* Compute the LQ factorization of the current block                 */
         /* A(i:m,i:i+ib-1). ATL_gelqr also produce T matrix                  */



         buildT = 1;                        /* Set it for time being .        */
         IINFO = ATL_gelqr(IB, N-I , (A + (I SHIFT) + I*LDA2) ,
                                LDA, (TAU + ( I SHIFT)),
                                ws_LQ2, ws_T, NB, ws_larfb, buildT);



         if (I+IB < M)
         {

            /*  Form the triangular factor of the block reflector             */
            /*  H = H(i) H(i+1) . . . H(i+ib-1)                               */
            /*                                                                */
            /*  After gelqr, ws_T contains 'T', the IB x IB triangular        */
            /*  factor 'T' of the block reflector. It is an output used       */
            /*  in the next call, dlarfb.                                     */
            /*  H = Id - Y'*T*Y, with Id=(N-I)x(N-I), Y=IB X(N-I)             */
            /*                                                                */
            /* TODO Correct thsi description                                  */
            /*  Apply H' to A(i:m,i+ib:n) from the top                        */
            /*                                                                */
            /*  The ws_T array used above is an input to dlarfb; it is        */
            /*  'T' in that routine, and LDT x K (translates here to          */
            /*  LDWORK x IB). The  use of WORK is an array that               */
            /*  must be LDWORK x K (IB = K), but is not an output.            */

               ATL_larfb(CblasRight, CblasNoTrans, LAForward, LARowStore,
                 M-I-IB, N-I, IB,
                (A+(I SHIFT)+I*LDA2),            /* A  matrix               */
                LDA, ws_T, NB,
                (A+((I +IB) SHIFT) + (I*LDA2)),   /*A Remainder              */
                LDA, ws_larfb, M);
         }

//         I = I + IB;
      } /* END for  I<= K-NX */
   }

   /*   Use unblocked code to factor the last or only block.                  */
   if (I < K)
   {
      IINFO = ATL_gelq2(M-I, N-I,
              (A+(I SHIFT)+I*LDA2), LDA, (TAU+(I SHIFT)),
               ws_LQ2);
   }

   return(INFO);
} /* END ATL_dgelqfF */

@ROUT ATL_gelqr
/*-----------------------------------------------------------------------------
 * This is a recursive implementation of ATL_dgeqrf.c; it performs a QR
 * factorization of a panel (M > N) with a bottom level of ATL_gelq2. The
 * recursion is on columns only; it divides by 2 until it reaches a
 * stopping point; at which time it calls ATL_gelq2 to complete a sub-panel,
 * ATL_larft and ATL_larfb to propagate the results, etc.
 *
 * ATL_gelqr.c :
 * int ATL_gelqr(int M, int N, TYPE *A, int LDA, TYPE  *TAU,
 *               TYPE *ws_QR2, TYPE *ws_T, int LDT,
 *               TYPE *WORKM, int buildT)
 *      NOTE :   ATL_gelq2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *  Purpose
 *  =======
 *
 *  ATL_gelqr computes a QR factorization of a real M-by-N matrix A:
 *  A = L * Q
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output)  array, dimension (LDA,N)
 *          On entry, the M-by-N matrix A.
 *          On exit, the elements on and above the diagonal of the array
 *          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
 *          upper triangular if m >= n); the elements below the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q as a
 *          product of min(m,n) elementary reflectors (see Further
 *          Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *          If LDA == 0, returns work sizes in *WORKV and *WORKM.
 *
 *  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORKM   Work space matrix, double precision matrix at least M rows by
 *          N columns; the amount used by larft and larfb.
 *
 *  buildT  If non-zero, dgelqr will build in ws_T the complete T necessary
 *          for the original panel it is passed;
 *          such that Q= I - transpose(Y) * T * Y.
 *          If zero, ws_T will contain only those elements of T necessary to
 *          complete the panel.
 -----------------------------------------------------------------------------*/

#ifndef NBLQF2
    #define   NBLQF2 4
#endif

int ATL_gelqr(int M, int N, TYPE *A, int LDA, TYPE  *TAU,
               TYPE *ws_QR2, TYPE *ws_T, int LDT,
               TYPE *WORKM, int buildT)
{

   int I, top, bottom, INFO, IINFO, lbuilt, rbuilt;
   int LDA2 = LDA SHIFT;                        /* for complex LDA *2         */
   int LDT2 = LDT SHIFT;                        /* for complex LDT *2         */


   if (M == 0) return;                          /* Nothing to do.             */

@skip   if (M <= NBLQF2)                             /* If we hit stopping point,  */
/*
 * Stop recursion if problem cache contained, or no more benefit from L3BLAS
 */
   if (ATL_MulBySize(M)*N <= LA_CE || N <= 4)
   {
      ATL_gelq2(M, N, A, LDA, TAU, ws_QR2);

      if (buildT)
      {
         ATL_larft(LAForward, LARowStore, N, M, A, LDA,
                    TAU, ws_T, LDT);            /* Build the T matrix.        */

      }

      return(0);                                /* All okay.                  */
   }

//   bottom = (M>>3)<<2;   TODO : replace the lone below                         /* Find bottom half, 0 mod 4.  */
   bottom = (M>>2)<<1;
   if (bottom ==0)                               /* If nothing left on bottom,  */
   {

      ATL_gelq2(M, N, A, LDA, TAU, ws_QR2);

      if (buildT)
      {
         ATL_larft(LAForward, LARowStore, N, M, A, LDA,
                    TAU, ws_T, LDT);            /* Build the T matrix.        */
      }

      return(0);                                /* Built no part of T.        */
   }

   top = M - bottom;                            /* Find the top half.        */
   /*---------------------------------------------------------------*/
   /* On the top half, we use the same workspaces.                 */
   /* Because we know we have a bottom hand side we must always      */
   /* build T, so we can multiply by Q before doing the bottom side. */
   /*---------------------------------------------------------------*/
   ATL_gelqr(top, N, A, LDA, TAU, ws_QR2, ws_T, LDT, WORKM, 1);

   /*---------------------------------------------------------------*/
   /* Now we must adjust the bottom hand side according to our T.    */
   /* We must apply H' to A[0:(M-1), top:(N-1)].                   */
   /*---------------------------------------------------------------*/

   ATL_larfb(CblasRight, CblasNoTrans,         /* From top, Transposed,  */
              LAForward, LARowStore,           /* Forward, Columnwise.    */
              bottom,                          /* Update area is bottom rows,  */
              N,                               /* 'bottom' columns,        */
              top,                             /* V is 'top' columns.    */
              A, LDA,                          /* V array (inside A)      */
              ws_T, LDT,                       /* T array (in work space) */
              A+(top SHIFT), LDA,              /* Array to update.        */
              WORKM, M);                       /* Workspace, leading dim. */

   /*---------------------------------------------------------------*/
   /* On the bottom half, we must adjust all pointers.               */
   /*---------------------------------------------------------------*/
   ATL_gelqr(bottom, N-top,                       /* Shorter rows.        */
              (A+(top SHIFT)+top*LDA2), LDA,     /* A at A[top,top].      */
              (TAU+(top SHIFT)),                  /* TAU at TAU[top].       */
              ws_QR2,                              /* No returned values.     */
             ( ws_T+(top SHIFT)+top*LDT2), LDT,  /* Build T at T[top,top].*/
              WORKM, buildT);                      /* No returned values.     */

   /*---------------------------------------------------------------*/
   /* If we build T, the left/top side must be completely built, and */
   /* the right/bottom side should be partially built. We need to fill in  */
   /* the upper left hand block, 'top' rows by 'bottom' columns.   */
   /* The formula is -T1 * (Y1 * Y2^T) * T2.                        */
   /* The routine is in ATL_larft.c.                               */
   /*---------------------------------------------------------------*/

   if (buildT)
   {
      ATL_larft_block(LAForward, LARowStore, N, M, top, bottom,  A, LDA,
                     ws_T, LDT);            /* Build the T matrix.        */
   }
   return(0);
} /* END ATL_gelqr */

@ROUT ATL_gerqf
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DGERQF( M, N, A, LDA, TAU, WORK, LWORK, INFO )
 *
 * ATL_gerqf.c :
 * int ATL_gerqf(int M, int N, TYPE  *A, int LDA, TYPE  *TAU,
 *              TYPE *WORK, int LWORK)
 *
 *  Purpose
 *  =======
 *
 *  ATL_gerqf  computes a RQ factorization of a real/complex M-by-N matrix A:
 *  A =R * Q.
 *
 *  Compared to LAPACK, here, a recursive pannel factorization is implemented.
 *  Refer ATL_gerqr.c andd ATL_larft.c for details.
 *
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output)  array, dimension (LDA,N)
 *          On entry, the m by n matrix A.
 *          On exit, if m <= n, the upper triangle of the subarray
 *          A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
 *          if m >= n, the elements on and above the (m-n)-th subdiagonal
 *          contain the m by n upper trapezoidal matrix R; the remaining
 *          elements, with the array TAU, represent the orthogonal matrix
 *          (unitary matrix incase of complex precision )  as a
 *          as a product of elementary reflectors (see Further
 *          Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *
 *  TAU     (output)  array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *  WORK    (workspace/output) array, dimension (MAX(1,LWORK))
 *          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
 *
 *  LWORK   (input) INTEGER
 *          The dimension of the array WORK.  LWORK >= max(1,M).
 *          For optimum performance LWORK >= M*NB, where NB is
 *          the optimal blocksize.
 *
 *          If LWORK = -1, then a workspace query is assumed; the routine
 *          only calculates the optimal size of the WORK array, returns
 *          this value as the first entry of the WORK array, and no error
 *          message related to LWORK is issued by XERBLA.
 *
 *
 *  INFO    (output) INTEGER
 *          = 0: successful exit
 *          < 0: if INFO = -i, the i-th argument had an illegal value
 *
 *  Further Details
 *  ===============
 *
 *  The matrix Q is represented as a product of elementary reflectors
 *
 *     Q = H(1) H(2) . . . H(k), where k = min(m,n).    (for Real precison)
 *     Q = H(1)' H(2)' . . . H(k)', where k = min(m,n). (for Complex Precison)
 *         (Note : Conjugate Transpose of H is taken above)
 *
 *  Each H(i) has the form
 *
 *     H(i) = I - tau * v * v'                 (for Real Precision)
 *     H(i) = I - tau * v * conjugate(v)'      (for Complex  Precision)
 *
 *  where tau is a real scalar, and v is a real vector with
 *  v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
 *  A(m-k+i,1:n-k+i-1), and tau in TAU(i).
 *----------------------------------------------------------------------------*/

#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

#ifdef  SREAL
     #define MYOPT LASreal
#endif
#ifdef  DREAL
    #define MYOPT  LADreal
#endif
#ifdef  SCPLX
    #define MYOPT  LAScplx
#endif
#ifdef  DCPLX
    #define MYOPT  LADcplx
#endif


int ATL_gerqf(int M, int N, TYPE  *A, int LDA, TYPE  *TAU,
               TYPE *WORK, int LWORK)
{
   int LQUERY, I, IB, IINFO, IWS, K, LDWORK, NB, NBMIN, LoopNB, NX, NEWN;
   int INFO, MAXMN;
   int i, LDA2, NB2, buildT;

   int NBOVERRIDE= 8;

   TYPE  *ws_RQ2,  *ws_T, *ws_larfb;   /* Workspace for LQ2,T, larfb          */

   /* Get NB  */
   NB = ATL_ilaenv(LAIS_OPT_NB, LAgerqf, MYOPT, M, N, -1, -1);

   MAXMN = (M<N)?N:M;                  /* Get Max     */
   INFO = 0;

   if (LWORK < 0)                     /* Query logic  */
   {
      /* Retun the size of work space required. This needs to be allocated    */
      /* by the caller                                                        */
      /* Work = Workspace for ATL_larfb + WS for ATL_larft + WS for ATL_geqr2 */


      //Temporary Logic
      if (NB < NBOVERRIDE  ) NB = NBOVERRIDE;

      *WORK = ( MAXMN*NB + NB*NB + MAXMN )  ;
      return(0);
   } else if (LWORK < (MAXMN*NB + NB*NB + MAXMN))
   {
      /* Check for the size of workspace allocated by the caller              */
      fprintf(stderr, "ATL_gerqf Error LWORK SHORT! LWORK=%i, MAXMN*NB=%i. \n",
      LWORK, MAXMN*NB);
      fflush(stderr);
   }


   /*
    *     Quick return if possible
    */
   if (M < 0) INFO = -1;
   else if (N < 0) INFO = -2;
   else if (LDA < M) INFO = -4;
   if (INFO != 0)
   {
      fprintf(stderr, "ERROR, RF, INFO=%i.\n", -INFO);
      return(INFO);
   }

   K = (M<N)?M:N;                      /* Get min */
   if (K == 0)
   {
      return(INFO);
   }

@beginskip
   NBMIN = 2;
   /* Get NX  */
   NX = ATL_ilaenv(LAIS_NBXOVER, LAgerqf, MYOPT, M, N, -1, -1);

   if (NX < 0) NX=0;
   //TODO :     remove this  hardcoding  later
   NBMIN = 1;
   if (NB < NBOVERRIDE  ) NB = NBOVERRIDE;
   NX = 0;
@endskip
   NBMIN = 2; NX = 0;

   /* Make the Workspace for ATL_larft and ATL_geqr2 and ATL_larfb            */
   ws_T = WORK;                             /* T workspace to begining of work*/
   ws_RQ2 = (WORK +(NB SHIFT)*NB );         /* After T Work space             */
   ws_larfb =  (WORK +(NB SHIFT)*NB
                     +  (MAXMN SHIFT) );    /* After workspace for T and LQ2  */

   /* Initialize I to K-NB             */
   I = K-NB;


   LDA2 = LDA SHIFT;                             /* for Complex LDA *2        */
   NB2  = NB SHIFT;                              /* for complex NB  *2        */

//   if (NB >= NBMIN && NB < K && NX < K)   //TO DO remoove the bottom
   if (NB >= NBMIN && NB <= K && NX < K)
   {
      /*
       *        Use blocked code initially
       */
//      while (I < K-NX)
      for( I =K-NB; I >= NX; I = I-NB)
      {
//         NEWN = I;

//         LoopNB = NB;
         /**********************************************/
         /* If not enough left for LoopNB, do leftover.*/
         /**********************************************/
//         IB = (NEWN < LoopNB)?NEWN:LoopNB;  /* Find min but check this condiotoin SIJU                        */
//         if ( IB == 0) IB = NB; /* To take care of special case when I = 0    */

         IB = NB;


         /* Compute the QL factorization of the current block                 */
         /*           A(1:m-k+i+ib-1,n-k+i:n-k+i+ib-1)                        */

         buildT = 1;                        /* Set it for time being .        */
         IINFO = ATL_gerqr( IB, N-K+I+IB,  (A + ((M-K+I) SHIFT)) ,
                                LDA, (TAU + ( I SHIFT)),
                                ws_RQ2, ws_T, NB, ws_larfb, buildT);


         if (M-K+I > 0)
         {

            /* Form the triangular factor of the block reflector              */
            /*   H = H(i+ib-1) . . . H(i+1) H(i)                              */
            /*                                                                */
            /*  After geqrr, ws_T contains 'T', the IB x IB triangular        */
            /*  factor 'T' of the block reflector. It is an output used       */
            /*  in the next call, dlarfb.                                     */
            /*  H = Id - Y*T*Y', with Id=(M-I)x(M-I), Y=(M-I)xIB. SIJU check this */
            /*                                                                */
            /*  Apply H' to A(i:m,i+ib:n) from the left                       */
            /*  Apply H' to A(1:m-k+i+ib-1,1:n-k+i-1) from the left SIJU check this is it not from right    */

            /*                                                                */
            /*  The ws_T array used above is an input to dlarfb; it is        */
            /*  'T' in that routine, and LDT x K (translates here to          */
            /*  LDWORK x IB). The  use of WORK is an array that               */
            /*  must be LDWORK x K (IB = K), but is not an output.            */

               ATL_larfb(CblasRight, CblasNoTrans, LABackward, LARowStore,
                  M-K+I, N-K+I+IB, IB,
                  (A+ ((M-K+I) SHIFT) ),          /* POinter to V or Y matrix */
                          LDA, ws_T, NB ,
                          A,                      /* A -Remainder            */
                          LDA, ws_larfb, M);
         }

         //I = I + IB;
      } /* END WHILE I <= K-NX */
   }

   /*   Use unblocked code to factor the last or only block.                  */
   if ((I+NB) > 0)
   {

      I = I + NB;
      IINFO = ATL_gerq2(M-K+I, N-K+I,
              (A), LDA, (TAU),
               ws_RQ2);
   }

   return(INFO);
} /* END ATL_dgerqf */

@ROUT ATL_gerqr
/*-----------------------------------------------------------------------------
 * This is a recursive implementation of ATL_dgeqrf.c; it performs a QR
 * factorization of a panel (M > N) with a bottom level of ATL_geqr2. The
 * recursion is on columns only; it divides by 2 until it reaches a
 * stopping point; at which time it calls ATL_geqr2 to complete a sub-panel,
 * ATL_larft and ATL_larfb to propagate the results, etc.
 *
 * ATL_gerqr.c :
 * int ATL_gerqr(int M, int N, TYPE *A, int LDA, TYPE  *TAU,
 *               TYPE *ws_QR2, TYPE *ws_T, int LDT,
 *               TYPE *WORKM, int buildT)
 *      NOTE :   ATL_geqr2.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *  Purpose
 *  =======
 *
 *  ATL_gerqr computes a QR factorization of a real M-by-N matrix A:
 *  A = R * Q.
 *
 *  Arguments
 *  =========
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix A.  M >= 0.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix A.  N >= 0.
 *
 *  A       (input/output)  array, dimension (LDA,N)
 *          On entry, the M-by-N matrix A.
 *          On exit, the elements on and above the diagonal of the array
 *          contain the min(M,N)-by-N upper trapezoidal matrix R (R is
 *          upper triangular if m >= n); the elements below the diagonal,
 *          with the array TAU, represent the orthogonal matrix Q as a
 *          product of min(m,n) elementary reflectors (see Further
 *          Details).
 *
 *  LDA     (input) INTEGER
 *          The leading dimension of the array A.  LDA >= max(1,M).
 *          If LDA == 0, returns work sizes in *WORKV and *WORKM.
 *
 *  TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
 *          The scalar factors of the elementary reflectors (see Further
 *          Details).
 *
 *  WORKM   Work space matrix, double precision matrix at least M rows by
 *          N columns; the amount used by larft and larfb.
 *
 *  buildT  If non-zero, dgerqr will build in ws_T the complete T necessary
 *          for the original panel it is passed;
 *          such that Q= I - transpose(Y) * T * Y.
 *          If zero, ws_T will contain only those elements of T necessary to
 *          complete the panel.
 -----------------------------------------------------------------------------*/

#ifndef NBRQF2
    #define   NBRQF2 4
#endif

int ATL_gerqr(int M, int N, TYPE *A, int LDA, TYPE  *TAU,
               TYPE *ws_LQ2, TYPE *ws_T, int LDT,
               TYPE *WORKM, int buildT)
{

   int I, top, bottom, INFO, IINFO, lbuilt, rbuilt;
   int LDA2 = LDA SHIFT;                        /* for complex LDA *2         */
   int LDT2 = LDT SHIFT;                        /* for complex LDT *2         */


   if (M == 0) return;                          /* Nothing to do.             */

@skip   if (M <= NBRQF2)                             /* If we hit stopping point,  */
/*
 * Stop recursion if problem cache contained, or no more benefit from L3BLAS
 */
   if (ATL_MulBySize(M)*N <= LA_CE || N <= 4)
   {
      ATL_gerq2(M, N, A, LDA, TAU, ws_LQ2);

      if (buildT)
      {
         ATL_larft(LABackward, LARowStore, N, M, A, LDA,
                    TAU, ws_T, LDT);            /* Build the T matrix.        */
      }

      return(0);                                /* All okay.                  */
   }

//   top = (M>>3)<<2;                           /* Find top half, 0 mod 4.  */
   top = (M>>2)<<1;                           /* This one is just for testing remove TODO  */
   if (top ==0)                               /* If nothing top on top,  */
   {
      ATL_gerq2(M, N, A, LDA, TAU, ws_LQ2);

      if (buildT)
      {
         ATL_larft(LABackward, LARowStore, N, M, A, LDA,
                    TAU, ws_T, LDT);            /* Build the T matrix.        */
      }

      return(0);                                /* Built no part of T.        */
   }

   bottom = M - top;                            /* Find the bottom half.        */

   /*---------------------------------------------------------------*/
   /* On the bottom half, we use the same workspaces.                 */
   /* Because we know we have a top hand side we must always      */
   /* build T, so we can multiply by Q before doing the top side. */
   /*---------------------------------------------------------------*/
   ATL_gerqr(bottom,N, (A+(top SHIFT)), LDA, (TAU+(top SHIFT)), ws_LQ2,
             ( ws_T+(top SHIFT)+top*LDT2), LDT,  /* Build T at T[top,top].*/
              WORKM, 1);

   /*---------------------------------------------------------------*/
   /* Now we must adjust the top hand side according to our T.    */
   /* We must apply H'                                             */
   /*---------------------------------------------------------------*/
   // SIJU SIJU   code below not corrected


   ATL_larfb(CblasRight, CblasNoTrans,         /* From right,Not  Transposed,  */
              LABackward, LARowStore,                        /* Backward, Rowwise.    */
              top,                               /* Update area is top rows (remainder),  */
              N,                            /* 'N' columns (remainder) */
              bottom,                           /* V is 'bottom' columns.    */
              (A +(top SHIFT))  , LDA,        /* V array (inside A)      */
//              ws_T, LDT,                       /* T array (in work space) */
             ( ws_T+(top SHIFT)+top*LDT2), LDT,  /* Build T at T[top,top].*/
              A, LDA,              /* Array to update.        */
              WORKM, M);                       /* Workspace, leading dim. */

   /*---------------------------------------------------------------*/
   /* On the top  half, */
   /*---------------------------------------------------------------*/
   ATL_gerqr(top, N-bottom,               /* Shorter columns.        */
              (A), LDA,     /* A at A[0,0].      */
              (TAU),                  /* TAU at TAU[top].       */
              ws_LQ2,                              /* No returned values.     */
             ( ws_T), LDT,  /* Build T at T[top,top].*/
              WORKM, buildT);                      /* No returned values.     */

   /*---------------------------------------------------------------*/
   /* If we build T, the bottom side must be completely built, and    */
   /* the top side should be partially built. We need to fill in  */
   /* the lower  left  hand block, 'bottom' rows by 'top' columns.   */
   /* The formula is -T2 * (Y2 * Y1^T) * T1.                        */
   /* The routine is in ATL_larft.c.                               */
   /*---------------------------------------------------------------*/

   if (buildT)
   {
      ATL_larft_block(LABackward, LARowStore,N, M, top, bottom,
         A, LDA, ws_T, LDT);                    /* compute upper corner.   */
   }

   return(0);
} /* END ATL_gerqr */

@ROUT ATL_lapy2
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *      DOUBLE PRECISION FUNCTION DLAPY2( X, Y )
 *      NOTE : ATL_lapy2.c  will get compiled to
 *             single precision  (ATL_slapy2.o)  and
 *              double precision (ATL_dlapt2.o)
 *
 *  Purpose
 *  =======
 *
 *  DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
 *  overflow.
 *
 *  Arguments
 *  =========
 *
 *  X       (input) single/double precision
 *  Y       (input) single/double precision
 *          X and Y specify the values x and y.
 *
 *----------------------------------------------------------------------------*/
#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

TYPE  ATL_lapy2(TYPE X, TYPE Y)
{
   TYPE  ONE=1.0, ZERO=0.0, W, Z, XABS, YABS, TEMP;

   //Find absolute values
   XABS = Mabs(X);
   YABS = Mabs(Y);
   W = (XABS<YABS)?YABS:XABS;
   Z = (XABS<YABS)?XABS:YABS;

   if (Z == ZERO) return(W);
   /* NOTE: If Z != 0, then W != 0 */
   TEMP = Z/W;


   TEMP = ONE + TEMP*TEMP;
   return(W * sqrt(TEMP));
} /* END ATL_dlapy2 */

@ROUT ATL_larfb
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *     SUBROUTINE DLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV,
 *     $                   T, LDT, C, LDC, WORK, LDWORK )
 *
 * ATL_larfb.c :
 *
 * void ATL_larfb(const enum CBLAS_SIDE SIDE, const enum CBLAS_TRANSPOSE TRANS,
 *     const enum ATL_LADIRECT  DIRECT, const enum ATL_LASTOREV STOREV,
 *                int M, int N, int K, TYPE *V, int LDV, TYPE *T, int LDT,
 *               TYPE *C, int LDC, TYPE *WORK, int LDWORK)
 *
 *
 *     NOTE :   ATL_larfb.c will get compiled to four precisions
 *                    single precision real,      double precision real
 *                    single precision complex,   double precision complex
 *  Purpose
 *  =======
 *
 *  ATL_larf  applies a real block reflector H or its transpose H' to a
 *  real/complex m by n matrix C, from either the left or the right.
 *
 *  Arguments
 *  =========
 *
 *  SIDE    (input) CHARACTER*1
 *          = 'L': apply H or H' from the Left
 *          = 'R': apply H or H' from the Right
 *
 *  TRANS   (input) CHARACTER*1
 *          = 'N': apply H (No transpose)
 *          = 'T': apply H' (Transpose)
 *
 *  DIRECT  (input) CHARACTER*1
 *          Indicates how H is formed from a product of elementary
 *          reflectors
 *          = 'F': H = H(1) H(2) . . . H(k) (Forward)
 *          = 'B': H = H(k) . . . H(2) H(1) (Backward)
 *
 *  STOREV  (input) CHARACTER*1
 *          Indicates how the vectors which define the elementary
 *          reflectors are stored:
 *          = 'C': Columnwise
 *          = 'R': Rowwise
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix C.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix C.
 *
 *  K       (input) INTEGER
 *          The order of the matrix T (= the number of elementary
 *          reflectors whose product defines the block reflector).
 *
 *  V       (input)  array, dimension
 *                                (LDV,K) if STOREV = 'C'
 *                                (LDV,M) if STOREV = 'R' and SIDE = 'L'
 *                                (LDV,N) if STOREV = 'R' and SIDE = 'R'
 *          The matrix V. See further details.
 *
 *  LDV     (input) INTEGER
 *          The leading dimension of the array V.
 *          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
 *          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
 *          if STOREV = 'R', LDV >= K.
 *
 *  T       (input)  array, dimension (LDT,K)
 *          The triangular k by k matrix T in the representation of the
 *          block reflector.
 *
 *  LDT     (input) INTEGER
 *          The leading dimension of the array T. LDT >= K.
 *
 *  C       (input/output)  array, dimension (LDC,N)
 *          On entry, the m by n matrix C.
 *          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.
 *
 *  LDC     (input) INTEGER
 *          The leading dimension of the array C. LDA >= max(1,M).
 *
 *  WORK    (workspace) array, dimension (LDWORK,K)
 *
 *  LDWORK  (input) INTEGER
 *          The leading dimension of the array WORK.
 *          If SIDE = 'L', LDWORK >= max(1,N);
 *          if SIDE = 'R', LDWORK >= max(1,M).
 *
 *  =====================================================================
 *  TonyC: When called by dgeqrf, V=&A(I,I), LDV=LDA. T=WORK, LDT=LDWORK.
 *  C=&A(I,I+IB), LDC=LDA. WORK=&WORK(IB+1), LDWORK=LDWORK. K=IB.
 -----------------------------------------------------------------------------*/
#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

#ifdef TREAL
    #define MY_TRANS CblasTrans
#else
    #define MY_TRANS CblasConjTrans
#endif

void ATL_larfb(const enum CBLAS_SIDE SIDE, const enum CBLAS_TRANSPOSE TRANS,
     const enum ATL_LADIRECT  DIRECT, const enum ATL_LASTOREV STOREV,
                int M, int N, int K, TYPE *V, int LDV, TYPE *T, int LDT,
                TYPE *C, int LDC, TYPE *WORK, int LDWORK)

{
   enum CBLAS_TRANSPOSE CTRANS, CTRANST;
   int    i, j;
   int  LDV2,LDC2, LDWORK2;
   LDV2 = LDV SHIFT;                          /* For complex, LDV*2           */
   LDC2 = LDC SHIFT;                          /* For complex, LDC*2           */
   LDWORK2 = LDWORK SHIFT;                    /* For complex, LDWORK * 2      */

   #ifdef TREAL
      const TYPE ONE = ATL_rone;
      const TYPE ZEROVAL = ATL_rzero;
          const TYPE NONE = ATL_rnone;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      const TYPE NONE[2] = {ATL_rnone, ATL_rzero};
      const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
   #endif

   /* Quick return if possible            */
   if (M <= 0 || N <= 0) return;          /* Early exit */

    /* Translate the Transpose and Transpose-Transpose settings */
      if (TRANS == CblasNoTrans )
      {
         CTRANS = CblasNoTrans;
         #ifdef TREAL
             CTRANST = CblasTrans;
         #else
             CTRANST = CblasConjTrans;
         #endif
      } else
      {
         #ifdef TREAL
            CTRANS = CblasTrans;
         #else
            CTRANS = CblasConjTrans;
         #endif
         CTRANST = CblasNoTrans;
      }

      if (STOREV == LAColumnStore)
      {
         if (DIRECT == LAForward )
         {
/*
 *           Let  V =  ( V1 )    (first K rows)
 *                     ( V2 )
 *           where  V1  is unit lower triangular.
 */
            if (SIDE == CblasLeft)
            {
/*
 *             Form  H * C  or  H' * C  where  C = ( C1 )
 *                                                 ( C2 )
 *
 *             W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)
 *
 *             W := C1'
 */
               for (j=0; j<K; j++)
               {
                  cblas_copy(N, C+(j SHIFT), LDC, WORK+j*LDWORK2, 1);
                  //For complex, make it conjugate
                  #ifdef TCPLX
                     ATL_lacgv(N,  WORK+j*LDWORK2, 1);
                       /* Making conjugate. Keep INCX as 2 */
//                       #ifdef SCPLX
//                           cblas_sscal(N*2, -1.0, WORK+j*LDWORK2, 2);
//                       #endif
//                       #ifdef DCPLX
//                           cblas_dscal(N*2, -1.0, WORK+j*LDWORK2, 2);
//                       #endif
                  #endif
               }

/*
 *             W := W * V1
 */
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasLower, CblasNoTrans, CblasUnit,
                           N, K, ONE, V, LDV, WORK, LDWORK);

               if (M > K)
               {
/*
 *                 W := W + C2'*V2
 */
                 //Conj trans change approapriately
                  cblas_gemm(CblasColMajor,
                      MY_TRANS, CblasNoTrans, N, K, M-K, ONE, C+(K SHIFT),
                              LDC, V+(K SHIFT), LDV, ONE, WORK, LDWORK);
               }
/*
 *             W := W * T'  or  W * T
 *
 *             'T' is the non-unit upper triangular array, on the right.
 *             alpha is one.
 */
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasUpper, CTRANST, CblasNonUnit,
                           N, K, ONE, T, LDT, WORK, LDWORK);
/*
 *             C := C - V * W'
 */
               if (M > K)
               {
/*
 *                 C2 := C2 - V2 * W'
 */
                  cblas_gemm(CblasColMajor,
                         CblasNoTrans, MY_TRANS, M-K, N, K, NONE,
                         V+(K SHIFT), LDV, WORK, LDWORK, ONE, C+(K SHIFT), LDC);
               }
/*
 *             W := W * V1'
 */
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasLower, MY_TRANS, CblasUnit,
                           N, K, ONE, V, LDV, WORK, LDWORK);
/*
 *             C1 := C1 - W'
 */
               for (j=0; j< (K ) ; j++)
               {
                  for (i=0; i<N; i++)
                  {
                    #ifdef TREAL
                       C[j+i*LDC2] -= WORK[i+j*LDWORK2];
                    #else
                       C[(j SHIFT) +i*LDC2] -= WORK[(i SHIFT) +j*LDWORK2];
                       /* Conjugate is taken, hence the addition              */
                      C[(j SHIFT) +i*LDC2 +1 ] += WORK[(i SHIFT) +j*LDWORK2 +1];
                    #endif
                  }
               } /*for */
            } else if (SIDE == CblasRight)
            {
/*
*              Form  C * H  or  C * H'  where  C = ( C1  C2 )
*
*              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
*
*              W := C1

               DO 40 J = 1, K
                  CALL DCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 )
*/
               for (j=0; j<K; j++)
               {
                  cblas_copy(M, C+(j*LDC), 1, WORK+j*LDWORK, 1);
               }
/* 40          CONTINUE */
/*
*              W := W * V1
*
               CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', M,
     $                     K, ONE, V, LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasLower, CblasNoTrans, CblasUnit,
                           M, K, ONE, V, LDV, WORK, LDWORK);
               if (N > K)
               {
/*
*                 W := W + C2 * V2
*
                  CALL DGEMM( 'No transpose', 'No transpose', M, K, N-K,
     $                        ONE, C( 1, K+1 ), LDC, V( K+1, 1 ), LDV,
     $                        ONE, WORK, LDWORK )
*/
                  cblas_gemm(CblasColMajor,
                              CblasNoTrans, CblasNoTrans, M, K, N-K, ONE,
                              C+K*LDC, LDC, V+K, LDV, ONE, WORK, LDWORK);
               }

/*
*              W := W * T  or  W * T'
*
               CALL DTRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasUpper, CTRANS, CblasNonUnit, M, K,
                           ONE, T, LDT, WORK, LDWORK);

/*
*              C := C - W * V'
*/
               if (N > K)
               {
/*
*                 C2 := C2 - W * V2'
*
                  CALL DGEMM( 'No transpose', 'Transpose', M, N-K, K,
     $                        -ONE, WORK, LDWORK, V( K+1, 1 ), LDV, ONE,
     $                        C( 1, K+1 ), LDC )
*/
                  cblas_gemm(CblasColMajor,
                              CblasNoTrans, CblasTrans, M, N-K, K, NONE,
                              WORK, LDWORK, V+K, LDV, ONE, C+K*LDC, LDC);
               }

/*
*              W := W * V1'
*
               CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', M, K,
     $                     ONE, V, LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasLower, CblasTrans, CblasUnit,
                           M, K, ONE, V, LDV, WORK, LDWORK);

/*
*              C1 := C1 - W
*
               DO 60 J = 1, K
                  DO 50 I = 1, M
                     C( I, J ) = C( I, J ) - WORK( I, J )
   50             CONTINUE
   60          CONTINUE
*/
               for (j=0; j<K; j++)
               {
                  for (i=0; i<M; i++)
                  {
                     C[i+j*LDC] -= WORK[i+j*LDWORK];
                  }
               }
            } /* SIDE == CblasRight */
         } else /* DIRECT != LAForward */
         {
/*
*           Let  V =  ( V1 )
*                     ( V2 )    (last K rows)
*           where  V2  is unit upper triangular.
*/
            if (SIDE == CblasLeft)
            {
/*             Form  H * C  or  H' * C  where  C = ( C1 )
*                                                  ( C2 )
*
*              W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)
*
*              W := C2'
*
               DO 70 J = 1, K
                  CALL DCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 )
   70          CONTINUE
*/
               for (j=0; j<K; j++)
               {
                  cblas_copy(N, C +((M-K+j) SHIFT) , LDC, WORK+j*LDWORK2, 1);
                  //For complex, make it conjugate
                  #ifdef TCPLX
                     ATL_lacgv(N,  WORK+j*LDWORK2, 1);
                  #endif
               }

/*
*              W := W * V2
*
               CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', N,
     $                     K, ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasUpper, CblasNoTrans, CblasUnit,
                           N, K, ONE, V+((M-K) SHIFT), LDV, WORK, LDWORK);

               if (M > K)
               {

/*
*                 W := W + C1'*V1
*
                  CALL DGEMM( 'Transpose', 'No transpose', N, K, M-K,
     $                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
*/
                  cblas_gemm(CblasColMajor,
                              MY_TRANS, CblasNoTrans, N, K, M-K, ONE, C,
                              LDC, V, LDV, ONE, WORK, LDWORK);
               }

/*
*              W := W * T'  or  W * T
*
               CALL DTRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasLower, CTRANST, CblasNonUnit, N,
                           K, ONE, T, LDT, WORK, LDWORK);

/*
*              C := C - V * W'
*/
               if (M > K)
               {

/*
*                 C1 := C1 - V1 * W'
*
                  CALL DGEMM( 'No transpose', 'Transpose', M-K, N, K,
     $                        -ONE, V, LDV, WORK, LDWORK, ONE, C, LDC )
*/
                  cblas_gemm(CblasColMajor,
                              CblasNoTrans, MY_TRANS, M-K, N, K, NONE,
                              V, LDV, WORK, LDWORK, ONE, C, LDC);
               }

/*
*              W := W * V2'
*
               CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', N, K,
     $                     ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasUpper, MY_TRANS, CblasUnit, N,
                           K, ONE, V+((M-K) SHIFT), LDV, WORK, LDWORK);

/*
*              C2 := C2 - W'
*
               DO 90 J = 1, K
                  DO 80 I = 1, N
                     C( M-K+J, I ) = C( M-K+J, I ) - WORK( I, J )
   80             CONTINUE
   90          CONTINUE
*/
               for (j=0; j<K; j++)
               {
                  for (i=0; i<N; i++)
                  {
                    #ifdef TREAL
                       C[M-K+j+i*LDC] -= WORK[i+j*LDWORK];
                    #else
                       C[((M-K+j) SHIFT) +i*LDC2] -= WORK[(i SHIFT) +j*LDWORK2];
                       /* Conjugate is taken, hence the addition              */
                       C[((M-K+j) SHIFT) + 1+ i*LDC2] += WORK[(i SHIFT)+ 1 +j*LDWORK2];
                    #endif
                  }
               }
            } else if (SIDE == CblasRight)
            {
/*
*              Form  C * H  or  C * H'  where  C = ( C1  C2 )
*
*              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
*
*              W := C2
*
               DO 100 J = 1, K
                  CALL DCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 )
  100          CONTINUE
*/
               for (j=0; j<K; j++)
               {
                  cblas_copy(M, C+(N-K+j)*LDC, 1, WORK+(j*LDWORK), 1);
               }

/*
*              W := W * V2
*
               CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', M,
     $                     K, ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasUpper, CblasNoTrans, CblasUnit,
                           M, K, ONE, V+(N-K), LDV, WORK, LDWORK);
               if (N > K)
               {
/*
*                 W := W + C1 * V1
*
                  CALL DGEMM( 'No transpose', 'No transpose', M, K, N-K,
     $                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
*/
                  cblas_gemm(CblasColMajor,
                              CblasNoTrans, CblasNoTrans, M, K, N-K, ONE, C,
                              LDC, V, LDV, ONE, WORK, LDWORK);
               }

/*
*              W := W * T  or  W * T'
*
               CALL DTRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasLower, CTRANS, CblasNonUnit, M, K,
                           ONE, T, LDT, WORK, LDWORK);

/*
*              C := C - W * V'
*/

               if (N > K)
               {

/*
*                 C1 := C1 - W * V1'
*
                  CALL DGEMM( 'No transpose', 'Transpose', M, N-K, K,
     $                        -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC )
*/
                  cblas_gemm(CblasColMajor,
                              CblasNoTrans, CblasTrans, M, N-K, K, NONE,
                              WORK, LDWORK, V, LDV, ONE, C, LDC);
               }

/*
*              W := W * V2'
*
               CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', M, K,
     $                     ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasUpper, CblasTrans, CblasUnit,
                           M, K, ONE, V+(N-K), LDV, WORK, LDWORK);

/*
*              C2 := C2 - W
*
               DO 120 J = 1, K
                  DO 110 I = 1, M
                     C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J )
  110             CONTINUE
  120          CONTINUE
*/
               for (j=0; j<K; j++)
               {
                  for (i=0; i<M; i++)
                  {
                     C[i+(N-K+j)*LDC] -= WORK[i+j*LDWORK];
                  }
               }
            } /* END IF SIDE == CblasRight */
         }
      } else if (STOREV == LARowStore)
      {

         if (DIRECT == LAForward)
         {
/*           Let  V =  ( V1  V2 )    (V1: first K columns)
*           where  V1  is unit upper triangular.
*/
            if (SIDE == CblasLeft)
            {
/*
*              Form  H * C  or  H' * C  where  C = ( C1 )
*                                                  ( C2 )
*
*              W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)
*
*              W := C1'
*
               DO 130 J = 1, K
                  CALL DCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 )
  130          CONTINUE
*/
               for (j=0; j<K; j++)
               {
                  cblas_copy(N, C+j, LDC, WORK+j*LDWORK, 1);
               }

/*
*              W := W * V1'
*
               CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', N, K,
     $                     ONE, V, LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasUpper, CblasTrans, CblasUnit,
                           N, K, ONE, V, LDV, WORK, LDWORK);

               if (M > K)
               {
/*
*                 W := W + C2'*V2'
*
                  CALL DGEMM( 'Transpose', 'Transpose', N, K, M-K, ONE,
     $                        C( K+1, 1 ), LDC, V( 1, K+1 ), LDV, ONE,
     $                        WORK, LDWORK )
*/
                  cblas_gemm(CblasColMajor,
                              CblasTrans, CblasTrans, N, K, M-K, ONE, C+K,
                              LDC, V+(K*LDV), LDV, ONE, WORK, LDWORK);
               }

/*
*              W := W * T'  or  W * T
*
               CALL DTRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasUpper, CTRANST, CblasNonUnit,
                           N, K, ONE, T, LDT, WORK, LDWORK);

/*
*              C := C - V' * W'
*/
               if (M > K)
               {
/*
*                 C2 := C2 - V2' * W'
*
                  CALL DGEMM( 'Transpose', 'Transpose', M-K, N, K, -ONE,
     $                        V( 1, K+1 ), LDV, WORK, LDWORK, ONE,
     $                        C( K+1, 1 ), LDC )
*/
                  cblas_gemm(CblasColMajor,
                              CblasTrans, CblasTrans, M-K, N, K, NONE,
                              V+(K*LDV), LDV, WORK, LDWORK, ONE, C+K, LDC);
               }

/*
*              W := W * V1
*
               CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', N,
     $                     K, ONE, V, LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasUpper, CblasNoTrans, CblasUnit,
                           N, K, ONE, V, LDV, WORK, LDWORK);

/*
*              C1 := C1 - W'
*
               DO 150 J = 1, K
                  DO 140 I = 1, N
                     C( J, I ) = C( J, I ) - WORK( I, J )
  140             CONTINUE
  150          CONTINUE
*/
               for (j=0; j<K; j++)
               {
                  for (i=0; i<N; i++)
                  {
                     C[j+i*LDC] -= WORK[i+j*LDWORK];
                  }
               }
            } else if (SIDE == CblasRight)
            {
/*              Form  C * H  or  C * H'  where  C = ( C1  C2 )
*
*              W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)
*
*              W := C1
*
               DO 160 J = 1, K
                  CALL DCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 )
  160          CONTINUE
*/

               for (j=0; j<K; j++)
               {
                  cblas_copy(M, C+j*LDC2, 1, WORK+j*LDWORK2, 1);
               }

/*
*              W := W * V1'
*
               CALL DTRMM( 'Right', 'Upper', 'Transpose', 'Unit', M, K,
     $                     ONE, V, LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasUpper, MY_TRANS, CblasUnit,
                           M, K, ONE, V, LDV, WORK, LDWORK);

               if (N > K)
               {
/*
*                 W := W + C2 * V2'
*
                  CALL DGEMM( 'No transpose', 'Transpose', M, K, N-K,
     $                        ONE, C( 1, K+1 ), LDC, V( 1, K+1 ), LDV,
     $                        ONE, WORK, LDWORK )
*/
                  cblas_gemm(CblasColMajor,
                              CblasNoTrans, MY_TRANS, M, K, N-K, ONE,
                              C+(K*LDC2), LDC, V+(K*LDV2), LDV, ONE, WORK,
                              LDWORK);

               }

/*
*              W := W * T  or  W * T'
*
               CALL DTRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasUpper, CTRANS, CblasNonUnit, M, K,
                           ONE, T, LDT, WORK, LDWORK);

/*
*              C := C - W * V
*/
               if (N > K)
               {

/*
*                 C2 := C2 - W * V2
*
                  CALL DGEMM( 'No transpose', 'No transpose', M, N-K, K,
     $                        -ONE, WORK, LDWORK, V( 1, K+1 ), LDV, ONE,
     $                        C( 1, K+1 ), LDC )
*/
                  cblas_gemm(CblasColMajor,
                              CblasNoTrans, CblasNoTrans, M, N-K, K, NONE,
                              WORK, LDWORK, V+(K*LDV2), LDV, ONE, C+(K*LDC2),
                              LDC);
               }

/*
*              W := W * V1
*
               CALL DTRMM( 'Right', 'Upper', 'No transpose', 'Unit', M,
     $                     K, ONE, V, LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasUpper, CblasNoTrans, CblasUnit,
                           M, K, ONE, V, LDV, WORK, LDWORK);

/*
*              C1 := C1 - W
*
               DO 180 J = 1, K
                  DO 170 I = 1, M
                     C( I, J ) = C( I, J ) - WORK( I, J )
  170             CONTINUE
  180          CONTINUE
*/
               for (j=0; j<K; j++)
               {
                  for (i=0; i<M; i++)
                  {
                     #ifdef TREAL
                        C[i+j*LDC] -= WORK[i+j*LDWORK];
                     #else
                       C[(i SHIFT)+j*LDC2] -= WORK[(i SHIFT)+j*LDWORK2];
                       C[(i SHIFT)+1+j*LDC2] -= WORK[(i SHIFT)+1+j*LDWORK2];
                     #endif
                  }
               }
            } /* END if SIDE == CblasRight */
         } else /* DIRECT != LAForward */
         {
/*          Let  V =  ( V1  V2 )    (V2: last K columns)
*           where  V2  is unit lower triangular.
*/
            if (SIDE == CblasLeft)
            {
/*              Form  H * C  or  H' * C  where  C = ( C1 )
*                                                  ( C2 )
*
*              W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)
*
*              W := C2'
*
               DO 190 J = 1, K
                  CALL DCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 )
  190          CONTINUE
*/
               for (j=0; j<K; j++)
               {
                  cblas_copy(N, C+M-K+j, LDC, WORK+j*LDWORK, 1);
               }

/*
*              W := W * V2'
*
               CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', N, K,
     $                     ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasLower, CblasTrans, CblasUnit, N,
                           K, ONE, V+(M-K)*LDV, LDV, WORK, LDWORK);

               if (M > K)
               {
/*
*                 W := W + C1'*V1'
*
                  CALL DGEMM( 'Transpose', 'Transpose', N, K, M-K, ONE,
     $                        C, LDC, V, LDV, ONE, WORK, LDWORK )
*/
                  cblas_gemm(CblasColMajor,
                              CblasTrans, CblasTrans, N, K, M-K, ONE, C, LDC,
                              V, LDV, ONE, WORK, LDWORK);
               }

/*
*              W := W * T'  or  W * T
*
               CALL DTRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasLower, CTRANST, CblasNonUnit, N,
                           K, ONE, T, LDT, WORK, LDWORK);

/*
*              C := C - V' * W'
*/
               if (M > K)
               {

/*
*                 C1 := C1 - V1' * W'
*
                  CALL DGEMM( 'Transpose', 'Transpose', M-K, N, K, -ONE,
     $                        V, LDV, WORK, LDWORK, ONE, C, LDC )
*/
                  cblas_gemm(CblasColMajor,
                              CblasTrans, CblasTrans, M-K, N, K, NONE, V,
                              LDV, WORK, LDWORK, ONE, C, LDC);
               }

/*
*              W := W * V2
*
               CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', N,
     $                     K, ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasLower, CblasNoTrans, CblasUnit, N,
                           K, ONE, V+(M-K)*LDV, LDV, WORK, LDWORK);

/*
*              C2 := C2 - W'
*
               DO 210 J = 1, K
                  DO 200 I = 1, N
                     C( M-K+J, I ) = C( M-K+J, I ) - WORK( I, J )
  200             CONTINUE
  210          CONTINUE
*/
               for (j=0; j<K; j++)
               {
                  for (i=0; i<N; i++)
                  {
                     C[M-K+j+i*LDC] -= WORK[i+j*LDWORK];
                  }
               }
            } else if (SIDE == CblasRight)
            {

/*             Form  C * H  or  C * H'  where  C = ( C1  C2 )
*
*              W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)
*
*              W := C2
*
               DO 220 J = 1, K
                  CALL DCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 )
  220          CONTINUE
*/
               for (j=0; j<K; j++)
               {
                  cblas_copy(M, C+(N-K+j)*LDC2, 1, WORK+j*LDWORK2, 1);
               }

/*
*              W := W * V2'
*
               CALL DTRMM( 'Right', 'Lower', 'Transpose', 'Unit', M, K,
     $                     ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasLower, MY_TRANS, CblasUnit, M,
                           K, ONE, V+(N-K)*LDV2, LDV, WORK, LDWORK);

               if (N > K)
               {

/*
*                 W := W + C1 * V1'
*
                  CALL DGEMM( 'No transpose', 'Transpose', M, K, N-K,
     $                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
*/
                  cblas_gemm(CblasColMajor,
                              CblasNoTrans, MY_TRANS, M, K, N-K, ONE, C,
                              LDC, V, LDV, ONE, WORK, LDWORK);
               }

/*
*              W := W * T  or  W * T'
*
               CALL DTRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K,
     $                     ONE, T, LDT, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasLower, CTRANS, CblasNonUnit, M, K,
                           ONE, T, LDT, WORK, LDWORK);

/*
*              C := C - W * V
*/
               if (N > K)
               {

/*
*                 C1 := C1 - W * V1
*
                  CALL DGEMM( 'No transpose', 'No transpose', M, N-K, K,
     $                        -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC )
*/
                  cblas_gemm(CblasColMajor,
                              CblasNoTrans, CblasNoTrans, M, N-K, K, NONE,
                              WORK, LDWORK, V, LDV, ONE, C, LDC);
               }

/*
*              W := W * V2
*
               CALL DTRMM( 'Right', 'Lower', 'No transpose', 'Unit', M,
     $                     K, ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )
*/
               cblas_trmm(CblasColMajor,
                           CblasRight, CblasLower, CblasNoTrans, CblasUnit,
                           M, K, ONE, V+(N-K)*LDV2, LDV, WORK, LDWORK);

/*
*              C1 := C1 - W   TODO: check this  C2 : = C2 - W
*
               DO 240 J = 1, K
                  DO 230 I = 1, M
                     C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J )
  230             CONTINUE
  240          CONTINUE
*/
               for (j=0; j<K; j++)
               {
                  for (i=0; i<M; i++)
                  {
                    #ifdef TREAL
                       C[i+(N-K+j)*LDC] -= WORK[i+j*LDWORK];
                    #else
                       C[(i SHIFT)+(N-K+j)*LDC2] -= WORK[(i SHIFT)+j*LDWORK2];
                       C[(i SHIFT)+1+(N-K+j)*LDC2] -= WORK[(i SHIFT)+1+j*LDWORK2];
                    #endif

                  }
               }
            } /* END IF SIDE == CblasRight */
         } /* END else DIRECT != LAForward */
      } /* END if STOREV == LARowwise */
      return;
/*
*     End of DLARFB
*/
} /* END ATL_dlarfb */

@ROUT ATL_larf
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK )
 *
 * ATL_larf.c
 * void ATL_larf(const enum  CBLAS_SIDE SIDE, const int M, const int N,TYPE *V,
 *              int INCV, SCALAR TAU, TYPE *C, int LDC, TYPE *WORK)
 *
 *     NOTE :   ATL_larf.c will get compiled to four precisions
 *                   single precision real,      double precision real
 *                   single precision complex,   double precision complex
 *
 *  Purpose
 *  =======
 *
 *  ATL_larf  applies a real/complex elementary reflector H to a real/complex
 *  m by n matrix  C, from either the left or the right. H is represented in
 *  the form
 *
 *        H = I - tau * v * v'                      ( For Real precision)
 *        H = I - tau * v * conjugate(v)'           ( For Real precision)
 *
 *  where tau is a real/complex  scalar and v is a real/complex  vector.
 *
 *  If tau = 0, then H is taken to be the unit matrix.
 *
 *  Arguments
 *  =========
 *
 *  SIDE    (input) CHARACTER*1
 *          = 'L': form  H * C
 *          = 'R': form  C * H
 *
 *  M       (input) INTEGER
 *          The number of rows of the matrix C.
 *
 *  N       (input) INTEGER
 *          The number of columns of the matrix C.
 *
 *  V       (input) array, dimension
 *                     (1 + (M-1)*abs(INCV)) if SIDE = 'L'
 *                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
 *          The vector v in the representation of H. V is not used if
 *          TAU = 0.
 *
 *  INCV    (input) INTEGER
 *          The increment between elements of v. INCV <> 0.
 *
 *  TAU     (input)
 *          The value tau in the representation of H.
 *          For complex  precison, it is a pointer  to  array
 *
 *  C       (input/output) array, dimension (LDC,N)
 *          On entry, the m by n matrix C.
 *          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
 *          or C * H if SIDE = 'R'.
 *
 *  LDC     (input) INTEGER
 *          The leading dimension of the array C. LDC >= max(1,M).
 *
 *  WORK    (workspace) array, dimension
 *                         (N) if SIDE = 'L'
 *                      or (M) if SIDE = 'R'
 *
 -----------------------------------------------------------------------------*/
#include <math.h>
#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

#ifdef TREAL
    #define MY_TRANS CblasTrans
#else
    #define MY_TRANS CblasConjTrans
#endif

void ATL_larf(const enum  CBLAS_SIDE SIDE, const int M, const int N,TYPE *V,
               int INCV, SCALAR TAU, TYPE *C, int LDC, TYPE *WORK)
{
   #ifdef TREAL
      const TYPE ONE     = ATL_rone;
      const TYPE ZEROVAL = ATL_rzero;
      TYPE NEGTAUVAL ;
   #else
      const TYPE ONE[2]     = {ATL_rone, ATL_rzero};
      const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
      TYPE NEGTAUVAL[2] ;
   #endif


   if (SIDE == CblasLeft)
   {
      /*
       *        Form  H * C
       */
      if (! SCALAR_IS_ZERO(TAU) )
      {
         #ifdef TREAL
             NEGTAUVAL = 0.-TAU;
         #else
             NEGTAUVAL[0]=0.-TAU[0];
             NEGTAUVAL[1]=0.-TAU[1];
         #endif
        /*
         *           w := C' * v
         */
         cblas_gemv(CblasColMajor, MY_TRANS, M, N, ONE, C, LDC,
                      V, INCV, ZEROVAL, WORK, 1);
        /*
         *           C := C - v * w'
         */
         #ifdef TREAL
            cblas_ger(CblasColMajor, M, N, NEGTAUVAL, V, INCV, WORK, 1,
                     C, LDC);
         #else
            cblas_gerc(CblasColMajor, M, N, NEGTAUVAL, V, INCV, WORK, 1,
                     C, LDC);
         #endif

      }
   }
   else /* SIDE != CblasLeft */
   {
      /*
       *        Form  C * H
       */
      if (! SCALAR_IS_ZERO(TAU) )
      {
         #ifdef TREAL
             NEGTAUVAL = 0.-TAU;
         #else
             NEGTAUVAL[0]=0.-TAU[0];
             NEGTAUVAL[1]=0.-TAU[1];
         #endif
         /*
          *           w := C * v
          */
         cblas_gemv(CblasColMajor, CblasNoTrans, M, N, ONE,
                        C, LDC, V, INCV, ZEROVAL, WORK, 1);
         /*
          *           C := C - w * v'
          */
         #ifdef TREAL
            cblas_ger(CblasColMajor, M, N, NEGTAUVAL, WORK, 1,
                       V, INCV, C, LDC);
         #else
            cblas_gerc(CblasColMajor, M, N, NEGTAUVAL, WORK, 1,
                       V, INCV, C, LDC);
         #endif
      }
   }
      return;
} /* END ATL_larf */
@ROUT ATL_larfg
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *     SUBROUTINE DLARFG( N, ALPHA, X, INCX, TAU )
 *
 * ATL_larfg.c :
 * void ATL_larfg( const int N, TYPE *ALPHA, TYPE *X, int INCX, TYPE *TAU)
 *        NOTE : ATL_larfg.c  will get compiled to 4 precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *  Purpose
 *  =======
 *
 *  Real Precision
 *  --------------
 *
 *  ATL_larfg generates a real/complex  elementary reflector H of order n, such
 *  that
 *
 *        H * ( alpha ) = ( beta ),   H' * H = I.
 *            (   x   )   (   0  )
 *
 *  where alpha and beta are scalars, and x is an (n-1)-element real
 *  vector. H is represented in the form
 *
 *        H = I - tau * ( 1 ) * ( 1 v' ) ,                 (Real Precisions)
 *                      ( v )
 *
 *        H = I - tau * ( 1 ) * ( 1 conjugate(v)' ) ,     (Complex Precisions)
 *                      ( v )
 *
 *  where tau is a real/complex scalar and v is a real/complex (n-1)-element
 *  vector.
 *
 *  If the elements of x are all zero, then tau = 0 and H is taken to be
 *  the unit matrix.
 *
 *  Otherwise  1 <= tau <= 2.
 *
 *
 *  Arguments
 *  =========
 *
 *  N       (input) INTEGER
 *          The order of the elementary reflector.
 *
 *  ALPHA   (input/output)
 *          On entry, the value alpha.
 *          On exit, it is overwritten with the value beta.
 *
 *  X       (input/output)   array pointer, dimension
 *                         (1+(N-2)*abs(INCX))
 *          On entry, the vector x.
 *          On exit, it is overwritten with the vector v.
 *
 *  INCX    (input) INTEGER
 *          The increment between elements of X. INCX > 0.
 *
 *  TAU     (output)
 *          value of tau.
 -----------------------------------------------------------------------------*/
#include <math.h>
#include "stdio.h"
#include "cblas.h"
#include "atlas_misc.h"
#include "atlas_lapack.h"


TYPE  SAFMIN=-1.;
/*---------------------------------------------------------------------------*/
/* HighLevel Logic : * Real Precision                                        */
/* --------------------------------------------------------------------------*/
/* On entry from ATL_geqr2(or any other variant lq, ql, rq) ,                */
/* *Alpha points at A[i,i] and *X points  at A[i+1, i].                      */
/* If N==1, cblas_nrm2 returns zero. The norm is actually                    */
/* found in two parts; XNORM is all of the column except for A[i,i], and if  */
/* that is zero, we return TAU of zero (so H = I).                           */
/* Otherwise, we combine XNORM and A[i,i] into BETAp using lapy2. So BETAp   */
/* is the actual norm2 of A[i:m, i].                                         */
/* We set BETA to BETAp but with the opposite sign as A[i,i]. This is done   */
/* to ensure that TAU is in [1,2].                                           */
/* We set TAU to (BETA-A[i,i])/BETA, and scale A[i+1:m,i] by 1/(A[i,i]-BETA).*/
/* Finally, we replace A[i,i] with BETA.                                     */
/* Note that |A[i,i]-BETA| > |A[i,i]|. Treat the column as X=[x1, x2, x3],   */
/* and assume x1 > 0. Then we return X' (prime, not transpose) as:           */
/* x1' = -||X||  (The element actually on the diagonal, and part of R.)      */
/* x2' = x2/(x1+||X||)                                                       */
/* x3' = x3/(x1+||X||)                                                       */
/* TAU = (-||X||-x1)/-||X|| = (x1+||X||)/||X||                               */
/*                                                                           */
/* This is NOT a textbook Householder reflection, because [1 v]^T does not   */
/* have a norm of 1. The purpose seems to be to save the first storage       */
/* location; the '1' is not stored anywhere. The choice of whether to make   */
/* A[i,i] either +/- ||X|| is strictly to control the range of TAU, but has  */
/* the added value of making the Householder matrix unique for any given A.  */
/* Note that |x1| < | (x1+||X||) |, i.e. the magnitude is always increased,  */
/* so the magnitude of xi/(x1+||X||) is always decreased. I'm not sure if    */
/* that is intended to reduce error or not.                                  */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/* Complex Precisions                                                        */
/*---------------------------------------------------------------------------*/
/* The  highlevel logic for Complex precision remains same as that of Real   */
/* precisions. The difference are                                            */
/*    BETAp is calculated using real part of A[i,i], imaginary part of A[i,i]*/
/*    and XNORM using lapy3.                                                 */
/*                                                                           */
/*    ATL_ladiv is called to apply complex number devision before            */
/*    performing  the scaling operation for A[i+1:m,i] by 1/(A[i,i]-BETA).   */
/*                                                                           */
/*   NOTE :                                                                  */
/*    For Real precision and Complex precision, the codes are kept seperately*/
/*    for clarity. ( Many code might be similar)                             */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
void ATL_larfg( const int N, TYPE *ALPHA, TYPE *X, int INCX, TYPE *TAU)
{

#ifdef TREAL

      TYPE ONE=1.0, ZERO=0.0, BETA, BETAp, RSAFMN, SAFMAX, XNORM;
      int    j, KNT;

      if (N < 1)
      {
         *TAU = ZERO;
         return;
      }

      // Get the norm2 .
      XNORM = cblas_nrm2(N-1, X, INCX);

      if (XNORM == ZERO)
      {
/*
 *        H  =  I
 */
         *TAU = ZERO;
      } else
      {
         BETAp = ATL_lapy2((*ALPHA), XNORM);    /* Get sqrt(a^2+b^2) */
         BETA = BETAp;                          /* Assume ALPHA < 0  */
         if ((*ALPHA) > 0) BETA = 0.-BETAp;     /* Change if assumed wrong. */

//TODO : Following logic will  be changed to get value at compilation time
/*
 * DLAMCH('S') returns 'safe minimum' (sfmin) such that
 * 1/sfmin does not overflow.
 * DLAMCH('E') returns epsilon for double precision.
 * For Intel doubles, sfmin = 2^{-1022}, and epsilon = 2^{-52}.
 * So SAFMIN = 2^{-1022+52} = 2^{-970}, = 512+256+128+64+8+2.
 *         SAFMIN = DLAMCH( 'S' ) / DLAMCH( 'E' )
 * For Intel single, sfmin = 2^{-126}, and epsilon = 2^{-8}.
 * So SAFMIN = 2^{-126+8} = 2^{-118}, = 64+32+16+4+2.
 */
         if (SAFMIN < 0.)           /* If not computed yet... */
         {
          #ifdef TREAL
           #ifdef DREAL
            TYPE p512, p256, p128, p64, p8=1./256., p2=0.5;
            p64=p8*p8;                 /* p16 */
            p64 *= p64;                /* p32 */
            p64 *= p64;                /* p64 */
            p128 = p64*p64;
            p256 = p128*p128;
            p512 = p256*p256;
            SAFMIN = (((((p2*p8)*p64)*p128)*p256)*p512);
          #else
            TYPE  p64, p32, p16,  p8=1./256., p4=0.25, p2=0.5;
            p16 =p8*p8;                /* p16 */
            p32 = p16*p16;             /* p32 */
            p64 = p32*p32;             /* p64 */
            SAFMIN = ((((p2*p4)*p16)*p32)*p64);
          #endif
         #endif
        }

         if (BETAp < SAFMIN)
         {
/*
 *           XNORM, BETA may be inaccurate; scale X and recompute them
 */
            RSAFMN = ONE / SAFMIN;           /* Set a maximum */
            KNT = 0;

            while (BETAp < SAFMIN)
            {
               KNT++;
               cblas_scal(N-1, RSAFMN, X, INCX);
               BETA *= RSAFMN;
               BETAp *= RSAFMN;
               *ALPHA *= RSAFMN;
            }
/*
 *           New BETA is at most 1, at least SAFMIN
 */
            XNORM = cblas_nrm2(N-1, X, INCX);
            BETA = ATL_lapy2((*ALPHA), XNORM);  /* Will always be positive */
            if ((*ALPHA) > 0) BETA = -BETA;     /* -SIGN(BETA, ALPHA)      */
            *TAU = (BETA-(*ALPHA)) / BETA;
            cblas_scal(N-1, ONE/((*ALPHA)-BETA), X, INCX);

/*
 *           If ALPHA is subnormal, it may lose relative accuracy
 */
            *ALPHA = BETA;
            for (j=0; j<KNT; j++)
            {
               (*ALPHA) *= SAFMIN;
            }
         } else /* General case */
         {
            *TAU = (BETA-(*ALPHA)) / BETA;
            cblas_scal(N-1, ONE / ((*ALPHA)-BETA), X, INCX);
            *ALPHA = BETA;
         }
      }
      return;
/*
 *     End of  Real Precision ATL_larfg
 */
#else
/*
 *     Beginning of  Complex  Precision ATL_larfg
 */
      TYPE ONE=1.0, ZERO=0.0, BETA, BETAp, RSAFMN, SAFMAX, XNORM, ALPHI, ALPHR;
      TYPE ONEVAL[2] =  {ATL_rone, ATL_rzero};
      int j, KNT;

      if ( N < 0)
      {
/*
 *        H  =  I
 */
        *(TAU)  = 0.0;
        *(TAU + 1) = 0.0;
        return;
      }

      //Get the nrm2
      XNORM = cblas_nrm2(N-1, X, INCX);

      ALPHR = *( ALPHA) ;
      ALPHI = *( ALPHA + 1) ;

      if ( (XNORM == ZERO) &&  (ALPHI == ZERO)  )
      {
/*
*        H  =  I
*/
        *(TAU)  = 0.0;
        *(TAU + 1) = 0.0;
      }
      else
      {

         BETAp = ATL_lapy3(ALPHR, ALPHI, XNORM);       /* Get sqrt( a^2 + b^2 + c^2) */
         BETA = BETAp;                                 /* Assume ALPHA < 0           */
         if ( (*ALPHA) > 0) BETA = 0. - BETAp;         /* Change if assumed wrong    */

/*
 * DLAMCH('S') returns 'safe minimum' (sfmin) such that
 * 1/sfmin does not overflow.
 * DLAMCH('E') returns epsilon for double precision.
 * For Intel doubles, sfmin = 2^{-1022}, and epsilon = 2^{-52}.
 * So SAFMIN = 2^{-1022+52} = 2^{-970}, = 512+256+128+64+8+2.
 *        SAFMIN = DLAMCH( 'S' ) / DLAMCH( 'E' )
 * For Intel single, sfmin = 2^{-126}, and epsilon = 2^{-8}.
 * So SAFMIN = 2^{-126+8} = 2^{-118}, = 64+32+16+4+2.
 */
         if (SAFMIN < 0.)           /* If not computed yet... */
         {
           #ifdef DCPLX
            TYPE p512, p256, p128, p64, p8=1./256., p2=0.5;
            p64=p8*p8;                 /* p16 */
            p64 *= p64;                /* p32 */
            p64 *= p64;                /* p64 */
            p128 = p64*p64;
            p256 = p128*p128;
            p512 = p256*p256;
            SAFMIN = (((((p2*p8)*p64)*p128)*p256)*p512);
          #else
            TYPE  p64, p32, p16,  p8=1./256., p4=0.25, p2=0.5;
            p16 =p8*p8;                /* p16 */
            p32 = p16*p16;             /* p32 */
            p64 = p32*p32;             /* p64 */
            SAFMIN = ((((p2*p4)*p16)*p32)*p64);
          #endif
        }

         RSAFMN = ONE / SAFMIN ;

         if ( BETAp  <  SAFMIN )
         {
/*
*           XNORM, BETA may be inaccurate; scale X and recompute them
*
*/
            KNT = 0;
            while ( BETAp < SAFMIN )
            {
                KNT++;
                #ifdef DCPLX
                     cblas_zdscal(N-1, RSAFMN, X, INCX);
                #else
                     cblas_csscal(N-1, RSAFMN, X, INCX);
                #endif
                BETA *= RSAFMN;
                BETAp *= RSAFMN;
                ALPHI = ALPHI*RSAFMN;
                ALPHR = ALPHR*RSAFMN;
            }


/*
 *           New BETA is at most 1, at least SAFMIN
 *
 */
            XNORM = cblas_nrm2(N-1, X, INCX);
            *(ALPHA) = ALPHR;
            *(ALPHA + 1) = ALPHI;

            BETA = ATL_lapy3(ALPHR, ALPHI,
                                         XNORM);   /* Will always be positive */
            if (ALPHR > 0) BETA = -BETA;           /* -SIGN(BETA, ALPHR)      */
            *(TAU) = ( BETA-ALPHR ) / BETA ;
            *(TAU + 1) =  (-1.0 * ALPHI) / BETA ;
            /* Modify alpha   to alpha - beta,  which is equal to alphar -beta*/
            *(ALPHA) = *(ALPHA) - BETA;
            // Perform complex division before scaling the X vector
            ATL_ladiv( ONEVAL,  ALPHA,
                                         ALPHA); /*ALPHA will have the result*/
            cblas_scal(N-1, ALPHA, X, INCX);

/*
 *           If ALPHA is subnormal, it may lose relative accuracy
 */
            *(ALPHA) = BETA;                    /* Real Part of alpha        */
            for (j=0; j<KNT; j++)
            {
               (*ALPHA) *= SAFMIN;
            }
            *(ALPHA + 1) = 0.0;                 /* Set Imaginary part to Zero*/
        }
        else                                    /* BETA > SAFMIN */
        {

            *(TAU) = ( BETA-ALPHR ) / BETA ;
            *(TAU + 1) =  (-1.0 * ALPHI) / BETA ;

            /* Modify alpha   to alpha - beta, which is equal to alphar -beta*/
            *(ALPHA) = *(ALPHA) - BETA ;
            // Perform complex division before scaling the X vector
            ATL_ladiv( ONEVAL,  ALPHA  ,
                                      ALPHA); /*ALPHA will have  the result */
            cblas_scal(N-1, ALPHA, X, INCX);
            *(ALPHA) = BETA;                    /* Real Part of alpha        */
            *(ALPHA + 1) = 0.0;                 /* Set Imaginary part to Zero*/
           }
      }
      return;
#endif
} /* END ATL_larfg */
@ROUT ATL_larfp
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *     SUBROUTINE DLARFG( N, ALPHA, X, INCX, TAU )
 *
 * ATL_larfp.c :
 * void ATL_larfp( const int N, TYPE *ALPHA, TYPE *X, int INCX, TYPE *TAU)
 *        NOTE : ATL_larfp.c  will get compiled to 4 precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *  Purpose
 *  =======
 *
 *  Real Precision
 *  --------------
 *
 *  ATL_larfp generates a real/complex  elementary reflector H of order n, such
 *  that
 *
 *        H * ( alpha ) = ( beta ),   H' * H = I.
 *            (   x   )   (   0  )
 *
 *  where alpha and beta are scalars, and x is an (n-1)-element real
 *  vector. H is represented in the form
 *
 *        H = I - tau * ( 1 ) * ( 1 v' ) ,                     (Real Precisions)
 *                      ( v )
 *
 *        H = I - tau * ( 1 ) * ( 1 conjugate(v)' ) ,       (Complex Precisions)
 *                      ( v )
 *
 *  where tau is a real/complex scalar and v is a real/complex (n-1)-element
 *  vector.
 *
 *  If the elements of x are all zero, then tau = 0 and H is taken to be
 *  the unit matrix.
 *
 *  Otherwise  1 <= tau <= 2.
 *
 *
 *  Arguments
 *  =========
 *
 *  N       (input) INTEGER
 *          The order of the elementary reflector.
 *
 *  ALPHA   (input/output)
 *          On entry, the value alpha.
 *          On exit, it is overwritten with the value beta.
 *
 *  X       (input/output)   array pointer, dimension
 *                         (1+(N-2)*abs(INCX))
 *          On entry, the vector x.
 *          On exit, it is overwritten with the vector v.
 *
 *  INCX    (input) INTEGER
 *          The increment between elements of X. INCX > 0.
 *
 *  TAU     (output)
 *          value of tau.
 *-----------------------------------------------------------------------------*/
#include <math.h>
#include "stdio.h"
#include "cblas.h"
#include "atlas_misc.h"
#include "atlas_lapack.h"

#ifdef TREAL
   #define SAFMIN sSAFMIN
#else
  #define  SAFMIN dSAFMIN
#endif

TYPE  SAFMIN=-1.;
/*---------------------------------------------------------------------------*/
/* HighLevel Logic : * Real Precision                                        */
/* --------------------------------------------------------------------------*/
/* On entry from ATL_geqr2(or any other variant lq, ql, rq) ,                */
/* *Alpha points at A[i,i] and *X points  at A[i+1, i].                      */
/* If N==1, cblas_nrm2 returns zero. The norm is actually                    */
/* found in two parts; XNORM is all of the column except for A[i,i], and if  */
/* that is zero, we return TAU of zero (so H = I).                           */
/* Otherwise, we combine XNORM and A[i,i] into BETAp using lapy2. So BETAp   */
/* is the actual norm2 of A[i:m, i].                                         */
/* We set BETA to BETAp but with the opposite sign as A[i,i]. This is done   */
/* to ensure that TAU is in [1,2].                                           */
/* We set TAU to (BETA-A[i,i])/BETA, and scale A[i+1:m,i] by 1/(A[i,i]-BETA).*/
/* Finally, we replace A[i,i] with BETA.                                     */
/* Note that |A[i,i]-BETA| > |A[i,i]|. Treat the column as X=[x1, x2, x3],   */
/* and assume x1 > 0. Then we return X' (prime, not transpose) as:           */
/* x1' = -||X||  (The element actually on the diagonal, and part of R.)      */
/* x2' = x2/(x1+||X||)                                                       */
/* x3' = x3/(x1+||X||)                                                       */
/* TAU = (-||X||-x1)/-||X|| = (x1+||X||)/||X||                               */
/*                                                                           */
/* This is NOT a textbook Householder reflection, because [1 v]^T does not   */
/* have a norm of 1. The purpose seems to be to save the first storage       */
/* location; the '1' is not stored anywhere. The choice of whether to make   */
/* A[i,i] either +/- ||X|| is strictly to control the range of TAU, but has  */
/* the added value of making the Householder matrix unique for any given A.  */
/* Note that |x1| < | (x1+||X||) |, i.e. the magnitude is always increased,  */
/* so the magnitude of xi/(x1+||X||) is always decreased. I'm not sure if    */
/* that is intended to reduce error or not.                                  */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/* Complex Precisions                                                        */
/*---------------------------------------------------------------------------*/
/* The  highlevel logic for Complex precision remains same as that of Real   */
/* precisions. The difference are                                            */
/*    BETAp is calculated using real part of A[i,i], imaginary part of A[i,i]*/
/*    and XNORM using lapy3.                                                 */
/*                                                                           */
/*    ATL_ladiv is called to apply complex number devision before            */
/*    performing  the scaling operation for A[i+1:m,i] by 1/(A[i,i]-BETA).   */
/*                                                                           */
/*   NOTE :                                                                  */
/*    For Real precision and Complex precision, the codes are kept seperately*/
/*    for clarity. ( Many code might be similar)                             */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
void ATL_larfp( const int N, TYPE *ALPHA, TYPE *X, int INCX, TYPE *TAU)
{
#ifdef TREAL

   TYPE ONE=1.0, ZERO=0.0, BETA, BETAp, RSAFMN, SAFMAX, XNORM;
   TYPE TWO=2.0;
   int    j, KNT;

   if (N < 0)
   {
      *TAU = ZERO;
      return;
   }

   // Get the norm2 .
   XNORM = cblas_nrm2(N-1, X, INCX);

   if (XNORM == ZERO)
   {
      /*
       *    H  =  [+/-1, 0; I], sign chosen so ALPHA >= 0
       */
      if ( (*ALPHA) > ZERO )
      {
         /* When TAU.eq.ZERO, the vector is special-cased to be               */
         /* all zeros in the application routines.  We do not need            */
         /* to clear it.                                                      */
         *TAU = ZERO;
      }
      else
      {
         /* However, the application routines rely on explicit                */
         /* zero checks when TAU.ne.ZERO, and we must clear X.                */
         *TAU = TWO;
         for ( j = 0; j < (N-1) ; j++)
         {
            X[ 1 + (j-1)*INCX ] = ZERO;
         }
         *ALPHA = 0. - (*ALPHA);
      }
   }
   else                                  /* XNORM NE ZERO                     */
   {
      BETAp = ATL_lapy2((*ALPHA), XNORM);/* Get sqrt(a^2+b^2)                 */
      BETA = BETAp;                      /* Assume ALPHA < 0                  */
      if ((*ALPHA) < 0) BETA = 0.-BETAp; /* Change the sign if alpha is -ve   */

      /* DLAMCH('S') returns 'safe minimum' (sfmin) such that        */
      /* 1/sfmin does not overflow.                                  */
      /* DLAMCH('E') returns epsilon for single/double  precision.   */


      if (SAFMIN < 0.)           /* If not computed yet... */
      {
         SAFMIN = ATL_lamch('S')/ATL_lamch('E');
      }

      KNT = 0;
      if (BETAp < SAFMIN)
      {
         /*
          *       XNORM, BETA may be inaccurate; scale X and recompute them
          */

         RSAFMN = ONE / SAFMIN;          /* Set a maximum                     */

         while (BETAp < SAFMIN)
         {
            KNT++;
            cblas_scal(N-1, RSAFMN, X, INCX);
            BETA *= RSAFMN;
            BETAp *= RSAFMN;
            *ALPHA *= RSAFMN;
         }
         /*
          *    New BETA is at most 1, at least SAFMIN
          */
         XNORM = cblas_nrm2(N-1, X, INCX);
         BETAp = ATL_lapy2((*ALPHA), XNORM);  /* Will always be positive      */
         BETA = BETAp;                        /* Assume ALPHA < 0             */
         if ((*ALPHA) > 0) BETA =0.0  -BETAp; /* -SIGN(BETA, ALPHA)           */

      }  /* BATAp < SAFMIN        */

      *ALPHA = *ALPHA + BETA;
      if ( BETA < ZERO )
      {
         BETA = 0. - BETA;
         *TAU = (0. - *ALPHA)/BETA;
      }
      else
      {
         *ALPHA = XNORM * (XNORM/(*ALPHA));
         *TAU   = *ALPHA/BETA;
         *ALPHA = 0.0 - *ALPHA ;
      }
      cblas_scal(N-1, ONE / (*ALPHA), X, INCX);

      for (j=0; j<KNT; j++)
      {
          BETA *= SAFMIN;
      }

      *ALPHA = BETA;

   } /* else on XNORM !=0 */
   return;
/*
 * End of  Real Precision ATL_larfp   REAL precision
 */
#else
/*
 * Beginning of  Complex  Precision ATL_larfp
 */
   TYPE ONE=1.0, ZERO=0.0, BETA, BETAp, RSAFMN, SAFMAX, XNORM, ALPHI, ALPHR;
   TYPE ONEVAL[2] =  {ATL_rone, ATL_rzero};
   TYPE TWO[2] =  {2.0, ATL_rzero};
   int j, KNT;

   if ( N < 0)
   {
      /*
       *    H  =  I
       */
      *(TAU)  = 0.0;
      *(TAU + 1) = 0.0;
      return;
   }

   //Get the nrm2
   XNORM = cblas_nrm2(N-1, X, INCX);

   ALPHR = *( ALPHA) ;
   ALPHI = *( ALPHA + 1) ;

   if (XNORM == ZERO )
   {
     /*
      *    H  =  [1-alpha/abs(alpha) 0; 0 I], sign chosen so ALPHA >= 0.
      */
      *(TAU)  = 0.0;
      *(TAU + 1) = 0.0;
      if ( ALPHI == ZERO )
      {
         if(ALPHR > ZERO)
         {
            /* When TAU.eq.ZERO, the vector is special-cased to be
             * all zeros in the application routines.  We do not need
             * to clear it.
             */

            *(TAU)  = 0.0;
            *(TAU + 1) = 0.0;
         }
         else
         {
            /* However, the application routines rely on explicit
             * zero checks when TAU.ne.ZERO, and we must clear X.
             */

            *(TAU)  = 2.0;
            *(TAU + 1) = 0.0;

            for ( j = 0; j < ((N-1) SHIFT ) ; j++) /*complex multiply by 2    */
            {
               X[ 2 + (j-1)*INCX ] = ZERO;
            }
            *(ALPHA) = 0. - *(ALPHA);
            *(ALPHA+1) = 0. - *(ALPHA+1);
         }
      }                                     /* ALPHI != ZERO                  */
      else
      {
         /* Only "reflecting" the diagonal entry to be real                   */
         /*            and non-negative.                                      */

         XNORM = ATL_lapy2( ALPHR, ALPHI ); /* Get sqrt(a^2+b^2)              */

         //TAU = DCMPLX( ONE - ALPHR / XNORM, -ALPHI / XNORM )
         *(TAU) = ( ONE-ALPHR / XNORM) ;
         *(TAU + 1) =  (0.0 - ALPHI) /XNORM ;

         for ( j = 0; j < ((N-1) SHIFT ) ; j++) /*complex multiply by 2       */
         {
            X[ 2 + (j-1)*INCX ] = ZERO;
         }
         *(ALPHA) = XNORM;                   /* Real Part of alpha            */
         *(ALPHA + 1) = 0.0;                 /* Set Imaginary part to Zero    */
      }                                      /* ALPHI = 0 ends                */
   }
   else                                      /* XNORM != 0                    */
   {
      /* XNORM != 0                                                           */
      BETAp = ATL_lapy3(ALPHR, ALPHI, XNORM);/* Get sqrt( a^2 + b^2 + c^2)    */
      BETA = BETAp;                          /* Assume ALPHA < 0              */
      if ( (*ALPHA) < 0) BETA = 0. - BETAp;  /*Change the sign if alpha is -ve*/

      /* DLAMCH('S') returns 'safe minimum' (sfmin) such that        */
      /* 1/sfmin does not overflow.                                  */
      /* DLAMCH('E') returns epsilon for single/double  precision.   */

      if (SAFMIN < 0.)           /* If not computed yet... */
      {
         SAFMIN = ATL_lamch('S')/ATL_lamch('E');
      }

      RSAFMN = ONE / SAFMIN ;
      KNT = 0;

      if ( BETAp  <  SAFMIN )
      {
         /*
          *     XNORM, BETA may be inaccurate; scale X and recompute them
          *
          */
         while ( BETAp < SAFMIN )
         {
            KNT++;
            #ifdef DCPLX
                cblas_zdscal(N-1, RSAFMN, X, INCX);
            #else
                cblas_csscal(N-1, RSAFMN, X, INCX);
            #endif
            BETA *= RSAFMN;
            BETAp *= RSAFMN;
            ALPHI = ALPHI*RSAFMN;
            ALPHR = ALPHR*RSAFMN;
         }

         /*
          *    New BETA is at most 1, at least SAFMIN
          *
          */
         XNORM = cblas_nrm2(N-1, X, INCX);
         *(ALPHA) = ALPHR;
         *(ALPHA + 1) = ALPHI;

         BETAp = ATL_lapy3(ALPHR, ALPHI, XNORM);  /* Will always be positive   */
         BETA = BETAp;
         if (ALPHR > 0) BETA = 0.0 -BETAp;        /* -SIGN(BETA, ALPHR)        */

      } /* BATAp < SAFMIN        */

      /* alpha = alpha+ beta. Imaginary part remains same                  */
      *ALPHA = *ALPHA + BETA;

      if ( BETA < ZERO )
      {
          BETA = 0.0 - BETA;

         /* TAU = -ALPHA/BETA                                              */
         *TAU     = (0. - *ALPHA)/BETA;
         *(TAU+1) = (0. - *(ALPHA+1))/BETA;
      }
      else
      {
         ALPHR = ALPHI * (ALPHI/ (*ALPHA));
         ALPHR = ALPHR + XNORM * (XNORM/(*ALPHA));

         //TAU = DCMPLX( ALPHR/BETA, -ALPHI/BETA )
         *TAU     = ALPHR/BETA;
         *(TAU+1) = (0.0 - ALPHI)/BETA;

         *ALPHA     = 0.0 - ALPHR;
         *(ALPHA+1) = ALPHI;
      }

      // Perform complex division before scaling the X vector
      ATL_ladiv( ONEVAL,  ALPHA  , ALPHA); /*ALPHA will have  the result   */
      cblas_scal(N-1, ALPHA, X, INCX);

      /* If BETA is subnormal, it may lose relative accuracy               */

      for (j=0; j<KNT; j++)
      {
         BETA *= SAFMIN;
      }
      *(ALPHA) = BETA;                    /* Real Part of alpha            */
      *(ALPHA + 1) = 0.0;                 /* Set Imaginary part to Zero    */
   }                                         /* XNORM != 0 ends               */
   return;
#endif
} /* END ATL_larfp */
@ROUT ATL_larft

/*-----------------------------------------------------------------------------
 * This is a recursive C implementation of the standard LAPACK Fortran routine:
 *      SUBROUTINE DLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )
 *
 * ATL_larft.c :
 * void ATL_larft(const enum ATL_LADIRECT DIRECT,
 *                const enum ATL_LASTOREV STOREV, int N, int K, TYPE *V,
 *                int LDV, TYPE  *TAU, TYPE *T, int LDT )
 *
 *     NOTE :   ATL_larft.c will get compiled to four precisions
 *               single precision real,      double precision real
 *               single precision complex,   double precision complex
 *
 *  Purpose
 *  =======
 *
 *  ATL_larft forms the triangular factor T of a real/complex block reflector H
 *  of order n, which is defined as a product of k elementary reflectors.
 *  We only handle DIRECT='F' (forward) and STOREV='C' (columnwise).
 *
 *  N       (input) INTEGER
 *          The order of the block reflector H. N >= 0.
 *
 *  K       (input) INTEGER
 *          The order of the triangular factor T (= the number of
 *          elementary reflectors). K >= 1.
 *
 *  V       (input/output) DOUBLE PRECISION array, dimension (LDV, K)
 *
 *  LDV     (input) INTEGER
 *          The leading dimension of the array V.
 *          LDV >= max(1,N).
 *
 *  TAU     (input)  array, dimension (K)
 *          TAU(i) must contain the scalar factor of the elementary
 *          reflector H(i).
 *
 *  T       (output) array, dimension (LDT,K)
 *          The k by k upper triangular factor T of the block reflector.
 *
 *  LDT     (input) INTEGER
 *          The leading dimension of the array T. LDT >= K.
 *
 *  Further Details
 *  ===============
 *
 *  The shape of the matrix V and the storage of the vectors which define
 *  the H(i) is best illustrated by the following example with n = 5 and
 *  k = 3. The elements equal to 1 are not stored.
 *
 *  DIRECT = 'F' and STOREV = 'C':
 *
 *               V = (  1       )
 *                   ( v1  1    )
 *                   ( v1 v2  1 )
 *                   ( v1 v2 v3 )
 *                   ( v1 v2 v3 )
 *
 *  =====================================================================
 *  We are using the recursive formulation outlined in the paper
 *  "Applying recursion to serial and parallel QR factorization leads to
 *   better performance", by E. Elmroth and F.G. Gustavson, 2000 (IBM).
 *
 *  The YT(Y^T) formulation is by Schreiber and Van Loan, 1989; but is
 *  modified in two ways. LAPACK uses Q=(I-YT(Y^T)) instead of Q=(I+YT(Y^T)),
 *  and also does not use unit vectors: As you can see above, our V vectors
 *  begin with '1' and thus cannot have unit norm, and working out the
 *  necessary T and TAU produces TAU[i] on the diagonal of T. If we stop our
 *  recursion at 1, TAU[0] is the result. If we stop at 2, we have a 2x2
 *  upper triangular matrix; with TAU[0] and TAU[1] on the diagonal, and
 *  -TAU[0]*TAU[1]* dotproduct(V[0], V[1]) in the upper right hand corner.
 *
 *  The Elmroth+Gustavson algorithm permits updates with different sizes,
 *  we make our split to try and keep the update area a multiple of 4 when
 *  possible, we presume this will aid SSE usage in multiplication.
 *
 -----------------------------------------------------------------------------*/
#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

#define ATL_larftFC           Mjoin(PATL,larftFC)
#define ATL_larftBC           Mjoin(PATL,larftBC)
#define ATL_larftFR           Mjoin(PATL,larftFR)
#define ATL_larftBR           Mjoin(PATL,larftBR)
#define ATL_larft_blockFC     Mjoin(PATL,larft_blockFC)
#define ATL_larft_blockBC     Mjoin(PATL,larft_blockBC)
#define ATL_larft_blockFR     Mjoin(PATL,larft_blockFR)
#define ATL_larft_blockBR     Mjoin(PATL,larft_blockBR)

void ATL_larftFC(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV,
                int N, int K, TYPE *V, int LDV, TYPE  *TAU, TYPE *T, int LDT );
void ATL_larftBC(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV,
                int N, int K, TYPE *V, int LDV, TYPE  *TAU, TYPE *T, int LDT );
void ATL_larftFR(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV,
                int N, int K, TYPE *V, int LDV, TYPE  *TAU, TYPE *T, int LDT );
void ATL_larftBR(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV,
                int N, int K, TYPE *V, int LDV, TYPE  *TAU, TYPE *T, int LDT );

void ATL_larft_blockFC(int N, int K, int left, int right,
                      TYPE *V, int LDV, TYPE *T, int LDT );
void ATL_larft_blockBC(int N, int K, int left, int right,
                      TYPE *V, int LDV, TYPE *T, int LDT );
void ATL_larft_blockFR(int N, int K, int left, int right,
                      TYPE *V, int LDV, TYPE *T, int LDT );
void ATL_larft_blockBR(int N, int K, int left, int right,
                      TYPE *V, int LDV, TYPE *T, int LDT );

/* Use CBLAS routines. */

   #ifdef TREAL
      #define MY_DOT  cblas_dot
   #else
      #define MY_DOT  cblas_dotc_sub
      #define MY_DOTU cblas_dotu_sub
   #endif

   #define MY_LEFT  CblasLeft
   #define MY_RIGHT CblasRight
   #define MY_LOWER CblasLower
   #define MY_UPPER CblasUpper
   #ifdef TREAL
       #define MY_TRANS CblasTrans
   #else
       #define MY_TRANS CblasConjTrans
   #endif

   #define MY_NOTRANS CblasNoTrans
   #define MY_UNIT    CblasUnit
   #define MY_NONUNIT CblasNonUnit

void ATL_larft_block(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV, int N, int K, int left, int right,
                      TYPE *V, int LDV,
                      TYPE *T, int LDT )
{
   if ( DIRECT == LAForward)
   {
      if ( STOREV == LAColumnStore )
      {
         ATL_larft_blockFC(N, K, left, right, V, LDV, T,  LDT );
      }
      else if (STOREV == LARowStore)
      {
         ATL_larft_blockFR(N, K, left, right, V, LDV, T,  LDT );
      }

   }
   else if (DIRECT == LABackward)
   {
      if ( STOREV == LAColumnStore)
      {
         ATL_larft_blockBC(N, K, left, right, V, LDV, T, LDT );
      }
      else if (STOREV == LARowStore)
      {
         ATL_larft_blockBR(N, K, left, right, V, LDV, T, LDT );
      }
   }
}


/*
 * This function produce the block portion of the T matrix in recursive
 * algorithm.
 */

void ATL_larft_blockFC(int N, int K, int left, int right,
                      TYPE *V, int LDV,
                      TYPE *T, int LDT )
{
      TYPE *Tw, *Y2, *T2;
      int    row, col;
      int LDV2, LDT2;
      LDV2 = LDV SHIFT;                          /* For complex LDV * 2       */
      LDT2 = LDT SHIFT;                          /* For complex LDT * 2       */

       #ifdef TREAL
          const TYPE ONE = ATL_rone;
          const TYPE ZEROVAL = ATL_rzero;
          const TYPE NONE = ATL_rnone;
       #else
          const TYPE ONE[2] = {ATL_rone, ATL_rzero};
          const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
          const TYPE NONE[2] = {ATL_rnone, ATL_rzero};
       #endif

      Tw = T+left*LDT2;                         /* Work at T[0, left].     */
      Y2 = V+(left SHIFT)+LDV2*left;            /* Y2 at V[left, left].    */
      T2 = T+(left SHIFT) +LDT2*left;           /* Address of new T2.      */

      /*-------------------------------------------------*/
      /* Fill in the upper right hand block, which is    */
      /* 'left' rows and 'right' columns.                */
      /*                                                 */
      /* -T1 * (Y1^T * Y2) * T2                          */
      /* Block upper right hand element is T+(LDT*left). */
      /*-------------------------------------------------*/
      /* Step 1: Y1^T * Y2, Y2 upper unit triangular.    */
      /* We do this in two steps to use DTRMM.           */
      /* We transpose by hand the first 'left' columns   */
      /* of Y1 into the workspace; then use DTRMM to     */
      /* multiply that on the right by the triangular    */
      /* part of Y2. Then we use DGEMM to compute        */
      /* Workspace += Y1rest^T * Y2rest.                 */
      /*                                                 */
      /* Note Y1rest[0,0] is at V+K, and                 */
      /* Y2rest[0,0] is at Y2+right.                     */
      /*                                                 */
      /*-------------------------------------------------*/
      for (row=0; row<left; row++)                 /* Each row of Tw          */
      {
         for (col=0; col<right; col++)             /* Each column of Tw       */
         {
            #ifdef TREAL
               *(Tw + row + col*LDT) =             /* Work[row, col]          */
               *((V+left)+col+row*LDV);            /* Y1[col, row].           */
            #else
               /* Copy the  ConjTranspose for complex                         */
               *(Tw + (row SHIFT) + col*LDT2) =    /* Work[row, col]          */
               *((V+ (left SHIFT))+(col SHIFT)
                                  +row*LDV2);      /* Y1[col, row].           */
               /* copy the imaginary part.                                    */
               *(Tw + (row SHIFT) + 1 + col*LDT2) =    /* Work[row, col]      */
               0.0 - ( *((V+ (left SHIFT))+(col SHIFT) +1 +
                                   row*LDV2) );    /* Y1[col, row].           */
            #endif
         }
      }

      /*-------------------------------------------------*/
      /* Copy complete, Tw is 'left' rows, 'right' cols. */
      /* Tw = 1.0 * Tw * Y2.                             */
      /* DTRMM: (right): B := alpha * B * triangular A.  */
      /*-------------------------------------------------*/
      cblas_trmm(CblasColMajor,                 /* Y2 is on right, lwr tri.*/
                MY_RIGHT, MY_LOWER,             /* Y2 is on right, lwr tri.*/
                MY_NOTRANS, MY_UNIT,            /* As-is, with unit diag.  */
                left, right, ONE,               /* B rows, cols, alpha=1.  */
                Y2, LDV, Tw, LDT);              /* A and B.                */
      /*-------------------------------------------------*/
      /* Dgemm can finish the multiply, if any is left.  */
      /* Tw += (Y1^T) * Y2, if N-K is > 0.               */
      /* DGEMM: C = alpha * A * B + Beta * C.            */
      /*-------------------------------------------------*/
      if (N > K)                                /* If any left below...    */
      {
        cblas_gemm(CblasColMajor,
                   MY_TRANS,                    /* Y1 is transposed.       */
                   MY_NOTRANS,                  /* Y2 is not.              */
                   left, right,                 /* Dimensions of C.        */
                   N-K,                         /* Height of columns.      */
                   ONE,                         /* No special multiplier.  */
                   (V+(K SHIFT)), LDV,          /* Y1[0,0], dist to Y1[0,1]*/
                   (Y2+(right SHIFT) ), LDV,    /* Y2[0,0], dist to Y2[0,1]*/
                   ONE,                         /* Add to existing data.   */
                   Tw, LDT);                    /* Wk[0,0], dist to Wk[0,1]*/
      }

      /*-------------------------------------------------*/
      /* Y1^T * Y2 complete; now two triangular mults.   */
      /* Tw = -1.0 * T1 * Tw.                            */
      /* DTRMM: (left): B:= alpha * triangular A * B     */
      /*-------------------------------------------------*/
      cblas_trmm(CblasColMajor,
               MY_LEFT, MY_UPPER,               /* T1 on left, upr tri.    */
               MY_NOTRANS, MY_NONUNIT,          /* As-is, non-unit diag.   */
                left, right, NONE,              /* B rows, cols, alpha=-1. */
                T, LDT, Tw, LDT);               /* A and B.                */

      /*-------------------------------------------------*/
      /* -T1 * (Y1^T * Y2) complete. Final tri T2 Mult.  */
      /* Tw = 1.0 * Tw * T2.                             */
      /* DTRMM: (right): B:= alpha * B * triangular A    */
      /*-------------------------------------------------*/
      cblas_trmm(CblasColMajor,
              MY_RIGHT, MY_UPPER,               /* T2 on right, upr tri.   */
               MY_NOTRANS, MY_NONUNIT,          /* As-is, non-unit diag.   */
                left, right, ONE,               /* B rows, cols, alpha=1.  */
                T2, LDT, Tw, LDT);              /* A and B.                */

      return;                                   /* All done.               */
} /* END ATL_dlarft_block */

/*
 * This function produce the block portion of the T matrix in recursive
 * algorithm.
 */
void ATL_larft_blockFR(int N, int K, int top, int bottom,
                      TYPE *V, int LDV,
                      TYPE *T, int LDT )
{
      TYPE *Tw, *Y2, *T2;
      int    row, col;
      int LDV2, LDT2;
      LDV2 = LDV SHIFT;                          /* For complex LDV * 2       */
      LDT2 = LDT SHIFT;                          /* For complex LDT * 2       */

       #ifdef TREAL
          const TYPE ONE = ATL_rone;
          const TYPE ZEROVAL = ATL_rzero;
          const TYPE NONE = ATL_rnone;
       #else
          const TYPE ONE[2] = {ATL_rone, ATL_rzero};
          const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
          const TYPE NONE[2] = {ATL_rnone, ATL_rzero};
       #endif
      Tw = T+top*LDT2;                         /* Work at T[0, top].     */
      Y2 = V+(top SHIFT)+LDV2*top;            /* Y2 at V[top, top].    */
      T2 = T+(top SHIFT) +LDT2*top;           /* Address of new T2.      */

      /*-------------------------------------------------*/
      /* Fill in the upper left hand block, which is     */
      /* 'top' rows and 'bottom' columns.                */
      /*                                                 */
      /* -T1 * (Y1 * Y2^T) * T2                          */
      /* Block upper left hand element is T+(LDT*top). */
      /*-------------------------------------------------*/
      /* Step 1: Y1 * Y2^T, Y2 upper unit triangular.    */
      /* We do this in two steps to use DTRMM.           */
      /* We copy by hand the 'top' columns   */
      /* of Y1 into the workspace; then use DTRMM to     */
      /* multiply that on the bottom by the triangular    */
      /* part of Y2. Then we use DGEMM to compute        */
      /* Workspace += Y1rest* Y2^Trest.                 */
      /*                                                 */
      /* Note Y1rest[0,0] is at V+K, and                 */
      /* Y2rest[0,0] is at Y2+bottom.                     */
      /*                                                 */
      /*-------------------------------------------------*/
      for (row=0; row<top; row++)                 /* Each row of Tw          */
      {
         for (col=0; col<bottom; col++)             /* Each column of Tw       */
         {
            #ifdef TREAL
               *(Tw + row + col*LDT) =             /* Work[row, col]          */
               *((V+top*LDV)+row+col*LDV);            /* Y1[col, row].           */
            #else

               *(Tw +( row SHIFT) + col*LDT2) =    /* Work[row, col]          */
               *((V+top*LDV2)+(row SHIFT)+col*LDV2);    /* Y1[col, row].      */

               /* copy the imaginary part.                                    */
               *(Tw +( row SHIFT)+1 + col*LDT2) =  /* Work[row, col]          */
               *((V+top*LDV2)+(row SHIFT)+ 1+col*LDV2);  /* Y1[col, row].     */

            #endif
         }
      }
      /*-------------------------------------------------*/
      /* Copy complete, Tw is 'top' rows, 'bottom' cols. */
      /* Tw = 1.0 * Tw * Y2^T.                          */
      /* DTRMM: (right): B := alpha * B * triangular A^T.  */
      /*-------------------------------------------------*/
      cblas_trmm(CblasColMajor,                 /* Y2 is on right, upr tri.*/
                MY_RIGHT, MY_UPPER,             /* Y2 is on right, upr tri.*/
                MY_TRANS, MY_UNIT,              /* As-is, with unit diag.  */
                top, bottom, ONE,               /* B rows, cols, alpha=1.  */
                Y2, LDV, Tw, LDT);              /* A and B.                */
      /*-------------------------------------------------*/
      /* Dgemm can finish the multiply, if any is left.  */
      /* Tw += Y1 * (Y2^T), if N-K is > 0.               */
      /* DGEMM: C = alpha * A * B + Beta * C.            */
      /*-------------------------------------------------*/
      if (N > K)                                /* If any top below...    */
      {
        cblas_gemm(CblasColMajor,
                   MY_NOTRANS,                  /* Y1 is not transposed.       */
                   MY_TRANS,                    /* Y2 is               */
                   top, bottom,                 /* Dimensions of C.        */
                   N-K,                         /* Height of columns.      */
                   ONE,                         /* No special multiplier.  */
                   (V+(K*LDV2)), LDV,           /* Y1[0,0], dist to Y1[0,1]*/
                   (Y2+(bottom*LDV2)), LDV,    /* Y2[0,0], dist to Y2[0,1]*/
                   ONE,                         /* Add to existing data.   */
                   Tw, LDT);                    /* Wk[0,0], dist to Wk[0,1]*/
      }

      /*-------------------------------------------------*/
      /* Y1 * Y2^T complete; now two triangular mults.   */
      /* Tw = -1.0 * T1 * Tw.                            */
      /* DTRMM: (left): B:= alpha * triangular A * B      */
      /*-------------------------------------------------*/
      cblas_trmm(CblasColMajor,
               MY_LEFT, MY_UPPER,               /* T1 on top, upr tri.    */
               MY_NOTRANS, MY_NONUNIT,          /* As-is, non-unit diag.   */
                top, bottom, NONE,              /* B rows, cols, alpha=-1. */
                T, LDT, Tw, LDT);               /* A and B.                */

      /*-------------------------------------------------*/
      /* -T1 * (Y * Y2^T) complete. Final tri T2 Mult.  */
      /* Tw = 1.0 * Tw * T2.                             */
      /* DTRMM: (right): B:= alpha * B * triangular A    */
      /*-------------------------------------------------*/
      cblas_trmm(CblasColMajor,
              MY_RIGHT, MY_UPPER,               /* T2 on bottom, upr tri.   */
               MY_NOTRANS, MY_NONUNIT,          /* As-is, non-unit diag.   */
                top, bottom, ONE,               /* B rows, cols, alpha=1.  */
                T2, LDT, Tw, LDT);              /* A and B.                */
      return;                                   /* All done.               */
} /* END ATL_dlarft_block */

/*
 * This function produce the block portion of the T matrix in recursive
 * algorithm.
 */
void ATL_larft_blockBC(int N, int K, int left, int right,
                      TYPE *V, int LDV,
                      TYPE *T, int LDT )
{
      TYPE *Tw, *Y2, *T2;
      int    row, col;
      int LDV2, LDT2;
      LDV2 = LDV SHIFT;                          /* For complex LDV * 2       */
      LDT2 = LDT SHIFT;                          /* For complex LDT * 2       */

       #ifdef TREAL
          const TYPE ONE = ATL_rone;
          const TYPE ZEROVAL = ATL_rzero;
          const TYPE NONE = ATL_rnone;
       #else
          const TYPE ONE[2] = {ATL_rone, ATL_rzero};
          const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
          const TYPE NONE[2] = {ATL_rnone, ATL_rzero};
       #endif

      Tw = T+(left SHIFT);                        /* Work at T[0 + left].   */
      Y2 = V+LDV2*left;            /* Y2 at V[0,left].    */
      T2 = T+(left SHIFT) +LDT2*left;           /* Address of new T2.      */

      /*-------------------------------------------------*/
      /* Fill in the lower  left hand block, which is    */
      /* 'right' rows and 'left' columns.                */
      /*                                                 */
      /* -T2 * (Y2^T * Y1) * T1                          */
      /* Block upper right hand element is T+(LDT*left). */
      /*-------------------------------------------------*/
      /* TODO : check all thsis comments   */
      /* Step 1: Y2^T * Y1, Y1 lower unit triangular.    */
      /* We do this in two steps to use DTRMM.           */
      /* We transpose by hand the 'last' 'right' columns */
      /* of Y2 into the workspace; then use DTRMM to     */
      /* multiply that on the right by the triangular    */
      /* part of Y1. Then we use DGEMM to compute        */
      /* Workspace += Y2rest^T * Y1rest.                 */
      /*                                                 */
      /* Note Y1rest[0,0] is at V, and                   */
      /* Y2rest[0,0] is at Y2.                           */
      /*                                                 */
      /*-------------------------------------------------*/
      for (row=0; row<right; row++)                 /* Each row of Tw          */
      {
         for (col=0; col<left; col++)             /* Each column of Tw       */
         {
            #ifdef TREAL
               /* Copy the  Transpose                         */
               *(Tw + row + col*LDT) =             /* Work[row, col]          */
               *((Y2+N-K) +row*LDV2 + col);   /* Y[col, row].           */
            #else
               /* Copy the  ConjTranspose for complex                         */
               *(Tw + (row SHIFT) + col*LDT2) =             /* Work[row, col]          */
               *(Y2+ ((N-K) SHIFT) +row*LDV2 + (col SHIFT) );   /* Y[col, row].           */

               /* copy the imaginary part.                                    */
               *(Tw + (row SHIFT) + 1 + col*LDT2) =             /* Work[row, col]          */
               0.0 - *(Y2+ ((N-K) SHIFT) +row*LDV2 + (col SHIFT) + 1 );   /* Y[col, row].           */
            #endif
         }
      }

      /*-------------------------------------------------*/
      /* Copy complete, Tw is 'right' rows, 'left' cols. */
      /* Tw = 1.0 * Tw * Y1.                             */
      /* DTRMM: (right): B := alpha * B * triangular A.  */
      /*-------------------------------------------------*/
      cblas_trmm(CblasColMajor,                 /* Y1 is on right, upr tri.*/
                MY_RIGHT, MY_UPPER,             /* Y1 is on right, upr tri.*/
                MY_NOTRANS, MY_UNIT,            /* As-is, with unit diag.  */
                right, left, ONE,               /* B rows, cols, alpha=1.  */
                (V + ((N -K) SHIFT)), LDV, Tw, LDT); /* A and B.            */
      /*-------------------------------------------------*/
      /* Dgemm can finish the multiply, if any is left.  */
      /* Tw += (Y2^T) * Y1, if N-K is > 0.               */
      /* DGEMM: C = alpha * A * B + Beta * C.            */
      /*-------------------------------------------------*/
      if (N > K)                                /* If any left below...    */
      {
        cblas_gemm(CblasColMajor,
                   MY_TRANS,                    /* Y2 is transposed.       */
                   MY_NOTRANS,                  /* Y1 is not.              */
                   right, left,                  /* Dimensions of C.        */
                   N-K,                         /* Height of columns.      */
                   ONE,                         /* No special multiplier.  */
                   (Y2), LDV,          /* Y2[0,0], dist to Y2[0,1]*/
                   (V ), LDV,    /* Y1[0,0], dist to Y1[0,1]*/
                   ONE,                         /* Add to existing data.   */
                   Tw, LDT);                    /* Wk[0,0], dist to Wk[0,1]*/
      }

      /*-------------------------------------------------*/
      /* Y2^T * Y1 complete; now two triangular mults.   */
      /* Tw = -1.0 * T2 * Tw.                            */
      /* DTRMM: (left): B:= alpha * triangular A * B     */
      /*-------------------------------------------------*/
      cblas_trmm(CblasColMajor,
               MY_LEFT, MY_LOWER,               /* T2 on left, lwr tri.    */
               MY_NOTRANS, MY_NONUNIT,          /* As-is, non-unit diag.   */
                right, left, NONE,              /* B rows, cols, alpha=-1. */
                T2, LDT, Tw, LDT);               /* A and B.                */

      /*-------------------------------------------------*/
      /* -T2 * (Y2^T * Y1) complete. Final tri T1 Mult.  */
      /* Tw = 1.0 * Tw * T1.                             */
      /* DTRMM: (right): B:= alpha * B * triangular A    */
      /*-------------------------------------------------*/
      cblas_trmm(CblasColMajor,
              MY_RIGHT, MY_LOWER,               /* T1 on right, lower tri.   */
               MY_NOTRANS, MY_NONUNIT,          /* As-is, non-unit diag.   */
                right, left, ONE,               /* B rows, cols, alpha=1.  */
                T, LDT, Tw, LDT);              /* A and B.                */


      return;                                   /* All done.               */
} /* END ATL_dlarft_block_BC */

void ATL_larft_blockBR(int N, int K, int top, int bottom,
                      TYPE *V, int LDV,
                      TYPE *T, int LDT )
{
      TYPE *Tw, *Y2, *T2;
      int    row, col;
      int LDV2, LDT2;
      LDV2 = LDV SHIFT;                          /* For complex LDV * 2       */
      LDT2 = LDT SHIFT;                          /* For complex LDT * 2       */

       #ifdef TREAL
          const TYPE ONE = ATL_rone;
          const TYPE ZEROVAL = ATL_rzero;
          const TYPE NONE = ATL_rnone;
       #else
          const TYPE ONE[2] = {ATL_rone, ATL_rzero};
          const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
          const TYPE NONE[2] = {ATL_rnone, ATL_rzero};
       #endif

      Tw = T+(top SHIFT);                        /* Work at T[top,0].   */
      Y2 = V+(top SHIFT);            /* Y2 at V[top, 0].    */
      T2 = T+(top SHIFT) +LDT2*top;           /* Address of new T2.      */

      /*-------------------------------------------------*/
      /* Fill in the lower  left hand block, which is    */
      /* 'bottom' rows and 'top' columns.                */
      /*                                                 */
      /* -T2 * (Y2 * Y1^T) * T1                          */
      /* Block  lower left hand elements  */
      /*-------------------------------------------------*/
      /* Step 1: Y2 * Y1^T, Y1 lower unit triangular.    */
      /* We do this in two steps to use DTRMM.           */
      /* We copy by hand the 'last-bottom' 'top' columns */
      /* of Y2 into the workspace; then use DTRMM to     */
      /* multiply that on the bottom by the triangular    */
      /* part of Y1. Then we use DGEMM to compute        */
      /* Workspace += Y2rest * Y1rest^T.                 */
      /*                                                 */
      /* Note Y1rest[0,0] is at V, and                   */
      /* Y2rest[0,0] is at Y2.                           */
      /*                                                 */
      /*-------------------------------------------------*/
      for (row=0; row<bottom; row++)                 /* Each row of Tw          */
      {
         for (col=0; col<top; col++)             /* Each column of Tw       */
         {
            #ifdef TREAL
               *(Tw + row + col*LDT) =             /* Work[row, col]          */
               *((Y2+ (N-K)*LDV) +row + (col*LDV));   /* Y[col, row].           */
            #else
               *(Tw + (row SHIFT) + col*LDT2) =             /* Work[row, col]          */
               *((Y2+ (N-K)*LDV2) +(row SHIFT) + (col*LDV2));   /* Y[col, row].           */


               /* copy the imaginary part.                                    */
               *(Tw + (row SHIFT) +1  + col*LDT2) =             /* Work[row, col]          */
               *((Y2+ (N-K)*LDV2) +(row SHIFT) +1 + (col*LDV2));   /* Y[col, row].           */

            #endif
         }
      }

      /*-------------------------------------------------*/
      /* Copy complete, Tw is 'bottom' rows, 'top' cols. */
      /* Tw = 1.0 * Tw * Y1^T.                             */
      /* DTRMM: (bottom): B := alpha*B * (op)triangular A.  */
      /*-------------------------------------------------*/
      cblas_trmm(CblasColMajor,                 /* Y1 is on bottom, lower tri.*/
                MY_RIGHT, MY_LOWER,             /* Y1 is on bottom, lower tri.*/
                MY_TRANS, MY_UNIT,            /* As-is, with unit diag.  */
                bottom, top, ONE,               /* B rows, cols, alpha=1.  */
                (V + ((N -K)*LDV2)), LDV, Tw, LDT); /* A and B.            */
      /*-------------------------------------------------*/
      /* Dgemm can finish the multiply, if any is top.  */
      /* Tw += Y2 * (Y1^T), if N-K is > 0.               */
      /* DGEMM: C = alpha * A * B + Beta * C.            */
      /*-------------------------------------------------*/
      if (N > K)                                /* If any top below...    */
      {
        cblas_gemm(CblasColMajor,
                   MY_NOTRANS,                    /* Y2 is not transposed.       */
                   MY_TRANS,                  /* Y1 is transposed.              */
                   bottom, top,                  /* Dimensions of C.        */
                   N-K,                         /* Height of columns.      */
                   ONE,                         /* No special multiplier.  */
                   (Y2), LDV,          /* Y2[0,0], dist to Y2[0,1]*/
                   (V ), LDV,    /* Y1[0,0], dist to Y1[0,1]*/
                   ONE,                         /* Add to existing data.   */
                   Tw, LDT);                    /* Wk[0,0], dist to Wk[0,1]*/
      }

      /*-------------------------------------------------*/
      /* Y2 * Y1^T complete; now two triangular mults.   */
      /* Tw = -1.0 * T2 * Tw.                            */
      /* DTRMM: (top): B:= alpha * triangular A * B     */
      /*-------------------------------------------------*/
      cblas_trmm(CblasColMajor,
               MY_LEFT, MY_LOWER,               /* T2 on left, lwr tri.    */
               MY_NOTRANS, MY_NONUNIT,          /* As-is, non-unit diag.   */
                bottom, top, NONE,              /* B rows, cols, alpha=-1. */
                T2, LDT, Tw, LDT);               /* A and B.                */

      /*-------------------------------------------------*/
      /* -T2 * (Y2 * Y1^T) complete. Final tri T1 Mult.  */
      /* Tw = 1.0 * Tw * T1.                             */
      /* DTRMM: (right): B:= alpha * B * triangular A    */
      /*-------------------------------------------------*/
      cblas_trmm(CblasColMajor,
              MY_RIGHT, MY_LOWER,               /* T1 on bottom, lower tri.   */
               MY_NOTRANS, MY_NONUNIT,          /* As-is, non-unit diag.   */
                bottom, top, ONE,               /* B rows, cols, alpha=1.  */
                T, LDT, Tw, LDT);              /* A and B.                */


      return;                                   /* All done.               */
} /* END ATL_dlarft_block_BR */

void ATL_larft(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV, int N, int K, TYPE *V, int LDV,
                TYPE  *TAU, TYPE *T, int LDT )
{

   if ( DIRECT == LAForward)
   {
      if ( STOREV == LAColumnStore)
      {
         ATL_larftFC(DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT );
      }
      else if (STOREV == LARowStore)
      {
         ATL_larftFR(DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT );
      }

   }
   else if (DIRECT == LABackward)
   {
      if ( STOREV == LAColumnStore)
      {
         ATL_larftBC(DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT );
      }
      else if (STOREV == LARowStore)
      {
         ATL_larftBR(DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT );
      }
   }
} /* END ATL_dlarft */

void ATL_larftFC(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV, int N, int K, TYPE *V, int LDV,
                TYPE  *TAU, TYPE *T, int LDT )
{
      TYPE   *Y2, *T2;
      TYPE   dt;
      int    row, col;
      int LDV2, LDT2;
      LDV2 = LDV SHIFT;                          /* for complex LDV *2        */
      LDT2 = LDT SHIFT;                          /* for comlex  LDT *2        */
      int right, left;

       #ifdef TREAL
          const TYPE ONE = ATL_rone;
          const TYPE ZEROVAL = ATL_rzero;
          TYPE VII;
          TYPE  d01, d02, d12;
       #else
          const TYPE ONE[2] = {ATL_rone, ATL_rzero};
          const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
          TYPE VII[2];
          TYPE  d01[2], d02[2], d12[2];
       #endif


      if (K == 0) return;                       /* Nothing to do.          */
      if (N == 0) return;                       /* Nothing to do.          */
      if (DIRECT != LAForward || STOREV != LAColumnStore)       /* If not my specialty,    */
      {
         fprintf(stderr, "ATL_dlarft called with DIRECT=%d, STOREV=%d.\n"
                         "Aborting.\n", DIRECT, STOREV);
         exit(1);
      }

      if (K == 1)                               /* Down to a scalar?       */
      {
        #ifdef TREAL
           *T = *TAU;                           /* Y. Just copy it.        */
        #else
           *T = *TAU;                           /* Y. Just copy it.        */
           *(T+1) = *(TAU+1);                   /* Y. Just copy it.        */
        #endif
         return;                                /* ...All done!            */
      }

      /*-------------------------------------------------------------------*/
      /* K=2: We only need T[0,1], computed as: (zero-relative):           */
      /*                                                                   */
      /* T[0, 1] = -tau[0] * d01 * tau[1].                                 */
      /*-------------------------------------------------------------------*/
      if (K == 2)
      {
         #ifdef TREAL
            *T = *TAU;                             /* Copy the diagonal...    */
            *(T+LDT+1) = *(TAU+1);                 /* ...                     */
            d01 = MY_DOT( N-2, V+2, 1, V+2+LDV, 1); /* Main dot product.      */
            d01 += *(V+1);                         /* Part mult by assumed 1.0*/
            *(T+LDT) = -(*TAU) * (*(TAU+1)) * d01; /* Fill in T[0,1].         */
         #else
            *T = *TAU;                            /* Copy the diagonal  -real */
            *(T+1) = *(TAU+1);                    /* Copy the diagonal. -real */
            *(T+LDT2+(1 SHIFT) ) = *(TAU+(1 SHIFT));     /* ...         -imag */
            *(T+LDT2+(1 SHIFT)+1) = *(TAU+(1 SHIFT) +1 );     /* ...    -imag */

            MY_DOT( N-2, V+(2 SHIFT), 1,
                      (V+(2 SHIFT )+LDV2), 1, d01);/* Main dot product.       */

            *(d01)+=*(V+(1 SHIFT));               /* Part mult by assumed 1.0 */
            *(d01+1)-=*(V+(1 SHIFT) + 1) ;        /* taken conj */

            /*  T[0,1] = -tau1*tau2*d01                                       */
            /* Perform                                                        */
            /*       tau1( -a -ib) * tau2(c+id) = (-ac+bd)  -i(bc+ad)-> res   */
            *(T+LDT2)  = -1.0* (*TAU) * (*(TAU + 2))  +
                         (*(TAU + 1) ) * (*(TAU + 3));
            *(T+LDT2 + 1)  = -1.0* (  (*(TAU + 1) ) * (*(TAU + 2))  +
                         (*TAU) * (*(TAU + 3))   ) ;

            /*  res = res* d01                                                */
            MY_DOTU( 1, (T+LDT2), 1,
                      (d01), 1, (T+LDT2) );                   /* T[0,1]       */

         #endif

         return;
      }

      right = (K>>3)<<2;
      left = K -right;
      if (right == 0)                           /* If not enough,          */
      {
         left  = K>>1;                          /* Take smaller half.      */
         right = K-left;                        /* right is the rest.      */
      }

      Y2 = V+(left SHIFT) +LDV2*left;          /* Y2 at V[left, left].     */
      T2 = T+(left SHIFT)+LDT2*left;           /* Address of new T2.       */

      /*-------------------------------------------------*/
      /* Recurse on the left, no change to T or V.       */
      /*-------------------------------------------------*/
      ATL_larftFC(DIRECT, STOREV, N, left,       /* K changes for left.      */
                 V, LDV, TAU, T, LDT);         /* Left uses same V,Tau,T.  */


      /*-------------------------------------------------*/
      /* Recurse on the right, T2 is always below and to */
      /* The right of T1 (adjacent with no overlap).     */
      /*-------------------------------------------------*/
      ATL_larftFC(DIRECT, STOREV, N-left, right,     /* N and K change on right.*/
               Y2, LDV, TAU+(left SHIFT), T2, LDT);/* Right new V, Tau, T.    */

      ATL_larft_blockFC(N, K, left, right,
                       V, LDV, T, LDT);            /* Fill in urh block.      */

} /* END ATL_dlarft */

void ATL_larftBC(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV, int N, int K, TYPE *V, int LDV,
                TYPE  *TAU, TYPE *T, int LDT )
{
      TYPE   *Y2, *T2;
      TYPE   dt;
      int    row, col;
      int LDV2, LDT2;
      LDV2 = LDV SHIFT;                          /* for complex LDV *2        */
      LDT2 = LDT SHIFT;                          /* for comlex  LDT *2        */
      int left, right;

       #ifdef TREAL
          const TYPE ONE = ATL_rone;
          const TYPE ZEROVAL = ATL_rzero;
          TYPE VII;
          TYPE  d10, d20, d21;
       #else
          const TYPE ONE[2] = {ATL_rone, ATL_rzero};
          const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
          TYPE VII[2];
          TYPE  d10[2], d02[2], d12[2];
       #endif

      if (K == 0) return;                       /* Nothing to do.          */
      if (N == 0) return;                       /* Nothing to do.          */
      if (DIRECT != LABackward || STOREV != LAColumnStore)       /* If not my specialty,    */
      {
         fprintf(stderr, "ATL_dlarft called with DIRECT=%d, STOREV=%d.\n"
                         "Aborting.\n", DIRECT, STOREV);
         exit(1);
      }

      if (K == 1)                               /* Down to a scalar?       */
      {
        #ifdef TREAL
           *T = *TAU;                           /* Y. Just copy it.        */
        #else
           *T = *TAU;                           /* Y. Just copy it.        */
           *(T+1) = *(TAU+1);                   /* Y. Just copy it.        */
        #endif
         return;                                /* ...All done!            */
      }

      /*-------------------------------------------------------------------*/
      /* K=2: We only need T[1,0], computed as: (zero-relative):           */
      /*                                                                   */
      /* T[0, 1] = -tau[0] * d10 * tau[1].        d10 : v0^T V1            */
      /*-------------------------------------------------------------------*/
      if (K == 2)
      {
         #ifdef TREAL
            *T = *TAU;                             /* Copy the diagonal...    */
            *(T+LDT+1) = *(TAU+1);                 /* ...                     */
            d10 = MY_DOT( N-2, V+LDV, 1, V, 1); /* Main dot product.      */
            d10 += *(V+LDV+N-2);                  /* Part mult by assumed 1.0*/
            *(T+1) = -(*(TAU+1)) * (*TAU)* d10;   /* Fill in T[0,1].         */
         #else
            *T = *TAU;                            /* Copy the diagonal  -real */
            *(T+1) = *(TAU+1);                    /* Copy the diagonal. -real */
            *(T+LDT2+(1 SHIFT) ) = *(TAU+(1 SHIFT));     /* ...         -imag */
            *(T+LDT2+(1 SHIFT)+1) = *(TAU+(1 SHIFT) +1 );     /* ...    -imag */

           /* Y is  conjugate transposed */
            MY_DOT( N-2, (V+LDV2), 1,
                      (V), 1, d10);/* Main dot product.       */

            *(d10)+=*(V+LDV2+((N-2) SHIFT));               /* Part mult by assumed 1.0 */
            *(d10+1)-=*(V+LDV2+((N-2) SHIFT) + 1) ;        /* taken conj */

            /*  T[1,0] = -tau1*tau2*d10                                       */
            /* Perform                                                        */
            /*       tau1( -a -ib) * tau2(c+id) = (-ac+bd)  -i(bc+ad)-> res   */
            *(T+ (1 SHIFT) )  = -1.0* (*TAU) * (*(TAU + 2))  +
                         (*(TAU + 1) ) * (*(TAU + 3));
            *(T+(1 SHIFT) + 1)  = -1.0* (  (*(TAU + 1) ) * (*(TAU + 2))  +
                         (*TAU) * (*(TAU + 3))   ) ;

            /*  res = res* d01                                                */
            MY_DOTU( 1, (T+ ( 1 SHIFT) ), 1,
                      (d10), 1, (T + (1 SHIFT)) );                   /* T[0,1]       */

         #endif

         return;
      }

      left = (K>>3)<<2;
      right = K -left;
      if (left == 0)                           /* If not enough,          */
      {
         right  = K>>1;                          /* Take smaller half.      */
         left = K-right;                        /* right is the rest.      */
      }

      Y2 = V+LDV2*left;          /* Y2 at V[0, left].     */
      T2 = T+(left SHIFT)+LDT2*left;           /* Address of new T2.       */

      /*-------------------------------------------------*/
      /* Recurse on the right, no change to T or V.       */
      /*-------------------------------------------------*/
      ATL_larftBC(DIRECT, STOREV, N, right,       /* K changes for left.      */
        Y2, LDV, (TAU+(left SHIFT)) , T2, LDT);  /* Left uses same V,Tau,T.  */

      /*-------------------------------------------------*/
      /* Recurse on the left, T1 is always above and to */
      /* The left of T1 (adjacent with no overlap).     */
      /*-------------------------------------------------*/
      ATL_larftBC(DIRECT, STOREV, N-right, left,     /* N and K change on right.*/
               V, LDV, TAU, T, LDT);            /* Left same V, Tau, T.    */

      ATL_larft_blockBC(N, K, left, right,
                       V, LDV, T, LDT);            /* Fill in urh block.      */

} /* END ATL_dlarft */


void ATL_larftFR(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV, int N, int K, TYPE *V, int LDV,
                TYPE  *TAU, TYPE *T, int LDT )
{
      TYPE   *Y2, *T2;
      TYPE   dt;
      int    row, col;
      int LDV2, LDT2;
      LDV2 = LDV SHIFT;                          /* for complex LDV *2        */
      LDT2 = LDT SHIFT;                          /* for comlex  LDT *2        */
      int bottom, top;

       #ifdef TREAL
          const TYPE ONE = ATL_rone;
          const TYPE ZEROVAL = ATL_rzero;
          TYPE VII;
          TYPE  d01, d02, d12;
       #else
          const TYPE ONE[2] = {ATL_rone, ATL_rzero};
          const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
          TYPE VII[2];
          TYPE  d01[2], d02[2], d12[2];
       #endif

      if (K == 0) return;                       /* Nothing to do.          */
      if (N == 0) return;                       /* Nothing to do.          */
      if (DIRECT != LAForward || STOREV != LARowStore)       /* If not my specialty,    */
      {
         fprintf(stderr, "ATL_dlarft called with DIRECT=%d, STOREV=%d.\n"
                         "Aborting.\n", DIRECT, STOREV);
         exit(1);
      }

      if (K == 1)                               /* Down to a scalar?       */
      {
        #ifdef TREAL
           *T = *TAU;                           /* Y. Just copy it.        */
        #else
           *T = *TAU;                           /* Y. Just copy it.        */
           *(T+1) = *(TAU+1);                   /* Y. Just copy it.        */
        #endif
         return;                                /* ...All done!            */
      }

      /*-------------------------------------------------------------------*/
      /* K=2: We only need T[0,1], computed as: (zero-relative):           */
      /*                                                                   */
      /* T[0, 1] = -tau[0] * d01 * tau[1].   ( z = -tau.T.Y.v')            */
      /*-------------------------------------------------------------------*/
      if (K == 2)
      {
         #ifdef TREAL
            *T = *TAU;                             /* Copy the diagonal...    */
            *(T+LDT+1) = *(TAU+1);                 /* ...                     */
            d01 = MY_DOT( N-2, (V+2*LDV), LDV, V+2*LDV+1, LDV); /* Main dot product.      */
            d01 += *(V+LDV);                         /* Part mult by assumed 1.0*/
            *(T+LDT) = -(*TAU) * (*(TAU+1)) * d01; /* Fill in T[0,1].         */
         #else
            *T = *TAU;                            /* Copy the diagonal  -real */
            *(T+1) = *(TAU+1);                    /* Copy the diagonal. -real */
            *(T+LDT2+(1 SHIFT) ) = *(TAU+(1 SHIFT));     /* ...         -imag */
            *(T+LDT2+(1 SHIFT)+1) = *(TAU+(1 SHIFT) +1 );     /* ...    -imag */

            /* conjugate of V is taken */
            MY_DOT( N-2, (V+2*LDV2 +(1 SHIFT)), LDV, (V+2*LDV2), LDV, d01); /* Main dot product.      */


           *( d01)  += *(V+LDV2);                         /* Part mult by assumed 1.0*/
           *(d01+1) += *(V+LDV2 + 1);                     /* Part mult by assumed 1.0*/

            /*  T[0,1] = -tau1*tau2*d0                                       */
            /* Perform                                                        */
            /*       tau1( -a -ib) * tau2(c+id) = (-ac+bd)  -i(bc+ad)-> res   */
            *(T+ LDT2 )  = -1.0* (*TAU) * (*(TAU + 2))  +
                         (*(TAU + 1) ) * (*(TAU + 3));
            *(T+ LDT2 + 1)  = -1.0* (  (*(TAU + 1) ) * (*(TAU + 2))  +
                         (*TAU) * (*(TAU + 3))   ) ;

            /*  res = res* d01                                                */
            MY_DOTU( 1, (T+LDT2), 1,
                      (d01), 1, (T+ LDT2) );                   /* T[1,0]       */

         #endif

         return;
      }

      bottom = (K>>3)<<2;
      top = K -bottom;
      if (bottom == 0)                           /* If not enough,          */
      {
         top  = K>>1;                          /* Take smaller half.      */
         bottom = K-top;                        /* bottom is the rest.      */
      }

      Y2 = V+(top SHIFT) +LDV2*top;          /* Y2 at V[top, top].     */
      T2 = T+(top SHIFT)+LDT2*top;           /* Address of new T2.       */

      /*-------------------------------------------------*/
      /* Recurse on the top, no change to T or V.       */
      /*-------------------------------------------------*/
      ATL_larftFR(DIRECT, STOREV, N, top,       /* K changes for top.      */
                 V, LDV, TAU, T, LDT);         /* Left uses same V,Tau,T.  */


      /*-------------------------------------------------*/
      /* Recurse on the bottom, T2 is always below and to */
      /* The bottom of T1 (adjacent with no overlap).     */
      /*-------------------------------------------------*/
      ATL_larftFR(DIRECT, STOREV, N-top, bottom,     /* N and K change on bottom.*/
               Y2, LDV, TAU+(top SHIFT), T2, LDT);/* Right new V, Tau, T.    */

      ATL_larft_blockFR(N, K, top, bottom,
                       V, LDV, T, LDT);            /* Fill in urh block.      */

} /* END ATL_dlarft */

void ATL_larftBR(const enum ATL_LADIRECT DIRECT, const enum ATL_LASTOREV STOREV, int N, int K, TYPE *V, int LDV,
                TYPE  *TAU, TYPE *T, int LDT )
{
//TODO : coded only for double prec
      TYPE   *Y2, *T2;
      TYPE   dt;
      int    row, col;
      int LDV2, LDT2;
      LDV2 = LDV SHIFT;                          /* for complex LDV *2        */
      LDT2 = LDT SHIFT;                          /* for comlex  LDT *2        */
      int top, bottom;

       #ifdef TREAL
          const TYPE ONE = ATL_rone;
          const TYPE ZEROVAL = ATL_rzero;
          TYPE VII;
          TYPE  d10, d20, d21;
       #else
          const TYPE ONE[2] = {ATL_rone, ATL_rzero};
          const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
          TYPE VII[2];
          TYPE  d10[2], d02[2], d12[2];
       #endif

      if (K == 0) return;                       /* Nothing to do.          */
      if (N == 0) return;                       /* Nothing to do.          */
      if (DIRECT != LABackward || STOREV != LARowStore)       /* If not my specialty,    */
      {
         fprintf(stderr, "ATL_dlarft called with DIRECT=%d, STOREV=%d.\n"
                         "Aborting.\n", DIRECT, STOREV);
         exit(1);
      }

      if (K == 1)                               /* Down to a scalar?       */
      {
        #ifdef TREAL
           *T = *TAU;                           /* Y. Just copy it.        */
        #else
           *T = *TAU;                           /* Y. Just copy it.        */
           *(T+1) = *(TAU+1);                   /* Y. Just copy it.        */
        #endif
         return;                                /* ...All done!            */
      }

      /*-------------------------------------------------------------------*/
      /* K=2: We only need T[1,0], computed as: (zero-relative):           */
      /*                                                                   */
      /* T[0, 1] = -tau[0] *  tau[1] * d10        d10 : V1*v0^T            */
      /*                                   => -tau*T*Y*v^T                 */
      /* T is a lower triangular matrix                                    */
      /*-------------------------------------------------------------------*/
      if (K == 2)
      {
         #ifdef TREAL
            *T = *TAU;                             /* Copy the diagonal...    */
            *(T+LDT+1) = *(TAU+1);                 /* ...                     */
            d10 = MY_DOT( N-2, V, LDV,(V+1), LDV); /* Main dot product.      */
            d10 += *(V+1+(N-2)*LDV);                  /* Part mult by assumed 1.0*/
            *(T+1) = -(*(TAU)) * (*(TAU+1))* d10;   /* Fill in T[1,0].         */
         #else
            *T = *TAU;                            /* Copy the diagonal  -real */
            *(T+1) = *(TAU+1);                    /* Copy the diagonal. -real */
            *(T+LDT2+(1 SHIFT) ) = *(TAU+(1 SHIFT));     /* ...         -imag */
            *(T+LDT2+(1 SHIFT)+1) = *(TAU+(1 SHIFT) +1 );     /* ...    -imag */

            /* conjugate of V is taken */
            MY_DOT( N-2, V, LDV, (V+( 1 SHIFT) ), LDV, d10); /* Main dot product.      */

            *(d10)+=*(V+(1 SHIFT) + (N-2)*LDV2);   /* Part mult by assumed 1.0 */
            *(d10+1)+=*(V+(1 SHIFT)+1 + (N-2)*LDV2 );       /* Part mult by assumed 1.0 */

            /*  T[1,0] = -tau1*tau2*d10                                       */
            /* Perform                                                        */
            /*       tau1( -a -ib) * tau2(c+id) = (-ac+bd)  -i(bc+ad)-> res   */
            *(T+ ( 1 SHIFT) )  = -1.0* (*TAU) * (*(TAU + 2))  +
                         (*(TAU + 1) ) * (*(TAU + 3));
            *(T+ ( 1 SHIFT) + 1)  = -1.0* (  (*(TAU + 1) ) * (*(TAU + 2))  +
                         (*TAU) * (*(TAU + 3))   ) ;

            /*  res = res* d10                                                */
            MY_DOTU( 1, (T+(1 SHIFT)), 1,
                      (d10), 1, (T+ ( 1 SHIFT) ) );                   /* T[1,0]       */

         #endif

         return;
      }

      top = (K>>3)<<2;
      bottom = K -top;
      if (top == 0)                           /* If not enough,          */
      {
         bottom  = K>>1;                          /* Take smaller half.      */
         top = K-bottom;                        /* bottom is the rest.      */
      }

      Y2 = V+(top SHIFT) ;                   /* Y2 at V[top,0].     */
      T2 = T+(top SHIFT)+LDT2*top;           /* Address of new T2.       */

      /*-------------------------------------------------*/
      /* Recurse on the bottom, no change to T or V.       */
      /*-------------------------------------------------*/
      ATL_larftBR(DIRECT, STOREV, N, bottom,       /* K changes for top.      */
        Y2, LDV, (TAU+(top SHIFT)) , T2, LDT);  /* Left uses same V,Tau,T.  */

      /*-------------------------------------------------*/
      /* Recurse on the top, T1 is always above and to */
      /* The top of T1 (adjacent with no overlap).     */
      /*-------------------------------------------------*/
      ATL_larftBR(DIRECT, STOREV, N-bottom, top,     /* N and K change on bottom.*/
               V, LDV, TAU, T, LDT);            /* Left same V, Tau, T.    */

      ATL_larft_blockBR(N, K, top, bottom,
                       V, LDV, T, LDT);            /* Fill in urh block.      */

} /* END ATL_dlarft */

@ROUT ATL_ladiv
/*-----------------------------------------------------------------------------
 * This is the C translation of the standard LAPACK Fortran routine:
 *      void      FUNCTION ZLADIV( X, Y, Z)
 *
 * ATL_ladiv.c :
 *             void ATL_cmladiv( TYPE *X, TYPE *Y, TYPE  *Z)
 *     NOTE :  a) ATL_ladiv.c will get compiled to two  precisions
 *                single precision complex,   double precision complex
 *
 *             b) This should be called only for real numbers
 *
 * Purpose
 * =======
 *
 * Z := X / Y, where X and Y are complex.  The computation of X / Y
 * will not overflow on an intermediary step unless the results
 * overflows.
 *
 *        This performs complex division in  real arithmetic
 *
 *                               a + i*b
 *                    p + i*q = ---------
 *                               c + i*d
 *
 *        The algorithm is due to Robert L. Smith and can be found
 *         in D. Knuth, The art of Computer Programming, Vol.2, p.195
 *
 * Arguments
 * =========
 *
 *         X       (input)
 *         Y       (input)
 *                 The complex scalars X and Y ( pointer to X and Y).
 *         Z       (input/output) is the output  ( pointer  to Z)
 *
 -----------------------------------------------------------------------------*/
#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"


void ATL_ladiv( TYPE *X, TYPE *Y, TYPE  *Z)
{
   TYPE   E, F;

/* If           X[0], X[1], Y[0], Y[1], &Z[0], &Z[1]  is mapped to            */
/* real numbers  A,    B,    C,    D,    *P,   *Q                             */
/* the computation is as below                                                */
/*                                                                            */
/*   if ( fabs(D) < fabs( C) ) {                                              */
/*         E = D / C ;                                                        */
/*         F = C + D*E ;                                                      */
/*         *P = ( A+B*E ) / F ;                                               */
/*         *Q = ( B-A*E ) / F ;                                               */
/*                                                                            */
/*   } else{                                                                  */
/*         E = C / D ;                                                        */
/*         F = D + C*E ;                                                      */
/*         *P = ( B+A*E ) / F ;                                               */
/*         *Q = ( -A+B*E ) / F ;                                              */
/*   }                                                                        */


   if ( Mabs(Y[1])  < Mabs(Y[0]) )
   {
      E = Y[1]/Y[0];
      F = Y[0] + Y[1]*E;
      *(Z)   = ( X[0] + X[1]*E ) / F ;
      *(Z+1) = ( X[1] - X[0]*E ) / F ;
   }
   else
   {
     E = Y[0]/Y[1];
     F = Y[1] + Y[0]*E;
     *(Z)   = (X[1]+ X[0]*E ) / F ;
     *(Z+1) = (-X[0] + X[1]*E ) / F ;
   }
} /* END AL_ladiv */
@ROUT ATL_lacgv
/*-----------------------------------------------------------------------------
* This is the C translation of the standard LAPACK Fortran routine:
*      SUBROUTINE C/Z LACGV( N, X, INCX )
*
*  Purpose
*  =======
*
*  ATL_lacgv.c conjugates a complex vector of length N.
*
*  Arguments
*  =========
*
*  N       (input) INTEGER
*          The length of the vector X.  N >= 0.
*
*  X       (input/output) complex array, dimension
*                         (1+(N-1)*abs(INCX))
*          On entry, the vector of length N to be conjugated.
*          On exit, X is overwritten with conjg(X).
*
*          NOTE : complex numbers are stored as,
*          real(single/complex), imaginary(single/complex)
*          in concequtive memory locations.
*
*  INCX    (input) INTEGER
*          The spacing between successive elements of X.
*
-----------------------------------------------------------------------------*/
#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

//Compiled only to precisions single complex and double complex.
void  ATL_lacgv( const int N, TYPE *X, int INCX)
{
   int i, ioff;

   if ( INCX == 1)
   {
      //imaginary part = Negetive of imaginary(X[i])
      for ( i = 0; i < N; i++)
      {
          *(X + (i SHIFT) + 1 ) = 0.0 - *(X + (i SHIFT) + 1 ) ;
      }
   }
   else
   {
      //TODO : Test this section on i off
      ioff =0;
      if ( INCX < 0 ){
         ioff = 0 - ( N-1)*INCX;
      }

      for ( i =0; i < N; i=i++)
      {
          //Negetaive of imaginary number is taken
          *(X+ ( ioff SHIFT ) + 1  ) = 0.0 - *(X+ (ioff SHIFT) + 1 );
          ioff = ioff + INCX;                    //increment the offset
      }
   } //else on INCX

   return;
}
@ROUT ATL_lapy3
/*-----------------------------------------------------------------------------
 *  This is the C translation of the standard LAPACK Fortran routine:
 *      DOUBLE PRECISION FUNCTION DLAPY3( X, Y, Z )
 *      NOTE : ATL_lapy3.c  will get compiled to
 *             single precision complex (ATL_clapy3.o)  and
 *              double precision complex (ATL_zlapt3.o)
 *
 *   Purpose
 *   =======
 *   ATL_lapy3 returns sqrt(x**2+y**2+z**2), taking care not to cause
 *         unnecessary overflow.
 *
 *   Arguments
 *   =========
 *
 *   X       (input) single/double precision
 *   Y       (input) single/double precision
 *   Z       (input) single/double precision
 *                 X, Y and Z specify the values x, y and z.
-----------------------------------------------------------------------------*/
#include "stdio.h"
#include "cblas.h"
#include "atlas_lapack.h"

TYPE  ATL_lapy3(TYPE X, TYPE Y, TYPE Z)
{
   TYPE  ONE=1.0, ZERO=0.0, W, Wtemp,  XABS, YABS, ZABS, TEMP;

   XABS = Mabs(X);
   YABS = Mabs(Y);
   ZABS = Mabs(Z);

   /* W : get the maximum absolute value from x,y,z        */
   Wtemp = (XABS<YABS)?YABS:XABS;
   W = (Wtemp<ZABS)?ZABS:Wtemp;

   if (W == ZERO)
   {
      /*   W can be zero for max(0,nan,0). Adding all three entries  */
      /*   together will make sure  NaN will not disappear.          */

         return( XABS + YABS + ZABS);
   }
   else
   {
         TEMP = ( XABS / W )*( XABS / W ) +
                ( YABS / W )*( YABS / W ) +
                ( ZABS / W )*( ZABS / W ) ;

         return (W * sqrt(TEMP));
   }
} /* END ATL_lapy3 */
@ROUT ATL_lamch
 /******************************************************************************
 *  ATL_lamch.c :
 *                TYPE  ATL_lamch(char  CMACH )
 *                Will get compiled to single precision and double precesion
 *
 *  Purpose
 *  =======
 *
 *  ATL_lamch determines single/double precision machine parameters.
 *
 *  Arguments
 *  =========
 *
 *  CMACH   (input) CHARACTER*1
 *          Specifies the value to be returned by DLAMCH:
 *          = 'E' or 'e',   DLAMCH := eps
 *          = 'S' or 's ,   DLAMCH := sfmin
 *          = 'B' or 'b',   DLAMCH := base
 *          = 'P' or 'p',   DLAMCH := eps*base
 *          = 'N' or 'n',   DLAMCH := t
 *          = 'R' or 'r',   DLAMCH := rnd
 *          = 'M' or 'm',   DLAMCH := emin
 *          = 'U' or 'u',   DLAMCH := rmin
 *          = 'L' or 'l',   DLAMCH := emax
 *          = 'O' or 'o',   DLAMCH := rmax
 *
 *          where
 *
 *          eps   = relative machine precision
 *          sfmin = safe minimum, such that 1/sfmin does not overflow
 *          base  = base of the machine
 *          prec  = eps*base
 *          t     = number of (base) digits in the mantissa
 *          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
 *          emin  = minimum exponent before (gradual) underflow
 *          rmin  = underflow threshold - base**(emin-1)
 *          emax  = largest exponent before overflow
 *          rmax  = overflow threshold  - (base**emax)*(1-eps)
 *
 *----------------------------------------------------------------------------*/
#include "stdio.h"
#include "atlas_misc.h"

#include "atlas_lapack.h"
#include "cblas.h"




#define TRUE 1
#define FLASE 0
#define ATL_rmin       Mjoin(PATL,rmin)
#define ATL_emin       Mjoin(PATL,emin)
#define ATL_mantissa   Mjoin(PATL,mantissa)
#define ATL_rmax       Mjoin(PATL,rmax)
#define ATL_epsilon1   Mjoin(PATL,epsilon1)

TYPE ATL_rmin();
int ATL_emin();
int ATL_mantissa();
TYPE ATL_rmax(int P);
TYPE  ATL_epsilon1();



TYPE  ATL_lamch(char  CMACH )
{
   const TYPE ONE = ATL_rone;
   const TYPE ZERO = ATL_rzero;
   const TYPE  BASE = 2.0;
   static int FIRST = TRUE;

   int   IT;
/*   double volatile  EMAX, EMIN, EPS, PREC, RMACH, RMAX, RMIN,
*                        RND, SFMIN, SMALL, T;
*/
//   TYPE volatile  EPS1,  RMACH, RMAX, RMIN, SFMIN, SMALL, T;
   TYPE static EPS1,  RMACH, RMAX, RMIN, SFMIN, SMALL, T;

   if(FIRST)
   {
      T     = ATL_mantissa();    // int to Double
      EPS1   = ATL_epsilon1();
      //PREC = BASE*EPS;         // Just for reference

      RMIN   = ATL_rmin();
      SFMIN  = RMIN;

      RMAX   = ATL_rmax(T);

      SMALL  = ONE /RMAX;

      if ( SMALL > SFMIN )
      {
         /* Use SMALL plus a bit, to avoid the possibility of rounding   */
         /*           causing overflow when computing  1/sfmin.          */
         SFMIN = SMALL*( ONE+EPS1 );

         //LOGICCHECK : Did not undertsnad this logic completely
         //will check again
      }
   }     /*  if first */

   switch(CMACH)
   {
      case 'E':
         RMACH = EPS1;
         break;
      case 'S':
         RMACH = SFMIN;
         break;
      case 'B':
         RMACH = BASE;
         break;
/*      case 'P':
 *        RMACH = PREC;
 */       break;
      case 'N':
         RMACH = T;
         break;
/*      case 'M':
 *        RMACH = EMIN;
 */        break;
      case 'U':
         RMACH = RMIN;
         break;
/*      case 'L':
 *        RMACH = EMAX;
 */        break;
      case 'O':
         RMACH = RMAX;
         break;
   }

   FIRST  = FLASE;
   return RMACH;
} /*End of ATL_lamch */


TYPE ATL_rmin()
{

   int EMIN, T, i;
   TYPE volatile LRMIN = 1.0;
   TYPE const RBASE = 1/2.0;

   /*  Now find  EMIN.  Let A = + or - 1, and + or - (1 + BASE**(-3)).    */
   /*  Keep dividing  A by BETA until (gradual) underflow occurs. This    */
   /*  is detected when we cannot recover the previous A.                 */

   EMIN = ATL_emin();

   /*  Special LOGIC :                                                    */
   /*  ( Non twos-complement machines, with gradual underflow;            */
   /*    e.g., IEEE standard followers )                                  */

   T = ATL_mantissa();
   EMIN = EMIN - 1 + T;

  /* Compute  RMIN by successive division by  BETA. We could compute      */
  /* RMIN as BASE**( EMIN - 1 ),  but some machines underflow during      */
  /* this computation.                                                    */

   for ( i = 0; i <  (1 - EMIN); i++)
   {
      LRMIN = LRMIN*RBASE;
   }

   return LRMIN;

}


int ATL_emin()
{
   /*  The minimum exponent before (gradual) underflow, computed by       */
   /*  setting A = START value (1.00  and dividing by BASE until the      */
   /*  previous  A  can not be recovered.                                 */

   int            I, EMIN;
   TYPE const    ONE = 1.0,  ZERO =0.0;
   TYPE volatile   A, B1, B2, C1, C2, D1, D2, RBASE;
   TYPE BASE = 2.0;
   int BASEINT = 2;

   A = 1.0;
   RBASE = ONE / BASE;
   EMIN = 1;
   B1 = A*RBASE;
   C1 = A;
   C2 = A;
   D1 = A;
   D2 = A;

   while ( ( C1 == A ) && ( C2 == A )  &&
       ( D1  == A ) && ( D2 == A )      )
   {

      EMIN = EMIN - 1;
      A = B1;
      B1 =  A / BASE;
      C1 = B1*BASE;
      D1 = ZERO;
      for(I=0; I< BASE ; I++) D1 = D1 + B1;

      B2 = A*RBASE;
      C2 =  B2 / RBASE;
      D2 = ZERO;

         //LOGICCHECK : did not understand why
         // D1 and D2 computation is required .

      for(I=0; I< BASE ; I++) D2 = D2 + B2;
   }
   return EMIN;
}


int ATL_mantissa()
{

   /*  Now find  the  mantissa, t.  It should  be the  integer part of  */
   /*  log to the base beta of a,  however it is safer to determine  t  */
   /*  by powering.  So we find t as the smallest positive integer for  */
   /*  which                                                            */
   /*         fl( beta**t + 1.0 ) = 1.0.                                */

   int LT;
   TYPE  volatile A,C;
   TYPE ONE = 1.0;
   TYPE BETA = 2.0;

   LT = 0;
   A = 1.0;
   C = 1.0;

   while(C == ONE )
   {
      LT = LT + 1;
      A = A*BETA;
      C = A+ ONE;
      C =  C -A ;
   }
   return LT;
}



TYPE ATL_rmax(int P)
{
   /* attempts to compute RMAX, the largest machine floating-point        */
   /*  number, without overflow.  It assumes that EMAX + abs(EMIN) sum    */
   /*  approximately to a power of 2                                      */

   TYPE volatile A =1.0;
   TYPE volatile B =1.0;
   TYPE volatile C =2.0;
   TYPE volatile   Z, Y, OLDY,  RECBAS ;
   TYPE const BETA = 2.0, ONE = 1.0, ZERO = 0.0;
   int I ;

   int IMAX = 0;          //Starting with 0,


   while ( C == 2.00)
   {
      IMAX = IMAX + 1;
      A = B;
      B = A* 2.0;
      C = B/A;
   }

   /*     Now create RMAX, the largest machine number, which should  */
   /*     be equal to (1.0 - BETA**(-P)) * BETA**EMAX .              */
   /*                                                                */
   /*     First compute 1.0 - BETA**(-P), being careful that the     */
   /*     result is less than 1.0 .                                  */

   RECBAS = ONE / BETA;
   Z = BETA - ONE;
   Y = ZERO;

   for (  I=0; I < P; I++)
   {
      Z = Z*RECBAS;
      if ( Y < ONE ) OLDY = Y;
      Y = Y +  Z ;
   }
   if ( Y > ONE )  Y = OLDY;

   //LOGICCHECK : I understood the significance of Y
   //and OLDY only at highlevel

   for( I = 0; I < IMAX ; I++)
   {
         Y = Y*BETA;
   }

   return Y;
}


TYPE  ATL_epsilon1()
{
   static TYPE eps;
   const TYPE  half=0.5;
   volatile TYPE  maxval, f1=0.5;

   do
   {
      eps = f1;
      f1 *= half;
      maxval = 1.0 + f1;
   }
   while (maxval != 1.0);
   return(eps);
}

@ROUT qrtst
@extract -b @(topd)/cw.inc lang=C -def cwdate 2009 -def cwauth "Siju Samuel" -def contrib "R. Clint Whaley, Anthony M. Castaldo"
/*
 *  This program is a tester for QR, RQ, LQ and QL factorization routines.
 *
 *
 *  TestProg  Variants : qr = 1 , rq = 2 , ql =3 , lq =4
*/

#include "atlas_misc.h"
#include "atlas_lapack.h"
#include "cblas.h"
#include "atlas_cblastypealias.h"
#include "atlas_tst.h"
#ifdef ATL_FULL_LAPACK
   #include "atlas_C2Flapack.h"
   @whiledef rt qr ql rq lq
   #ifdef TREAL
      #define LA_@up@(rt)2Q Mjoin(Mjoin(ATL_C2F,PRE),orm@(rt))
   #else
      #define LA_@up@(rt)2Q Mjoin(Mjoin(ATL_C2F,PRE),unm@(rt))
   #endif
   @endwhile
#endif
#ifdef GCCWIN
   ___main(){} __main(){} MAIN__(){} _MAIN_(){}
#endif

#define PRINT_1    0
#define TEST_3     0
#define TEST_4     1
#define TESTONLYCALL_1    1
#define SIZE    10000


#ifdef TREAL
    static const TYPE ONE = ATL_rone;
    static const TYPE ZEROVAL = ATL_rzero;
    #define MY_TRANS CblasTrans
#else
    static const TYPE ONE[2] = {ATL_rone, ATL_rzero};
    static const TYPE ZEROVAL[2] = {ATL_rzero, ATL_rzero};
    #define MY_TRANS CblasConjTrans
#endif



#ifdef TimeF77
   #define test_gelqf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
   ATL_assert(!Mjoin(PATL,f77gelqf)(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_))
#else
   #include "clapack.h"
   #define test_gelqf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      Mjoin(Mjoin(ATL_,PRE),gelqf)(M_, N_, A_, lda_, tau_, wrk_,lw_)
#endif
#ifdef TimeF77
   #define test_gerqf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
   ATL_assert(!Mjoin(PATL,f77gerqf)(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_))
#else
   #include "clapack.h"
   #define test_gerqf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      Mjoin(Mjoin(ATL_,PRE),gerqf)(M_, N_, A_, lda_, tau_, wrk_, lw_)
#endif
#ifdef TimeF77
   #define test_geqlf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
   ATL_assert(!Mjoin(PATL,f77geqlf)(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_))
#else
   #include "clapack.h"
   #define test_geqlf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      Mjoin(Mjoin(ATL_,PRE),geqlf)(M_, N_, A_, lda_, tau_, wrk_, lw_)
#endif
#ifdef TimeF77
   #define test_geqrf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
   ATL_assert(!Mjoin(PATL,f77geqrf)(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_))
#else
   #include "clapack.h"
   #define test_geqrf(Major_, M_, N_, A_, lda_, tau_, wrk_, lw_) \
      Mjoin(Mjoin(ATL_,PRE),geqrf)(M_, N_, A_, lda_, tau_, wrk_, lw_)
#endif

/*
 * Print a Matrix
 */
void printMMMatrix(char *msg, TYPE *A, int M, int N, int lda)
{
    if(PRINT_1)
       Mjoin(PATL,geprint)(msg, M, N, A, lda);
}

/*
 * Print a Vector
 */
void printVVector( char * msg, TYPE *X, int N)
{
    if(PRINT_1)
       Mjoin(PATL,geprint)(msg, N, 1, X, N);
}

/*
 * Copy Vector X1[1:n] to  -1.0*X1[1:n]
 */
void   makeVectorToNegVal( TYPE *X1, int size)
{
    int  i, size2;
    size2 = size SHIFT;                // 2*size, for  complex  numbers

    for ( i= 0; i < size2; i++)
    {
        X1[i] = -1.0*X1[i];
        //X1[i] = 0.0 -X1[i];
    }
}

/*
 * Copy Vector X1[1:n] from  -1.0*X1[1:n]
 */
void   makeVectorToConjVal( TYPE *X1, int size)
{
    int  i;

    for ( i= 0; i < size; i++)
    {

       #ifdef TREAL
           X1[(i SHIFT)  ] = 1.0*X1[(i SHIFT) ]; //Change to just return
       #else
           // Only Applied to Imaginary part
           X1[(i SHIFT) +1 ] = 0.0 -X1[(i SHIFT) +1];
       #endif
    }
}

int AllocationErr( char * msg)
{
    printf("Error while allocating %s\n", msg);
    exit(-1);
}

/*
 * Rreturns a duplicate of the A matrix, with new leading dimension
 * lda   : leading dimension of A
 * ldc   : leading dimension of Duplicate Matrix
 */
static TYPE *DupMat(enum ATLAS_ORDER Order, int M, int N, TYPE *A, int lda,
                    int ldc)
{
   int i, j, M2;
   const int ldc2 = (ldc SHIFT), lda2 = (lda SHIFT);
   TYPE *C;
   if (Order == CblasRowMajor)
   {
      i = M;
      M = N;
      N = i;
   }
   M2 = M SHIFT;
   ATL_assert(ldc >= M);
   C = malloc(ATL_MulBySize(ldc)*N);
   ATL_assert(C);
   for (j=0; j != N; j++)
   {
      for (i=0; i != M2; i++) C[i] = A[i];
      C += ldc2;
      A += lda2;
   }
   return(C-N*ldc2);
}

/*
 * Make input square matrix A[NxN] as Identity Matrix.
 */
void  makeIdenty(TYPE *A, int N, int lda)
{
    int i, j, lda2;

    lda2 = lda SHIFT;                  // 2*lda for complex

    for(i=0; i<N; i++)
    {
      for(j=0; j<N; j++)
      {
          //TODO : Check this, to keep this or just keep additional
          //       part for complex  alone
          #ifdef TREAL
              if(i==j){
                 *(A+j*lda2+i) = 1.0;
              }
              else {
                 *(A+j*lda2+i) = 0.0;
              }
          #else
              if(i==j){
                 *(A+j*lda2 + (i SHIFT ) ) = 1.0;
                 *(A+j*lda2+ (i SHIFT ) + 1) = 0.0;
              }
              else {
                 *(A+j*lda2+ (i SHIFT ) ) = 0.0;
                 *(A+j*lda2+ (i SHIFT ) + 1) = 0.0;
              }
          #endif
      }
    }
}


/*
 * Copy values of  Matrix A to B.
 * (NOTE : Tested for input square matrix A[NxN]
 *         lda and ldb same )
 */
void copyMatrix(TYPE *A, int lda,  TYPE* B, int ldb,  int M, int N)
{
    int i, j;
    int lda2 = lda SHIFT;
    int ldb2 = ldb SHIFT;

    for(i=0; i<(M SHIFT); i++)                 //to take care of complex
    {
      for(j=0; j<N; j++)
      {
          *(B+j*ldb2+i) = *(A+j*lda2+i) ;
      }
    }
}

/*
 * Allocate a space for ldmxN for 'real'.
 * For Complex allocate space for (2*ldm)xN.
 * It also takes care of the precision.
 * Then generate matrix for MxN, real/complex values based on the precision.
 */
TYPE *GetGE(int M, int N, int lda)
{
   TYPE *A;
   A = malloc(ATL_MulBySize(lda)*N);
   if (A) Mjoin(PATL,gegen)(M, N, A, lda, M*N+lda);
   return(A);
}


/*
 * Populate Vi vector  from the given ROW of A Matrix.  A has the pointer
 * to the first element  in the row. N represent the size of row.
 * 'numberOfVielement' denotes  (N - number of zero elements in Vi)
 *
 *   if       ROW-> v v v v R R R (example)
 *   then     VI->  v v v v 1 (example)
 *
 *   NOTE : For Complex conjugate of v(i) is taken
 *
 */
void populateVViForRQ (TYPE *Vi, TYPE * A, int lda,
                       int numberOfVielement)
{
   //Copy routine
   int j =0;
   int i =0;
   int lda2 = lda SHIFT;

   #ifdef TREAL
          for ( j = 0; j < (numberOfVielement -1 ); j++)
          {
             Vi[j]= *(A+j*lda);
          }
          Vi[numberOfVielement -1 ] = 1.0;
   #else
          for ( j = 0; j < ( (numberOfVielement -1)); j++)
          {
             Vi[(j SHIFT) ]= *(A+j*lda2);

             // Conjugate is taken
             Vi[(j SHIFT) +1 ]= 0.0 - *(A+j*lda2 + 1);

          }
          Vi[ ( (numberOfVielement -1) SHIFT)  ] = 1.0;
          Vi[ ( (numberOfVielement -1) SHIFT) + 1  ] = 0.0;
   #endif
}

/*
 * Populate Vi vector  from the given ROW of A Matrix.  A has the pointer
 * to the first element  in the row. N represent the size of row.
 * 'numberOfVielement' denotes  (N - number of zero elements in Vi)
 *
 *    vi -> L L v v v v v  (example)
 *           To
 *    vi -> 1 v v v v v  (example)
 *
 *     NOTE : Conjugate is taken for complex
 *
 */
void populateViForLQ (TYPE *Vi, TYPE * A, int N, int lda,
                                     int numberOfVielement )
{
   int j =0;
   int i =0;
   int lda2 = lda SHIFT;

   #ifdef TREAL
      Vi[0] = 1.0;
      for (j=1; j < numberOfVielement; j++)
      {
         Vi[j]= *(A+ (( N - numberOfVielement + j)*lda) );
      }
   #else
      Vi[0] = 1.0;
      Vi[1] = 0.0;
      for (j=1; j < numberOfVielement; j++)
      {
          Vi[(j SHIFT) ]= *(A+ (( N - numberOfVielement + j)*lda2) );
          Vi[(j SHIFT) + 1]= 0.0 - *(A+ (( N - numberOfVielement + j)*lda2) + 1 );
      }
   #endif

}
/*
 * Populate Vi vector  from the given ROW of A Matrix.  A has the pointer
 * to the first element  in the row. N represent the size of row.
 * 'numberOfVielement' denotes  (N - number of zero elements in Vi)
 *
 *  UnitPos   : if R,  vi -> v v v v 1 0 0  (example)
 *  UnitPos   : if L,  vi -> 0 1 v v v v v  (example)
 *
 */
void populateVViFromRow (TYPE *Vi, TYPE * A, int lda, int N,
                                     int numberOfVielement, char UnitPos)
{
   #ifdef TREAL
      static const TYPE ONE=ATL_rone;
   #else
      static const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   #endif

   //Copy routine
   int j =0;
   int i =0;
   int lda2 = lda SHIFT;

   #ifdef TREAL
       if (UnitPos == 'L')
       {
          for ( j = 0; j < (numberOfVielement -1 ); j++)
          {
             Vi[j]= *(A+j*lda);


          }
          Vi[numberOfVielement -1 ] = 1.0;
          for (j=numberOfVielement ; j< N;  j++)
          {
              Vi[j] = 0.0 ;
          }
       } else // UnitPosition R
       {
          for (j=0; j< (N-numberOfVielement);  j++)
          {
              Vi[j] = 0.0;
          }
          Vi[N -numberOfVielement] = 1.0;
          for (j=(N-numberOfVielement+1) ; j< N;  j++)
          {
              Vi[j]= *(A+j*lda);
          }
       }
   #else
       if (UnitPos == 'L')
       {
          for ( j = 0; j < ( (numberOfVielement -1)); j++)
          {
             Vi[(j SHIFT) ]= *(A+j*lda2);
             Vi[(j SHIFT) +1 ]= *(A+j*lda2 + 1);

          }
          Vi[ ( (numberOfVielement -1) SHIFT)  ] = 1.0;
          Vi[ ( (numberOfVielement -1) SHIFT) + 1  ] = 0.0;
          for (j=(numberOfVielement SHIFT) ; j< (N SHIFT);  j++)
          {
              Vi[j] = 0.0 ;
          }
       } else // UnitPosition R
       {
          for (j=0; j< ( (N-numberOfVielement) SHIFT );  j++)
          {
              Vi[j] = 0.0;
          }
          Vi[(N -numberOfVielement) SHIFT ] = 1.0;
          Vi[((N -numberOfVielement) SHIFT) + 1 ] = 0.0;
          for (j=(N-numberOfVielement+1) ; j< N;  j++)
          {
              Vi[j SHIFT ]= *(A+j*lda2);
              Vi[(j SHIFT) +1  ]= *(A+j*lda2 + 1);
          }
       }
   #endif

}

/*
 * Populate Vi vector  from the given COLUMN of A Matrix.  A has the pointer
 * to the top of the column. M represent the length  of column.
 * 'numberOfVielement' denotes  (M - number of zero elements in Vi)
 */
void populateViForQR(TYPE *Vi, TYPE * A, int M,  int numberOfVielement)
{
   int j = 0;

   #ifdef TREAL
      Vi[0] = 1.0;
   #else
      Vi[0] = 1.0;
      Vi[1] = 0.0;
   #endif
   for (j=1; j<numberOfVielement;  j++)
   {
      #ifdef TREAL
         Vi[j] = A[j+ M-numberOfVielement];
      #else
         Vi[(j SHIFT)] = A[((j+ M-numberOfVielement) SHIFT) ];
         Vi[(j SHIFT)+1] = A[((j+ M-numberOfVielement) SHIFT) + 1 ];
      #endif
   }

}
//------------------------------------
/*
 * Populate Vi vector  from the given COLUMN of A Matrix.  A has the pointer
 * to the top of the column.
 * 'numberOfVielement' denotes  (M - number of zero elements in Vi)
 *
 *                      v                        v
 *                      v                        v
 *                      v            TO          v
 *                      R                        1
 *                      R
 *                      R
 */
void populateViForQL(TYPE *Vi, TYPE * A,  int numberOfVielement)
{
   int j =0;

  #ifdef TREAL
     for (j=0; j< (numberOfVielement-1);  j++)
     {
         Vi[j] = A[j];
     }
     Vi[numberOfVielement -1 ] = 1.0;
  #else
     for (j=0; j< ( (numberOfVielement-1) SHIFT );  j++)
     {
        Vi[j ] = A[j];

     }
     Vi[(numberOfVielement -1) SHIFT ] = 1.0;
     Vi[ ((numberOfVielement -1) SHIFT ) + 1 ] = 0.0;
  #endif

}
//------------------------------------

// A must have the pointer to the column Top of column
/*
 * Populate Vi vector  from the given COLUMN of A Matrix.  A has the pointer
 * to the top of the column. M represent the length  of column.
 * 'numberOfVielement' denotes  (M - number of zero elements in Vi)
 *
 *  UnitPos   : if T,  vi (example)         UnitPos   : if B
 *                      0                        v
 *                      0                        v
 *                      1                        v
 *                      v                        1
 *                      v                        0
 *                      v                        0
 */
void populateVVi(TYPE *Vi, TYPE * A,  int M, int numberOfVielement, char UnitPos)
{
   #ifdef TREAL
      const TYPE ONE=ATL_rone;
   #else
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   #endif

   //Copy routine
   int j =0;

  #ifdef TREAL
       if (UnitPos == 'T')
       {
          for ( j = 0; j < (M - numberOfVielement); j++)
          {
             Vi[j]=0.0;
          }
          Vi[M - numberOfVielement] = 1;
          for (j=(M-numberOfVielement+1) ; j< M;  j++)
          {
              Vi[j] = A[j];
          }
       } else // UnitPosition B
       {

          for (j=0; j< (numberOfVielement-1);  j++)
          {
              Vi[j] = A[j];
          }
          Vi[numberOfVielement -1 ] = 1.0;
          for (j=(numberOfVielement) ; j< M;  j++)
          {
              Vi[j] = 0.0;
          }
       }
  #else
       if (UnitPos == 'T')
       {
          for ( j = 0; j < ( (M - numberOfVielement) SHIFT  ); j++)
          {
             Vi[j]=0.0;
          }

          Vi[ (M - numberOfVielement) SHIFT ] = 1.0;
          Vi[ ( (M - numberOfVielement) SHIFT)  + 1 ] = 0.0;

          for (j=( (M-numberOfVielement+ 1) SHIFT ) ; j<  (M SHIFT) ;  j++)
          {
              Vi[j] = A[j];
          }
       } else // UnitPosition B
       {

          for (j=0; j< ( (numberOfVielement-1) SHIFT );  j++)
          {
              Vi[j ] = A[j];

          }
          Vi[(numberOfVielement -1) SHIFT ] = 1.0;
          Vi[ ((numberOfVielement -1) SHIFT ) + 1 ] = 0.0;
          for (j=(numberOfVielement SHIFT) ; j< (M SHIFT);  j++)
          {
              Vi[j] = 0.0;
          }
       }
  #endif

}



//Mamke Matrix to UT
/*  Make Matrix A to Upper Triangular or Upper Trapezoidal to make R matrix
 *  as per QR factorization. (Refer lapaack for how the values are stored in A)
 */
void makeToUTForQR(TYPE *A , int lda, int M, int N)
{
    int i, j;
    int lda2 = lda SHIFT;              // 2*lda for complex

    for(i=0; i<M; i++)
    {
      for(j=0; (j<i && j < N) ; j++)
      {
          #ifdef TREAL
                 *(A+j*lda2+i SHIFT) =  0.0;
          #else
                 *(A+j*lda2+(i SHIFT)) =  0.0;
                 *(A+j*lda2+(i SHIFT) + 1) =  0.0;
          #endif
      }
    }
}

/*
 * Make  the lower portion of the matrix to zero w.r.t to the
 * diagonal from bottom left (Note: change to standard naming)
 */
void makeToUTForRQ(TYPE *A , int lda, int M, int N )
{
    int i, j , lda2;
    int k =0;

    lda2 = lda SHIFT;

    int mn = Mmin(M,N) ;

    for(i=(M-1); i >= (M -mn) ; i--)
    {
      k++;

      for(j=(N-1-k ); j>=0  ; j--)
      {
          #ifdef TREAL
                 *(A+j*lda2+i) =  0.0;
          #else
                 *(A+j*lda2+ (i SHIFT) ) =  0.0;
                 *(A+j*lda2+ (i SHIFT) + 1) =  0.0;
          #endif
      }
    }
}


/*
 * Make  the upper portion of the matrix to zero w.r.t to the
 * diagonal from upper right  (Note: change to standard naming)
 */
void makeToLTForLQ(TYPE *A , int lda, int M, int N )
{
    int i, j, lda2 ;
    int k =0;

    lda2 = lda SHIFT;
    int mn = Mmin(M,N) ;


    for(i=0;  i< mn  ; i++)
    {

      for(j= (i+1); j < N ; j++)
      {
          #ifdef TREAL
                 *(A+j*lda2+(i SHIFT) ) =  0.0;
          #else
                 *(A+j*lda2+(i SHIFT)) =  0.0;
                 *(A+j*lda2+(i SHIFT) + 1) =  0.0;
          #endif
      }
    }
}

/*
 * Make  the upper portion of the matrix to zero w.r.t to the
 * diagonal from bottom left (Note: change to standard naming)
 */
void makeToLTForQL(TYPE *A , int lda, int M, int N )
{
    int i, j , lda2;
    int k =0;

    lda2 = lda SHIFT;

    int mn = Mmin(M,N) ;

    for(j=(N-1); j >= (N -mn) ; j--)
    {
      k++;

      for(i=(M-1-k ); i>=0  ; i--)
      {
          #ifdef TREAL
                 *(A+j*lda2+i) =  0.0;
          #else
                 *(A+j*lda2+ (i SHIFT) ) =  0.0;
                 *(A+j*lda2+ (i SHIFT) + 1) =  0.0;
          #endif
      }
    }
}


static TYPE lqtest(int M, int N, int lda, int flushKB, double *time)
{
@skip   printf("LQ test STARTS --------------------------------------------------\n");
   TYPE *A, *TAU, *TAUNEG,  *WORK, *WORKF,  *L, *W ;
   TYPE *Q, *VI;
   TYPE *AORIG;
   int viCounter =0;
   TYPE dtmp, dtmp1;
   double t0;

   int ITER ;

   #ifdef TREAL
      TYPE NEGTAUVAL = ATL_rzero;
   #else
      TYPE NEGTAUVAL[2] = {ATL_rzero, ATL_rzero};
   #endif


   int LWORK;
   TYPE normA, eps, resid;
   int i, j, k, ldn, ldm, ldmn;

//TODO: Remove later
//#ifdef TimeF77
   ldm = M;
   ldn = N;
   const int MNmin = Mmin(M,N);
   const int Maxmn = Mmax(M,N);
   ldmn = MNmin;

   //Epsilon
   eps = Mjoin(PATL,epsilon)();

   //Allocate A and initialize
   A = GetGE(M, N, lda);
   if (A == NULL) AllocationErr("A");


   //Allocate A Original and copy from A
   AORIG = DupMat(CblasColMajor, M, N, A, lda, lda);

   //Call to get the  size of workspace required
   test_gelqf(CblasColMajor, M, N, &dtmp1, lda,
                 &dtmp1,
                 &dtmp, -1);
   //Get Work and LWORK
   LWORK = dtmp;
   WORK = malloc(ATL_MulBySize(LWORK));
   if (WORK == NULL) return(-1);

   //TAU
   TAU = malloc(ATL_MulBySize(MNmin));
   if (TAU == NULL) AllocationErr("TAU");
   if (flushKB > 0)
   {
      t0 = ATL_flushcache(flushKB*1024);
      t0 += ATL_flushcache(-1);
   }
   t0 = time00();
   test_gelqf(CblasColMajor, M, N, (TYPE*)(A), lda,
                 (TYPE*)(TAU),
                 (TYPE*)(WORK), LWORK);
   *time = time00() - t0;
   if (flushKB)
      t0 += ATL_flushcache(0);

   //Allocate and Copy TAU to TAUNEG
   TAUNEG = DupMat(CblasColMajor, MNmin, 1, TAU, ldmn, ldmn);

   makeVectorToNegVal(TAUNEG, MNmin);

   //Allocate Vi, based on Size of N
   VI = malloc(ATL_MulBySize(N));
   if (VI == NULL) AllocationErr("VI");

   //Allocate Q and Q-temp,   lda equals N
   Q = malloc(ATL_MulBySize(ldn)*N);
   if (Q == NULL) AllocationErr("Q");

   W = malloc(ATL_MulBySize(ldn));
   if (W == NULL) AllocationErr("W");

   makeIdenty(Q, N, ldn);              //Q: Size of Q mat  and lda is N

   //Copy A[M, N] to L and then Modify the upper part of DIAG w.r.t top left
   L= DupMat(CblasColMajor, M, N, A, lda, ldm);
   makeToLTForLQ(L , ldm, M, N );

   printMMMatrix("AORIG",AORIG, M, N, lda);
   printMMMatrix("A",A, M, N, lda);
   printMMMatrix("Q MARTIX ", Q, N, N, ldn);
   printMMMatrix("L matrix", L, M, N, ldm);
   printVVector("TAU", TAU, MNmin);
   printVVector("TAUNEG", TAUNEG, MNmin);

   // Temporary Logic
@beginskip
   if ((M > SIZE ) || ( N > SIZE ))
   {
      #ifdef CHANGELATER
      /* Call The lapack/Fortran code ormqr to  find Q matrix. */
      call_f77lq(CblasColMajor, N, N, MNmin , &dtmp1, lda,
                       &dtmp1,
                        &dtmp1, ldn ,
                        &dtmp, -1);

      /* Get Work and LWORK */
      free(WORK);
      LWORK = dtmp;
      WORKF  = malloc(ATL_MulBySize(LWORK));
      if (WORKF == NULL) AllocationErr("WORKF");

      /* Q will have the computed Q matrix from elemetary reflectors */
      call_f77lq(CblasColMajor, N, N, MNmin , (TYPE*)(A), lda,
                        (TYPE*)(TAU),
                        (TYPE*)(Q), ldn ,
                        (TYPE*)(WORKF), LWORK);
     #endif
   printMMMatrix("Q", Q, N, N, ldn);

   }
   else
   {
@endskip
   #ifdef ATL_FULL_LAPACK
      ATL_assert(!LA_LQ2Q(CblasRight, CblasNoTrans, N, N, MNmin, A, lda, TAU,
                          Q, ldn));
   #else
      /* Form Q Matrix
       * Q = H(K).H(K-1)..........H(2).H(1).
       *     where H(i) = I -tau(i).v(i).v(i)^T.
       *
       *     Forming H Matrix from v and propogating the results, has resulted in
       *     taking a lot of CPU. So the following logic for forming Q is
       *     implemented
       *
       *       Q(Current) =   Q(Previous) * H (Current)
       *       Equivalent to,
       *           Q(K-1) =   Q(k) * H(K-1)
       *                     Note : Q matrix will get replaced in  each iterations
       *     In each Q(k) will hold the  previous Q values as below
       *                 1 0
       *                 0 Q
       *
       *       =>   Q(k) * (I - tau(k-1) v(k-1) v(k-1)^T)
       *       =>  Q(k) - tau(k-1)  w v(k-1)^T  where
       *                             w => Q(k) v(k-1)
       *
       *    NOTE : For complex
       * Q = H(k)^T.H(k-1)^T..........H(2)^T.H(1)^T.
       *     Transpose is applied by taking the conjugate transpose of
       *     tau.
       */
      ITER = 1;
      for (i =  MNmin-1; i >= 0 ;  i-- )
      {
          // Make Vi And take its conjugate for Complex numbers . For complex, the conjugate
          // value is stord in the output.
          //  In the firest iteration, gets V(k)

          populateViForLQ(VI, (A +(( MNmin - ITER) SHIFT)), N, lda, (N - MNmin + ITER ) );
          printVVector("VI",VI, M);

          //TAU
          #ifdef TREAL
               NEGTAUVAL=TAUNEG[i];
          #else
               NEGTAUVAL[0] = TAUNEG[( i SHIFT) ];
               // Conjugate Transpose
               NEGTAUVAL[1] = 0.0 - TAUNEG[ (i SHIFT) + 1 ];
          #endif
          // Q will be MxM matrix, intially populated as I matrix.
          // In each iteration Q will hold the  previous Q values as below
          //    Q 0
          //    0 1

          /* Step 1 */
          /* Q(k)*v */
          cblas_gemv(CblasColMajor, CblasNoTrans,
                             (N - MNmin + ITER ) ,    /* row size  */
                             (N - MNmin + ITER ) ,    /* Column  size  */
                              ONE,
                              (Q + ((MNmin -ITER)*(ldn SHIFT))
                                 + ((MNmin - ITER) SHIFT)) , ldn,               /* Q and ldq     */
                              VI, 1,
                              ZEROVAL, W, 1);

         // Perform Q(k) - tau W v^T
         #ifdef TREAL
            cblas_ger(CblasColMajor, (N - MNmin + ITER ), (N - MNmin + ITER ),
                      NEGTAUVAL, W, 1,
                       VI, 1,
                       (Q + ((MNmin -ITER)*(ldn SHIFT))
                          + ((MNmin - ITER) SHIFT)) ,
                        ldn );
          #else
            cblas_gerc(CblasColMajor, (N - MNmin + ITER ), (N - MNmin + ITER ),
                      NEGTAUVAL, W, 1,
                      VI, 1,
                      (Q + ((MNmin -ITER)*(ldn SHIFT))
                          + ((MNmin - ITER) SHIFT)) ,
                        ldn );
         #endif

         printMMMatrix("Q", Q, N, N, ldn);
          ITER++;
      }
   #endif
@skip   }
//--------------------------%%%%

   // Calculate LQ  and Compare with AORIG
   // L*Q -> A
   cblas_gemm(CblasColMajor, CblasNoTrans, CblasNoTrans, M  , N,
                 N , ONE, L, ldm, Q, ldn, ZEROVAL, A , lda);

   printMMMatrix("LQ Matrix ", A, M, N, lda);


   //Get the  Norm of RQ      s A has the result
   normA = Mjoin(PATL,genrm1)(M, N, AORIG, lda);

   // Find residue || A - Q*L ||  /   || A ||
   resid = Mjoin(PATL,gediffnrm1)(M, N, AORIG, lda, A, lda);
   resid /= (normA * eps * Mmin(M,N));


   // free
/*   free(A);
   free(TAU);
   free(TAUNEG);
   free(WORK);
   free(L);
   free(Q);
   free (VI);
   free(AORIG);
*/


//TODO : Remove later
//#endif
   return(resid);
}

static TYPE qltest(int M, int N, int lda, int flushKB, double *time)
{
@skip   printf("QL test STARTS --------------------------------------------------\n");
   TYPE *A, *TAU, *TAUNEG,  *WORK, *L, *W ;
   TYPE *Q, *VI;
   TYPE *AORIG;
   TYPE dtmp, dtmp1;
   double t0;

   int ITER;

   #ifdef TREAL
      TYPE NEGTAUVAL = ATL_rzero;
   #else
      TYPE NEGTAUVAL[2] = {ATL_rzero, ATL_rzero};
   #endif

   int LWORK;
   TYPE normA, eps, resid;
   int i, j, k, ldm, ldmn;
   int lda2 = lda SHIFT;
//TODO: Remove later
//#ifdef TimeF77

   ldm = M;
   const int MNmin = Mmin(M,N);
   ldmn = MNmin;

   //Epsilon
   eps = Mjoin(PATL,epsilon)();

   //Allocate A and initialize
   A = GetGE(M, N, lda);
   if (A == NULL) AllocationErr("A");

   //Allocate A Original and copy from A
   AORIG = DupMat(CblasColMajor, M, N, A, lda, lda);

   //Call to get the  size of workspace required
   test_geqlf(CblasColMajor, M, N, &dtmp1, lda,
                 &dtmp1,
                 &dtmp, -1);

   //Get Work and LWORK                         : WILL BE MODIFIED
   LWORK = dtmp;
   WORK = malloc(ATL_MulBySize(LWORK));
   if (WORK == NULL) return(-1);

   //TAU
   TAU = malloc(ATL_MulBySize(MNmin));
   if (TAU == NULL) AllocationErr("TAU");

   if (flushKB)
   {
      t0 = ATL_flushcache(flushKB*1024);
      t0 += ATL_flushcache(-1);
   }
   t0 = time00();
   test_geqlf(CblasColMajor, M, N, (TYPE*)(A), lda,
                 (TYPE*)(TAU),
                 (TYPE*)(WORK), LWORK);
   *time = time00() - t0;
   if (flushKB)
      t0 += ATL_flushcache(0);

   //Allocate and Copy TAU to TAUNEG
   TAUNEG = DupMat(CblasColMajor, MNmin, 1, TAU, ldmn, ldmn);

   makeVectorToNegVal(TAUNEG, MNmin);

   //Allocate Vi, based on Size of M
   VI = malloc(ATL_MulBySize(M));
   if (VI == NULL) AllocationErr("VI");

   //Allocate Q and Q-temp,   lda equals M
   Q = malloc(ATL_MulBySize(ldm)*M);
   if (Q == NULL) AllocationErr("Q");

   W = malloc(ATL_MulBySize(ldm));
   if (W == NULL) AllocationErr("W");

   makeIdenty(Q, M, ldm);              //Q:     Size of Q mat  and lda is M


   //Make L Matrix  from A  and lda as M
   L = malloc(ATL_MulBySize(ldm)*N);       //Has size [M, N]
   if (L == NULL) return(-1);

   //Copy A[M, N] to L and then Modify the Tringular part
   //above the diagonal w.r.t bottom right diagonal
   L = DupMat(CblasColMajor, M, N, A, lda, ldm);

   makeToLTForQL(L , ldm, M, N );

   printMMMatrix("AORIG",AORIG, M, N, lda);
   printMMMatrix("A",A, M, N, lda);
   printMMMatrix("Q ", Q, M, M, ldm);
   printMMMatrix("L matrix", L, M, N, ldm);
   printVVector("TAU", TAU, MNmin);
   printVVector("TAUNEG", TAUNEG, MNmin);

   // Temporary Logic
@beginskip
   if ((M > SIZE ) || ( N > SIZE ))
   {
      #ifdef CHANGELATER
      /* Call The lapack/Fortran code ormql to  find Q matrix. */
      call_f77ql(CblasColMajor, M, M, MNmin , &dtmp1, lda,
                       &dtmp1,
                        &dtmp1, ldm ,
                        &dtmp, -1);

      /* Get Work and LWORK */
      LWORK = dtmp;
      WORK  = malloc(ATL_MulBySize(LWORK));
      if (WORK == NULL) AllocationErr("WORK");

      /* Q will have the computed Q matrix from elemetary reflectors */
      call_f77ql(CblasColMajor, M, M, MNmin , (TYPE*)(A + ((N - MNmin)*lda2)), lda,
                        (TYPE*)(TAU),
                        (TYPE*)(Q), ldm ,
                        (TYPE*)(WORK), LWORK);
      #endif 
   printMMMatrix("Q", Q, M, M, ldm);

   }
   else
   {
@endskip
   #ifdef ATL_FULL_LAPACK
      ATL_assert(!LA_QL2Q(CblasLeft, CblasNoTrans, M, M, MNmin,
                          A+(N-MNmin)*lda2, lda, TAU, Q, ldm));
   #else
      /* Form Q Matrix
       * Q = H(K).H(K-1)..........H(2).H(1).
       *     where H(i) = I -tau(i).v(i).v(i)^T.
       *
       *     Forming H Matrix from v and propogating the results, has resulted in
       *     taking a lot of CPU. So the following logic for forming Q is
       *     implemented
       *
       *       Q(Current) =  (I - tau v v^T) * Q(Previous)
       *       Equivalent to,
       *           Q(K+1) =   H(K+1) * Q(k)
       *                     Note : Q matrix will get replaced in  each iterations
       *     In each Q(k) will hold the  previous Q values as below
       *                 Q 0
       *                 0 1
       *
       *       =>   (I - tau(k+1) v(k+1) v(k-1)^T) * Q(k)
       *       =>  Q(k) - tau(k+1)  v(k+1) w^T  where
       *                             w => Q(k)^T v(k+1)
       *
       */
      ITER = 1;
      for (i = 0; i <  MNmin; i++)
      {
          // Make Vi
          populateViForQL(VI, (A + ((N - MNmin + ITER -1)*lda2)) , (M - MNmin + ITER)) ;

          printVVector("VI",VI, M);

          //TAU
          #ifdef TREAL
               NEGTAUVAL=TAUNEG[i];
          #else
               NEGTAUVAL[0] = TAUNEG[( i SHIFT) ];
               NEGTAUVAL[1] = TAUNEG[ (i SHIFT) + 1 ];
          #endif
          // Q will be MxM matrix, intially populated as I matrix.
          // In each iteration Q will hold the  previous Q values as below
          //    Q 0
          //    0 1

          /* Step 1 */
          /* Q(k)^T*v */
          cblas_gemv(CblasColMajor, MY_TRANS,
                             (M - MNmin + ITER ) ,    /* row size  */
                             (M - MNmin + ITER ) ,    /* Column  size  */
                              ONE,
                              (Q), ldm,               /* Q and ldq     */
                              VI, 1,
                              ZEROVAL, W, 1);

         // Perform Q(k) - tau W v^T
         #ifdef TREAL
            cblas_ger(CblasColMajor, (M - MNmin + ITER ), (M - MNmin + ITER ),
                      NEGTAUVAL, VI, 1,
                       W, 1,
                      (Q) ,ldm);
          #else
            cblas_gerc(CblasColMajor, (M - MNmin + ITER ), (M - MNmin + ITER ),
                      NEGTAUVAL, VI, 1,
                      W, 1,
                      (Q),ldm);
         #endif

         printMMMatrix("Q", Q, M, M, ldm);
          ITER++;

      }
   #endif
@skip   }


   // Calculate Q*R  and Compare with AORIG
   // Q*L -> A
   cblas_gemm(CblasColMajor, CblasNoTrans, CblasNoTrans, M  , N,
                 M , ONE, Q, ldm, L, ldm, ZEROVAL, A , lda);

   printMMMatrix("QL Matrix ", A, M, N, lda);

   //Get the  Norm of QL      s A has the result
   normA = Mjoin(PATL,genrm1)(M, N, AORIG, lda);

   // Find residue || A - Q*L ||  /   || A ||
   resid = Mjoin(PATL,gediffnrm1)(M, N, AORIG, lda, A, lda);
   resid /= (normA * eps * Mmin(M,N));


   // free
/*   free(A);
   free(TAU);
   free(TAUNEG);
   free(WORK);
   free(L);
   free(Q);
   free (VI);
   free(AORIG);
*/
//Remove later
//#endif

   return(resid);
}


/*
 * Calls gerq ( single, double, single complex and double complex ).
 * From A[MxN] Matrix returned from geqr routines, compute Q and R matrix.
 * Find the residual for ( A_original - RQ  ) operation.
 *
 *   Also, make H(k) = i-tau*vv'
 *   and compute Q = H(1)*H(2)...H(k)  where k = Min(M,N)
 *
 *   VI has size of N
 *
 */
static TYPE rqtest(int M, int N, int lda, int flushKB, double *time)
{
@skip   printf("RQ test STARTS --------------------------------------------------\n");
   TYPE *A, *TAU, *TAUNEG,  *WORK, *WORKF, *R, *W ;
   TYPE *Q, *VI;
   TYPE *AORIG;
   TYPE dtmp, dtmp1;
   double t0;

   int ITER;

   #ifdef TREAL
      TYPE NEGTAUVAL = ATL_rzero;
   #else
      TYPE NEGTAUVAL[2] = {ATL_rzero, ATL_rzero};
   #endif

   int LWORK;
   TYPE normA, eps, resid;
   int i, j, k, ldn, ldm, ldmn;
   int lda2 = lda SHIFT;

   ldm = M;
   ldn = N;
   const int MNmin = Mmin(M,N);
   ldmn = MNmin;

   //Epsilon
   eps = Mjoin(PATL,epsilon)();

   //Allocate A and initialize
   A = GetGE(M, N, lda);
   if (A == NULL) AllocationErr("A");

   //Allocate A Original and copy from A
   AORIG = DupMat(CblasColMajor, M, N, A, lda, lda);

   //Call to get the  size of workspace required
   test_gerqf(CblasColMajor, M, N, &dtmp1, lda,
                      &dtmp1,
                      &dtmp, -1);

   //Get Work and LWORK
   LWORK = dtmp;
   WORK = malloc(ATL_MulBySize(LWORK));
   if (WORK == NULL) return(-1);

   //TAU
   TAU = malloc(ATL_MulBySize(MNmin));
   if (TAU == NULL) AllocationErr("TAU");

   if (flushKB)
   {
      t0 = ATL_flushcache(flushKB*1024);
      t0 += ATL_flushcache(-1);
   }
   t0 = time00();
   test_gerqf(CblasColMajor, M, N, (TYPE*)(A), lda,
                 (TYPE*)(TAU),
                 (TYPE*)(WORK), LWORK);
   *time = time00() - t0;
   if (flushKB)
      t0 += ATL_flushcache(0);

   //Allocate and Copy TAU to TAUNEG
   TAUNEG = DupMat(CblasColMajor, MNmin, 1, TAU, ldmn, ldmn);

   makeVectorToNegVal(TAUNEG, MNmin);
//   makeVectorToConjVal(TAUNEG , MNmin);

   //Allocate Vi, based on Size of N
   VI = malloc(ATL_MulBySize(N));
   if (VI == NULL) AllocationErr("VI");

   //Allocate Q and Q-temp,   lda equals N
   Q = malloc(ATL_MulBySize(ldn)*N);
   if (Q == NULL) AllocationErr("Q");

   W = malloc(ATL_MulBySize(N));
   if (Q == NULL) AllocationErr("W");

   makeIdenty(Q, N, ldn);              //Q: Size of Q mat  and lda is N

   //Copy A[M, N] to R and then Modify the Lower part of DIAG
   R = DupMat(CblasColMajor, M, N, A, lda, ldm);
   makeToUTForRQ(R , ldm, M, N );

   //Printing Values
   printMMMatrix("AORIG",AORIG, M, N, lda);
   printMMMatrix("A",A, M, N, lda);
   printMMMatrix("Q MARTIX ", Q, N, N, ldn);
   printMMMatrix("R matrix", R, M, N, ldm);
   printVVector("TAU", TAU, MNmin);
   printVVector("TAUNEG", TAUNEG, MNmin);

@beginskip
   // Temporary Logic
   if ((M > SIZE ) || ( N > SIZE ))
   {
      #ifdef CHANGELATER
      /* Call The lapack/Fortran code ormrq to  find Q matrix. */
      call_f77rq(CblasColMajor, N, N, MNmin , &dtmp1, lda,
                       &dtmp1,
                        &dtmp1, ldn ,
                        &dtmp, -1);

      free(WORK);
      /* Get Work and LWORK */
      LWORK = dtmp;
      WORKF  = malloc(ATL_MulBySize(LWORK));
      if (WORKF == NULL) AllocationErr("WORK");

      /* Q will have the computed Q matrix from elemetary reflectors */
      call_f77rq(CblasColMajor, N, N, MNmin , (TYPE*)(A + ((M -MNmin) SHIFT)), lda,
                        (TYPE*)(TAU),
                        (TYPE*)(Q), ldn ,
                        (TYPE*)(WORKF), LWORK);
      #endif
   printMMMatrix("Q", Q, N, N, ldn);

   }
   else
   {
@endskip
   #ifdef ATL_FULL_LAPACK
      ATL_assert(!LA_RQ2Q(CblasRight, CblasNoTrans, N, N, MNmin,
                          A+((M-MNmin)SHIFT), lda, TAU, Q, ldn));
   #else
      /* Form Q Matrix
       * Q = H(1).H(2)..........H(k-1).H(k).
       *     where H(i) = I -tau(i).v(i).v(i)^T.
       *
       *     Forming H Matrix from v and propogating the results, has resulted in
       *     taking a lot of CPU. So the following logic for forming Q is
       *     implemented
       *
       *       Q(Current) = (Q(previous)* I - tau v v^T)
       *       Equivalent to,
       *           Q(K+1) =   Q(k) * H(K+1)
       *                     Note : Q matrix will get replaced in  each iterations
       *     In each Q(k) will hold the  previous Q values as below
       *                 Q 0
       *                 0 1
       *
       *       =>  Q(k) * (I - tau(k+1) v(k+1) v(k-1)^T)
       *       =>  Q(k) - tau(k+1)  w   v(k+1)^T  where
       *                             w => Q(k) v(k+1)
       *
       *
       *    NOTE : For complex
       * Q = H(1)^T.H(2)^T..........H(k-1)^T.H(k)^T.
       *     Transpose is applied by taking the conjugate transpose of
       *     tau.
       */

      ITER = 1;

      for (i = 0  ; i < MNmin ; i++)
      {
          // Make Vi And take its conjugate for Complex numbers . For complex, the conjugate
          // value is stord in the output.
          populateVViForRQ(VI, (A + ((M - MNmin + ITER -1) SHIFT) ) ,lda, (N - MNmin + ITER )) ;
          printVVector("VI______________ ",VI, N);

          //TAU
          #ifdef TREAL
               NEGTAUVAL=TAUNEG[i];
          #else
               NEGTAUVAL[0] = TAUNEG[(i SHIFT) ];
               // Conjugate Transpose
               NEGTAUVAL[1] = 0.0 - TAUNEG[(i SHIFT) + 1 ];

          #endif

          // Q will be MxM matrix, intially populated as I matrix.
          // In each iteration Q will hold the  previous Q values as below
          //    Q 0
          //    0 1

          /* Step 1 */
          /* Q(k)*v */
          cblas_gemv(CblasColMajor, CblasNoTrans,
                             (N - MNmin + ITER ) ,    /* row size  */
                             (N - MNmin + ITER ) ,    /* Column  size  */
                              ONE,
                              (Q), ldn,               /* Q and ldq     */
                              VI, 1,
                              ZEROVAL, W, 1);

         // Perform Q(k) - tau W v^T
         #ifdef TREAL
            cblas_ger(CblasColMajor, (N - MNmin + ITER ), (N - MNmin + ITER ),
                      NEGTAUVAL, W, 1,
                       VI, 1,
                      (Q) ,ldn);
          #else
            cblas_gerc(CblasColMajor, (N - MNmin + ITER ), (N - MNmin + ITER ),
                      NEGTAUVAL, W, 1,
                      VI, 1,
                      (Q),ldn);
         #endif

         printMMMatrix("Q ", Q, N, N, ldn);
          ITER++;
      }
   #endif
@skip   }


   // Calculate Q*R  and Compare with AORIG
   // R*Q -> A
   cblas_gemm(CblasColMajor, CblasNoTrans, CblasNoTrans, M  , N,
                 N , ONE, R, ldm, Q, ldn, ZEROVAL, A , lda);

   printMMMatrix("RQ Matrix ", A, M, N, lda);

   //Get the  Norm of RQ      s A has the result
   normA = Mjoin(PATL,genrm1)(M, N, AORIG, lda);

   // Find residue || A - R*Q ||  /   || A ||
   resid = Mjoin(PATL,gediffnrm1)(M, N, AORIG, lda, A, lda);
   resid /= (normA * eps * Mmin(M,N));

/*
   free(A);
   free(TAU);
   free(TAUNEG);
   free(WORK);
   free(R);
   free(Q);
   free (VI);
   free(AORIG);
*/
   return(resid);
}


/*
 * Calls geqr ( single, double, single complex and double complex ).
 * From A[MxN] Matrix returned from geqr routines, compute Q and R matrix.
 * Find the residual for ( A_original - QR  ) operation.
 *
 *   Also, make H(k) = i-tau*vv'
 *   and compute Q = H(1)*H(2)...H(k)  where k = Min(M,N)
 *
 */
TYPE qrtest(int M, int N, int lda, int flushKB, double *time)
{
   TYPE *A, *TAU, *TAUNEG,  *WORK, *WORKF,  *R , *W ;
   TYPE *Q, *VI;
   TYPE *AORIG ;
   TYPE  dtmp, dtmp1;
   double t0;

   int ITER;

   #ifdef TREAL
      TYPE NEGTAUVAL = ATL_rzero;
      TYPE AII ;
   #else
      TYPE NEGTAUVAL[2] = {ATL_rzero, ATL_rzero};
      TYPE AII[2] ;
   #endif


   int LWORK;
   TYPE normA, eps, resid;
   int i, j, k, ldm, ldmn ;
   int lda2 = lda SHIFT;

   ldm = M;
   const int MNmin = Mmin(M,N);
   ldmn = MNmin;

   //Epsilon
   eps = Mjoin(PATL,epsilon)();

   //Allocate A and initialize
   A = GetGE(M, N, lda);
   if (A == NULL) AllocationErr("A");


   printMMMatrix("AORIG from A ", A, M, N, lda);


   //Allocate A Original and copy from A
   AORIG = DupMat(CblasColMajor, M, N, A, lda, lda);

   //Call to get the  size of workspace required
   test_geqrf(CblasColMajor, M, N, &dtmp1, lda,
                 &dtmp1,
                 &dtmp, -1);

   LWORK = dtmp;

   //Get Work and LWORK
   WORK = malloc(ATL_MulBySize(LWORK));
   if (WORK == NULL) return(-1);

   //TAU
   TAU = malloc(ATL_MulBySize(MNmin));
   if (TAU == NULL) AllocationErr("TAU");

   if (flushKB)
   {
      t0 = ATL_flushcache(flushKB*1024);
      t0 += ATL_flushcache(-1);
   }
   t0 = time00();
   test_geqrf(CblasColMajor, M, N, (TYPE*)(A), lda,
                 (TYPE*)(TAU),
                 (TYPE*)(WORK), LWORK);
   *time = time00() - t0;
   if (flushKB)
      t0 += ATL_flushcache(0);


//TODO : DELETE this condition later
if (  TESTONLYCALL_1 )
{

   //Allocate and Copy TAU to TAUNEG
   TAUNEG = DupMat(CblasColMajor, MNmin, 1, TAU, ldmn, ldmn);

   makeVectorToNegVal(TAUNEG, MNmin);

   //Allocate Q and Q-Temp,   lda equals M(ldm)
   Q = malloc(ATL_MulBySize(ldm)*M);
   if (Q == NULL) AllocationErr("Q");

   W = malloc(ATL_MulBySize(M));
   if (W == NULL) AllocationErr("W");

   makeIdenty(Q, M, ldm);              //Q:     Size of Q mat  and lda is M


   // Copy A[M, N of lda] to R[M, N od ldm] and then make the elements
   // below diagonals as zero
   R = DupMat(CblasColMajor, M, N, A, lda, ldm);
   makeToUTForQR(R , ldm, M,N);

   //Printing Values
   printMMMatrix("AORIG", AORIG, M, N, lda);
   printMMMatrix("A", A, M, N, lda);
   printMMMatrix("Q", Q, M, M, ldm);
   printMMMatrix("R", R, M, N, ldm);
   printVVector("TAU", TAU, MNmin);
   printVVector("TAUNEG", TAUNEG, MNmin);

   #ifdef ATL_FULL_LAPACK
      ATL_assert(!LA_QR2Q(CblasLeft, CblasNoTrans, M, M, MNmin, A, lda, TAU, 
                          Q, ldm));
@beginskip
   if ((M > SIZE ) || ( N > SIZE ))
   {
      #ifdef  CHANGELATER
   printMMMatrix("Q before  Fortran", Q, M, M, ldm);
      /* Call The lapack/Fortran code ormqr to  find Q matrix. */
      call_f77qr(CblasColMajor, M, M, MNmin , &dtmp1, lda,
                       &dtmp1,
                        &dtmp1, ldm ,
                        &dtmp, -1);

      /* Get Work and LWORK */
      LWORK = dtmp;
//      free(WORK);  //Already allocated is freed
      WORK  = malloc(ATL_MulBySize(LWORK));
//      WORK  = malloc(ATL_MulBySize(LWORK*10));
      if (WORK == NULL) AllocationErr("WORK");

      /* Q will have the computed Q matrix from elemetary reflectors */
      call_f77qr(CblasColMajor, M, M, MNmin , (TYPE*)(A), lda,
                        (TYPE*)(TAU),
                        (TYPE*)(Q), ldm ,
                        (TYPE*)(WORK), LWORK);
       #endif  
       printMMMatrix("Q from Fortran", Q, M, M, ldm);
   }
   else
   {
@endskip
   #else
      /* Form Q Matrix
       * Q = H(1).H(2)..........H(k-1).H(k).
       *     where H(i) = I -tau(i).v(i).v(i)^T.
       *
       *     Forming H Matrix from v and propogating the results, has resulted in
       *     taking a lot of CPU. So the following logic for forming Q is
       *     implemented
       *
       *       Q(Current) = (I - tau v v^T)*Q(previous)
       *       Equivalent to,
       *           Q(K-1) =  ( H(k-1))* Q(k)
       *                     Note : Q matrix will get replaced in  each iterations
       *       =>  (I - tau(k-1) v(k-1) v(k-1)^T) Q(k)
       *       =>  Q(k) - tau(k-1) w v(k+1)^T where
       *                             w => Q(k)^T v(k-1)
       */

      // Make diagonal element of A, which  holds VI to 1.0
      for (i = 0; i < MNmin; i++)
      {
          #ifdef TREAL
           *(A  + i*lda + i ) = 1.0;
          #else
           *(A  + (i * ( lda SHIFT)) + ( i SHIFT))   = 1.0;
           *(A  + (i * ( lda SHIFT)) + ( i SHIFT ) + 1) = 0.0;
          #endif
      }


      ITER = 1;
      for (i =( MNmin - 1); i >= 0; i--)

      {
          // Point Vi to  A(diagonal element )
          VI = (A + (i*(lda SHIFT)) + ( i SHIFT));

   //       populateViForQR(VI, (A+i*lda2), M, (M-i));

   //      printVVector("VI", VI, (M-i));

          // -TAU
          #ifdef TREAL
               NEGTAUVAL=TAUNEG[i];
          #else
               NEGTAUVAL[0] = TAUNEG[(i SHIFT) ];
               NEGTAUVAL[1] = TAUNEG[ (i SHIFT) + 1 ];
          #endif

          // Q will be MxM matrix, intially populated as I matrix.
          // In each Q will hold the  previous Q values as below
          //   1 0
          //   0 Q

          // Step 1.
          // Q(k)^T*v
          cblas_gemv(CblasColMajor, MY_TRANS,
                             (M - MNmin + ITER ) ,    /* row size  */
                             (M - MNmin + ITER ) ,    /* Column  size  */
                              ONE,
                              (Q + ((MNmin - ITER)*(ldm SHIFT))
                                 +( (MNmin - ITER) SHIFT )), ldm,
                              VI, 1,
                              ZEROVAL, W, 1);

         // Perform Q(k) - tau v W^T
         #ifdef TREAL
            cblas_ger(CblasColMajor, (M - MNmin + ITER ), (M - MNmin + ITER ),
                      NEGTAUVAL, VI, 1,
                       W, 1,
                      (Q + ((MNmin - ITER)*(ldm SHIFT))
                                 +( (MNmin - ITER) SHIFT ))
                      ,ldm);
         #else
            cblas_gerc(CblasColMajor, (M - MNmin + ITER ), (M - MNmin + ITER ),
                      NEGTAUVAL, VI, 1,
                      W, 1,
                      (Q + ((MNmin - ITER)*(ldm SHIFT))
                                 +( (MNmin - ITER) SHIFT ))
                      ,ldm);
         #endif


         printMMMatrix("Q", Q, M, M, ldm);


          ITER++;

      }
   #endif
@skip   } // if ON forming  Q matrix

   // Calculate Q*R  and Compare with AORIG
   // Q*R -> A       Reuse A space
   cblas_gemm(CblasColMajor, CblasNoTrans, CblasNoTrans, M  , N,
                 M , ONE, Q, ldm, R, ldm, ZEROVAL, A , lda);

   printMMMatrix("QR  A matrix", A, M, N, lda);

   //Get the  Norm of QR      as A has the result
   normA = Mjoin(PATL,genrm1)(M, N, AORIG, lda);


   // Find residue || A - Q*R ||  /   || A ||
   resid = Mjoin(PATL,gediffnrm1)(M, N, AORIG, lda, A, lda);
   resid /= (normA * eps * Mmin(M,N));

//TODO : remove this later TESTONLYCONDITION
} // end of test only


   //free
//   free(A);
//   free(TAU);
//   free(TAUNEG);
//  free(WORK);
//   free(R);
//   free(Q);
//   free(W);
//   free(AORIG);

   return(resid);
}

char *RoutInt2Str2(int rout)
/*
 * returns 2-char abbreviation for LAPACK householder routine rout
 */
{
   char *sp = "QR";
   if (rout == LAgeqlf)
      sp = "QL";
   else if (rout == LAgerqf)
      sp = "RQ";
   else if (rout == LAgelqf)
      sp = "LQ";
   return(sp);
}

int GetMyReps(int N, int *nreps)
/*
 * Finds the correct nreps for this N
 */
{
   int n, i;

   n = *nreps++;
   for (i=n+n-2; i>=0; i -= 2)
   {
      if (N >= nreps[i])
         return(nreps[i+1]);
   }
   return(nreps[1]);
}

int RunCase(TYPE thresh, int flushKB, int rout, int M, int N, int lda)
/*
 * RETURNS: 0 if residual is <= thresh, otherwise 1
 */
{
   TYPE resid;
   TYPE (*qtest)(int, int, int, int, double*);
   double time;
   double Time2Flops(int rout, int UPLO, int M, int N, double time);

@skip   printf("%2s  %3s %6d %6d %6d  %10.4e %11.2f  %9.2e\n",
@skip          RoutInt2Str2(rout), "Col", M, N, lda, 0.0, 0.0, -1.0);
   switch(rout)
   {
   case LAgeqrf:
      qtest = qrtest;
      break;
   case LAgeqlf:
      qtest = qltest;
      break;
   case LAgerqf:
      qtest = rqtest;
      break;
   case LAgelqf:
      qtest = qltest;
      break;
   }
   resid = qtest(M, N, lda, flushKB, &time);
   printf("%2s  %3s %6d %6d %6d  %10.4e %11.2f  %9.2e\n",
          RoutInt2Str2(rout), "Col", M, N, lda, time, 
          Time2Flops(rout, 0, M, N, time), resid);
   return(resid <= thresh ? 1 : 0);
}

int RunCases(TYPE thresh, int flushKB, int ldagap, int *NREPS, int *routs, 
              int *Ms, int *Ns)
/*
 * RETURNS: number of failed cases 
 */
{
   int r, o, m, n, M, lda, npass=0, ntest=0, nreps, k;
   printf("Rt  Maj      M      N    lda        TIME       MFLOP   RESIDUAL\n");
   printf("==  ===  =====  =====  =====  ==========  ==========  =========\n");

   for (r=1; r <= routs[0]; r++)  /* loop over routines */
   {
      for (o=0; o < 1; o++)  /* useless order loop, add later */
      {
         for (n=1; n <= Ns[0]; n++)
         {
            for (m=1; m <= Ms[0]; m++)
            {
               M = (Ms[m]) ? Ms[m]:Ns[n];
               nreps = GetMyReps(Mmin(M, Ns[n]), NREPS);
               for (k=0; k < nreps; k++)
               {
                  npass += RunCase(thresh, flushKB, routs[r], M, Ns[n], 
                                   M+ldagap);
                  ntest++;
               }
            }
         }
      }
   }
   printf("\n%d cases ran, %d cases passed\n\n", ntest, npass);
   return(ntest-npass);
}

#define CAN_NB 0
@extract -b @(topd)/Clint/atlas-tlp.base rout=qrtstGF

int main(int nargs, char **args)
{
   int *Ns, *Ms, *ROUTs, *nreps; 
   int flushKB, ldagap;
   TYPE thresh;

   GetFlags(nargs, args, &flushKB, &thresh, &nreps, &ROUTs, &ldagap, &Ms, &Ns);
   return(RunCases(thresh, flushKB, ldagap, nreps, ROUTs, Ms, Ns));
}
