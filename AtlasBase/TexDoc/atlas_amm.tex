\documentclass[11pt]{article}

%\usepackage{psfig}
\usepackage{epsfig}

\newcommand{\Wskip}[1]{ }
\newcommand{\Wceil}[1]{\lceil #1 \rceil}
\newcommand{\Wfloor}[1]{\lfloor #1 \rfloor}

\newenvironment{routdef}[1]
{
   \begin{list}{BLANK}
   {
      \setlength{\parsep}{0in}
      \setlength{\itemsep}{.01in}
      \setlength{\partopsep}{0in}
      \setlength{\topsep}{0.1in}
      \setlength{\labelsep}{0in}
      \setlength{\labelwidth}{#1in}
      \setlength{\leftmargin}{#1in}
   }
} {\end{list}}
\newcommand{\rditem}[2]{\item[#1\hfill(~]#2 )}



\textwidth=6in
\textheight=8.7in
\hoffset = -.6in
\voffset = -.6in

\begin{document}

\begin{titlepage}
\title{A Collaborative guide to ATLAS Development}
\vspace{.4in}
\author
{
 R. Clint Whaley \thanks { {\tt rwhaley@users.sourceforge.net} }
}
\end{titlepage}
\maketitle
\begin{abstract}
ATLAS originally copied input GEMM matrices into block-major subblocks,
and tuned a block-major kernel for performance.  Due to vectorization
and extreme-scale computing, ATLAS has been redesigned to copy to 
access-major storage, with a new access-major kernel API. 
This paper overviews ATLAS access-major matmul framework.
\end{abstract}

\newpage
\tableofcontents
%\listoftables
%\listoffigures

\newpage
\section{Introduction}
\section{Access-major kernel and related terminology}
All access-major kernels share a common interface, and perform
$C \leftarrow A \times B + \beta C$, where $\beta = 0, 1, -1$.
\section{Access-major storage}
\subsection{Storage for $C$}
\subsection{$M$-vectorized storage}
\subsubsection{Storage of $A$}
\subsubsection{Storage of $B$}
\subsection{$K$-vectorized storage}
\subsubsection{Storage of $A$}
\subsubsection{Storage of $B$}
\section{Telling ATLAS to produce a user-specific AMM Kernel library}

\end{document}
