@ROUT !
   @define pre @@(@pre)@
   @PRE S C
      @define typ @float@
      @define sz @4@
   @PRE D Z
      @define sz @8@
      @define typ @double@
   @PRE !
#define ATL_VLEN @(vl)
#if !defined(SREAL) && !defined(DREAL) && !defined(SCPLX) && !defined(DCPLX)
   @PRE C `   #define SCPLX 1`
   @PRE S `   #define SREAL 1`
   @PRE D `   #define DREAL 1`
   @PRE Z `   #define DCPLX 1`
#endif
@ifdef ! TRI
   @iexp TRI 0
@endifdef
@SKIP TRI = 1 means lower triangular C (SYRK)
@iif TRI = 1
@BEGINSKIP ====================================================================
********** SYRK COPY: from now on, we are using unrestricted syrk copies
********** If you want to enable restricted copy for testing or timing purpose
********** init SYRKU with 0
@ENDSKIP   ====================================================================
@ifdef ! SYRKU
   @SKIP @define SYRKU @1@  
   @define SYRKU @0@  
@endifdef
   @iif SYRKU = 0
      @define ma @1@
      @define na @1@
      @iif mu ! nu
         @iif mu > nu
            @iexp ma @(nu) @(mu) / 
            @iexp mma @(ma) @(nu) *
            @iif mu ! mma
            @SKIP @abort "mu (@(mu)) must be multiple of nu (@(nu))" 
            @endiif
            @skip @print ************ma = @(ma)
         @endiif
         @iif nu > mu
            @iexp na @(mu) @(nu) / 
            @iexp nna @(na) @(mu) *
            @iif nu ! nna
            @abort "nu (@(nu)) must be multiple of mu (@(mu))"  
            @endiif
            @skip @print ************na = @(na)
         @endiif
         @define mEn @0@
      @endiif
      @iif mu = nu
         @define mEn @1@
      @endiif
   @endiif
@endiif
@SKIP ****************** bitvector for parameterized unrolling *****************
@BEGINSKIP
   Now we created two flags: one for main loop and other for cleanup loop
   bvML : bitvector, default 3, with following meanings:
      0 : no unroll in any dimension
      1 : unroll MU dimension
      2 : unroll NU dimension
      3 : unroll both dimension
   bvCU : bitvector, default 0, with following meanings: 
      0 : no unroll in any dimension
      1 : unroll MU dimension
      2 : unroll NU dimension
      3 : unroll both dimension
@ENDSKIP
@SKIP **** made fully unrolled mainloop (bvML=3) as the default case
@ifdef ! bvML
   @iexp bvML 3  
@endifdef
@SKIP **** made fully unrolled cleanup loop (bvCU=3) as the  default case 
@ifdef ! bvCU
   @iexp bvCU 3 
@endifdef
@BEGINSKIP
   to make code more readable, I create two flag to represent to each bits
   ML_NUR, ML_MUR
   CU_NUR, CU_MUR
   NOTE: if ML is rolled CU is ignored 
@ENDSKIP
@iexp ML_MUR @(bvML) 1 &
@iexp ML_NUR @(bvML) 2 &
@iexp ML_MUNU @(bvML) 3 =
@iexp ML_NO @(bvML) 0 = 
@SKIP @print ML_MUR=@(ML_MUR) ML_NUR=@(ML_NUR) ML_MUNU=@(ML_MUNU) 
@iexp CU_MUR @(bvCU) 1 &
@iexp CU_NUR @(bvCU) 2 &
@iexp CU_MUNU @(bvCU) 3 =
@iexp CU_NO @(bvCU) 0 = 
@SKIP @print CU_MUR = @(CU_MUR) CU_NUR = @(CU_NUR)
@SKIP **************************************************************************
@ROUT blk2C C2blk
#include <stddef.h>
@ifdef ! cpvl
   @iexp cpvl 1
@endifdef
@iif vl = 0
   @iexp vl 1
@endiif
@iif cpvl > 1
#define ATL_VLEN @(vl)
#include "atlas_simd.h"
@endiif
#if defined(__STDC_VERSION__) && (__STDC_VERSION__/100 >= 1999)
   #define INLINE inline
#endif
@SKIP LEGAL: alpha=[1,-1,X], beta=[0,1,-1,X]
@SKIP if (alpha==1) && (beta==0 || beta==1)) -> char same as #
@ifdef ! rtnm
   @define rtnm @ATL_USERCPMM@
@endifdef
@SKIP ***********************copy routines for real type********************** 
@PRE S D
@SKIP blksz = ((mu*nu+vlen-1)/vlen)*vlen
@iexp bs @(vl) @(mu) @(nu) * @(vl) + -1 + / @(vl) *
/* HERE vl=@(vl), mu=@(mu), nu=@(nu) bs=@(bs) */
@SKIP this proc handles only one element
@SKIP IN : alpha, beta 
@BEGINPROC doElement r c C_ k p_
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C `                  @(C_)@(c)[@(r)] = @(p_)[@(k)];`
@ROUT C2blk `                  @(p_)[@(k)] = @(C_)@(c)[@(r)];`
            @endiif
            @iif beta = 1
@ROUT blk2C `                  @(C_)@(c)[@(r)] += @(p_)[@(k)];`
@ROUT C2blk `                  @(p_)[@(k)] += @(C_)@(c)[@(r)];`
            @endiif
            @iif beta = -1
@ROUT blk2C `                  @(C_)@(c)[@(r)] = @(p_)[@(k)] - @(C_)@(c)[@(r)];`
@ROUT C2blk `                  @(p_)[@(k)] = @(C_)@(c)[@(r)] - @(p_)[@(k)];`
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `                  @(C_)@(c)[@(r)] = beta*@(C_)@(c)[@(r)] + @(p_)[@(k)];`
@ROUT C2blk `                  @(p_)[@(k)] = beta*@(p_)[@(k)] + @(C_)@(c)[@(r)];`
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C `                  @(C_)@(c)[@(r)] = -@(p_)[@(k)];`
@ROUT C2blk `                  @(p_)[@(k)] = -@(C_)@(c)[@(r)];`
            @endiif
            @iif beta = 1
@ROUT blk2C `                  @(C_)@(c)[@(r)] -= @(p_)[@(k)];`
@ROUT C2blk `                  @(p_)[@(k)] -= @(C_)@(c)[@(r)];`
            @endiif
            @iif beta = -1
@ROUT blk2C `                  @(C_)@(c)[@(r)] = -@(C_)@(c)[@(r)] - @(p_)[@(k)];`
@ROUT C2blk `                  @(p_)[@(k)] = -@(C_)@(c)[@(r)] - @(p_)[@(k)];`
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `                  @(C_)@(c)[@(r)] = beta*@(C_)@(c)[@(r)] - @(p_)[@(k)];`
@ROUT C2blk `                  @(p_)[@(k)] = beta*@(p_)[@(k)] - @(C_)@(c)[@(r)];`
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C `                  @(C_)@(c)[@(r)] = alpha*@(p_)[@(k)];`
@ROUT C2blk `                  @(p_)[@(k)] = alpha*@(C_)@(c)[@(r)];`
            @endiif
            @iif beta = 1
@ROUT blk2C `                  @(C_)@(c)[@(r)] += alpha*@(p_)[@(k)];`
@ROUT C2blk `                  @(p_)[@(k)] += alpha*@(C_)@(c)[@(r)];`
            @endiif
            @iif beta = -1
@ROUT blk2C `                  @(C_)@(c)[@(r)] = alpha*@(p_)[@(k)] - @(C_)@(c)[@(r)];`
@ROUT C2blk `                  @(p_)[@(k)] = alpha*@(C_)@(c)[@(r)] - @(p_)[@(k)];`
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `                  @(C_)@(c)[@(r)] = beta*@(C_)@(c)[@(r)] + alpha*@(p_)[@(k)];`
@ROUT C2blk `                  @(p_)[@(k)] = beta*@(p_)[@(k)] + alpha*@(C_)@(c)[@(r)];`
            @endiif
         @endiif
@ENDPROC
@SKIP handles square blocks 
@BEGINPROC doBlock m_ n_ p_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(j) @(mu) * @(i) +
         @callproc doElement @(i) @(j) C @(k) @(p_) 
         @iexp i @(i) 1 +
      @endiwhile
      @iif m_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles rolled blocks only   
@BEGINPROC doBlockRolled C_ mu_ nu_ cinc_  
         { /* rolled block copy */
            unsigned int ii, jj; 
@ROUT blk2C `            @(typ) *rC0 = @(C_);`
@ROUT C2blk `            const @(typ) *rC0 = @(C_);`
@ROUT blk2C `            const @(typ) *pr = p;`
@ROUT C2blk `            @(typ) *pr = p;`
            for (jj=0; jj < @(nu_); jj++, rC0 += ldc, pr += @(mu))
            {
               for (ii=0; ii < @(mu_); ii++)
               {
                  @callproc doElement ii 0 rC ii pr 
               }
            }
      @iif cinc_ ! 0
            @(C_) += @(mu);
      @endiif
         }
@ENDPROC
@SKIP handles block Mu unrolled 
@BEGINPROC doBlockMuUR m_ cinc_  
   @define i @dum@
         C0 = C; p0 = p;  
         for (jj=0; jj < nu; jj++, C0 += ldc, p0 += @(mu))
         {
      @iexp i 0
      @iwhile i < @(m_)
         @callproc doElement @(i) 0 C @(i) p0 
         @iexp i @(i) 1 +
      @endiwhile
         }
      @iif cinc_ ! 0
         C += @(mu);
      @endiif
   @undef i
@ENDPROC
@SKIP handles block Nu unrolled, m_=0 means NU cleanup rolled 
@BEGINPROC doBlockNuUR nu_
   @define j @dum@
         for (ii=0; ii < mu; ii++)
         {
            @iexp j 0
            @iwhile j < @(nu_)
               @callproc doElement ii @(j) C @(mu)*@(j)+ii p
               @iexp j @(j) 1 +
            @endiwhile
         }
   @undef j
@ENDPROC
@iif TRI = 0
@SKIP ********************** GEMM copy: real type ******************************
/*
 * Main Loop:
 @iif bvML = 0
 * Both Rolled
 @endiif
 @iif ML_MUR ! 0
 * Mu unrolled
 @endiif
 @iif ML_NUR ! 0
 * Nu unrolled
 @endiif
 */
@iif cpvl = 1
void @(rtnm)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   @ROUT blk2C
   const @(typ) alpha,  /* scalar for b */
   const @(typ) *b,     /* matrix stored in @(mu)x@(nu)-major order */
   const @(typ) beta,   /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) alpha,  /* scalar for C */
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) beta,   /* scalar for b */
   @(typ) *b            /* matrix stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
@endiif
@iif cpvl > 1
static INLINE void a2c_1(const size_t M, const size_t N, const @(typ) alpha, 
                         const @(typ) *b, const SCALAR beta, 
                         @(typ) *C, ATL_CSZT ldc)
@endiif
{
   unsigned int i, j;
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   const unsigned int pansz = (nr) ? (nf+1)*@(bs) : nf*@(bs); /* bs=@(bs) */
   @SKIP *** NU_UR NO_UR cases: MU_UR = 0 
   @iif ML_MUR = 0
   const size_t incC = ldc*@(nu) - ((M+@(mu)-1)/@(mu))*@(mu);
   unsigned int ii, mu;
   @endiif
   @iif ML_MUR ! 0
   const size_t incC = ldc*@(nu) - m;
   @endiif
   @SKIP *** MU_UR and MN_UR cases  
   @iif ML_NUR = 0
   unsigned int jj, nu;
   @endiif
   @iif ML_NUR = 0
@ROUT C2BLK `   const @(typ) *C0 ; `          
@ROUT BLK2C `   @(typ) *C0; `          
   @endiif
   @iif ML_NUR ! 0
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   @endiif 
   @SKIP *** end of declaration, handle main loop now  
   @SKIP *** NU_UR and MN_UR cases 
   @iif ML_NUR ! 0
   for (j=nf; j; j--, b += @(bs))
   {
   @endiif
   @SKIP *** MU_UR and NO_UR cases 
   @iif ML_NUR = 0
   for (j=0; j < N; j += nu, b += @(bs))
   {
      @ROUT blk2C `      const @(typ) *p0;`
      @ROUT C2blk `      @(typ) *p0;`
   @endiif
   @SKIP *** common on all cases 
      @ROUT blk2C `      const @(typ) *p = b;`
      @ROUT C2blk `      @(typ) *p = b;`
   @SKIP *** MU_UR and NO_UR cases 
   @iif ML_NUR = 0
      nu = ((N-j) >= @(nu)) ? @(nu) : (N-j);
   @endiif
   @SKIP *** MU_UR and MN_UR cases 
   @iif ML_MUR ! 0
      for (i=mf; i; i--, p += pansz)
      {
      @iif ML_MUNU ! 0
         @callproc doBlock @(mu) @(nu) p
      @endiif
      @iif ML_MUNU = 0
         @callproc doBlockMuUR @(mu) 1 
      @endiif
      }
   @endiif 
   @iif ML_MUR = 0
      for (i=0; i < M; i += mu, p += pansz)
      {
         mu = ((M-i) >= @(mu)) ? @(mu) : (M-i);
         @iif ML_NO = 0
         @callproc doBlockNuUR @(nu)
      @iexp j 0
      @iwhile j < @(nu)
         C@(j) += @(mu);
         @iexp j @(j) 1 +
      @endiwhile
         @endiif 
         @iif ML_NO ! 0 
         @callproc doBlockRolled C mu nu 1 
         @endiif
      }
   @endiif
@SKIP --- M cleanup: MU_UR and MUNU_UR   
   @iif ML_MUR ! 0
      @iif CU_MUR = 0
      { /* clean up in M dimension */
         @iif ML_MUNU ! 0
         @callproc doBlockRolled C0 mr @(nu) 0  
         @endiif
         @iif ML_MUNU = 0
         @callproc doBlockRolled C mr nu 0  
         @endiif
      }
      @endiif
      @iif CU_MUR ! 0
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
         @iif ML_MUNU ! 0
      @callproc doBlock @(m) @(nu) p
         @endiif
         @iif ML_MUNU = 0
      @callproc doBlockMuUR @(m) 0 
         @endiif
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
      @endiif
   @endiif
   @iif ML_NUR ! 0
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
   @endiif
   @iif ML_NUR = 0
      C += incC;
   @endiif
   }
@SKIP --- N cleanup
   @iif ML_NUR ! 0
      @iif nu > 1
         @iif CU_NUR = 0
   { /* Cleanup in N dimension */
@ROUT blk2C `      const @(typ) *p = b;`
@ROUT C2blk `      @(typ) *p = b;`
            @iif ML_MUNU ! 0
      unsigned int mu;
            @endiif
      C += ldc * n;  
      for (i=0; i < M; i += mu, p += pansz)
      {
         mu = ((M-i) >= @(mu)) ? @(mu) : (M-i);
         @callproc doBlockRolled C mu nr 1
      }
   }
         @endiif
         @iif CU_NUR ! 0
   switch(nr)
   {
@ROUT blk2C `      const @(typ) *p;`
@ROUT C2blk `      @(typ) *p;`
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      p = b;
            @iif ML_MUNU ! 0
      for (i=0; i < mf; i++, p += pansz)
      {
         @callproc doBlock @(mu) @(n) p
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @callproc doBlock @(m) @(n) p
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
            @endiif
            @iif ML_MUNU = 0
      for (i=0; i < M; i += mu, p += pansz)
      {
         mu = ((M-i) >= @(mu)) ? @(mu) : (M-i);
         @callproc doBlockNuUR @(n)          
      @iexp j 0
      @iwhile j < @(n)
         C@(j) += @(mu);
         @iexp j @(j) 1 +
      @endiwhile
      }
            @endiif
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
         @endiif
      @endiif
   @endiif
}
@endiif
@iif TRI = 1
@iif SYRKU = 0
@SKIP ******************** Restricted SYRK copy: real type *********************
@SKIP handles diagonal blocks when mu = nu 
@SKIP IN: mu, nu, beta, alpha
@BEGINPROC doDiBlock n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define c @dum@
   @define r @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(j) @(mu) * @(i) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j { i
@ROUT C2blk
         @iif j > i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j { i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
@ROUT blk2C C2blk
      @callproc doElement @(r) @(c) C @(k) p  
@ROUT blk2C 
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef r
   @undef c
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles diagonal subblocks when mu=ma*nu
@SKIP IN: mu, nu, beta, alpha
@BEGINPROC doDiBlockmn m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define jj @dum@
   @define k @dum@
   @define t @dum@
   @define sc @dum@
      switch (j%@(ma_))
      {
      @iexp sc 0
      @iwhile sc < @(ma_)
      case @(sc):
         @iexp j 0
         @iwhile j < @(n_)  
            @iexp i 0
            @iwhile i < @(m_) 
               @iexp k @(j) @(mu) * @(i) +
               @iexp t @(nu) @(sc) *
               @iexp t @(t) @(j) +
               @iif i < @(t) 
@ROUT C2blk    
               @iexp jj @(m_) -1 +    
               @callproc doElement @(jj) @(j) C @(k) p 
@ROUT C2blk blk2C
               @endiif
               @iif i } @(t)
               @callproc doElement @(i) @(j) C @(k) p
               @endiif
               @iexp i @(i) 1 +
            @endiwhile
         C@(j) += @(m_);
            @iexp j @(j) 1 +
         @endiwhile
         break;
         @iexp sc @(sc) 1 +
      @endiwhile
      default:;
      }
   @undef sc
   @undef t
   @undef k
   @undef jj
   @undef j
   @undef i
@ENDPROC
@SKIP cleanup diagonal subblocks when mu!=nu 
@SKIP IN: mu, nu, beta, alpha,
@BEGINPROC doCuDiBlockmn m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define jj @dum@
   @define k @dum@
   @define t @dum@
   @define sc @dum@
   @define m @dum@
      unsigned int kk;
      switch (j%@(ma_))
      {
      @iexp m @(ma_) -1 +
      @iexp sc 0
      @iwhile sc < @(m)
      case @(sc):
         @iexp j 0
         @iwhile j < @(n_)  
            @iexp i 0 
            @iwhile i < @(m_) 
               @iexp k @(j) @(mu) * @(i) +
               @iexp t @(nu) @(sc) *
               @iexp t @(t) @(j) +
@ROUT C2blk    
               @iif i < @(t) 
               @iexp jj @(i) 1 +    
            p[@(k)] = 0.0;
               @endiif
@ROUT C2blk blk2C
               @iif i } @(t)
                  @skip "upper limit"
                  @iexp t @(sc) 1 +
                  @iexp t @(t) @(nu) *
                  @iif i < @(t)
            @callproc doElement @(i) @(j) C @(k) p
                  @endiif
               @endiif
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
            @skip "now from nu to mu "
            @iexp jj @(sc) 1 +
            @iexp jj @(jj) @(n_) *
         for (kk=@(jj); kk < mr; kk++ )
         {
               @iexp jj 0
               @iwhile jj < @(n_)
                  @iexp t @(jj) @(m_) * 
                  @callproc doElement kk @(jj) C @(t)+kk p
                  @iexp jj @(jj) 1 +
               @endiwhile
         }
         break;
         @iexp sc @(sc) 1 +
      @endiwhile
      default:;
      }
   @undef m
   @undef sc
   @undef t
   @undef k
   @undef jj
   @undef j
   @undef i
@ENDPROC
@SKIP diagonal block when nu > mu and nu = na * mu
@BEGINPROC doDikkBlockna n_ 
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define c @dum@
   @define r @dum@
   @define m @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(j) @(mu) * @(i) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j { i
@ROUT C2blk
         @iif j > i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j { i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
@ROUT blk2C C2blk
         @skip @iexp m @(n_) @(n_) *
         @callproc doElement @(r) @(c) C @(k)+kk p 
@ROUT blk2C
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef m
   @undef r
   @undef c
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP full blocks with multiplication 
@BEGINPROC donaBlock m_ n_ 
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define m @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(j) @(mu) * @(i) +
         @callproc doElement @(i) @(j) C @(k)+kk p 
         @iexp i @(i) 1 +
      @endiwhile
      @iif m_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef m
   @undef k
   @undef j
   @undef i
@ENDPROC
@iif cpvl = 1
void @(rtnm)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   @ROUT blk2C
   const @(typ) alpha,  /* scalar for b */
   const @(typ) *b,     /* matrix stored in @(mu)x@(nu)-major order */
   const @(typ) beta,   /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) alpha,  /* scalar for C */
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) beta,   /* scalar for b */
   @(typ) *b            /* matrix stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
@endiif
@iif cpvl > 1
static INLINE void a2c_1(const size_t M, const size_t N, const @(typ) alpha, 
                         const @(typ) *b, const SCALAR beta, 
                         @(typ) *C, ATL_CSZT ldc)
@endiif
{
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   @iif mEn = 1
   unsigned int pansz = @(bs);
   const size_t incC0 = (ldc+1)*@(nu);
   @endiif
   @iif mEn = 0
      @skip "*** special case for mu = ma*nu"
      @iif ma ! 1
   unsigned int pansz = @(bs)*@(ma);
   const unsigned int manf = (N/(@(nu)*@(ma)))*@(ma);
   const unsigned int manr = nf - manf;
   const size_t incC0 = ldc*@(nu);
      @endiif 
      @skip "*** special case for nu = na * mu"
      @iif na ! 1
   unsigned int pansz = @(bs);
   const size_t incC0 = (ldc+1)*@(mu); 
   const unsigned int mnf = N/@(mu);
   const unsigned int mnr = N - (mnf*@(mu));
   unsigned int kk; 
      @endiif
   @endiif
   unsigned int i, j;
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
@iif na = 1
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif na ! 1
      @define j @1@
      @iwhile j < @(mu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
   @iif mEn = 1
   for (j=0; j < nf; j++)
   @endiif
   @iif mEn = 0
      @iif ma ! 1
   size_t incC;
   for (j=0; j < manf; j++)
      @endiif
      @iif na ! 1
   for (j=0; j < mnf; j++)
      @endiif
   @endiif
   {
@ROUT blk2C `      const @(typ) *p = b;`
@ROUT C2blk `      @(typ) *p = b;`
   @iif mEn = 1
      unsigned int psz = pansz+@(bs), incC = incC0 - (mf-j)*@(mu);

      @callproc doDiBlock @(nu)
      p += pansz;
      for (i=j+1; i < mf; i++, p += psz, psz += @(bs))
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      unsigned int psz = pansz + @(ma)*@(bs); 
      incC = incC0 - (mf-(j+1)/@(ma))*@(mu);
      @callproc doDiBlockmn @(mu) @(nu) @(ma)
      p += pansz;
      for (i=j/@(ma)+1; i < mf; i++, p += psz, psz += @(bs)*@(ma))
      @endiif
      @iif na ! 1
      unsigned int psz = pansz, incC = incC0 - (mf-j)*@(mu);
         kk = j % @(na);
      @iexp mumu @(mu) @(mu) *
         kk *= @(mumu);
      @callproc doDikkBlockna @(mu) 
      p += pansz;
      for (i=j+1; i < mf; i++, p += psz )
      @endiif
   @endiif
@iif na = 1
      {
         @callproc doBlock @(mu) @(nu) p
      }
@endiif
@iif na ! 1
      {
         @callproc donaBlock @(mu) @(mu) 
         psz += ((i%@(na))==0?@(bs):0);
      }
@endiif
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
@iif na = 1
      @callproc doBlock @(m) @(nu) p
@endiif
@iif na ! 1
      @callproc donaBlock @(m) @(mu) 
@endiif
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
@iif na = 1
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
@endiif
@iif na ! 1
   @iexp j 0
   @iwhile j < @(mu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
@endiif
   @iif mEn = 1
      pansz += @(bs);
      b += pansz;
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      b += ((j+1)% @(ma))==0 ? pansz+@(bs) : @(bs);
      if ( (j+1) % @(ma) == 0)
         pansz += @(ma)*@(bs);
      @endiif
      @iif na ! 1
      pansz += ((j+1)%@(na)==0?@(bs):0);
      b += pansz;
      @endiif
   @endiif
   }
      @SKIP "Remainder of manr = nf - manf " 
   @iif mEn = 0
      @iif ma ! 1
   for (j=manf; j < nf; j++)
   {
@ROUT blk2C `      const @(typ) *p = b;`
@ROUT C2blk `      @(typ) *p = b;`
      unsigned int psz = pansz + @(ma)*@(bs), 
                         incC = incC0 - (mf-(j+1)/@(ma))*@(mu);
         @callproc doCuDiBlockmn @(mu) @(nu) @(ma)
      p += pansz;
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      b += ((j+1)% @(ma))==0 ? pansz+@(bs) : @(bs);
      if ( (j+1) % @(ma) == 0)
         pansz += @(ma)*@(bs);
   }
         @endiif
      @endiif
@iif na = 1
@iif nu > 1
   switch(nr)
   {
@ROUT blk2C `      const @(typ) *p;`
@ROUT C2blk `      @(typ) *p;`
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      p = b;
   @iif mEn = 1
         @callproc doDiBlock @(n)
   @endiif
   @iif mEn = 0
      @iif ma ! 1
         p += mr - nr; 
         @iexp k 0
         @iwhile k < @(n)
            C@(k) += mr-nr;
            @iexp k @(k) 1 +
         @endiwhile
         @skip "for nr cleanup, it works like mu=nu"
         @callproc doDiBlock @(n)
      @endiif
   @endiif
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
@endiif
@iif na ! 1
@iif mu > 1
   kk = mnf % @(na);
   kk *= @(mumu);
   switch(mnr)
   {
@ROUT blk2C `      const @(typ) *p;`
@ROUT C2blk `      @(typ) *p;`
   @iexp n 1
   @iwhile n < @(mu)
   case @(n):
      p = b;
      @callproc doDikkBlockna @(n) 
         break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
@endiif
}
@SKIP ********** SYRK L2UT copy: real type *************************************
@SKIP this proc handles single element
@SKIP IN : alpha, beta, C, b 
@BEGINPROC doElementT r_ c_ k_
   @iif alpha = 1
      @iif beta = 0
@ROUT blk2C `            C@(c_)[@(r_)] = b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = C@(c_)[@(r_)];`
      @endiif
      @iif beta = 1
@ROUT blk2C `            C@(c_)[@(r_)] += b[@(k_)];`
@ROUT C2blk `            b[@(k_)] += C@(c_)[@(r_)];`
      @endiif
      @iif beta = -1
@ROUT blk2C `            C@(c_)[@(r_)] = b[@(k_)] - C@(c_)[@(r_)];`
@ROUT C2blk `            b[@(k_)] = C@(c_)[@(r_)] - b[@(k_)];`
      @endiif
      @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c_)[@(r_)] = beta*C@(c_)[@(r_)] + b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = beta*b[@(k_)] + C@(c_)[@(r_)];`
      @endiif
   @endiif
   @iif alpha = -1
      @iif beta = 0
@ROUT blk2C `            C@(c_)[@(r_)] = -b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = -C@(c_)[@(r_)];`
      @endiif
      @iif beta = 1
@ROUT blk2C `            C@(c_)[@(r_)] -= b[@(k_)];`
@ROUT C2blk `            b[@(k_)] -= C@(c_)[@(r_)];`
      @endiif
      @iif beta = -1
@ROUT blk2C `            C@(c_)[@(r_)] = -C@(c_)[@(r_)] - b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = -C@(c_)[@(r_)] - b[@(k_)];`
      @endiif
      @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c_)[@(r_)] = beta*C@(c_)[@(r_)] - b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = beta*b[@(k_)] - C@(c_)[@(r_)];`
      @endiif
   @endiif
   @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
      @iif beta = 0
@ROUT blk2C `            C@(c_)[@(r_)] = alpha*b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = alpha*C@(c_)[@(r_)];`
      @endiif
      @iif beta = 1
@ROUT blk2C `            C@(c_)[@(r_)] += alpha*b[@(k_)];`
@ROUT C2blk `            b[@(k_)] += alpha*C@(c_)[@(r_)];`
      @endiif
      @iif beta = -1
@ROUT blk2C `            C@(c_)[@(r_)] = alpha*b[@(k_)] - C@(c_)[@(r_)];`
@ROUT C2blk `            b[@(k_)] = alpha*C@(c_)[@(r_)] - b[@(k_)];`
      @endiif
      @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `            C@(c_)[@(r_)] = beta*C@(c_)[@(r_)] + alpha*b[@(k_)];`
@ROUT C2blk `            b[@(k_)] = beta*b[@(k_)] + alpha*C@(c_)[@(r_)];`
      @endiif
   @endiif
@ENDPROC
@SKIP handles full block 
@BEGINPROC doBlockT m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(i) @(mu) * @(j) +
         @callproc doElementT @(i) @(j) @(k)  
         @iexp i @(i) 1 +
      @endiwhile
      @iif m_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles full blocks when nu=na*mu 
@BEGINPROC doBlockTna m_ n_ mu_ inc_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(i) @(mu_) * @(j) +
         @callproc doElementT @(i) @(j) @(k)  
         @iexp i @(i) 1 +
      @endiwhile
            C@(j) += @(inc_);
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles partial block when nu = na*mu (na!=1) 
@BEGINPROC doDiBlockTna m_ n_ mu_ nu_ inc_ sc_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define t @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp t @(nu_) @(sc_) *
         @iexp t @(t) @(j) +
         @iexp k @(i) @(mu_) * @(j) +
@ROUT C2blk
         @iif i > @(t)
         p[@(k)] = 0.0;
         @endiif
@ROUT C2blk blk2C
         @iif i { @(t)
            @iexp t @(sc_) 1 +
            @iexp t @(t) @(nu_) *
            @iif i < @(t)
         @callproc doElementT @(i) @(j) @(k)  
            @endiif   
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
            C@(j) += @(inc_);
      @iexp j @(j) 1 +
   @endiwhile
   @undef t
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles block with offset kk
@BEGINPROC doBlockTkk m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(i) @(mu) * @(j) +
         @callproc doElementT @(i) @(j) kk+@(k)  
         @iexp i @(i) 1 +
      @endiwhile
            C@(j) += @(m_);
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@skip handles diagonal block
@BEGINPROC doDiBlockT n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(i) @(mu) * @(j) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j } i
      @callproc doElementT @(r) @(c) @(k)
         @endiif
@ROUT C2blk
         @iif j < i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j } i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
      @callproc doElementT @(r) @(c) @(k)
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@skip handles diagonal block with offset kk
@BEGINPROC doDiBlockTkk n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(i) @(mu) * @(j) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j } i
      @callproc doElementT @(r) @(c) kk+@(k)
         @endiif
@ROUT C2blk
         @iif j < i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j } i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
      @callproc doElementT @(r) @(c) kk+@(k)
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@skip  handles cleanup of diagonal block when mu=ma*nu
@SKIP IN: mu, nu, beta, alpha,
@BEGINPROC doCuDiBlockT m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define sc @dum@
   @define t @dum@
   @iexp sc 0
   @iwhile sc < @(ma_)
      case @(sc):
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(i) @(m_) *
         @iexp t @(sc) @(n_) *
         @iexp k @(k) @(t) +
         @iexp k @(k) @(j) +
         @iif j } i
            @callproc doElementT @(i) @(j) @(k)
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
         C@(j) += @(n_);
      @iexp j @(j) 1 +
   @endiwhile
         break;
      @iexp sc @(sc) 1 +
   @endiwhile
   @undef t
   @undef sc
   @undef k
   @undef j
   @undef i
@ENDPROC
@ROUT C2blk `#if 0`
#ifndef Mjoin
   #define Mjoin(pre, nam) my_join(pre, nam)
   #define my_join(pre, nam) pre ## nam
#endif
/*
 * The block is assumed to store L, this function does a transpose while
 * copying so that it is transferred with Upper portion of C
 */
void Mjoin(ATL_USERCPMM,_L2UT)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   @ROUT blk2C
   const @(typ) alpha,  /* scalar for b */
   const @(typ) *b,     /* matrix stored in @(mu)x@(nu)-major order */
   const @(typ) beta,   /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) alpha,  /* scalar for C */
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) beta,   /* scalar for b */
   @(typ) *b            /* matrix stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
{
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   unsigned int i, j;
@iif na = 1      
   const size_t incC0 = ldc*@(nu);
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif na ! 1      
   const size_t incC0 = ldc*@(mu);
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(mu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif mEn = 0
   @iif ma ! 1
   unsigned int pansz = @(ma)*@(bs);
@ROUT blk2C `   const @(typ) *p = b;` 
@ROUT C2blk `   @(typ) *p = b;` 
   int kk;
   @endiif
@endiif
@iif na = 1
   for (j=0; j < nf; j++)
   {
      unsigned int incC = incC0 - (j+1)*@(nu);
      @iif mEn = 0
         @iif ma ! 1
      b = p;
      kk = j % @(ma);
      kk *= @(nu);
         @endiif
      @endiif
      for (i=0; i < j; i++, b += @(bs))
      {
      @iif mEn = 1
         @callproc doBlockT @(mu) @(nu)
      @endiif
      @iif mEn = 0
         @iif ma ! 1
         @callproc doBlockTkk @(nu) @(nu) 
         @endiif
      @endiif
      }
   @iif mEn = 1
      @callproc doDiBlockT @(nu)
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      b += @(bs);
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      switch(j%@(ma))
      {
         @callproc doCuDiBlockT @(mu) @(nu) @(ma)
      default:;
      }
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      p += ((j+1)%@(ma)==0? pansz: 0);
      pansz += ((j+1)%@(ma)==0? @(ma)*@(bs):0);
      @endiif
   @endiif
   }
@endiif
@iif na ! 1
   for (j=0; j < mf; j++)
   {
      size_t incC = incC0 - (j/@(na)+1)*@(nu);
      for (i=0; i < j/@(na); i++, b+=@(bs))
      {
         @callproc doBlockTna @(nu) @(mu) @(mu) @(nu)
      }
      switch(j%@(na))
      {
      @iexp n 0
      @iwhile n < @(na)
      case @(n):
         @callproc doDiBlockTna @(nu) @(mu) @(mu) @(mu) @(nu) @(n)
      break;
         @iexp n @(n) 1 +
      @endiwhile
      default:;
      }
   @iexp j 0
   @iwhile j < @(mu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      b += @(bs);
   }
@endiif
@iif nu > 1
   @iif mEn = 1
   switch(nr)
   {
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      for (i=0; i < mf; i++, b += @(bs))
      {
         @callproc doBlockT @(mu) @(n)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @skip Assumption for sryk  m = n" 
      @callproc doDiBlockT @(m) 
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endiif
   @iif mEn = 0
      @iif ma ! 1
   b = p;
   kk = nf % @(ma);
   kk *= @(nu);
   switch(nr)
   {
         @iexp n 1
         @iwhile n < @(nu)
   case @(n) :
      for (i=0; i < nf; i++, b+=@(bs))
      {
         @callproc doBlockTkk @(nu) @(n)
      }
         @callproc doDiBlockTkk @(n)
      break;
            @iexp n @(n) 1 +
         @endiwhile
   default:;
   }
      @endiif
   @endiif
@endiif
@iif mu > 1
   @iif na ! 1
   switch (mr)
   {
      @iexp n 1
      @iwhile n < @(mu)
   case @(n):
      for (i=0; i < nf; i++, b+=@(bs))
      {
      @callproc doBlockTna @(nu) @(n) @(mu) @(nu)
      }
      switch ( mf % @(na))
      {
            @iexp m 0 
            @iwhile m < na  
      case @(m):
            @callproc doDiBlockTna @(nu) @(n) @(mu) @(mu) @(nu) @(m)
         break;
               @iexp m @(m) 1  +
            @endiwhile
      default:;
      }
      break;
         @iexp n @(n) 1 +
      @endiwhile
   default:;
   }
   @endiif
@endiif
}
@ROUT C2blk `#endif`
@endiif
@SKIP ********************** Unrestricted SYRK copy: Real Type *****************
@iif SYRKU ! 0
@SKIP handles rolled rectangual blocks, used for cleanup as well
@BEGINPROC doTrBlocksRolled mu_ nu_ tstmu_
         unsigned int mu=N-i, ii, jj, nblks;
@ROUT C2BLK `         const @(typ) *C0 = C + i; `          
@ROUT BLK2C `         @(typ) *C0 = C + i; `          
@ROUT C2BLK `         @(typ) *p = rw + cinc; `          
@ROUT BLK2C `         const @(typ) *p = rw + cinc; `     
   @iif tstmu_ = 1
         mu = (mu >= @(mu)) ? @(mu) : mu;
   @endiif
         in = i + mu;
         for (jj=0; jj < @(nu_); jj++, C0 += ldc, p += @(mu))
         {
            for (ii=0; ii < @(mu_); ii++)
            {
               @callproc doElement ii 0 C ii p 
            }
         }
         nblks = (in-1+@(nu)) / @(nu);  /* # of row blocks in this panel */
         rwpan = nblks*@(bs);
         rw += rwpan;
@ENDPROC
@SKIP handles unrolled rectangual blocks, used for cleanup as well
@BEGINPROC doTrBlocksUR 
      for (; (i+@(mu)) < N; i = in)
      {
         unsigned int nblks;
@ROUT C2BLK `         @(typ) *p = rw + cinc; `          
@ROUT BLK2C `         const @(typ) *p = rw + cinc; `          
@ROUT blk2C `        @declare "         @(typ) " n n ";"`
@ROUT C2blk `        @declare "         const @(typ) " n n ";"`
         *C0=C+i
         @define j @1@
         @iwhile j < @(nu)
            @iexp i @(j) -1 +
            *C@(j)=C@(i)+ldc
            @iexp j @(j) 1 +
         @endiwhile
      @enddeclare
         in = i + @(mu);
         @callproc doBlock @(mu) @(nu) p 
         nblks = (in-1+@(nu)) / @(nu);  /* # of row blocks in this panel */
         rwpan = nblks*@(bs);
         rw += rwpan;
      }
@ENDPROC
@BEGINPROC doTrBlocksMuUR mu_ nu_
         for (; (i+@(mu)) < N; i = in)
         {
            unsigned int jj, nblks;
@ROUT C2BLK `            const @(typ) *C0 = C + i; `          
@ROUT BLK2C `            @(typ) *C0 = C + i; `          
@ROUT C2BLK `            @(typ) *p = rw + cinc; `          
@ROUT BLK2C `            const @(typ) *p = rw + cinc; `          
            in = i + @(mu);
            for (jj=0; jj < @(nu_); jj++, C0 += ldc, p += @(mu))
            {
            @iexp i 0
            @iwhile i < @(mu_)
               @callproc doElement @(i) 0 C @(i) p 
               @iexp i @(i) 1 +
            @endiwhile
            } 
            nblks = (in-1+@(nu)) / @(nu);  /* # of row blocks in this panel */
            rwpan = nblks*@(bs);
            rw += rwpan;
         }
@ENDPROC
@BEGINPROC doTrBlocksNuUR mu_ nu_ 
      for (; i < N; i = in)
      {
         unsigned int ii, nblks, mu=N-i;
@ROUT C2BLK `         @(typ) *p = rw + cinc; `          
@ROUT BLK2C `         const @(typ) *p = rw + cinc; `          
@ROUT blk2C `        @declare "         @(typ) " n n ";"`
@ROUT C2blk `        @declare "         const @(typ) " n n ";"`
         *C0=C+i
         @define j @1@
         @iwhile j < @(nu)
            @iexp i @(j) -1 +
            *C@(j)=C@(i)+ldc
            @iexp j @(j) 1 +
         @endiwhile
      @enddeclare
         mu = (mu >= @(mu)) ? @(mu) : mu;
         in = i + mu;
         for (ii=0; ii < @(mu_); ii++)
         {
            @iexp j 0
            @iwhile j < @(nu_)
               @callproc doElement ii @(j) C @(mu)*@(j)+ii p
               @iexp j @(j) 1 +
            @endiwhile
         }
         nblks = (in-1+@(nu)) / @(nu);  /* # of row blocks in this panel */
         rwpan = nblks*@(bs);
         rw += rwpan;
      }
@ENDPROC
@SKIP handles diagonal crossing blocks, implement rolled version first
@BEGINPROC doDiagBlock mu_ nu_
/*
 *    Handling of diagonal blocks for this colpan 
 */
      for (; i < jn; i = in)
      {
         unsigned int mu=N-i, ii, jj, nblks;
@ROUT C2BLK `         const @(typ) *C0 = C + i; `          
@ROUT BLK2C `         @(typ) *C0 = C + i; `          
@ROUT C2BLK `         @(typ) *p = rw + cinc; `          
@ROUT BLK2C `         const @(typ) *p = rw + cinc; `          
         mu = (mu >= @(mu)) ? @(mu) : mu;
         in = i + mu;
@SKIP /* based on full/cleanup, nu can be const or var */
         for (jj=0; jj < @(nu_); jj++, C0 += ldc, p += @(mu)) 
         {
            const unsigned int J=j+jj;
            for (ii=0; ii < mu; ii++)
            {
               const unsigned int I=i+ii;
               if (I >= J)
               {
                  @callproc doElement ii 0 C ii p 
               }
            }
         }
         nblks = (in-1+@(nu)) / @(nu);  /* # of row blocks in this panel */
         rwpan = nblks*@(bs);
         rw += rwpan; /* finished all blocks in rowpanel */
         rW = (in <= jn) ? rw : rW;
      }
@ENDPROC
@BEGINSKIP
*** We are only unrolling the main loop here, parameterized for both dimension  
@ENDSKIP
/*
 * Main Loop:
 @iif bvML = 0
 * Both Rolled
 @endiif
 @iif ML_MUR ! 0
 * Mu unrolled
 @endiif
 @iif ML_NUR ! 0
 * Nu unrolled
 @endiif
 */
@iif cpvl = 1
void @(rtnm)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   @ROUT blk2C
   const @(typ) alpha,  /* scalar for b */
   const @(typ) *b,     /* matrix stored in @(mu)x@(nu)-major order */
   const @(typ) beta,   /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) alpha,  /* scalar for C */
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) beta,   /* scalar for b */
   @(typ) *b            /* matrix stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
@endiif
@iif cpvl > 1
static INLINE void a2c_1(const size_t M, const size_t N, const @(typ) alpha, 
                         const @(typ) *b, const SCALAR beta, 
                         @(typ) *C, ATL_CSZT ldc)
@endiif
{
   int j, jn, cinc, rwpan;
   unsigned int pansz = @(bs);
   const size_t incC = ldc*@(nu);
@ROUT C2BLK `   @(typ) *rW=b, *rw; `
@ROUT BLK2C `   const @(typ) *rW=b, *rw; `
/*
 * NOTE: we assume N=M, always square for syrk 
 */
   @iif ML_NO = 0 
      @iif ML_NUR ! 0
   const unsigned int nf = N/@(nu);
   const unsigned int n = nf*@(nu), nr = N-n;
      @endiif
/*
 * NU colpan: Full panel, without cleanup (N direction)
 */
      @iif ML_NUR ! 0 
   for (cinc=j=0; j < n; j = jn, C += incC, cinc += @(bs))
      @endiif
   @SKIP ***** Nu rolled, no need of Nu cleanup 
      @iif ML_NUR = 0
   for (cinc=j=0; j < N; j = jn, C += incC, cinc += @(bs))
      @endiif
   {
      unsigned int i, in, nd;
      @iif ML_NUR = 0
      unsigned int nu = N-j;
      nu = (nu >= @(nu)) ? @(nu) : nu;
      jn = j + nu;      /* main loop, full NU block */
      @endiif
      @iif ML_NUR ! 0
      jn = j + @(nu);      /* main loop, full NU block */
      @endiif
      i = (j/@(mu))*@(mu);
      rw = rW;
/*
 *    handle the diagonal-crossing blocks first
 *    NOTE: this can be full-MU block or partial----> no unrolling right now 
 */
      @iif ML_NUR ! 0
         @callproc doDiagBlock mu @(nu)
      @endiif
      @iif ML_NUR = 0
         @callproc doDiagBlock mu nu
      @endiif
/*
 *    Full block after diagonal crossing, n=m  
 */
      @iif ML_MUNU = 1
         @callproc doTrBlocksUR
      @endiif
      @SKIP only MU unrolling.. ML_MU true for both MU and MUNU
      @iif ML_NUR = 0
         @callproc doTrBlocksMuUR @(mu) nu
      @endiif
      @iif ML_MUR = 0 
         @callproc doTrBlocksNuUR mu @(nu)
      @endiif
      @iif ML_MUR = 1 
/*
 *    MU cleanup 
 */   
      if (i < N)
      {
         @iif ML_MUNU = 1
            @callproc doTrBlocksRolled mu @(nu) 0
         @endiif
         @iif ML_MUR = 1
            @callproc doTrBlocksRolled mu nu 0
         @endiif 
      }
      @endiif 
   }
   @endiif
@BEGINSKIP
*
*  Following codes execute for three cases: 
*     NU unrolled, both unrolled and no unroll 
*     So, condition: if ML_MUR = 0 || ML_MUNU = 1 
@ENDSKIP
   @iif @iexp 1 @(ML_MUNU) = 0 @(ML_MUR) = |
      @iif ML_NO = 0
/*
 * cleanup in N dimension
 */
   if (j < N)
      @endiif
      @iif ML_NO = 1
   for (cinc=j=0; j < N; j = jn, C += incC, cinc += @(bs)) 
      @endiif 
   {
      unsigned int  i, in, nu = N-j, nd, nblks;
      jn = j + nu;
      i = (j/@(mu))*@(mu);
      rw = rW;
      @callproc doDiagBlock mu nu 
/*
 *    full blocks before diagonal 
 */
      for (; i < N; i = in)
      {
         @callproc doTrBlocksRolled mu nu 1
      }
   }
   @endiif
}
@SKIP ************** Unrestricted SYRK L2UT ************************************ 
@SKIP this proc handles single element
@SKIP IN : alpha, beta, C, b 
@BEGINPROC doElementT r_ c_ C_ k_ b_
   @iif alpha = 1
      @iif beta = 0
@ROUT blk2C `                  @(C_)@(c_)[@(r_)] = @(b_)[@(k_)];`
@ROUT C2blk `                  @(b_)[@(k_)] = @(C_)@(c_)[@(r_)];`
      @endiif
      @iif beta = 1
@ROUT blk2C `                  @(C_)@(c_)[@(r_)] += @(b_)[@(k_)];`
@ROUT C2blk `                  @(b_)[@(k_)] += @(C_)@(c_)[@(r_)];`
      @endiif
      @iif beta = -1
@ROUT blk2C `                  @(C_)@(c_)[@(r_)] = @(b_)[@(k_)] - @(C_)@(c_)[@(r_)];`
@ROUT C2blk `                  @(b_)[@(k_)] = @(C_)@(c_)[@(r_)] - @(b_)[@(k_)];`
      @endiif
      @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `                  @(C_)@(c_)[@(r_)] = beta*@(C_)@(c_)[@(r_)] + @(b_)[@(k_)];`
@ROUT C2blk `                  @(b_)[@(k_)] = beta*@(b_)[@(k_)] + @(C_)@(c_)[@(r_)];`
      @endiif
   @endiif
   @iif alpha = -1
      @iif beta = 0
@ROUT blk2C `                  @(C_)@(c_)[@(r_)] = -@(b_)[@(k_)];`
@ROUT C2blk `                  @(b_)[@(k_)] = -@(C_)@(c_)[@(r_)];`
      @endiif
      @iif beta = 1
@ROUT blk2C `                  @(C_)@(c_)[@(r_)] -= @(b_)[@(k_)];`
@ROUT C2blk `                  @(b_)[@(k_)] -= @(C_)@(c_)[@(r_)];`
      @endiif
      @iif beta = -1
@ROUT blk2C `                  @(C_)@(c_)[@(r_)] = -@(C_)@(c_)[@(r_)] - @(b_)[@(k_)];`
@ROUT C2blk `                  @(b_)[@(k_)] = -@(C_)@(c_)[@(r_)] - @(b_)[@(k_)];`
      @endiif
      @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `                  @(C_)@(c_)[@(r_)] = beta*@(C_)@(c_)[@(r_)] - @(b_)[@(k_)];`
@ROUT C2blk `                  @(b_)[@(k_)] = beta*@(b_)[@(k_)] - @(C_)@(c_)[@(r_)];`
      @endiif
   @endiif
   @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
      @iif beta = 0
@ROUT blk2C `                  @(C_)@(c_)[@(r_)] = alpha*@(b_)[@(k_)];`
@ROUT C2blk `                  @(b_)[@(k_)] = alpha*@(C_)@(c_)[@(r_)];`
      @endiif
      @iif beta = 1
@ROUT blk2C `                  @(C_)@(c_)[@(r_)] += alpha*@(b_)[@(k_)];`
@ROUT C2blk `                  @(b_)[@(k_)] += alpha*@(C_)@(c_)[@(r_)];`
      @endiif
      @iif beta = -1
@ROUT blk2C `                  @(C_)@(c_)[@(r_)] = alpha*@(b_)[@(k_)] - @(C_)@(c_)[@(r_)];`
@ROUT C2blk `                  @(b_)[@(k_)] = alpha*@(C_)@(c_)[@(r_)] - @(b_)[@(k_)];`
      @endiif
      @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C `                  @(C_)@(c_)[@(r_)] = beta*@(C_)@(c_)[@(r_)] + alpha*@(b_)[@(k_)];`
@ROUT C2blk `                  @(b_)[@(k_)] = beta*@(b_)[@(k_)] + alpha*@(C_)@(c_)[@(r_)];`
      @endiif
   @endiif
@ENDPROC
@SKIP handles full block 
@BEGINPROC doBlockT m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(i) @(mu) * @(j) +
         @callproc doElementT @(i) @(j) C @(k) b  
         @iexp i @(i) 1 +
      @endiwhile
      @iif m_ = mu
            C@(j) += @(mu);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef j
   @undef i
@ENDPROC
@ROUT C2blk `#if 0`
#ifndef Mjoin
   #define Mjoin(pre, nam) my_join(pre, nam)
   #define my_join(pre, nam) pre ## nam
#endif
/*
 * The block is assumed to store L, this function does a transpose while
 * copying so that it is transferred with Upper portion of C
 */
void Mjoin(ATL_USERCPMM,_L2UT)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   @ROUT blk2C
   const @(typ) alpha,  /* scalar for b */
   const @(typ) *b,     /* matrix stored in @(mu)x@(nu)-major order */
   const @(typ) beta,   /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) alpha,  /* scalar for C */
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) beta,   /* scalar for b */
   @(typ) *b            /* matrix stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
{
   size_t j, jn;
   const size_t incCm = ldc*@(mu);
/*
 * NOTE: we assume N=M, always square for syrk 
 */
   const size_t nf = N/@(nu);
   const size_t n = nf*@(nu), nr = N-n;
/*
 * since it's upper transpose case, the direction of @(mu) and NU interchanged
 */
   for (j=0; j < N; j = jn, C += incCm)
   {
      size_t i, in, nu;
      size_t mu = N-j;
      mu = (mu >= @(mu)) ? @(mu) : mu;
      jn = j + mu;
      nu = @(nu);
/*
 *    for upper triangle, blocks whose do not intersect with diagonal follow:
 *               y0 > x1 => j > (in-1)
 *                       => j > i+nu-1
 *    access of C-workspace is consecutive
 */
      for (i=0; j > (i+nu-1); i=in, b += @(bs) )
      {
@ROUT C2BLK `        @(typ) *rw0 = b; `
@ROUT BLK2C `        const @(typ) *rw0 = b; `
@ROUT C2BLK `        const @(typ) *C0 = C+i; `
@ROUT BLK2C `        @(typ) *C0 = C+i; `
         unsigned int ii, jj;
         size_t nu = N-i;
         nu = (nu >= @(nu)) ? @(nu) : nu;
         in = i + nu;
         for (jj=0; jj < mu; jj++, C0 += ldc, rw0++)
         {
@ROUT C2BLK `           @(typ) *pr = rw0; `
@ROUT BLK2C `           const @(typ) *pr = rw0; `
            for (ii=0; ii < nu; ii++, pr += @(mu))
            {
               @callproc doElementT ii 0 C 0 pr 
            }
         }
      }
/*
 *    intersection occurs at later blocks
 */
      for ( ; i < jn; i=in, b += @(bs))
      {
@ROUT C2BLK `        @(typ) *rw0 = b; `
@ROUT BLK2C `        const @(typ) *rw0 = b; `
@ROUT C2BLK `        const @(typ) *C0 = C+i; `
@ROUT BLK2C `        @(typ) *C0 = C+i; `
         unsigned int ii, jj;
         size_t nu = N-i;
         nu = (nu >= @(nu)) ? @(nu) : nu;
         in = i + nu;
         for (jj=0; jj < mu; jj++, C0 += ldc, rw0++)
         {
@ROUT C2BLK `           @(typ) *pr = rw0; `
@ROUT BLK2C `           const @(typ) *pr = rw0; `
            size_t J=j+jj;
            for (ii=0; ii < nu; ii++, pr += @(mu))
            {
               size_t I=i+ii;
               if (I <= J)
               {
                  @callproc doElementT ii 0 C 0 pr 
               }
            }
         }
      }
   }
}
@ROUT C2blk `#endif`
@endiif
@endiif
@SKIP ******************** Complex data type ***********************************
@PRE C Z
   @iexp betX 0 @(beta) ! 1 @(beta) ! & -1 @(beta) ! &
   @iexp alpX 0 @(alpha) ! 1 @(alpha) ! & -1 @(alpha) ! &
@SKIP blksz = ((mu*nu+vlen-1)/vlen)*vlen
@iexp bs @(vl) @(mu) @(nu) * @(vl) + -1 + / @(vl) *
/* HERE vl=@(vl), mu=@(mu), nu=@(nu) bs=@(bs)*/
@SKIP handles single element 
@BEGINPROC doElement c_ ir_ ii_ C_ k_ pr_ pi_
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C 
                  @(C_)@(c_)[@(ir_)]   = @(pr_)[@(k_)];
                  @(C_)@(c_)[@(ii_)]   = @(pi_)[@(k_)];
@ROUT C2blk 
                  @(pr_)[@(k_)]  = @(C_)@(c_)[@(ir_)];
                  @(pi_)[@(k_)]  = @(C_)@(c_)[@(ii_)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
                  @(C_)@(c_)[@(ir_)]   += @(pr_)[@(k_)];
                  @(C_)@(c_)[@(ii_)]   += @(pi_)[@(k_)];
@ROUT C2blk 
                  @(pr_)[@(k_)]  += @(C_)@(c_)[@(ir_)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
                  @(C_)@(c_)[@(ir_)]   = @(pr_)[@(k_)] - @(C_)@(c_)[@(ir_)];
                  @(C_)@(c_)[@(ii_)]   = @(pi_)[@(k_)] - @(C_)@(c_)[@(ii_)];
@ROUT C2blk 
                  @(pr_)[@(k_)]  = @(C_)@(c_)[@(ir_)] - @(pr_)[@(k_)];
                  @(pi_)[@(k_)]  = @(C_)@(c_)[@(ii_)] - @(pi_)[@(k_)];
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
               { 
                  const register @(typ) rc=@(C_)@(c_)[@(ir_)], 
                        ic=@(C_)@(c_)[@(ii_)];
                  register @(typ) rr=@(pr_)[@(k_)], ir=@(pi_)[@(k_)];
                  rr += rc * rb;
                  ir += ic * rb;
                  rr -= ic * ib;
                  ir += rc * ib;
                  @(C_)@(c_)[@(ir_)] = rr;
                  @(C_)@(c_)[@(ii_)] = ir;
               }
@ROUT C2blk 
               { 
                  const register @(typ) rc=@(pr_)[@(k_)], ic=@(pi_)[@(k_)];
                  register @(typ) rr=@(C_)@(c_)[@(ir_)], ir=@(C_)@(c_)[@(ii_)];
                  rr += rc * rb;
                  ir += ic * rb;
                  rr -= ic * ib;
                  ir += rc * ib;
                  @(pr_)[@(k_)] = rr;
                  @(pi_)[@(k_)] = ic;
               }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C 
               @(C_)@(c_)[@(ir_)]   = -@(pr_)[@(k_)];
               @(C_)@(c_)[@(ii_)]   = -@(pi_)[@(k_)];
@ROUT C2blk 
               @(pr_)[@(k_)]  = -@(C_)@(c_)[@(ir_)];
               @(pi_)[@(k_)]  = -@(C_)@(c_)[@(ii_)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
               @(C_)@(c_)[@(ir_)]   -= @(pr_)[@(k_)];
               @(C_)@(c_)[@(ii_)]   -= @(pi_)[@(k_)];
@ROUT C2blk 
               @(pr_)[@(k_)]  -= @(C_)@(c_)[@(ir_)];
               @(pi_)[@(k_)]  -= @(C_)@(c_)[@(ii_)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
               @(C_)@(c_)[@(ir_)]   = -@(C_)@(c_)[@(ir_)] - @(pr_)[@(k_)];
               @(C_)@(c_)[@(ii_)]   = -@(C_)@(c_)[@(ii_)] - @(pi_)[@(k_)];
@ROUT C2blk 
               @(pr_)[@(k_)]  = -@(C_)@(c_)[@(ir_)] - @(pr_)[@(k_)];
               @(pi_)[@(k_)]  = -@(C_)@(c_)[@(ii_)] - @(pi_)[@(k_)];
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
               { 
                  const register @(typ) rc=@(C_)@(c_)[@(ir_)], 
                        ic=@(C_)@(c_)[@(ii_)];
                  register @(typ) rr = -@(pr_)[@(k_)], ir = -@(pi_)[@(k_)];
                  rr += rc * rb;
                  ir += ic * rb;
                  rr -= ic * ib;
                  ir += rc * ib;
                  @(C_)@(c_)[@(ir_)] = rr;
                  @(C_)@(c_)[@(ii_)] = ir;
               }
@ROUT C2blk 
               { 
                  const register @(typ) rc=@(pr_)[@(k_)], ic=@(pi_)[@(k_)];
                  register @(typ) rr = -@(C_)@(c_)[@(ir_)], 
                           ir = -@(C_)@(c_)[@(ii_)];
                  rr += rc * rb;
                  ir += ic * rb;
                  rr -= ic * ib;
                  ir += rc * ib;
                  @(pr_)[@(k_)] = rr;
                  @(pi_)[@(k_)] = ic;
               }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C 
               { 
                  const register @(typ) rc=@(pr_)[@(k_)], ic=@(pi_)[@(k_)];
                  register @(typ) rr, ir;
                  rr = rc * ra;
                  ir = ic * ra;
                  rr -= ic * ia;
                  ir += rc * ia;
                  @(C_)@(c_)[@(ir_)] = rr;
                  @(C_)@(c_)[@(ii_)] = ir;
               }
@ROUT C2blk 
               { 
                  const register @(typ) rc=@(C_)@(c_)[@(ir_)], 
                        ic=@(C_)@(c_)[@(ii_)];
                  register @(typ) rr, ir;
                  rr  = rc * ra;
                  ir  = ic * ra;
                  rr -= ic * ia;
                  ir += rc * ia;
                  @(pr_)[@(k_)] = rr;
                  @(pi_)[@(k_)] = ir;
               }
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
               { 
                  const register @(typ) rc=@(pr_)[@(k_)], ic=@(pi_)[@(k_)];
                  register @(typ) rr=@(C_)@(c_)[@(ir_)], ir=@(C_)@(c_)[@(ii_)];
                  rr += rc * ra;
                  ir += ic * ra;
                  rr -= ic * ia;
                  ir += rc * ia;
                  @(C_)@(c_)[@(ir_)] = rr;
                  @(C_)@(c_)[@(ii_)] = ir;
               }
@ROUT C2blk 
               { 
                  const register @(typ) rc=@(C_)@(c_)[@(ir_)], 
                        ic=@(C_)@(c_)[@(ii_)];
                  register @(typ) rr=@(pr_)[@(k_)], ir=@(pi_)[@(k_)];
                  rr += rc * ra;
                  ir += ic * ra;
                  rr -= ic * ia;
                  ir += rc * ia;
                  @(pr_)[@(k_)] = rr;
                  @(pi_)[@(k_)] = ir;
               }
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
               { 
                  const register @(typ) rc=@(pr_)[@(k_)], ic=@(pi_)[@(k_)];
                  register @(typ) rr = -@(C_)@(c_)[@(ir_)], 
                           ir = -@(C_)@(c_)[@(ii_)];
                  rr += rc * ra;
                  ir += ic * ra;
                  rr -= ic * ia;
                  ir += rc * ia;
                  @(C_)@(c_)[@(ir_)] = rr;
                  @(C_)@(c_)[@(ii_)] = ir;
               }
@ROUT C2blk 
               { 
                  const register @(typ) rc=@(C_)@(c_)[@(ir_)], 
                        ic=@(C_)@(c_)[@(ii_)];
                  register @(typ) rr = -@(pr_)[@(k_)], ir = -@(pi_)[@(k_)];
                  rr += rc * ra;
                  ir += ic * ra;
                  rr -= ic * ia;
                  ir += rc * ia;
                  @(pr_)[@(k_)] = rr;
                  @(pi_)[@(k_)] = ir;
               }
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
               {
                  register @(typ) rc=@(C_)@(c_)[@(ir_)], ic=@(C_)@(c_)[@(ii_)];
                  register @(typ) rB=@(pr_)[@(k_)], iB=@(pi_)[@(k_)], r0, i0, 
                           r1, i1;
                  r0  = rb * rc;
                  r1  = ra * rB;
                  i0  = rb * ic;
                  i1  = ra * iB;
                  r0 -= ib * ic;
                  i1 += ib * rc;
                  r1 -= ia * iB;
                  i1 += ia * rB;
                  @(C_)@(c_)[@(ir_)] = r0 + r1;
                  @(C_)@(c_)[@(ii_)] = i0 + i1;
               }
@ROUT C2blk 
               {
                  register @(typ) rB=@(C_)@(c_)[@(ir_)], iB=@(C_)@(c_)[@(ii_)];
                  register @(typ) rc=@(pr_)[@(k_)], ic=@(pi_)[@(k_)], r0, i0, 
                           r1, i1;
                  r0  = rb * rc;
                  r1  = ra * rB;
                  i0  = rb * ic;
                  i1  = ra * iB;
                  r0 -= ib * ic;
                  i1 += ib * rc;
                  r1 -= ia * iB;
                  i1 += ia * rB;
                  @(pr_)[@(k_)] = r0 + r1;
                  @(pi_)[@(k_)] = i0 + i1;
               }
@ROUT blk2C C2blk
            @endiif
         @endiif
@ENDPROC
@SKIP handles full block
@BEGINPROC doBlock m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(j) @(mu) * @(i) +
         @callproc doElement @(j) @(ir) @(ii) C @(k) pr pi 
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(mu) @(mu) +
      @iif m_ = mu
            C@(j) += @(i);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles block Mu unrolled 
@BEGINPROC doBlockMuUR m_ cinc_
   @define i @dum@
         C0 = C; pr0 = pr; pi0 = pi;  
         for (jj=0; jj < nu; jj++, C0 += ldc2, pr0 += @(mu), pi0 += @(mu))
         {
      @iexp i 0
      @iwhile i < @(m_)
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @callproc doElement 0 @(ir) @(ii) C @(i) pr0 pi0 
         @iexp i @(i) 1 +
      @endiwhile
         }
      @iif cinc_ ! 0
         @iexp i @(mu) @(mu) +
         C += @(i);
      @endiif
   @undef i
@ENDPROC
@SKIP handles block Nu unrolled, m_=0 means NU cleanup rolled 
@BEGINPROC doBlockNuUR nu_
   @define j @dum@
         for (ii=0; ii < mu; ii++)
         {
            @iexp j 0
            @iwhile j < @(nu_)
               @callproc doElement @(j) 2*ii 2*ii+1 C @(mu)*@(j)+ii pr pi
               @iexp j @(j) 1 +
            @endiwhile
         }
   @undef j
@ENDPROC
@SKIP handles rolled blocks only   
@BEGINPROC doBlockRolled C_ mu_ nu_ cinc_  
   @define i @dum@
         { /* rolled block copy */
            unsigned int ii, jj; 
@ROUT blk2C `            @(typ) *rC0 = @(C_);`
@ROUT C2blk `            const @(typ) *rC0 = @(C_);`
@ROUT blk2C `            const @(typ) *rw = pr, *iw = pi;`
@ROUT C2blk `            @(typ) *rw = pr, *iw = pi;`
            for (jj=0; jj < @(nu_); jj++, rC0 += ldc2, rw += @(mu), iw += @(mu))
            {
               for (ii=0; ii < @(mu_); ii++)
               {
                  @callproc doElement 0 2*ii 2*ii+1 rC ii rw iw 
               }
            }
      @iif cinc_ ! 0
         @iexp i @(mu) @(mu) +
            @(C_) += @(i);
      @endiif
         }
   @undef i
@ENDPROC
@SKIP handles diagonal subblocks when mu=ma*nu
@SKIP IN: mu, nu, beta, alpha
@BEGINPROC doDiBlockmn m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define t @dum@
   @define sc @dum@
   @define ir @dum@
   @define ii @dum@
   @define jj @dum@
      switch (j%@(ma_))
      {
      @iexp sc 0
      @iwhile sc < @(ma_)
      case @(sc):
         @iexp j 0
         @iwhile j < @(n_)  
            @iexp i 0
            @iwhile i < @(m_) 
               @iexp k @(j) @(mu) * @(i) +
               @iexp t @(nu) @(sc) *
               @iexp t @(t) @(j) +
               @iif i < @(t) 
@ROUT C2blk    
                  @iexp jj @(m_) -1 +    
                  @iexp ir @(jj) @(jj) + 
                  @iexp ii @(ir) 1 + 
                  @callproc doElement @(j) @(ir) @(ii) C @(k) pr pi 
@ROUT C2blk blk2C
               @endiif
               @iif i } @(t)
                  @iexp ir @(i) @(i) + 
                  @iexp ii @(ir) 1 + 
                  @callproc doElement @(j) @(ir) @(ii) C @(k) pr pi
               @endiif
               @iexp i @(i) 1 +
            @endiwhile
         @iexp ir @(m_) @(m_) +
         @skip C@(j) += @(m_);
         C@(j) += @(ir);
            @iexp j @(j) 1 +
         @endiwhile
         break;
         @iexp sc @(sc) 1 +
      @endiwhile
      default:;
      }
   @undef jj
   @undef ii 
   @undef ir 
   @undef sc
   @undef t
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP diagonal block when nu > mu and nu = na * mu
@BEGINPROC doDikkBlockna n_ 
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define c @dum@
   @define r @dum@
   @define m @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(j) @(mu) * @(i) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j { i
@ROUT C2blk
         @iif j > i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j { i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
@ROUT blk2C C2blk
         @iexp ir @(r) @(r) + 
         @iexp ii @(ir) 1 + 
         @callproc doElement @(c) @(ir) @(ii) C @(k)+kk pr pi 
@ROUT blk2C
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            @iexp ir @(mu) @(mu) +
            @skip C@(j) += @(mu);
            C@(j) += @(ir);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef m
   @undef r
   @undef c
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP full blocks with multiplication 
@BEGINPROC donaBlock m_ n_ _
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define m @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(j) @(mu) * @(i) +
         @iexp ir @(i) @(i) + 
         @iexp ii @(ir) 1 + 
         @callproc doElement @(j) @(ir) @(ii) C @(k)+kk pr pi 
         @iexp i @(i) 1 +
      @endiwhile
      @iif m_ = mu
         @iexp ir @(mu) @(mu) + 
            C@(j) += @(ir);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef m
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles cleanup of diagonal subblocks when mu=ma*nu
@SKIP IN: mu, nu, beta, alpha,
@BEGINPROC doCuDiBlockmn m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define jj @dum@
   @define t @dum@
   @define sc @dum@
   @define m @dum@
      unsigned int kk;
      switch (j%@(ma_))
      {
      @iexp m @(ma_) -1 +
      @iexp sc 0
      @iwhile sc < @(m)
      case @(sc):
         @iexp j 0
         @iwhile j < @(n_)  
            @iexp i 0 
            @iwhile i < @(m_) 
               @iexp k @(j) @(mu) * @(i) +
               @iexp t @(nu) @(sc) *
               @iexp t @(t) @(j) +
@ROUT C2blk    
               @iif i < @(t) 
               @iexp jj @(i) 1 +    
            pr[@(k)] = 0.0;
            pi[@(k)] = 0.0;
               @endiif
@ROUT C2blk blk2C
               @iif i } @(t)
                  @skip "upper limit"
                  @iexp t @(sc) 1 +
                  @iexp t @(t) @(nu) *
                  @iif i < @(t)
                     @iexp ir @(i) @(i) + 
                     @iexp ii @(ir) 1 + 
            @callproc doElement @(j) @(ir) @(ii) C @(k) pr pi
                  @endiif
               @endiif
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
            @skip "now from nu to mu "
            @iexp jj @(sc) 1 +
            @iexp jj @(jj) @(n_) *
            for (kk=@(jj); kk < mr; kk++ )
            {
               @iexp jj 0
               @iwhile jj < @(n_)
                  @iexp t @(jj) @(m_) * 
                  @callproc doElement @(jj) (kk<<1) ((kk<<1)+1) C @(t)+kk pr pi
                  @iexp jj @(jj) 1 +
               @endiwhile
            }
            break;
         @iexp sc @(sc) 1 +
      @endiwhile
      default:;
      }
   @undef m
   @undef sc
   @undef t
   @undef jj
   @undef k
   @undef j
   @undef i
@ENDPROC
@ROUT blk2C C2blk
@iif TRI = 0 
/*
 * Main Loop:
 @iif bvML = 0
 * Both Rolled
 @endiif
 @iif ML_MUR ! 0
 * Mu unrolled
 @endiif
 @iif ML_NUR ! 0
 * Nu unrolled
 @endiif
 */
@iif cpvl = 1
void @(rtnm)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   const @(typ) *alpha, /* scalar for b */
   @ROUT blk2C
   const @(typ) *rC,    /* real block stored in @(mu)x@(nu)-major order */
   const @(typ) *iC,    /* imag block stored in @(mu)x@(nu)-major order */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *rC,          /* real block stored in @(mu)x@(nu)-major order */
   @(typ) *iC           /* imag block stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
@endiif
@iif cpvl > 1
static INLINE void a2c_1(const size_t M, const size_t N, const @(typ) alpha, 
                         const @(typ) *b, const SCALAR beta, 
                         @(typ) *C, ATL_CSZT ldc)
@endiif
{
@SKIP *********************** GEMM copy: complex type **************************
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   const unsigned int pansz = (nr) ? (nf+1)*@(bs) : nf*@(bs); /* bs=@(bs) */
   unsigned int i, j;
   @iif alpX ! 0
   const register @(typ) ra=(*alpha), ia=alpha[1];
   @endiif
   @iif betX ! 0
   const register @(typ) rb=(*beta), ib=beta[1];
   @endiif
   @iif ML_MUR = 0
   unsigned int ii, mu;
   const size_t incC = (ldc*@(nu) - ((M+@(mu)-1)/@(mu))*@(mu))<<1; 
   const size_t ldc2 = ldc+ldc;
   @endiif
   @iif ML_MUR ! 0
   const size_t incC = (ldc*@(nu) - m)<<1, ldc2 = ldc+ldc;
   @endiif
   @iif ML_NUR = 0
   unsigned int jj, nu;
   @endiif
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   @iif ML_NUR ! 0
   for (j=nf; j; j--, rC += @(bs), iC += @(bs))
   {
   @endiif
   @iif ML_NUR = 0
   for (j=0; j < N; j+=nu, rC += @(bs), iC += @(bs))
   {
@ROUT blk2C `      const @(typ) *pr0, *pi0;`
@ROUT C2blk `      @(typ) *pr0, *pi0;`
   @endiif
@ROUT blk2C `      const @(typ) *pr = rC, *pi = iC;`
@ROUT C2blk `      @(typ) *pr = rC, *pi = iC;`
   @iif ML_NUR = 0
      nu = N - j;
      nu = (nu > @(nu)) ? @(nu) : nu;
   @endiif
   @iif ML_MUR ! 0
      for (i=mf; i; i--, pr += pansz, pi += pansz)
      {
      @iif ML_MUNU ! 0
         @callproc doBlock @(mu) @(nu)
      @endiif
      @iif ML_MUNU = 0
         @callproc doBlockMuUR @(mu) 1
      @endiif
      }
   @endiif
   @iif ML_MUR = 0
      for (i=0; i < M; i += mu, pr += pansz, pi += pansz)
      {
         mu = M-i;
         mu = (mu >= @(mu)) ? @(mu) : mu;
         @iif ML_NO = 0
         @callproc doBlockNuUR @(nu)
      @iexp k @(mu) @(mu) +
      @iexp j 0
      @iwhile j < @(nu)
         C@(j) += @(k);
         @iexp j @(j) 1 +
      @endiwhile
         @endiif 
         @iif ML_NO ! 0 
         @callproc doBlockRolled C mu nu 1 
         @endiif
      }
   @endiif
@SKIP --- M cleanup: MU_UR and MUNU_UR  
   @iif ML_MUR ! 0 
      @iif CU_MUR = 0
      { /* clean up in M dimension */
         @iif ML_MUNU ! 0
         @callproc doBlockRolled C0 mr @(nu) 0  
         @endiif
         @iif ML_MUNU = 0
         @callproc doBlockRolled C mr nu 0  
         @endiif
      }
      @endiif
      @iif CU_MUR ! 0
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
         @iif ML_MUNU ! 0
      @callproc doBlock @(m) @(nu)
         @endiif
         @iif ML_MUNU = 0
      @callproc doBlockMuUR @(m) 0
         @endiif
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
      @endiif
   @endiif
   @iif ML_NUR ! 0
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
   @endiif
   @iif ML_NUR = 0
      C += incC;
   @endiif
   }
@SKIP --- N cleanup
   @iif ML_NUR ! 0
      @iif nu > 1
         @iif CU_NUR = 0
   { /* Cleanup in N dimension */
@ROUT blk2C `      const @(typ) *pr = rC, *pi = iC;`
@ROUT C2blk `      @(typ) *pr = rC, *pi = rC;`
            @iif ML_MUNU ! 0
      unsigned int mu;
            @endiif
      C += ((ldc * n)<<1);  
      for (i=0; i < M; i += mu, pr += pansz, pi += pansz)
      {
         mu = ((M-i) >= @(mu)) ? @(mu) : (M-i);
         @callproc doBlockRolled C mu nr 1
      }
   }
         @endiif
         @iif CU_NUR ! 0
   switch(nr)
   {
@ROUT blk2C `      const @(typ) *pr, *pi;`
@ROUT C2blk `      @(typ) *pr, *pi;`
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      pr = rC; pi = iC;
            @iif ML_MUNU ! 0
      for (i=0; i < mf; i++, pr += pansz, pi += pansz)
      {
         @callproc doBlock @(mu) @(n)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @callproc doBlock @(m) @(n)
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
            @endiif
            @iif ML_MUNU = 0
      for (i=0; i < M; i += mu, pr += pansz, pi += pansz)
      {
         mu = ((M-i) >= @(mu)) ? @(mu) : (M-i);
         @callproc doBlockNuUR @(n)          
      @iexp k @(mu) @(mu) +
      @iexp j 0
      @iwhile j < @(n)
         C@(j) += @(k);
         @iexp j @(j) 1 +
      @endiwhile
      }
            @endiif
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
         @endiif
      @endiif
   @endiif
}
@endiif
@SKIP ***************** SYRK copy: complex type ********************************
@iif TRI = 1
@SKIP handles diagonal block when mu=nu
@SKIP IN: mu, nu, beta, alpha
@BEGINPROC doDiBlock n_
   @define i @dum@
   @define ir @dum@
   @define ii @dum@
   @define j @dum@
   @define k @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
@ROUT C2blk 
         @iif j > i
            @iexp ir @(j) @(j) +
            @define h @@(i)@
         @endiif
         @iif j { i
            @iexp ir @(i) @(i) +
            @define h @@(j)@
         @endiif
         @iexp ii @(ir) 1 +
         @iexp k @(j) @(mu) * @(i) +
@ROUT blk2C 
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(j) @(mu) * @(i) +
         @iif j { i
@ROUT blk2C C2blk
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C 
            C@(j)[@(ir)] = pr[@(k)];  
            C@(j)[@(ii)] = pi[@(k)];
@ROUT C2blk 
            pr[@(k)] = C@(h)[@(ir)];
            pi[@(k)] = C@(h)[@(ii)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(j)[@(ir)] += pr[@(k)];
            C@(j)[@(ii)] += pi[@(k)];
@ROUT C2blk 
            pr[@(k)] += C@(h)[@(ir)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(j)[@(ir)] = pr[@(k)] - C@(j)[@(ir)];
            C@(j)[@(ii)] = pi[@(k)] - C@(j)[@(ii)];
@ROUT C2blk 
            pr[@(k)] = C@(h)[@(ir)] - pr[@(k)];
            pi[@(k)] = C@(h)[@(ii)] - pi[@(k)];
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rr=pr[@(k)], ir=pi[@(k)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr=C@(h)[@(ir)], ir=C@(h)[@(ii)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               pr[@(k)] = rr;
               pi[@(k)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C 
            C@(j)[@(ir)] = -pr[@(k)];
            C@(j)[@(ii)] = -pi[@(k)];
@ROUT C2blk 
            pr[@(k)] = -C@(h)[@(ir)];
            pi[@(k)] = -C@(h)[@(ii)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(j)[@(ir)] -= pr[@(k)];
            C@(j)[@(ii)] -= pi[@(k)];
@ROUT C2blk 
            pr[@(k)] -= C@(h)[@(ir)];
            pi[@(k)] -= C@(h)[@(ii)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(j)[@(ir)] = -C@(j)[@(ir)] - pr[@(k)];
            C@(j)[@(ii)] = -C@(j)[@(ii)] - pi[@(k)];
@ROUT C2blk 
            pr[@(k)] = -C@(h)[@(ir)] - pr[@(k)];
            pi[@(k)] = -C@(h)[@(ii)] - pi[@(k)];
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rr = -pr[@(k)], ir = -pi[@(k)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr = -C@(h)[@(ir)], ir = -C@(h)[@(ii)];
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               pr[@(k)] = rr;
               pi[@(k)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr, ir;
               rr = rc * ra;
               ir = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(h)[@(ir)], ic=C@(h)[@(ii)];
               register @(typ) rr, ir;
               rr  = rc * ra;
               ir  = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k)] = rr;
               pi[@(k)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr=C@(j)[@(ir)], ir=C@(j)[@(ii)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(h)[@(ir)], ic=C@(h)[@(ii)];
               register @(typ) rr=pr[@(k)], ir=pi[@(k)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k)] = rr;
               pi[@(k)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            { 
               const register @(typ) rc=pr[@(k)], ic=pi[@(k)];
               register @(typ) rr = -C@(j)[@(ir)], ir = -C@(j)[@(ii)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(j)[@(ir)] = rr;
               C@(j)[@(ii)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(h)[@(ir)], ic=C@(h)[@(ii)];
               const register @(typ) rr = -pr[@(k)], ir = -pi[@(k)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               pr[@(k)] = rr;
               pi[@(k)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            {
               register @(typ) rc=C@(j)[@(ir)], ic=C@(j)[@(ii)];
               register @(typ) rB=pr[@(k)], iB=pi[@(k)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               C@(j)[@(ir)] = r0 + r1;
               C@(j)[@(ii)] = i0 + i1;
            }
@ROUT C2blk 
            {
               register @(typ) rB=C@(h)[@(ir)], iB=C@(h)[@(ii)];
               register @(typ) rc=pr[@(k)], ic=pi[@(k)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               pr[@(k)] = r0 + r1;
               pi[@(k)] = i0 + i1;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
@ROUT blk2C
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(mu) @(mu) +
      @iif n_ = mu
            C@(j) += @(i);
      @endiif
@ROUT C2blk `      @undef h`
      @iexp j @(j) 1 +
   @endiwhile
   @undef k
   @undef ii
   @undef ir
   @undef j
   @undef i 
@ENDPROC
@SKIP handles diagonal subblocks when mu=ma*nu
@SKIP IN: mu, nu, beta, alpha
@BEGINPROC doDiBlockmn m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define t @dum@
   @define sc @dum@
   @define ir @dum@
   @define ii @dum@
   @define jj @dum@
      switch (j%@(ma_))
      {
      @iexp sc 0
      @iwhile sc < @(ma_)
      case @(sc):
         @iexp j 0
         @iwhile j < @(n_)  
            @iexp i 0
            @iwhile i < @(m_) 
               @iexp k @(j) @(mu) * @(i) +
               @iexp t @(nu) @(sc) *
               @iexp t @(t) @(j) +
               @iif i < @(t) 
@ROUT C2blk    
                  @iexp jj @(m_) -1 +    
                  @iexp ir @(jj) @(jj) + 
                  @iexp ii @(ir) 1 + 
                  @callproc doElement @(j) @(ir) @(ii) C @(k) pr pi 
@ROUT C2blk blk2C
               @endiif
               @iif i } @(t)
                  @iexp ir @(i) @(i) + 
                  @iexp ii @(ir) 1 + 
                  @callproc doElement @(j) @(ir) @(ii) C @(k) pr pi
               @endiif
               @iexp i @(i) 1 +
            @endiwhile
         @iexp ir @(m_) @(m_) +
         @skip C@(j) += @(m_);
         C@(j) += @(ir);
            @iexp j @(j) 1 +
         @endiwhile
         break;
         @iexp sc @(sc) 1 +
      @endiwhile
      default:;
      }
   @undef jj
   @undef ii 
   @undef ir 
   @undef sc
   @undef t
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP diagonal block when nu > mu and nu = na * mu
@BEGINPROC doDikkBlockna n_ 
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define c @dum@
   @define r @dum@
   @define m @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(j) @(mu) * @(i) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j { i
@ROUT C2blk
         @iif j > i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j { i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
@ROUT blk2C C2blk
         @iexp ir @(r) @(r) + 
         @iexp ii @(ir) 1 + 
         @callproc doElement @(c) @(ir) @(ii) C @(k)+kk pr pi 
@ROUT blk2C
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            @iexp ir @(mu) @(mu) +
            @skip C@(j) += @(mu);
            C@(j) += @(ir);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef m
   @undef r
   @undef c
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP full blocks with multiplication 
@BEGINPROC donaBlock m_ n_ 
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define m @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp k @(j) @(mu) * @(i) +
         @iexp ir @(i) @(i) + 
         @iexp ii @(ir) 1 + 
         @callproc doElement @(j) @(ir) @(ii) C @(k)+kk pr pi 
         @iexp i @(i) 1 +
      @endiwhile
      @iif m_ = mu
         @iexp ir @(mu) @(mu) + 
            C@(j) += @(ir);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef m
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles cleanup of diagonal subblocks when mu=ma*nu
@SKIP IN: mu, nu, beta, alpha,
@BEGINPROC doCuDiBlockmn m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define jj @dum@
   @define t @dum@
   @define sc @dum@
   @define m @dum@
      unsigned int kk;
      switch (j%@(ma_))
      {
      @iexp m @(ma_) -1 +
      @iexp sc 0
      @iwhile sc < @(m)
      case @(sc):
         @iexp j 0
         @iwhile j < @(n_)  
            @iexp i 0 
            @iwhile i < @(m_) 
               @iexp k @(j) @(mu) * @(i) +
               @iexp t @(nu) @(sc) *
               @iexp t @(t) @(j) +
@ROUT C2blk    
               @iif i < @(t) 
               @iexp jj @(i) 1 +    
            pr[@(k)] = 0.0;
            pi[@(k)] = 0.0;
               @endiif
@ROUT C2blk blk2C
               @iif i } @(t)
                  @skip "upper limit"
                  @iexp t @(sc) 1 +
                  @iexp t @(t) @(nu) *
                  @iif i < @(t)
                     @iexp ir @(i) @(i) + 
                     @iexp ii @(ir) 1 + 
            @callproc doElement @(j) @(ir) @(ii) C @(k) pr pi
                  @endiif
               @endiif
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
            @skip "now from nu to mu "
            @iexp jj @(sc) 1 +
            @iexp jj @(jj) @(n_) *
            for (kk=@(jj); kk < mr; kk++ )
            {
               @iexp jj 0
               @iwhile jj < @(n_)
                  @iexp t @(jj) @(m_) * 
                  @callproc doElement @(jj) (kk<<1) ((kk<<1)+1) C @(t)+kk pr pi
                  @iexp jj @(jj) 1 +
               @endiwhile
            }
            break;
         @iexp sc @(sc) 1 +
      @endiwhile
      default:;
      }
   @undef m
   @undef sc
   @undef t
   @undef jj
   @undef k
   @undef j
   @undef i
@ENDPROC
@iif cpvl = 1
void @(rtnm)
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   const @(typ) *alpha, /* scalar for b */
   @ROUT blk2C
   const @(typ) *rC,    /* real block stored in @(mu)x@(nu)-major order */
   const @(typ) *iC,    /* imag block stored in @(mu)x@(nu)-major order */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *rC,          /* real block stored in @(mu)x@(nu)-major order */
   @(typ) *iC           /* imag block stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
@endiif
@iif cpvl > 1
static INLINE void a2c_1(const size_t M, const size_t N, const @(typ) alpha, 
                         const @(typ) *b, const SCALAR beta, 
                         @(typ) *C, ATL_CSZT ldc)
@endiif
{
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   @iif mEn = 1
   unsigned int pansz = @(bs);
   const size_t ldc2 = ldc+ldc, incC0 = (ldc2+2)*@(nu);
   @endiif
   @iif mEn = 0
      @skip "*** case mu = ma*nu"
      @iif ma ! 1
   unsigned int pansz = @(bs)*@(ma);
   const unsigned int manf = (N/(@(nu)*@(ma)))*@(ma);
   const unsigned int manr = nf - manf;
   const size_t ldc2 = ldc+ldc, incC0 = ldc2*@(nu);
      @endiif 
      @skip "*** special case for nu = na * mu"
      @iif na ! 1
   unsigned int pansz = @(bs);
   const size_t ldc2 = ldc+ldc, incC0 = (ldc2+2)*@(nu);
   const unsigned int mnf = N/@(mu);
   const unsigned int mnr = N - (mnf*@(mu));
   unsigned int kk; 
      @endiif
   @endiif
   unsigned int i, j;
   @iif alpX ! 0
   const register @(typ) ra=(*alpha), ia=alpha[1];
   @endiif
   @iif betX ! 0
   const register @(typ) rb=(*beta), ib=beta[1];
   @endiif
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
@iif na = 1
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif na ! 1
      @define j @1@
      @iwhile j < @(mu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
   @iif mEn = 1
   for (j=0; j < nf; j++)
   @endiif
   @iif mEn = 0
      @iif ma ! 1
   size_t incC;
   for (j=0; j < manf; j++)
      @endiif
      @iif na ! 1
   for (j=0; j < mnf; j++)
      @endiif
   @endiif
   {
@ROUT blk2C `      const @(typ) *pr = rC, *pi = iC;`
@ROUT C2blk `      @(typ) *pr = rC, *pi = iC;`
   @iif mEn = 1
      unsigned int psz = pansz+@(bs), incC = incC0 - (mf-j)*(@(mu)+@(mu));
      @callproc doDiBlock @(nu)
      pr += pansz; pi += pansz;
      for (i=j+1; i < mf; i++, pr += psz, pi += psz, psz += @(bs))
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      unsigned int psz = pansz + @(ma)*@(bs); 
      incC = incC0 - (mf-(j+1)/@(ma))*(@(mu)+@(mu));
      @callproc doDiBlockmn @(mu) @(nu) @(ma)
      pr += pansz; pi += pansz;
      for (i=j/@(ma)+1; i < mf; i++, pr += psz, pi += psz, psz += @(bs)*@(ma))
      @endiif
      @iif na ! 1
      unsigned int psz = pansz, incC = incC0 - (mf-j)*@(mu);
      kk = j % @(na);
      @iexp mumu @(mu) @(mu) *
      kk *= @(mumu);
      @callproc doDikkBlockna @(mu) 
      pr += pansz; pi += pansz;
      for (i=j+1; i < mf; i++, pr += psz, pi += psz )
      @endiif
   @endiif
@iif na = 1
      {
         @callproc doBlock @(mu) @(nu)
      }
@endiif
@iif na ! 1
      {
         @callproc donaBlock @(mu) @(mu) 
         psz += ((i%@(na))==0?@(bs):0);
      }
@endiif
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
@iif na = 1
      @callproc doBlock @(m) @(nu)
@endiif
@iif na ! 1
      @callproc donaBlock @(m) @(mu) 
@endiif
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
@iif na = 1
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
@endiif
@iif na ! 1
   @iexp j 0
   @iwhile j < @(mu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
@endiif
   @iif mEn = 1
      pansz += @(bs);
      rC += pansz;
      iC += pansz;
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      rC += ((j+1)% @(ma))==0 ? pansz+@(bs) : @(bs);
      iC += ((j+1)% @(ma))==0 ? pansz+@(bs) : @(bs);
      if ( (j+1) % @(ma) == 0)
         pansz += @(ma)*@(bs);
      @endiif
      @iif na ! 1
      pansz += ((j+1)%@(na)==0?@(bs):0);
      rC += pansz;
      iC += pansz;
      @endiif
   @endiif
   }
   @SKIP "Remainder of manr = nf - manf " 
   @iif mEn = 0
      @iif ma ! 1
   for (j=manf; j < nf; j++)
   {
@ROUT blk2C `      const @(typ) *pr = rC, *pi = iC;`
@ROUT C2blk `      @(typ) *pr = rC, *pi = iC;`
      unsigned int psz = pansz + @(ma)*@(bs), 
                         incC = incC0 - ((mf-(j+1)/@(ma))<<1)*@(mu);
         @callproc doCuDiBlockmn @(mu) @(nu) @(ma)
      pr += pansz;
      pi += pansz;
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      rC += ((j+1)% @(ma))==0 ? pansz+@(bs) : @(bs);
      iC += ((j+1)% @(ma))==0 ? pansz+@(bs) : @(bs);
      if ( (j+1) % @(ma) == 0)
         pansz += @(ma)*@(bs);
   }
         @endiif
      @endiif
@iif na = 1
   @iif nu > 1
   switch(nr)
   {
@ROUT blk2C `      const @(typ) *pr, *pi;`
@ROUT C2blk `      @(typ) *pr, *pi;`
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      pr = rC; pi = iC;
   @iif mEn = 1
      @callproc doDiBlock @(n)
   @endiif
   @iif mEn = 0
      @iif ma ! 1
         pr += mr - nr; pi += mr - nr; 
         @iexp k 0
         @iwhile k < @(n)
            @skip ---C@(k) += mr-nr;
            C@(k) += ((mr-nr)<<1);
            @iexp k @(k) 1 +
         @endiwhile
         @skip "for nr cleanup, it works like mu=nu"
         @callproc doDiBlock @(n)
      @endiif
   @endiif
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endiif
@endiif
@iif na ! 1
   @iif mu > 1
   kk = mnf % @(na);
   kk *= @(mumu);
   switch(mnr)
   {
@ROUT blk2C `      const @(typ) *pr, *pi;`
@ROUT C2blk `      @(typ) *pr, *pi;`
   @iexp n 1
   @iwhile n < @(mu)
   case @(n):
      pr= rC;
      pi =iC;
      @callproc doDikkBlockna @(n) 
         break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endiif
@endiif
}
@SKIP ***************** SYRK L2UT : complex type *******************************
@SKIP handles single element 
@BEGINPROC doElementT c_ ir_ ii_ k_ 
         @iif alpha = 1
            @iif beta = 0
@ROUT blk2C 
            C@(c_)[@(ir_)] = rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] = -iC[@(k_)];
            #else
               C@(c_)[@(ii_)] = iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] = C@(c_)[@(ir_)];
            #ifdef Conj_
               iC[@(k_)] = -C@(c_)[@(ii_)];
            #else
               iC[@(k_)] = C@(c_)[@(ii_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(c_)[@(ir_)] += rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] -= iC[@(k_)];
            #else
               C@(c_)[@(ii_)] += iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] += C@(c_)[@(ir_)];
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(c_)[@(ir_)] = rC[@(k_)] - C@(c_)[@(ir_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] = -iC[@(k_)] - C@(c_)[@(ii_)];
            #else
               C@(c_)[@(ii_)] = iC[@(k_)] - C@(c_)[@(ii_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] = C@(c_)[@(ir_)] - rC[@(k_)];
            #ifdef Conj_
               iC[@(k_)] = C@(c_)[@(ii_)] + iC[@(k_)];
            #else
               iC[@(k_)] = C@(c_)[@(ii_)] - iC[@(k_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rr=rC[@(k_)];
               #ifdef Conj_
                  register @(typ) ir = -iC[@(k_)];
               #else
                  register @(typ) ir =  iC[@(k_)];
               #endif
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=rC[@(k_)], ic=iC[@(k_)];
               register @(typ) rr=C@(c_)[@(ir_)];
               #ifdef Conj_
                  register @(typ) ir = -C@(c_)[@(ii_)];
               #else
                  register @(typ) ir =  C@(c_)[@(ii_)];
               #endif
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               rC[@(k_)] = rr;
               iC[@(k_)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif alpha = -1
            @iif beta = 0
@ROUT blk2C 
            C@(c_)[@(ir_)] = -rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] = iC[@(k_)];
            #else
               C@(c_)[@(ii_)] = -iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] = -C@(c_)[@(ir_)];
            #ifdef Conj_
               iC[@(k_)] = C@(c_)[@(ii_)];
            #else
               iC[@(k_)] = -C@(c_)[@(ii_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            C@(c_)[@(ir_)] -= rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] += iC[@(k_)];
            #else
               C@(c_)[@(ii_)] -= iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] -= C@(c_)[@(ir_)];
            #ifdef Conj_
               iC[@(k_)] += C@(c_)[@(ii_)];
            #else
               iC[@(k_)] -= C@(c_)[@(ii_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            C@(c_)[@(ir_)] = -C@(c_)[@(ir_)] - rC[@(k_)];
            #ifdef Conj_
               C@(c_)[@(ii_)] = iC[@(k_)] - C@(c_)[@(ii_)];
            #else
               C@(c_)[@(ii_)] = -C@(c_)[@(ii_)] - iC[@(k_)];
            #endif
@ROUT C2blk 
            rC[@(k_)] = -C@(c_)[@(ir_)] - rC[@(k_)];
            #ifdef Conj_
               iC[@(k_)] = C@(c_)[@(ii_)] - iC[@(k_)];
            #else
               iC[@(k_)] = -C@(c_)[@(ii_)] - iC[@(k_)];
            #endif
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rr = -rC[@(k_)];
               #ifdef Conj_
                  register @(typ) ir = iC[@(k_)];
               #else
                  register @(typ) ir = -iC[@(k_)];
               #endif
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=rC[@(k_)], ic=iC[@(k_)];
               register @(typ) rr = -C@(c_)[@(ir_)];
               #ifdef Conj_
                  register @(typ) ir =  C@(c_)[@(ii_)];
               #else
                  register @(typ) ir = -C@(c_)[@(ii_)];
               #endif
               rr += rc * rb;
               ir += ic * rb;
               rr -= ic * ib;
               ir += rc * ib;
               rC[@(k_)] = rr;
               iC[@(k_)] = ic;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
         @iif @iexp @(alpha) 1 ! @(alpha) -1 ! &
            @iif beta = 0
@ROUT blk2C 
            { 
               const register @(typ) rc=rC[@(k_)];
               #ifdef Conj_
                  const register @(typ) ic = -iC[@(k_)];
               #else
                  const register @(typ) ic =  iC[@(k_)];
               #endif
               register @(typ) rr, ir;
               rr = rc * ra;
               ir = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)];
               #ifdef Conj_
                  const register @(typ) ic = -C@(c_)[@(ii_)];
               #else
                  const register @(typ) ic =  C@(c_)[@(ii_)];
               #endif
               register @(typ) rr, ir;
               rr  = rc * ra;
               ir  = ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               rC[@(k_)] = rr;
               iC[@(k_)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = 1
@ROUT blk2C 
            { 
               const register @(typ) rc=rC[@(k_)];
               #ifdef Conj_
                  const register @(typ) ic = -iC[@(k_)];
               #else
                  const register @(typ) ic =  iC[@(k_)];
               #endif
               register @(typ) rr=C@(c_)[@(ir_)], ir=C@(c_)[@(ii_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)];
               #ifdef Conj_
                  const register @(typ) ic = -C@(c_)[@(ii_)];
               #else
                  const register @(typ) ic =  C@(c_)[@(ii_)];
               #endif
               register @(typ) rr=rC[@(k_)], ir=iC[@(k_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               rC[@(k_)] = rr;
               iC[@(k_)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif beta = -1
@ROUT blk2C 
            { 
               const register @(typ) rc=rC[@(k_)];
               #ifdef Conj_
                  const register @(typ) ic = -iC[@(k_)];
               #else
                  const register @(typ) ic =  iC[@(k_)];
               #endif
               register @(typ) rr = -C@(c_)[@(ir_)], ir = -C@(c_)[@(ii_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               C@(c_)[@(ir_)] = rr;
               C@(c_)[@(ii_)] = ir;
            }
@ROUT C2blk 
            { 
               const register @(typ) rc=C@(c_)[@(ir_)];
               #ifdef Conj_
                  const register @(typ) ic = -C@(c_)[@(ii_)];
               #else
                  const register @(typ) ic =  C@(c_)[@(ii_)];
               #endif
               register @(typ) rr = -rC[@(k_)], ir = -iC[@(k_)];
               rr += rc * ra;
               ir += ic * ra;
               rr -= ic * ia;
               ir += rc * ia;
               rC[@(k_)] = rr;
               iC[@(k_)] = ir;
            }
@ROUT blk2C C2blk
            @endiif
            @iif @iexp @(beta) 0 ! @(beta) 1 ! & @(beta) -1 ! &
@ROUT blk2C 
            {
               register @(typ) rc=C@(c_)[@(ir_)], ic=C@(c_)[@(ii_)];
               register @(typ) rB=rC[@(k_)], r0, i0, r1, i1;
               #ifdef Conj_
                  register @(typ) iB = -iC[@(k_)];
               #else
                  register @(typ) iB =  iC[@(k_)];
               #endif
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               C@(c_)[@(ir_)] = r0 + r1;
               C@(c_)[@(ii_)] = i0 + i1;
            }
@ROUT C2blk 
            {
               register @(typ) rB=C@(c_)[@(ir_)];
               #ifdef Conj_
                  register @(typ) iB = -C@(c_)[@(ii_)];
               #else
                  register @(typ) iB =  C@(c_)[@(ii_)];
               #endif
               register @(typ) rc=rC[@(k_)], ic=iC[@(k_)], r0, i0, r1, i1;
               r0  = rb * rc;
               r1  = ra * rB;
               i0  = rb * ic;
               i1  = ra * iB;
               r0 -= ib * ic;
               i1 += ib * rc;
               r1 -= ia * iB;
               i1 += ia * rB;
               rC[@(k_)] = r0 + r1;
               iC[@(k_)] = i0 + i1;
            }
@ROUT blk2C C2blk
            @endiif
         @endiif
@ENDPROC
@SKIP handles full subblock
@BEGINPROC doBlockT m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu) * @(j) +
            @callproc doElementT @(j) @(ir) @(ii) @(k) 
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(mu) @(mu) +
      @iif m_ = mu
            C@(j) += @(i);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP hanldes blocks with offset kk
@BEGINPROC doBlockTkk m_ n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu) * @(j) +
         @callproc doElementT @(j) @(ir) @(ii) kk+@(k)  
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(m_) @(m_) +
            C@(j) += @(i);
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles full block when nu=na*mu
@BEGINPROC doBlockTna m_ n_ mu_ inc_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu_) * @(j) +
         @callproc doElementT @(j) @(ir) @(ii) @(k)  
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(inc_) @(inc_) +
            C@(j) += @(i);
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles diagonal blocks
@BEGINPROC doDiBlockT n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
@ROUT C2blk 
         @iif j < i
            @iexp ir @(j) @(j) +
            @define h @@(i)@
         @endiif
         @iif j } i
            @iexp ir @(i) @(i) +
            @define h @@(j)@
         @endiif
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu) * @(j) +
            @callproc doElementT @(h) @(ir) @(ii) @(k) 
@ROUT blk2C 
         @iexp ir @(i) @(i) +
         @iexp ii @(ir) 1 +
         @iexp k @(i) @(mu) * @(j) +
         @iif j } i
            @callproc doElementT @(j) @(ir) @(ii) @(k) 
         @endiif
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
         @iexp i @(mu) @(mu) +
            C@(j) += @(i);
      @endiif
@ROUT C2blk `      @undef h`
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef k
   @undef j
   @undef i
@ENDPROC
@skip handles diagonal block with offset kk
@BEGINPROC doDiBlockTkk n_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(i) @(mu) * @(j) +
@ROUT blk2C
         @iexp r @(i)
         @iexp c @(j)
         @iif j } i
         @iexp ir @(r) @(r) +
         @iexp ii @(ir) 1 +
      @callproc doElementT @(c) @(ir) @(ii) kk+@(k)
         @endiif
@ROUT C2blk
         @iif j < i
            @iexp r @(j)
            @iexp c @(i)
         @endiif
         @iif j } i
            @iexp r @(i)
            @iexp c @(j)
         @endiif
         @iexp ir @(r) @(r) +
         @iexp ii @(ir) 1 +
      @callproc doElementT @(c) @(ir) @(ii) kk+@(k)
@ROUT blk2C C2blk
         @iexp i @(i) 1 +
      @endiwhile
      @iif n_ = mu
            @iexp i @(mu) @(mu) +
            C@(j) += @(i);
      @endiif
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef k
   @undef j
   @undef i
@ENDPROC
@skip  hanldes diagonal cleanup when mu=ma*nu
@SKIP IN: mu, nu, beta, alpha,
@BEGINPROC doCuDiBlockT m_ n_ ma_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define sc @dum@
   @define t @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp sc 0
   @iwhile sc < @(ma_)
      case @(sc):
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(n_)
         @iexp k @(i) @(m_) *
         @iexp t @(sc) @(n_) *
         @iexp k @(k) @(t) +
         @iexp k @(k) @(j) +
         @iif j } i
            @iexp ir @(i) @(i) +
            @iexp ii @(ir) 1 +
            @callproc doElementT @(j) @(ir) @(ii) @(k)
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
      @iexp i @(n_) @(n_) +
         C@(j) += @(i);
      @iexp j @(j) 1 +
   @endiwhile
         break;
      @iexp sc @(sc) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef t
   @undef sc
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP handles partial block when nu=na*mu 
@BEGINPROC doDiBlockTna m_ n_ mu_ nu_ inc_ sc_
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define t @dum@
   @define ir @dum@
   @define ii @dum@
   @iexp j 0
   @iwhile j < @(n_)
      @iexp i 0
      @iwhile i < @(m_)
         @iexp t @(nu_) @(sc_) *
         @iexp t @(t) @(j) +
         @iexp k @(i) @(mu_) * @(j) +
@ROUT C2blk
         @iif i > @(t)
         pr[@(k)] = 0.0;
         pi[@(k)] = 0.0;
         @endiif
@ROUT C2blk blk2C
         @iif i { @(t)
            @iexp t @(sc_) 1 +
            @iexp t @(t) @(nu_) *
            @iif i < @(t)
               @iexp ir @(i) @(i) +
               @iexp ii @(ir) 1 +
         @callproc doElementT @(j) @(ir) @(ii) @(k)  
            @endiif   
         @endiif
         @iexp i @(i) 1 +
      @endiwhile
         @iexp i @(inc_) @(inc_) +
            C@(j) += @(i);
      @iexp j @(j) 1 +
   @endiwhile
   @undef ii
   @undef ir
   @undef t
   @undef k
   @undef j
   @undef i
@ENDPROC
@ROUT C2blk `#if 0`
#ifndef Mjoin
   #define Mjoin(pre, nam) my_join(pre, nam)
   #define my_join(pre, nam) pre ## nam
#endif
/*
 * The block is assumed to store L, this function does a transpose while
 * copying so that it is transferred with Upper portion of C
 */
#ifdef Conj_
void Mjoin(ATL_USERCPMM,_L2UH)
#else
void Mjoin(ATL_USERCPMM,_L2UT)
#endif
(
   const size_t M,      /* number of rows in A */
   const size_t N,      /* number of columns in A */
   const @(typ) *alpha, /* scalar for b */
   @ROUT blk2C
   const @(typ) *rC,    /* real block stored in @(mu)x@(nu)-major order */
   const @(typ) *iC,    /* imag block stored in @(mu)x@(nu)-major order */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *C,           /* matrix to be copied to access-major format */
   const size_t ldc     /* stride between row elements */
   @ROUT C2blk
   const @(typ) *C,     /* matrix to be copied to access-major format */
   const size_t ldc,    /* stride between row elements */
   const @(typ) *beta,  /* scalar for C */
   @(typ) *rC,          /* real block stored in @(mu)x@(nu)-major order */
   @(typ) *iC           /* imag block stored in @(mu)x@(nu)-major order */
   @ROUT C2blk blk2C
)
{
   const unsigned int mf = M/@(mu), nf = N/@(nu);
   const unsigned int m = mf*@(mu), n = nf*@(nu), mr = M-m, nr = N-n;
   unsigned int i, j;
   @iif alpX ! 0
   const register @(typ) ra=(*alpha), ia=alpha[1];
   @endiif
   @iif betX ! 0
   const register @(typ) rb=(*beta), ib=beta[1];
   @endiif
@iif na = 1      
   const size_t ldc2 = ldc+ldc, incC0 = ldc2*@(nu);
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif na ! 1      
   const size_t ldc2 = ldc+ldc, incC0 = ldc2*@(mu);
@ROUT blk2C `   @declare "   @(typ) " n n ";"`
@ROUT C2blk `   @declare "   const @(typ) " n n ";"`
      *C0=C
      @define j @1@
      @iwhile j < @(mu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif mEn = 0
   @iif ma ! 1
   unsigned int pansz = @(ma)*@(bs);
@ROUT blk2C `   const @(typ) *pr = rC, *pi = iC;` 
@ROUT C2blk `   @(typ) *pr = rC, *pi = iC;` 
   int kk;
   @endiif
@endiif
@iif na = 1
   for (j=0; j < nf; j++)
   {
      unsigned int incC = incC0 - ((j+1)<<1)*@(nu);
      @iif mEn = 0
         @iif ma ! 1
      rC = pr; iC = pi;
      kk = j % @(ma);
      kk *= @(nu);
         @endiif
      @endiif
      for (i=0; i < j; i++, rC += @(bs), iC += @(bs))
      {
      @iif mEn = 1
         @callproc doBlockT @(mu) @(nu)
      @endiif
      @iif mEn = 0
         @iif ma ! 1
         @callproc doBlockTkk @(nu) @(nu) 
         @endiif
      @endiif
      }
   @iif mEn = 1
      @callproc doDiBlockT @(nu)
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      rC += @(bs); iC += @(bs); 
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      switch(j%@(ma))
      {
      @callproc doCuDiBlockT @(mu) @(nu) @(ma)
      default:;
      }
   @iexp j 0
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      pr += ((j+1)%@(ma)==0? pansz: 0);
      pi += ((j+1)%@(ma)==0? pansz: 0);
      pansz += ((j+1)%@(ma)==0? @(ma)*@(bs):0);
      @endiif
   @endiif
   }
@endiif
@iif na ! 1
   for (j=0; j < mf; j++)
   {
      size_t incC = incC0 - ((j/@(na)+1)*@(nu))>>1;
      for (i=0; i < j/@(na); i++, rC+=@(bs), iC+=@(bs))
      {
         @callproc doBlockTna @(nu) @(mu) @(mu) @(nu)
      }
      switch(j%@(na))
      {
      @iexp n 0
      @iwhile n < @(na)
      case @(n):
         @callproc doDiBlockTna @(nu) @(mu) @(mu) @(mu) @(nu) @(n)
      break;
         @iexp n @(n) 1 +
      @endiwhile
      default:;
      }
   @iexp j 0
   @iwhile j < @(mu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      rC += @(bs); iC += @(bs);
   }
@endiif
@iif nu > 1
   @iif mEn = 1
   switch(nr)
   {
   @iexp n 1
   @iwhile n < @(nu)
   case @(n):
      for (i=0; i < mf; i++, rC += @(bs), iC += @(bs))
      {
         @callproc doBlockT @(mu) @(n)
      }
      switch(mr)
      {
   @iexp m 1
   @iwhile m < @(mu)
      case @(m):
      @skip Assumption for sryk  m = n" 
      @callproc doDiBlockT @(m) 
      @iexp m @(m) 1 +
         break;
   @endiwhile
      default:;
      }
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endiif
   @iif mEn = 0
      @iif ma ! 1
      rC = pr; iC = pi;
      kk = nf % @(ma);
      kk *= @(nu);
      switch(nr)
      {
         @iexp n 1
         @iwhile n < @(nu)
         case @(n) :
            for (i=0; i < nf; i++, rC+=@(bs), iC+=@(bs))
            {
               @callproc doBlockTkk @(nu) @(n)
            }
               @callproc doDiBlockTkk @(n)
         break;
            @iexp n @(n) 1 +
         @endiwhile
      default:;
      }
      @endiif
   @endiif
@endiif
@iif mu > 1
   @iif na ! 1
   switch (mr)
   {
      @iexp n 1
      @iwhile n < @(mu)
      case @(n):
         for (i=0; i < nf; i++, rC+=@(bs), iC+=@(bs))
         {
         @callproc doBlockTna @(nu) @(n) @(mu) @(nu)
         }
         switch ( mf % @(na))
         {
            @iexp m 0 
            @iwhile m < na  
         case @(m):
            @callproc doDiBlockTna @(nu) @(n) @(mu) @(mu) @(nu) @(m)
            break;
               @iexp m @(m) 1  +
            @endiwhile
         }
      break;
         @iexp n @(n) 1 +
      @endiwhile
   default:;
   }
   @endiif
@endiif
}
@ROUT C2blk `#endif`
@endiif
@SKIP ***************** END of SYRK L2UT: complex type**************************
@ROUT blk2C_x87
@BEGINPROC GetAOff i_ j_
   @define of @1@
@iif @iexp @(i_) 0 = @(j_) 0 = &
   @define ao @(pA)@
@endiif
@iif @(j_) = 0
   @define al @@(i_)*SZ(pA)@
@endiif
@iif @(j_) = 1
   @iif (i_) = 0
      @define al @(pA,lda)@
   @endiif
   @iif (i_) ! 0
      @define al @@(i_)*SZ(pA,lda)@
   @endiif
@endiif
@iif @(j_) = 2
   @iif (i_) = 0
      @define al @(pA,lda,2)@
   @endiif
   @iif (i_) ! 0
      @define al @@(i_)*SZ(pA,lda,2)@
   @endiif
@endiif
@iif @(j_) = 3
   @iif (i_) = 0
      @define al @(pA,lda3)@
   @endiif
   @iif (i_) ! 0
      @define al @@(i_)*SZ(pA,lda3)@
   @endiif
@endiif
@iif @(j_) = 4
   @iif (i_) = 0
      @define al @(pA,lda,4)@
   @endiif
   @iif (i_) ! 0
      @define al @@(i_)*SZ(pA,lda,4)@
   @endiif
@endiif
@ENDPROC
#include "atlas_asm.h"
/*
 *                            rdi       rsi             xmm0            rdx
 * void ATL_ATL_USERCPMM(size_t M, size_t N, const TYPE alpha, const TYPE *w,
 *                                  xmm1       rcx         r8
 *                       const TYPE beta, TYPE *A, size_t lda);
 *                       
 */
#define M    %rdi
#deifne N    %rsi
#define pW   %rdx
#define pA   %rcx
#define lda  %rax  /* comes in r8 */
#define lda3 %r8  
#define Mr   %r9
#define Nr   %r10
#define II   %r11
.text
.global ATL_asmdecor(ATL_USERCPMM)
ALIGN16
ATL_asmdecor(ATL_USERCPMM):
   mov M, Mr
/*
 * M = M / 12  -> (M/4) /3;
 */
   shr $2, M   /* M /= 4 */
   mov M, %rax
   movabsq $-6148914691236517205, M
   mulq M
   shrq M
/*
 * rax = 12*(M/12)
 */
   lea (M,M,2), %rax /* rax = 3*(M/12) */
   shl $2, %rax      /* rax = 12*(M/12) */
   sub %rax, Mr      /* Mr = M - (M/12)*12 */

   shr $2, N  /* N /= 4 */
   mov N, %rax
   shl $2, %rax
   sub %rax, Nr     /* Nr = N - (N/4)*4 */

   mov %r8, lda
   lea (%r8,%r8,2), lda3
   #ifdef ALPHAX
      movlpd %xmm0, -8(%rsp)
      fldl -8(%esp)              /* ST={alpha} */
      #ifdef BETAX
         movlpd %xmm1, -8(%rsp)
         fldl -8(%esp)           /* ST={beta,alpha} */
         #define SCAN 2
      #else
         #define SCAN 1
      #endif
   #elif defined(BETAX)
      #define SCAN 1
      movlpd %xmm1, -8(%rsp)
      fldl -8(%esp)              /* ST={beta} */
   #else
      #define SCAN 0
   #endif
   #if SCAN == 1
      #define ST4 %st4
      #define ST5 %st5
      #define ST6 %st6
   #elif SCAN == 2
      #define ST4 %st5
      #define ST5 %st6
      #define ST6 %st7
   #endif
   cmp $0, N
   je CLEAN_N
   cmp $0, M
   je CLEAN_N
   LOOPN:
      mov M, II
      LOOPM:
         fldl (pW)          /* ST={p[0],[bet],[alp]} */
         #ifdef BETAX
            fmul %st1, %st  /* ST={bet*p[0],[bet],[alp]} */
         #elif defined(BETAN) || defined(BETAN1)
            fchs
         #endif
         fldl 8(pW)         /* ST={p[1], bet*p[0],[bet],[alp]} */
         #ifdef BETAX
            fmul %st2, %st  /* ST={bet*p[1],bet*p[0],[bet],[alp]} */
         #elif defined(BETAN) || defined(BETAN1)
            fchs
         #endif
         fldl 16(pW)        /* ST={p[2], bet*p[1],bet*p[0],[bet],[alp]} */
         #ifdef BETAX
            fmul %st3, %st  /* ST={bet*p[2],bet*p[1],bet*p[0],[bet],[alp]} */
         #elif defined(BETAN) || defined(BETAN1)
            fchs
         #endif
         fldl (pA)  /* ST={A[0],{bet*p[2],bet*p[1],bet*p[0],[bet],[alp]} */
         #ifdef ALPHAX
            fmul ST4, %st
         #elif defined(BETAN) || defined(BETAN1)
            fchs
         #endif
         fldl 8(pA)
         #ifdef ALPHAX
            fmul ST5, %st
         #elif defined(ALPHAN) || defined(ALPHAN1)
            fchs
         #endif
         fldl 16(pA)
         #ifdef ALPHAX
            fmul ST6, %st /*{A[2],A[1],A[0],p[2],p[1],p[0],[bet],[alp] */
         #elif defined(ALPHAN) || defined(ALPHAN1)
            fchs
         #endif
         dec II
      jne LOOPM
      dec N
   jne LOOPN

