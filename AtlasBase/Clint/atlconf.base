@extract -b @(topd)/gen.inc what=crsetup
@ROUT GetFlags
   @ifdef allflags
      @define -t @-t@
      @define -t2 @-t2@
      @define -O @-O@
      @define -s @-s@
      @define -A @-A@
      @define -V @-V@
      @define -O @-O@
      @define -b @-b@
      @define -o @-o@
      @define -C @-C@
      @define -Cg @-Cg@
      @define -D @-D@
      @define -d @-d@
      @define -ad @-ad@
      @define -f @-f@
      @define -lapackref @-lapackref@
@skip      @define -LAsrc @-LAsrc@
      @define -gcc3 @-gcc3@
      @define -S @-S@
      @define -m @-m@
      @define -nof77 @-nof77@
      @define -pmake @-pmake@
      @define -flapack @-flapack@
      @define -f77lib @-f77lib@
      @define -maflags @-maflags@
   @endifdef
void PrintUsage(char *name, int iarg, char *arg)
{
   fprintf(stderr, "\nERROR around arg %d (%s).\n", iarg, 
           arg ? arg : "unknown");
   fprintf(stderr, "USAGE: %s [flags] where flags are:\n", name);
   fprintf(stderr, "   -v <verb> : verbosity level\n");
@ifdef -O
   fprintf(stderr, "   -O <enum OSTYPE #>  : set OS type\n");
@endifdef
@ifdef -s
   fprintf(stderr, "   -s <enum ASMDIA #>  : set assembly dialect\n");
@endifdef
@ifdef -A
   fprintf(stderr, "   -A <enum MACHTYPE #> : set machine/architecture\n");
@endifdef
@ifdef -V
   fprintf(stderr, 
   "   -V #    # = ((1<<vecISA1) | (1<<vecISA2) | ... | (1<<vecISAN))\n");
@endifdef
@ifdef -b
   fprintf(stderr, "   -b <32/64> : set pointer bitwidth\n");
@endifdef
@ifdef -o
   fprintf(stderr, "   -o <outfile>\n");
@endifdef
@ifdef -C
   fprintf(stderr, "   -C [xc,ic,if,sk,dk,sm,dm,al,ac] <compiler>\n");
   fprintf(stderr, "   -F [xc,ic,if,sk,dk,sm,dm,al,ac,gc] '<comp flags>'\n");
   fprintf(stderr,    /* HERE */
           "   -Fa [xc,ic,if,sk,dk,sm,dm,al,ac,gc] '<comp flags to append>'\n");
   fprintf(stderr, "        al: append flags to all compilers\n");
   fprintf(stderr, "        ac: append flags to all C compilers\n");
   @ifdef -Cg
   fprintf(stderr, "        gc: append flags to gcc compiler used in user-contributed index files.\n");
   fprintf(stderr, "        acg: append to all C compilers & the index gcc\n");
   fprintf(stderr, "        alg: append to all compilers & the index gcc\n");
   @endifdef
   fprintf(stderr, 
      "   -T <targ> : ssh target for cross-compilation (probably broken)\n");
@endifdef
@ifdef -D
   fprintf(stderr, "   -D [c,f] -D<mac>=<rep> : cpp #define to add to [CDEFS,F2CDEFS]\n");
   fprintf(stderr, 
   "      eg. -D c -DL2SIZE=8388604 -D f -DADD__ -D f -DStringSunStyle\n");
@endifdef
@ifdef -d
   @ifdef ! -d2
   fprintf(stderr, "   -d [s,b]  : set source/build directory\n");
   @endifdef
   @ifdef -d2
   fprintf(stderr, "   -d [s,b,ms,md,ks,kd] <directory>  : set directory\n");
   fprintf(stderr, "      [s,b] : source/build directory\n");
   fprintf(stderr, 
   "      [ms,md] : single & double precision matmul archdef directory\n");
   fprintf(stderr, 
       "      [ks,kd] : single & double precision kernel archdef directory\n");
   @endifdef
@endifdef
@ifdef -f
   fprintf(stderr, "   -f <#> : size (in KB) to flush before timing\n");
@endifdef
@ifdef -t
   fprintf(stderr, 
           "   -t <#> : set # of threads (-1: autodect; 0: no threading)\n");
@endifdef
@ifdef -m
   fprintf(stderr, "   -m <mhz> : set clock rate\n");
@endifdef
@ifdef -S
   fprintf(stderr, "   -S[i/s] <handle> <val>  : special int/string arg\n");
   @ifdef -ad
   fprintf(stderr, 
           "      -Si bozol1 <0/1> : supress/enable bozo L1 defaults\n");
   fprintf(stderr, 
           "      -Si archdef <1/0> : enable/supress arch default use\n");
   fprintf(stderr, 
           "      -Si latune <1/0> : do/don't tune F77 LAPACK routines\n");
   @endifdef
   @ifdef -nof77
      fprintf(stderr, 
        "      -Si nof77 <0/1> : Have/don't have fortran compiler\n");
   @endifdef
   @ifdef -nocygwin
      fprintf(stderr, 
        "      -Si nocygwin <0/1> : Do/don't depend on GPL cygwin library\n");
      fprintf(stderr, 
        "                           (Windows compiler/cygwin install only)\n");
   @endifdef
   @ifdef -thrchk
      fprintf(stderr, 
        "      -Si cputhrchk <0/1> : Ignore/heed CPU throttle probe\n");
   @endifdef
   @ifdef -t2
      fprintf(stderr, 
        "      -Si omp <0/1> : don'tuse/use OpenMP for threading\n");
      fprintf(stderr,
"      -Si antthr <0/1/2> : nobuild/build/use Antoine's code for threading\n");
   @endifdef
   @ifdef -lapackref
      fprintf(stderr, 
              "      -Si lapackref <0/1>: Netlib lapack is not/is unpacked\n");
      fprintf(stderr, "                           to $BLDdir/src/lapack/ref\n");
   @endifdef
   @ifdef -gcc3
   fprintf(stderr, 
        "      -Ss kern <path/to/comp> : use comp for all kernel compilers\n");
   @endifdef
   @ifdef -LAsrc
   fprintf(stderr, 
      "      -Ss LAsrc <path/to/LAPACK/SRC> : Build full LAPACK using this\n");
   fprintf(stderr, 
      "                directory's LAPACK routines (must be in F77)\n");
   @endifdef
   @ifdef -pmake
   fprintf(stderr, 
        "      -Ss pmake <parallel make invocation (eg '$(MAKE) -j 4')>\n");
   @endifdef
   @ifdef -f77lib
   fprintf(stderr, 
"      -Ss f77lib <path to f77 lib needed by C compiler>\n");
   @endifdef
   @ifdef -flapack
   fprintf(stderr, 
"      -Ss flapack <path to netlib lapack>: used to build full lapack lib\n");
   @endifdef
   @ifdef -maflags
   fprintf(stderr, "      -Ss [s,d]maflags 'flags'\n");
   @endifdef
@endifdef
   fprintf(stderr, 
      "NOTE: enum #s can be found by : make xprint_enums ; ./xprint_enums\n");
   exit(iarg);
}

void GetFlags(int nargs,                /* nargs as passed into main */
              char **args,              /* args as passed into main */
              int *verb,                /* verbosity setting */
   @define iflag @v@
   @define ivar  @verb@
@ifdef -O
   @define iflag @O@
   @define ivar  @OS@
              enum OSTYPE *OS,          /* OS to assume */
@endifdef
@ifdef -s
   @define iflag @s@
   @define ivar  @asmb@
              enum ASMDIA *asmb,        /* assembly dialect to assume */
@endifdef
@ifdef -V
   @define iflag @V@
   @define ivar  @vec@
              int *vec,                 /* Vector ISA extension bitfield */
@endifdef
@ifdef -A
   @define iflag @A@
   @define ivar  @mach@
              enum MACHTYPE *mach,     /* machine/arch to assume */
@endifdef
@ifdef -m
   @define iflag @m@
   @define ivar  @mhz@
              int *mhz,                /* Clock rate in Mhz */
@endifdef
@ifdef -b
   @define iflag @b@
   @define ivar @ptrbits@
              int *ptrbits             /* # of bits in ptr: 32/64 */,
@endifdef
@ifdef -t
   @define iflag @t@
   @define ivar @nthreads@
              int *nthreads,           /* # of threads */
   @ifdef -t2
              int *omp,                /* Build OpenMP version of threading? */
              int *AntThr,             /* Build Antoine's threads? */
   @endifdef
@endifdef
@ifdef -C
              char **comps,
@endifdef
@ifdef -Cg
              char **gccflags,        /* append flags for user-contrib gcc */
@endifdef
@ifdef -o
              char **outfile,
@endifdef
@ifdef -d
              char **srcdir,          /* path to top of source directory */
              char **bindir,          /* path to top of binary directory */
@endifdef
@ifdef -ad
              int *bozol1,            /* Use untuned L1 */
              int *UseArchDef,        /* Use arch defaults */
              int *latune,            /* Tune LAPACK? */
@endifdef
@ifdef -nof77
              int *NoF77, 
@endifdef
@ifdef -nocygwin
              int *NoCygwin,
@endifdef
@ifdef -thrchk
              int *ThrChk,
@endifdef
@ifdef -lapackref
              int *lapackref,
@endifdef
@ifdef -d2
              char **archdefs,
@endifdef
@ifdef -D
              char **f2cdefs,         /* F77-to-C interface defines */
              char **ecdefs,          /* extra cpp defines to add to CDEFS */
@endifdef
@ifdef -pmake
              char **pmake,           /* parallel make command */
@endifdef
@ifdef -flapack
              char **flapack,         /* netlib F77 LAPACK  */
@endifdef
@ifdef -maflags
              char **smaflags,       /* single prec muladd flags */
              char **dmaflags,       /* double prec muladd flags */
@endifdef
@ifdef -f77lib
              char **f77lib,         /* netlib F77 LAPACK  */
@endifdef
@ifdef -LAsrc
              char **LAsrc,          /* netlib F77 LAPACK  SRC directory */
@endifdef
@ifdef -f
   @define iflag @f@
   @define ivar @flush@
              int *flush,             /* size in KB to flush */
@endifdef
   @define sflag @T@
   @define svar  @targ@
              char **targ             /* mach to ssh to*/
             )
{
   int i, k, k0, kn, DoInt;
   char *sp, *sp0;
@ifdef -gcc3
   char *gcc3=NULL;
@endifdef
@ifdef -D
   char *cdefs=NULL, *fdefs=NULL;
   char ln[1024];
@endifdef

   *verb = 0;
@ifdef -LAsrc
   *LAsrc = NULL;
@endifdef
@ifdef -d
   *srcdir = *bindir = NULL;
@endifdef
@ifdef -ad
    *bozol1 = 0;
    *latune = *UseArchDef = 1;
@endifdef
@ifdef -flapack
    *flapack = NULL;
@endifdef
@ifdef -f77lib
    *f77lib = NULL;
@endifdef
@ifdef -maflags
    *smaflags = *dmaflags = NULL;
@endifdef
@ifdef -m
    *mhz = 0;
@endifdef
@ifdef -d2
   for (i=0; i < NARDEF; i++)
      archdefs[i] = NULL;
@endifdef
@ifdef -o
   *outfile = NULL;
@endifdef
@whiledef svar
   *@(svar) = NULL;
   @define svar2 @@(svar)@
@endwhile
@whiledef svar2
   @define svar @@(svar2)@
@endwhile
@ifdef -C
   for (k=0; k < NCOMP*3; k++)
      comps[k] = NULL;
@endifdef
@ifdef -Cg
   *gccflags = NULL;
@endifdef

@whiledef ivar
   *@(ivar) = 0;
   @define ivar2 @@(ivar)@
@endwhile
@whiledef ivar2
   @define ivar @@(ivar2)@
@endwhile
@ifdef -nocygwin
   *NoCygwin = 0;
@endifdef
@ifdef -nof77
   *NoF77 = 0;
@endifdef
@ifdef -thrchk
   *ThrChk = 1;
@endifdef
@ifdef -t
   *nthreads = -1;
@endifdef
@ifdef -t2
   *omp = *AntThr = 0;
@endifdef
@ifdef -pmake
   *pmake = NULL;
@endifdef
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
@whiledef iflag
      case '@(iflag)':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         *@(ivar) = atoi(args[i]);
         break;
   @undef ivar
@endwhile
@whiledef sflag
      case '@(sflag)':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         *@(svar) = args[i];
         break;
   @undef svar
@endwhile
@ifdef -S
      case 'S':
         if (args[i][2] != 'i' && args[i][2] != 's')
            PrintUsage(args[0], i, "-S needs i or s suffix!");
         DoInt = args[i][2] == 'i';
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         sp0 = args[i];
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         if (DoInt)
            k = atoi(args[i]);
         else 
            sp = args[i];
   @define else @@
   @ifdef -ad
         if (!strcmp(sp0, "archdef"))
            *UseArchDef = k;
         else if (!strcmp(sp0, "bozol1"))
            *bozol1 = k;
         else if (!strcmp(sp0, "latune"))
            *latune = k;
         @define else @else@
   @endifdef
   @ifdef -t2
         @(else) if (!strcmp(sp0, "omp"))
            *omp = k;
         @(else) if (!strcmp(sp0, "antthr"))
            *AntThr = k;
   @endifdef
   @ifdef -lapackref
         @(else) if (!strcmp(sp0, "lapackref"))
            *lapackref = k;
   @endifdef
   @ifdef -nof77
         @(else) if (!strcmp(sp0, "nof77"))
            *NoF77 = k;
      @define else @else@
   @endifdef
   @ifdef -nocygwin
         @(else) if (!strcmp(sp0, "nocygwin"))
            *NoCygwin = k;
      @define else @else@
   @endifdef
   @ifdef -thrchk
         @(else) if (!strcmp(sp0, "cputhrchk"))
            *ThrChk = k;
      @define else @else@
   @endifdef
   @ifdef -gcc3
         @(else) if (!strcmp(sp0, "kern"))
            gcc3 = sp;
      @define else @else@
   @endifdef
   @ifdef -LAsrc
         @(else) if (!strcmp(sp0, "LAsrc") || !strcmp(sp0, "lasrc"))
            *LAsrc = sp;
      @define else @else@
   @endifdef
   @ifdef -pmake
         else if (!strcmp(sp0, "pmake"))
            *pmake = sp;
   @endifdef
   @ifdef -flapack
        @(else) if (!strcmp(sp0, "flapack"))
           *flapack = sp;
   @endifdef
   @ifdef -f77lib 
        @(else) if (!strcmp(sp0, "f77lib"))
           *f77lib = sp;
   @endifdef
   @ifdef -maflags
        @(else) if (!strcmp(sp0, "smaflags"))
           *smaflags = sp;
        else if (!strcmp(sp0, "dmaflags"))
           *dmaflags = sp;
   @endifdef
         else
            PrintUsage(args[0], i-1, sp0);
         break;
   @whiledef else
   @endwhile
@endifdef
@ifdef -o
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         *outfile = args[i];
         break;
@endifdef
@ifdef -D
      case 'D':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         if (args[i-1][0] == 'f')
            fdefs = NewAppendedString(fdefs, args[i]);
         else
            cdefs = NewAppendedString(cdefs, args[i]);
         break;
@endifdef
@ifdef -d
      case 'd':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         sp = args[i-1];
         if (*sp == 's')
            *srcdir = args[i];
         else if (*sp == 'b')
            *bindir = args[i];
   @ifdef -d2
         else if (*sp == 'm' && sp[1] == 's')
            archdefs[ADsm] = args[i];
         else if (*sp == 'm' && sp[1] == 'd')
            archdefs[ADdm] = args[i];
         else if (*sp == 'k' && sp[1] == 's')
            archdefs[ADsk] = args[i];
         else if (*sp == 'k' && sp[1] == 'd')
            archdefs[ADdk] = args[i];
         else
            PrintUsage(args[0], i-1, sp);
   @endifdef
         break;
@endifdef
@ifdef -C
      case 'C':
      case 'F':
         if (++i >= nargs)
            PrintUsage(args[0], i, "out of arguments");
         sp = args[i];
         k = -1;
         if (*sp == 'i' && sp[1] == 'c') k = ICC_;
         if (*sp == 'g' && sp[1] == 'c') k = GCC_;
         else if (*sp == 'i' && sp[1] == 'f') k = F77_;
         else if (*sp == 's' && sp[1] == 'k') k = SKC_;
         else if (*sp == 'd' && sp[1] == 'k') k = DKC_;
         else if (*sp == 's' && sp[1] == 'm') k = SMC_;
         else if (*sp == 'd' && sp[1] == 'm') k = DMC_;
         else if (*sp == 'x' && sp[1] == 'c') k = XCC_;
         if (*sp == 'a' && (sp[1] == 'l' || sp[1] == 'c'))
         {  /* only appended flags can be applied to all compilers */
@skip            if (args[i-1][1] != 'F') PrintUsage(args[0], i, args[i]);
@skip            if (args[i-1][2] != 'a') PrintUsage(args[0], i, args[i]);
            if (args[i-1][1] == 'F') 
            {
               if (args[i-1][2] == 'a')
               {
                  k0 = NCOMP+NCOMP;
                  kn = k0 + NCOMP;
               }
               else
               {
                  k0 = NCOMP;
                  kn = NCOMP+NCOMP;
               }
            }
            else
            {
               k0 = 0;
               kn = NCOMP;
            }
            if (++i >= nargs)
               PrintUsage(args[0], i, "out of arguments");
            for (k=k0; k < kn; k++)
               if (sp[1] == 'l' || k-2*NCOMP != F77_)
                  comps[k] = args[i];
@ifdef -Cg
            if (sp[2] == 'g' && args[i-2][1] == 'F')
               *gccflags = args[i];
@endifdef
         }
@ifdef -Cg
         else if (*sp == 'g' && sp[1] == 'c')
         {
            if (++i >= nargs)
               PrintUsage(args[0], i, "out of arguments");
            *gccflags = args[i];
         }
@endifdef
         else
         {
            if (k < 0) PrintUsage(args[0], i, args[i]);
            if (args[i-1][1] == 'F') 
            {
               k += NCOMP;
               if (args[i-1][2] == 'a') 
                  k += NCOMP;
            }
            if (++i >= nargs)
               PrintUsage(args[0], i, "out of arguments");
            comps[k] = args[i];
         }
         break;
@endifdef
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
@ifdef -C
/* 
 * allocate these strings ourselves so we can free them later if necessary
 */
   for (i=0; i < 3*NCOMP; i++)
   {
      if (comps[i])
      {
         if (!strcmp(comps[i], "default"))
            comps[i] = NULL;
         else
         {
            sp = malloc(sizeof(char)*(strlen(comps[i])+1));
            strcpy(sp, comps[i]);
            comps[i] = sp;
         }
      }
   }
@endifdef
@ifdef -gcc3
/*
 * If the special flag -Ss gcc3 is thrown, force gcc3's use for all kernel
 * compilers (standard gcc assumed to be gcc4)
 */
   if (gcc3)
   {
      for (i=0; i < NCOMP; i++)
      {
         if (!comps[i] && (i == SMC_ || i == DMC_ || i == SKC_ || i == DKC_))
            comps[i] = NewStringCopy(gcc3);
      }
   }
@endifdef
@ifdef -D
   *f2cdefs = fdefs;
   *ecdefs = cdefs;
@endifdef
@ifdef -b
   if (*ptrbits != 32 && *ptrbits != 64)
      *ptrbits = 0;
@endifdef
@ifdef -ad
@skip   *latune = *latune && *LAsrc;   /* can't tune LAPACK w/o LAPACK source */
@endifdef
}
@endextract
@ROUT atlconf.h
#ifndef ATLCONF_H
   #define ATLCONF_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define NOS 13
static char *osnam[NOS] = 
   {"UNKNOWN", "Linux", "SunOS", "SunOS4", "OSF1", "IRIX", "AIX", 
    "Win9x", "WinNT", "WinSFU", "HPUX", "FreeBSD", "OSX"};
enum OSTYPE {OSOther=0, OSLinux, OSSunOS, OSSunOS4, OSOSF1, OSIRIX, OSAIX,
             OSWin9x, OSWinNT, OSWinSFU, OSHPUX, OSFreeBSD, OSOSX};
#define OSIsWin(OS_) ( ((OS_) == OSWinNT) || ((OS_) == OSWin9x) || \
                       ((OS_) == OSWinSFU) )

enum ARCHFAM {AFOther=0, AFPPC, AFSPARC, AFALPHA, AFX86, AFIA64, AFMIPS, 
              AFARM, AFS390};

#define NMACH 42
static char *machnam[NMACH] = 
   {"UNKNOWN", "POWER3", "POWER4", "POWER5", "PPCG4", "PPCG5", 
    "POWER6", "POWER7", "IBMz9", "IBMz10", "IBMz196",
    "P5", "P5MMX", "PPRO", "PII", "PIII", "PM", "CoreSolo", 
    "CoreDuo", "Core2Solo", "Core2", "Corei1", "Corei2", "Atom", "P4", "P4E", 
    "Efficeon", "K7", "HAMMER", "AMD64K10h", "UNKNOWNx86", 
    "IA64Itan", "IA64Itan2",
    "USI", "USII", "USIII", "USIV", "UST2", "UnknownUS", 
    "MIPSR1xK", "MIPSICE9", "ARMv7"};
enum MACHTYPE {MACHOther, IbmPwr3, IbmPwr4, IbmPwr5, PPCG4, PPCG5,
               IbmPwr6, IbmPwr7,
               IbmZ9, IbmZ10, IbmZ196,  /* s390(x) in Linux */ 
               IntP5, IntP5MMX, IntPPRO, IntPII, IntPIII, IntPM, IntCoreS,
               IntCoreDuo, IntCore2Solo, IntCore2, IntCorei1, IntCorei2,
               IntAtom, IntP4, IntP4E, TMEff, 
               AmdAthlon, AmdHammer, Amd64K10h, x86X, 
               IA64Itan, IA64Itan2,
               SunUSI, SunUSII, SunUSIII, SunUSIV, SunUST2, SunUSX, 
               MIPSR1xK, /* includes R10K, R12K, R14K, R16K */
               MIPSICE9,  /* SiCortex ICE9 -- like MIPS5K */
               ARMv7      /* includes Cortex A8, A9 */
               };
#define MachIsX86(mach_) \
   ( (mach_) >= IntP5 && (mach_) <= x86X )
#define MachIsIA64(mach_) \
   ( (mach_) >= IA64Itan && (mach_) <= IA64Itan2 )
#define MachIsUS(mach_) \
   ( (mach_) >= SunUSI && (mach_) <= SunUSX )
#ifdef __mips__
   #define MachIsMIPS(mach_) \
      ( (__mips__) || (mach_) >= MIPSR1xK && (mach_) <= MIPSICE9 )
#else
   #define MachIsMIPS(mach_) \
      ( (mach_) >= MIPSR1xK && (mach_) <= MIPSICE9 )
#endif
#define MachIsPPC(mach_) \
   ( (mach_) >= PPCG4 && (mach_) <= PPCG5 )
#define MachIsARM(mach_) \
   ( (mach_) == ARMv7 )
#define MachIsS390(mach_) \
   ( (mach_) >= IbmZ9 && (mach_) <= IbmZ196 )


static char *f2c_namestr[5] = {"UNKNOWN","Add_", "Add__", "NoChange", "UpCase"};
static char *f2c_intstr[5] =
       {"UNKNOWN", "F77_INTEGER=int", "F77_INTEGER=long", 
        "F77_INTEGER=\"long long\"", "F77_INTEGER=short"};
static char *f2c_strstr[5]=
       {"UNKNOWN", "SunStyle", "CrayStyle", "StructVal", "StructPtr"};

enum F2CNAME {f2c_NamErr=0, f2c_Add_, f2c_Add__, f2c_NoChange, f2c_UpCase};
enum F2CINT {f2c_IntErr=0, FintCint, FintClong, FintClonglong, FintCshort};
enum F2CSTRING {f2c_StrErr=0, fstrSun, fstrCray, fstrStructVal, fstrStructPtr};

#define NISA 10
static char *ISAXNAM[NISA] = 
   {"", "VSX", "AltiVec", "AVXMAC", "AVX", "SSE3", "SSE2", "SSE1", "3DNow", 
    "NEON"};
enum ISAEXT 
   {ISA_None=0, ISA_VSX, ISA_AV, ISA_AVXMAC, ISA_AVX, 
    ISA_SSE3, ISA_SSE2, ISA_SSE1, ISA_3DNow,
    ISA_NEON};

@ROUT atlconf.h asmconf.h
#define NASMD 9
enum ASMDIA 
   {ASM_None=0, gas_x86_32, gas_x86_64, gas_sparc, gas_ppc, gas_parisc, 
    gas_mips, gas_arm, gas_s390};
static char *ASMNAM[NASMD] =
   {"",     "GAS_x8632", "GAS_x8664", "GAS_SPARC", "GAS_PPC", "GAS_PARISC",
    "GAS_MIPS", "GAS_ARM", "GAS_S390"};
@ROUT atlconf.h

/*
 * Used for archinfo probes (can pack in bitfield)
 */
enum WHATPROBE{Parch=1, P64=2, Pncpu=4, Pverb=8, Pncache=16, PCacheSize=32,
               PMhz=64, Pthrottle=128};

#define NARDEF 4
enum ARDEF{ADsk=0, ADdk, ADsm, ADdm};  /* m = matmul kernel, k = non-mm kern */
/*
 * Used for all the compilers ATLAS needs
 */
#define NCOMP 8
static char *COMPNAME[NCOMP]={"ICC","SMC","DMC","SKC","DKC","XCC","GCC","F77"};
#define ICC_ 0   /* Compiles non-computation routines, and all I/O */
#define SMC_ 1   /* single prec matmul compiler */
#define DMC_ 2   /* double prec matmul compiler */
#define SKC_ 3   /* single prec computation compiler (non-mm kernels) */
#define DKC_ 4   /* double prec computation compiler */
#define XCC_ 5   /* Compiler for frontend of cross-compilation */
#define GCC_ 6
#define F77_ 7   /* Valid fixed-format Fortran77 compiler */

typedef struct CompNode COMPNODE;
struct CompNode
{
   int priority;              /* priority of this definition */
   int comps[1];              /* bitfield: (1<<ICC)|...|(1<<F77) */
   int OS[(NOS+31)/32];       /* bitfield for OS */
   int arch[(NMACH+31)/32];   /* bitfields for architecture */
   char *comp, *flags;        /* compiler & flags as strings */
   COMPNODE *next;
};
#include "atlconf_misc.h"

#endif
@ROUT print_enums
#include "atlconf.h"

void BarfOutArchs(FILE *fpout, int ibeg, int iend)
{
   int i;

   assert(ibeg < NMACH && ibeg >= 0);
   assert(iend < NMACH && iend >= 0);
   if (ibeg == iend)
      fprintf(fpout, "\nMACHTYPE %d = '%s'\n", ibeg, machnam[ibeg]);
   else
   {
      fprintf(fpout, "Architectural enums (Config's enum MACHTYPE):\n");
      for (i=ibeg; i <= iend; i++)
         fprintf(fpout, "   %3d = '%s'\n", i, machnam[i]);
      fprintf(fpout, "\n");
   }
}

void BarfOutOSs(FILE *fpout, int ibeg, int iend)
{
   int i;

   assert(ibeg < NOS && ibeg >= 0);
   assert(iend < NOS && iend >= 0);
   if (ibeg == iend)
      fprintf(fpout, "\nOSTYPE %d = '%s'\n", ibeg, osnam[ibeg]);
   else
   {
      fprintf(fpout, "Operating System enums (Config's enum OSTYPE):\n");
      for (i=ibeg; i <= iend; i++)
         fprintf(fpout, "   %3d = '%s'\n", i, osnam[i]);
      fprintf(fpout, "\n");
   }
}

void BarfOutComps(FILE *fpout, int ibeg, int iend)
{
   int i;

   assert(ibeg < NCOMP && ibeg >= 0);
   assert(iend < NCOMP && iend >= 0);
   if (ibeg == iend)
      fprintf(fpout, "\nCOMPTYPE %d = '%s'\n", ibeg, COMPNAME[ibeg]);
   else
   {
      fprintf(fpout, "Compiler integer defines:\n");
      for (i=ibeg; i <= iend; i++)
         fprintf(fpout, "   %3d = '%s'\n", i, COMPNAME[i]);
      fprintf(fpout, "\n");
   }
}

void PrintUsage(char *name, int i)
{
   fprintf(stderr, "Error in arg %d, USAGE:\n", i);
   fprintf(stderr, 
           "   %s [-a (archs)] [-o OSes] [-A ibeg iend] [-O ibeg iend]\n",
           name);
   exit(i);
}

void GetFlags(int nargs, char **args, int *DoArch, int *abeg, int *aend, 
              int *DoOS, int *osbeg, int *osend, 
              int *DoComps, int *cbeg, int *cend)
{
   int i, usrargs=0;

   *DoArch = *DoOS = *DoComps = 0;
   *abeg = 0;
   *aend = NMACH-1;
   *osbeg = 0;
   *osend = NOS-1;
   *cbeg = 0;
   *cend = NCOMP-1;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i);
      switch(args[i][1])
      {
      case 'a':
         *DoArch = usrargs = 1;
         break;
      case 'o':
         *DoOS = usrargs = 1;
         break;
      case 'c':
         *DoComps = usrargs = 1;
      case 'C':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *cbeg = atoi(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *cend = atoi(args[i]);
         usrargs = *DoComps = 1;
         break;
      case 'A':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *abeg = atoi(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *aend = atoi(args[i]);
         usrargs = *DoArch = 1;
         break;
      case 'O':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *osbeg = atoi(args[i]);
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *osend = atoi(args[i]);
         usrargs = *DoOS = 1;
         break;
      default:
         PrintUsage(args[0], i);
      }
   }
   if (!usrargs)
      *DoArch = *DoOS = *DoComps = 1;
}

int main(int nargs, char **args)
{
   int DoArch, abeg, aend, DoOS, osbeg, osend, DoComp, cbeg, cend;

   GetFlags(nargs, args, &DoArch, &abeg, &aend, &DoOS, &osbeg, &osend,
            &DoComp, &cbeg, &cend);

   fprintf(stdout, "\n");
   if (DoArch)
      BarfOutArchs(stdout, abeg, aend);
   if (DoOS)
      BarfOutOSs(stdout, osbeg, osend);
   if (DoComp)
      BarfOutComps(stdout, cbeg, cend);
   return(0);
}
@ROUT IsGcc
@extract -b @(topd)/cw.inc lang=c -define cwdate 2011
#include <stdio.h>
#include <assert.h>
#include "atlconf_misc.h"
void PrintUsage(char *name, int iarg, char *flag)
{
   fprintf(stderr, "Unknown flag '%s' in position %d!\n", flag, iarg);
   fprintf(stderr, "USAGE: [-l <lvl>] <gcc candidate>\n");
   exit(iarg);
}
int main(int nargs, char **args)
{
   int lvl=0;  /* 0: is gcc, 1: is gcc 4 but not apple gcc 2: gcc 4.x, with x >= 4 */
   int i;
   char *comp=NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] == '-')
      {
         if (args[i][1] == 'l')
	 {
	    if (++i >= nargs)
	       PrintUsage(args[0], i, "out of arguments");
	    lvl = atoi(args[i]);
	 }
	 else
	    PrintUsage(args[0], i, args[i]);
      }
      else
         comp = args[i];
   }
   assert(comp);
   if (!CompIsGcc(comp))
      return(1);
   if (lvl)
   {
      int icmp, major, minor, patch;

      GetGccVers(comp, &icmp, &major, &minor, &patch);
      #if 0
         fprintf(stderr, "comp='%s': cmp=%d, major=%d, minor=%d, patch=%d\n", 
	         comp, icmp, major, minor, patch);
      #endif
      if (icmp || major < 4)
         return(2);
      if (lvl > 1)
         if (minor < 4)
	    return(3);
   }
   printf("%s\n", comp);
   return(0);
}
@ROUT atlconf_misc
@extract -b @(topd)/gen.inc what=cw @(cw98)
#include "atlconf.h"

@extract -b @(incd)/query.inc

int fNumLines(char *fnam)
{
   FILE *fp;
   char ln[256];
   int i;

   fp = fopen(fnam, "r");
   assert(fp != NULL);
   for (i=0; fgets(ln, 256, fp); i++);
   return(i);
}

@ROUT atlconf_misc atlar findgcc
char *CmndResultsNoErr(char *targ, char *cmnd)
{
   static char tnam[128];
   static int FirstTime=1;
   char ln[8196];

   if (FirstTime)
   {
      FirstTime = 0;
      assert(tmpnam(tnam));
   }
   if (targ) sprintf(ln, "ssh %s \"%s\" > %s 2>/dev/null \n", targ, cmnd, tnam);
   else sprintf(ln, "%s > %s 2>/dev/null\n", cmnd, tnam);
   system(ln); 
   return(tnam);
}
char *CmndResults(char *targ, char *cmnd)
{
   static char tnam[128];
   static int FirstTime=1;
   char ln[8196];

   if (FirstTime)
   {
      FirstTime = 0;
      assert(tmpnam(tnam));
   }
   if (targ) sprintf(ln, "ssh %s \"%s\" > %s 2>&1 \n", targ, cmnd, tnam);
   else sprintf(ln, "%s > %s 2>&1\n", cmnd, tnam);
   if (!system(ln)) return(tnam);
   return(NULL);
}

int CmndOneLine(char *targ, char *cmnd, char *ln)
/*
 * executes a system call with contents of cmnd, returns the output in ln;
 * Returns value returned by system call
 * if targ is set, we ssh to that machine
 */
{
   int i;
   FILE *fp;
   char *tnam;

   ln[0] = '\0';
   tnam = CmndResults(targ, cmnd);
   if (tnam)
   {
      fp = fopen(tnam, "r");
      assert(fp);
      if (!fgets(ln, 2048, fp)) ln[0] = '\0';
      fclose(fp);
      return(0);
   }
   else ln[0] = '\0';
   return(1);
}

int GetIntBeforeWord(char *word, char *ln)
/* 
 * Finds integer before word in sentence.  
 * RETURNS: integer on success, BADINT on failure
 */
{
   char *sp;
   sp = strstr(ln, word);
   if (sp == ln) return(BADINT);
   sp--;
   while(isspace(*sp) && sp != ln) sp--;
   if (sp == ln) return(BADINT);
   while (isdigit(*sp) && sp != ln) sp--;
   if (sp == ln) return(BADINT);
   return(atoi(sp));
}

@ROUT atlconf_misc
int GetScreenHeight()
/* 
 * Returns the number of vertical lines window has
 */
{
   int i;
   for (i=160; i; i--) fprintf(stdout, "%03d\n", i);
   i = GetIntRange(0, 0, 160, "", "number at top left of screen");
   return(i);
}

void GetEnter(FILE *fpout)
{
   char ln[128];
   fprintf(fpout, "---------- PRESS ENTER TO CONTINUE ---------- ");
   fgets(ln, 128, stdin);
}

int DisplayFile(char *fnam, FILE *fpout, int nlines)
{
   FILE *fp;
   char ln[256];
   int i, GoOn=1;

   fp = fopen(fnam, "r");
   if (fp == NULL)
   {
      fprintf(stderr, "Unable to open file '%s', continuing without display.\n",
              fnam);
      return(-1);
   }
   if (nlines)
   {
@skip      nlines--;
      do
      {
         for (i=0; i < nlines; i++)
         {
            GoOn = (fgets(ln, 256, fp) != NULL);
            if (!GoOn) break;
            fprintf(fpout, "%s", ln);
         }
         if (GoOn) GetEnter(stdout);
         else break;
      }
      while(GoOn);
   }
   else while (fgets(ln, 256, fp)) fprintf(fpout, "%s", ln);
   i = ferror(fp);
   fclose(fp);
   return(i);
}

int DisplayFile0(char *fnam, FILE *fpout)
{
   FILE *fp;
   char ln[256];
   int i;

   fp = fopen(fnam, "r");
   if (fp == NULL)
   {
      fprintf(stderr, "Unable to open file '%s', continuing without display.\n",
              fnam);
      return(-1);
   }
   while (fgets(ln, 256, fp)) fprintf(fpout, "%s", ln);
   i = ferror(fp);
   fclose(fp);
   return(i);
}

int FoundInFile(char *fnam, char *str)
{
   FILE *fp;
   int found=0;
   char ln[256];

   fp = fopen(fnam, "r");
   assert(fp);
   while (fgets(ln, 256, fp))
   {
      if (strstr(ln, str))
      {
         found=1;
         break;
      }
   }
   fclose(fp);
   return(found);
}

char *FindUname(char *targ)
{
   static int FirstTime=1;
   static char unam[64];
   static char unamT[6];
   if (FirstTime)
   {
      if (FileIsThere("/bin/uname")) strcpy(unam, "/bin/uname");
      else if (FileIsThere("/usr/bin/uname")) strcpy(unam, "/usr/bin/uname");
      else strcpy(unam, "uname");
      strcpy(unamT, "uname");
      FirstTime = 0;
   }
   if (targ && targ[0] != '\0')
      return(unamT);
   return(unam);
}

enum ARCHFAM ProbeArchFam(char *targ)
/*
 * Tries to guess broad architectural family using uname
 */
{
   enum ARCHFAM fam=AFOther;
   char cmnd[256], res[256];
   char *uname;
   uname = FindUname(targ);
   sprintf(cmnd, "%s -m", uname);
   if ( !CmndOneLine(targ, cmnd, res) )
   {
      if (strstr(res, "ppc") || strstr(res, "Power Macintosh") ||
          strstr(res, "powerpc")) fam = AFPPC;
      else if (strstr(res, "sparc")) fam = AFSPARC;
      else if (strstr(res, "alpha")) fam = AFALPHA;
      else if (strstr(res, "ia64")) fam = AFIA64;
      else if (strstr(res, "mips")) fam = AFMIPS;
      else if (strstr(res, "arm")) fam = AFARM;
      else if (strstr(res, "s390")) fam = AFS390;
      else if ( strstr(res, "i686") || strstr(res, "i586") ||
                strstr(res, "i486") || strstr(res, "i386") ||
                strstr(res, "x86") || strstr(res, "x86_64") ) fam = AFX86;
   }
/*
 * Try uname -p if uname -m didn't work
 */
   if (fam == AFOther)
   {
      sprintf(cmnd, "%s -p", uname);
      if ( !CmndOneLine(targ, cmnd, res) )
      {
         if (strstr(res, "ppc") || strstr(res, "Power Macintosh") ||
             strstr(res, "powerpc")) fam = AFPPC;
         else if (strstr(res, "sparc")) fam = AFSPARC;
         else if (strstr(res, "alpha")) fam = AFALPHA;
         else if (strstr(res, "ia64")) fam = AFIA64;
         else if ( strstr(res, "i686") || strstr(res, "i586") ||
                   strstr(res, "i486") || strstr(res, "i386") ||
                   strstr(res, "x86_64") ) fam = AFX86;
         else if (strstr(res, "mips")) fam = AFMIPS;
         else if (strstr(res, "arm")) fam = AFARM;
         else if (strstr(res, "s390")) fam = AFS390;
      }
   }
   return(fam);
}

/* 
 * ===========================================================================
 * These files handle setting/checking bits in (possibly) multi-word bitfields
 * ===========================================================================
 */
int IsBitSetInField(int *field, int bit)
/*
 * RETURNS: 1 if bit bit is 1, else 0
 */
{
   int word;
/*
 * Find which word the bit is in (assume 32-bit ints for safety), and what
 * bit in that word it is
 */
   word = bit >> 5;
   bit -= (word<<5);
   return(field[word] & (1<<bit));
}

void SetBitInField(int *field, int bit)
/*
 * Sets bit bit in multiword bitfield field
 */
{
   int word;
   word = bit >> 5;
   bit -= (word<<5);
   field[word] |= (1<<bit);
}

/*
 * ===================================================================
 * These files do some string processing for some crude pseudo-parsing
 * ===================================================================
 */

void KillUselessSpace(char *str)
/*
 * This routine removes all whitespace from beginning & end of str, and 
 * collapses multiple intra-word whitespace to one space
 * NOTE: killing whitespace means '\n' are transformed to ' ' or '\0'!
 * NOTE: This implementation ignores ' and ", so will collapse substrings
 */
{
   int i;  /* index to uncopied portion */
   int j;  /* index to place to copy next character */

   if (str)
   {
      for (i=0; str[i] && isspace(str[i]); i++);
      if (str[i])
      {
         j = 0;
         while (str[i])
         {
            while (str[i] && !isspace(str[i]))
               str[j++] = str[i++];
            if (str[i])
            {
               str[j++] = ' ';
            }
            while (isspace(str[i])) i++;
         }
         if (isspace(str[j-1]))
            str[j-1] = '\0';
         else str[j] = '\0';
      }
      else str[0] = '\0';
   }
}

char *GetPathWithoutName(char *file)
/* 
 *RETURNS: string containing path without last file/dir
 */
{
   char *sp;
   int i, lastslash;
   char ch;
   char *NewStringCopy(char *old);

   for (lastslash=i=0; file[i]; i++)
      if (file[i] == '/')
         lastslash = i;
   i = lastslash;
   ch = file[i];
   file[i] = '\0';
   sp = NewStringCopy(file);
   file[i] = ch;
   return(sp);
}
char *NameWithoutPath(char *file)
/*
 * Strips off path from file, assuming unix / for path
 * RETURNS: string containing file w/o path
 */
{
   int i, lastslash;
   char *cp;

   for (lastslash=i=0; file[i]; i++)
      if (file[i] == '/')
         lastslash = i;
   cp = malloc(sizeof(char)*(i-lastslash+1));
   assert(cp);
   strcpy(cp, file+((file[lastslash] == '/') ? lastslash+1 : 0));
   KillUselessSpace(cp);
   return(cp);
}

int GetIntVers(char *str, int *nskip)
{
   char ln[64];
   int i, j;

   *nskip = 0;
   for (i=0; str[i] && !isdigit(str[i]); i++);  /* skip non-digits */
   if (str[i])
   {
      for (j=0; j < 64 && str[j+i] && isdigit(str[j+i]); j++) ln[j] = str[j+i];
      ln[j] = '\0';
      if (j)
      {
         *nskip = i+j;
         return(atoi(ln));
      }
   }
   return(-1);
}

@beginskip
int GccIsApple(char *gcc)
{
   char ln[2048], ln2[2048];
   sprintf(ln, "%s --version", gcc);
   if (CmndOneLine(NULL, ln, ln2) == 0)
   {
      if (strstr(ln2, "Apple Computer"))
         return(1);
   }
   return(0);
}
@endskip
void GetGccVers(char *gcc, int *comp, int *major, int *minor, int *patch)
/*
 * comp: 0: gcc;  1: egcs;  2: pgcc, 3: apple's gcc
 */
{
   char ln[512], ln2[512];
   int i, j;

   *comp = *major = *minor = *patch = -1;
   sprintf(ln, "%s --version", gcc);
   if (CmndOneLine(NULL, ln, ln2) == 0)
   {
      if (strstr(ln2, "Apple Computer") || strstr(ln2, "Apple Inc"))
         *comp = 3;
/*
 *    Skip compiler name, which may have digits in it
 */
      for (i=0; ln2[i] && !isspace(ln2[i]); i++);
      *major = GetIntVers(ln2+i, &j); j += i;
      if (*major != -1)
      {
         *minor = GetIntVers(ln2+j, &i); j += i;
         if (*minor != -1)
         {
            *patch = GetIntVers(ln2+j, &i); j += i;
            if (strstr(ln2, "egcs")) *comp = 1;
            else if (strstr(ln2, "pgcc")) *comp = 2;
            else if (*comp == -1) *comp = 0;
         }
      }
   }
}

char *GetPathEnvVar(void)
/*
 * returns users path with inter-name spaces replaced by "\ " 
 * and dirs separated by spaces
 */
{
   char *path, *pp, *p;
   int i, n;

   path = getenv("PATH");
   if (!path)
      return(NULL);
   
   n = strlen(path);
   p = pp = malloc((2*n+1)*sizeof(char));
   assert(pp);
   for (i=0; i < n; i++)
   {
      if (path[i] == ':')
         *p++ = ' ';
      else if (path[i] == ' ')
      {
         *p = '\\';
	 p[1] = ' ';
	 p += 2;
      }
      else
         *p++ = path[i];
   }
   *p = '\0';
   return(pp);
}

int CompIsGcc(char *comp)
/*
 * Tries to detect if compiler is gcc w/o scoping name of compiler
 */
{
   char cmnd[1024], res[1024];

   sprintf(cmnd, "%s --version", comp);
   if (CmndOneLine(NULL, cmnd, res) == 0)
   {
/*
 *    The direct comps added because Ubuntu stopped printing (GCC) in the
 *    version line.  Don't want to search for just "gcc", since that will
 *    match with pgcc
 */
      if (strstr(res, "(GCC)") || strstr(res, " GCC ") ||
          strstr(res, "GNU Fortran") || strstr(res, "(GCC ") ||
          (res[0] == 'g' && res[1] == 'c' && res[2] == 'c' && res[3] == ' ')
         )
         return(1);
   }
   return(0);
}
int CompIsAppleGcc(char *comp)
/*
 * Tries to detect if compiler is Apple's funked-up gcc 
 */
{
   char cmnd[1024], res[1024];

   if (CompIsGcc(comp))
   {
      res[0] = '\0';
      sprintf(cmnd, "%s -v 2>&1 | fgrep Apple", comp);
      CmndOneLine(NULL, cmnd, res);
      if (strstr(res, "Apple"))
         return(1);
   }
   return(0);
}

int CompIsMIPSpro(char *comp)
/*
 * RETURNS: 1 if compiler is MIPSpro compiler, 0 otherwise
 */
{
   char cmnd[1024], res[1024];

   sprintf(cmnd, "%s -v", comp);
   if (CmndOneLine(NULL, cmnd, res) == 0)
   {
      if (strstr(res, "MIPSpro Compiler"))
         return(1);
   }
   return(0);
}

int CompIsPathScale(char *comp)
{
   char cmnd[1024], res[1024];

   sprintf(cmnd, "%s -v", comp);
   if (CmndOneLine(NULL, cmnd, res) == 0)
   {
      if (strstr(res, "PathScale"))
         return(1);
   }
   return(0);
}

int CompIsSunWorkshop(char *comp)
/*
 * RETURNS: 1 if compiler is Sun WorkShop compiler, 0 otherwise
 */
{
   char cmnd[1024], res[1024];

   sprintf(cmnd, "%s -V", comp);
   if (CmndOneLine(NULL, cmnd, res) == 0)
   {
      if (strstr(res, "Sun WorkShop"))
         return(1);
   }
   return(0);
}

int CompIsIBMXL(char *comp)
/*
 * RETURNS: 1 if compiler is an IBM XL compiler, 0 otherwise
 */
{
   char cmnd[1024], res[1024];

   sprintf(cmnd, "%s -qversion", comp);
   if (CmndOneLine(NULL, cmnd, res) == 0)
   {
      if (strstr(res, "IBM XL"))
         return(1);
   }
   return(0);
}

char *NewStringCopy(char *old)
/*
 * RETURNS: newly allocates string containing copy of string old
 */
{
   char *new;
   new = malloc(sizeof(char)*(strlen(old)+1));
   strcpy(new, old);
   return(new);
}
char *NewAppendedString0(char *old, char *app)
/*
 * RETURNS: string holding : old + app
 * NOTE: frees old string after copy
 */
{
   char *new;
   if (!old)
   {
      new = malloc(sizeof(char)*(strlen(app)+1));
      assert(new);
      strcpy(new, app);
   }
   else
   {
      new = malloc(sizeof(char)*(strlen(old) + strlen(app)+1));
      assert(new);
      strcpy(new, old);
      strcat(new, app);
      free(old);
   }
   return(new);
}
char *NewAppendedString(char *old, char *app)
/*
 * RETURNS: string holding : old + " " + app
 * NOTE: frees old string after copy
 */
 
{
   char *new;
   if (!old)
   {
      new = malloc(sizeof(char)*(strlen(app)+1));
      assert(new);
      strcpy(new, app);
   }
   else
   {
      new = malloc(sizeof(char)*(strlen(old) + strlen(app)+2));
      assert(new);
      strcpy(new, old);
      strcat(new, " ");
      strcat(new, app);
      free(old);
   }
   return(new);
}
char **GetLinesFromFile
(
   char *fnam,    /* filename to read in */
   char **curlns  /* NULL-termed list of lines to prepend to file list ret */
)
/*
 * Read all lines from file fnam, suffix them to lines in curlns, delete 
 * curlns, and return them as NULL-terminated array of strings
 */
{
   char **lns=NULL;
   FILE *fpin;
   int i, n, nc=0, N;
   char ln[2048];

   if (!fnam)
      return(NULL);
   fpin = fopen(fnam, "r");
   assert(fpin);
   for (n=0; fgets(ln, 2048, fpin); n++);  /* count number of lines in file */
   rewind(fpin);
   if (curlns)
      for (nc=0; curlns[nc]; nc++);
   N = n+nc;
   if (N < 1)
      return(NULL);
   lns = malloc((N+1)*sizeof(char*));
   assert(lns);
   if (nc)
   {
      for (i=0; i < nc; i++)
         lns[i] = curlns[i];
      free(curlns);
   }
   for (i=0; i < n; i++)
   {
      int k;
      char *sp;
      assert(fgets(ln, 2048, fpin));
      k = strlen(ln)+1;
      lns[i+nc] = sp = malloc(k*sizeof(char));
      assert(sp);
      strcpy(sp, ln);
/* 
 *    Get rid of whitespace on end of line
 */
      for (k -= 2; isspace(sp[k]); k--) sp[k] = '\0';
   }
   lns[N] = NULL;
   return(lns);
}

void PrintAllStringsInList
(
   char *exp,
   char **strs  /* NULL terminated arrayof strings to be printed */
)
{
   int i;
   if (!strs)
   {
      printf("%s: NULL\n", exp);
      return;
   }
   printf("%s:\n", exp);
   for (i=0; strs[i]; i++)
      printf("   '%s'\n", strs[i]);
}
void KillAllStringsInList
(
   char **strs  /* NULL terminated arrayof strings to be freed */
)
{
   int i;
   if (!strs)
      return;
   for (i=0; strs[i]; i++)
      free(strs[i]);
   free(strs);
}

char *FreeListGetString
(
   char **strs, /* NULL-terminated array of strings to be freed */
   int n        /* only string you want to retain from array (returned) */
)
{
   char *ret;
   int i;

   if (!strs)
      return(NULL);
   ret = strs[n];
   for (i=0; strs[i]; i++)
   {
      if (i != n)
         free(strs[i]);
   }
   free(strs);
   return(ret);
}

char **NewOneStringList
(
   char **strs, /* NULL-terminated array of strings to be freed */
   int n        /* only string you want to retain from array (returned) */
)
{
   char **nstrs;
   nstrs = malloc(2*sizeof(char*));
   assert(nstrs);
   nstrs[0] = FreeListGetString(strs, n);
   nstrs[1] = NULL;
   return(nstrs);
}
@endextract
@ROUT atlconf_misc.h
#ifndef ATLCONF_MISC_H
   #define ATLCONF_MISC_H

void GetDate(int *month, int *day, int *year, int *hour, int *min);
long GetInt(FILE *fpin, long Default, char *spc, char *expstr);
long GetIntRange(long Default, long Min, long Max, char *spc, char *expstr);
long GetIntVer(long Default, long Min, long Max, char *spc, char *expstr);
void GetString(FILE *fpin, char *Default, char *spc, char *expstr,
               int len, char *str0);
void GetStrVer(char *def, char *spc, char *expstr, int len, char *str);
int IsYes(char def, char *spc, char *expstr);
char GetChar(char def, char *spc, char *expstr);
int FileIsThere(char *nam);
void ATL_mprintf(int np, ...);
int GetFirstInt(char *ln);
long long GetFirstLong(char *ln);
double GetFirstDouble(char *ln);
int GetLastInt(char *ln);
long long GetLastLong(char *ln);
int fNumLines(char *fnam);
char *GetPathEnvVar(void);
char *CmndResults(char *targ, char *cmnd);
char *CmndResultsNoErr(char *targ, char *cmnd);
int CmndOneLine(char *targ, char *cmnd, char *ln);
int GetIntBeforeWord(char *word, char *ln);
int GetScreenHeight();
void GetEnter(FILE *fpout);
int DisplayFile(char *fnam, FILE *fpout, int nlines);
int DisplayFile0(char *fnam, FILE *fpout);
int FoundInFile(char *fnam, char *str);
char *FindUname(char *targ);
enum ARCHFAM ProbeArchFam(char *targ);
void KillUselessSpace(char *str);
int IsBitSetInField(int *field, int bit);
void SetBitInField(int *field, int bit);
void KillUselessSpace(char *str);
char *NameWithoutPath(char *file);
char *GetPathWithoutName(char *file);
void GetGccVers(char *gcc, int *comp, int *major, int *minor, int *patch);
int CompIsGcc(char *comp);
int CompIsAppleGcc(char *comp);
int CompIsMIPSpro(char *comp);
int CompIsPathScale(char *comp);
int CompIsSunWorkshop(char *comp);
int CompIsIBMXL(char *comp);
char *NewStringCopy(char *old);
char *NewAppendedString0(char *old, char *app);
char *NewAppendedString(char *old, char *app);
char **GetLinesFromFile(char *fnam, char **curlns); /* append lines in fnam */
void KillAllStringsInList(char **strs);
void PrintAllStringsInList(char *exp, char **strs);
char *FreeListGetString(char **strs, int n);
char **NewOneStringList(char **strs, int n);

#define syschk(ln_) \
{ \
   int ierr; \
   ierr = system(ln_); \
   if (ierr) \
   { \
      fprintf(stderr, "ERROR %d IN SYSCMND: '%s'\n", ierr, (ln_)); \
      exit(ierr); \
   } \
}

#define Mciswspace(C) ( (((C) > 8) && ((C) < 14)) || ((C) == 32) )
#define Mlowcase(C) ( ((C) > 64 && (C) < 91) ? (C) | 32 : (C) )

#define BADINT -777938

#endif
@ROUT cputhrottle.txt
It appears that your Operating System is doing CPU throttling.  Because
the OS adjusts the Mhz of the CPU as things are running, timings become
extremely unreliable.  An ATLAS install, therefore, is completely useless
(ATLAS makes optimization decisions on essentially random data).  Therefore,
you need to disable CPU throttling before continuing the install.  On most
machines this may be done by changing the BIOS settings (eg., on my Athlon-64
machine, I can say "No" to "Cool and Quiet" under "Power Management").
Alternatively, most operating systems allow you to set it yourself.  Under
many Linux distros, a command similar to this will work:
   /usr/bin/cpufreq-selector -g performance \
      -f `cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq`

For multiprocessors, you have to issue this command for each cpu, adding
the '-c #' flag for each.

On Kubuntu, I had problems with this not working because scaling_max_freq
was set to the minimal speed.  To fix, I had to first increase the max scaling
frequency, which you can do (as root) by (where <#> below is replaced by each processor
number (eg., 0 and 1 for dual processor system):
   cd /sys/devices/system/cpu/cpu<#>/cpufreq
   cp cpuinfo_max_freq scaling_max_freq

Under MacOS or Windows, you may be able to change this under the power settings.
In any case, either change this using your OS or BIOS, and try again, as ATLAS
cannot achieve a valid install in the face of CPU throttling.
@ROUT CompMake.txt
#  ---------------------------------------------------------------------------
#  Various compilers and linkers.  The compilers recognized by ATLAS are:
#    F77 :  Compiler to compile f77 interface code with -- Should match what
#           user compile's his own code with; has no affect on ATLAS 
#           performance
#    ICC :  Compiler to used to compile all non-kernels in ATLAS, including
#           C interface codes.  Should match whatever compiler user compiles
#           with.  Impact on performance should be minimal.
#    SMC :  Compiler to use to compile single precision matmul kernels
#    DMC :  Compiler to use to compile double precision matmul kernels
#    SKC :  Compiler to use to compile single precision non-matmul kernels
#    DKC :  Compiler to use to compile double precision non-matmul kernels
#    XCC :  Compiler to be used on the compile engine of a cross-compiler
#  These C compiler are mostly the same, but flags are often different.
#  Note that if you specify no F77 compiler, F77 will be set to a C compiler
#  to aid in linking.
#  ---------------------------------------------------------------------------
@ROUT probe_os
#include "atlconf.h"

enum OSTYPE ProbeOS(int verb, char *targ)
{
   int ierr;
   char ln[1024], ln2[1024];
   enum OSTYPE i, OS;
   char *unam;

   if (verb) printf("Probing to make operating system determination:\n");
   unam = FindUname(targ);

   sprintf(ln2, "%s -s", unam);
   ierr = CmndOneLine(targ, ln2, ln);
   if (ierr == 0)
   {
/* 
 *    Accept GNU (HURD) as Linux, since they seem to use same stuff;
 *    This is patch from Sylvestre Ledru; I have no direct experience wt HURD
 */
      if(strstr(ln, "Linux") || strstr(ln, "GNU")) OS = OSLinux;
      else if(strstr(ln, "FreeBSD")) OS = OSFreeBSD;
      else if (strstr(ln, "Darwin")) OS = OSOSX;
      else if(strstr(ln, "SunOS")) 
      {
         sprintf(ln2, "%s -r", unam);
         CmndOneLine(targ, ln2, ln);
         if (ln[0] == '4') OS = OSSunOS4;
         else OS = OSSunOS;
      }
      else if(strstr(ln, "OSF1")) OS = OSOSF1;
      else if(strstr(ln, "IRIX")) OS = OSIRIX;
      else if(strstr(ln, "AIX")) OS = OSAIX;
      else if(strstr(ln, "Interix")) OS = OSWinSFU;
      else if(strstr(ln, "WIN"))
      {
         if (strstr(ln, "95") || strstr(ln, "98") || strstr(ln, "_ME")) 
            OS = OSWin9x;
/*
 *       Need to confirm what is returned under cygwin for XP, etc.
 */
         else if (strstr(ln, "NT")) OS = OSWinNT;
         else ierr = 1;
      }
      else if (strstr(ln, "HP-UX")) OS = OSHPUX;
      else ierr = 1;
   }
   if (ierr)
   {
      printf("\n\nUnable to determine OS, quitting\n\n");
      exit(-1);
   }
   if (verb)
      printf("Operating system configured as %s\n\n", osnam[OS]);

   return(OS);
}

void PrintUsage(char *name, int i)
{
   fprintf(stderr, "Error around argument %d\n", i);
   fprintf(stderr, "USAGE: %s -v <verbose #> -T <targ machine>\n", name);
   exit(-1);
}

int GetFlags(int nargs, char **args, char *targ)
{
   int verb=1, i;
   *targ = '\0';
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i);
      switch(args[i][1])
      {
      case 'v':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         verb = atoi(args[i]);
         break;
      case 'T':                    /* target machine for spawn */
         if (++i >= nargs)
            PrintUsage(args[0], i);
         strcpy(targ, args[i]);
         break;
      default:
         PrintUsage(args[0], i);
      }
   }
   return(verb);
}

int main(int nargs, char **args)
{
   int verb;
   char targ[1024];
   enum OSTYPE OS;
   verb = GetFlags(nargs, args, targ);
   OS = ProbeOS(verb, *targ == '\0' ? NULL : targ);
   printf("OS=%d\n", OS);
   return(OS == OSOther);
}
@ROUT probe_asm
#include "atlconf.h"

int RunASMProbe(char *targ, int verb, enum OSTYPE OS, char *asmnam)
{
   char ln[2048], ln2[2048];
   if (targ)
      sprintf(ln2, "make IRun_%s atlrun=atlas_runX args=\"-v %d\" MYFLAGS=\"-DATL_OS_%s\" targ=%s 2> /dev/null | fgrep SUCCESS",
              asmnam, verb, osnam[OS], targ);
   else
      sprintf(ln2, "make IRun_%s args=\"-v %d\" MYFLAGS=\"-DATL_OS_%s\" 2> /dev/null | fgrep SUCCESS",
              asmnam, verb, osnam[OS]);
   if (verb > 1)
      fprintf(stderr, "system(%s)\n", ln2);
   if(!CmndOneLine(NULL, ln2, ln))
   {
      if (strstr(ln, "SUCCESS"))
      {
         if (verb)
            fprintf(stdout, "   %s: DETECTED!\n", asmnam);
         return(1);
      }
   }
   if (verb)
      fprintf(stdout, "   %s: NO.\n", asmnam);
   return(0);
}

enum ASMDIA ProbeASM(char *targ, int verb, enum OSTYPE OS)
{
   int i;
   for (i=1; i < NASMD; i++)
      if (RunASMProbe(targ, verb, OS, ASMNAM[i]))
         return(i);
   return(ASM_None);
}

@beginskip
void PrintUsage(char *name, int i)
{
   fprintf(stderr, "Error around argument %d\n", i);
   fprintf(stderr, "USAGE: %s -O <os#> [-v <verbose #> -T <targ machine>]\n", name);
   exit(-1);
}
@endskip

@extract -b @(basd)/atlconf.base rout=GetFlags -def -O "" -def -v ""

int main(int nargs, char **args)
{
   char *targ;
   int verb;
   enum OSTYPE OS;
   enum ASMDIA asmd;
   GetFlags(nargs, args, &verb, &OS, &targ);
   asmd = ProbeASM(targ, verb, OS);
   printf("ASM=%d\n", asmd);
   return(asmd == ASM_None);
}
@ROUT Makefile
SHELL=/bin/sh
@skip TOPdir = /home/whaley/TEST
@skip CC = gcc
@skip CFLAGS = -g
SRCdir = $(TOPdir)/CONFIG/src
INCdir = $(TOPdir)/CONFIG/include
mydir = $(BLDdir)
atlrun = atlas_run
INCFLAGS = -I$(INCdir)
MYFLAGS =
CCFLAGS = $(INCFLAGS) $(MYFLAGS) $(CFLAGS)
XCC = $(CC)
XCFLAGS = $(CCFLAGS)
LIBS =
args =
rdir = /tmp
arch=
GUNZIP = gunzip
TAR = tar
wind=/usr/local/bin

all : build
xconfig : $(SRCdir)/config.c atlconf_misc.o
	$(XCC) $(XCFLAGS) -o xconfig $(SRCdir)/config.c atlconf_misc.o $(LIBS)
xspew : $(SRCdir)/SpewMakeInc.c atlconf_misc.o
	$(XCC) $(XCFLAGS) -o xspew $(SRCdir)/SpewMakeInc.c atlconf_misc.o \
               $(LIBS)
xisgcc : $(SRCdir)/IsGcc.c atlconf_misc.o
	$(XCC) $(XCFLAGS) -o $@ $(SRCdir)/IsGcc.c atlconf_misc.o $(LIBS)
mgwgfortran : $(SRCdir)/mgwcmp.c
	$(XCC) $(XCCFLAGS) "-DDEFDF=$(cmppath)" -o $@ $(SRCdir)/mgwcmp.c
mgwgcc : $(SRCdir)/mgwcmp.c
	$(XCC) $(XCCFLAGS) "-DDEFDF=$(cmppath)" -o $@ $(SRCdir)/mgwcmp.c
mgwar : $(SRCdir)/mgwcmp.c
	$(XCC) $(XCCFLAGS) "-DDEFDF=$(cmppath)" -o $@ $(SRCdir)/mgwcmp.c
mgwranlib : $(SRCdir)/mgwcmp.c
	$(XCC) $(XCCFLAGS) "-DDEFDF=$(cmppath)" -o $@ $(SRCdir)/mgwcmp.c

$(wind)/ATLwin_ifort.exe : $(SRCdir)/winf77.c
	gcc -mno-cygwin -o $(wind)/ATLwin_ifort.exe -DDEFDF=ifort \
            $(SRCdir)/winf77.c
$(wind)/ATLwin_icc.exe : $(SRCdir)/wincc.c
	gcc -mno-cygwin -o $(wind)/ATLwin_icc.exe -DDEFDF=icl \
            $(SRCdir)/wincc.c
@whiledef wcc icl cl
$(wind)/ATLwin_@(wcc).exe : $(SRCdir)/wincc.c
	gcc -mno-cygwin -o $(wind)/ATLwin_@(wcc).exe -DDEFDF=@(wcc) \
            $(SRCdir)/wincc.c
@endwhile
xprobe_comp : xisgcc probe_comp.o atlconf_misc.o
	$(XCC) $(XCFLAGS) -o xprobe_comp probe_comp.o atlconf_misc.o $(LIBS)
@whiledef prb OS asm vec arch f2c pmake aff
xprobe_@(prb) : probe_@(prb).o atlconf_misc.o
	$(XCC) $(XCFLAGS) -o xprobe_@(prb) probe_@(prb).o atlconf_misc.o $(LIBS)
@endwhile

xprint_enums : $(SRCdir)/print_enums.c
	$(XCC) $(XCFLAGS) -o xprint_enums $(SRCdir)/print_enums.c
xatlbench : atlbench.o atlconf_misc.o
	$(XCC) $(XCFLAGS) -o xatlbench atlbench.o atlconf_misc.o
@whiledef file atlconf_misc probe_OS probe_asm probe_vec probe_arch probe_comp probe_f2c probe_pmake atlbench probe_aff
@(file).o : $(SRCdir)/@(file).c
	$(XCC) $(XCFLAGS) -c $(SRCdir)/@(file).c
@endwhile
@whiledef file atlconf_misc
@(file)_BE.o : $(SRCdir)/@(file).c
	$(CC) $(CCFLAGS) -o @(file)_BE.o -c $(SRCdir)/@(file).c
@endwhile

atlas_run :
	cd $(atldir) ; ./$(exe) $(args) > $(redir)
atlas_runX :
	scp $(atldir)/$(exe) $(targ):$(rdir)/$(exe)
	ssh $(targ) 'cd $(rdir) ; ./$(exe) $(args)' > $(redir)
force_build:

#
# General probes always ran locally (possibly cross-compiling machine)
# General probes call system (they're essentially shell scripts)
#
@whiledef prb OS comp
IRun_@(prb): xprobe_@(prb) force_build
	- rm -f config1.out
	$(MAKE) atlas_run atldir=$(mydir) exe=xprobe_@(prb) args="$(args)" \
                redir=config1.out
	- cat config1.out
@endwhile
@whiledef prb f2c asm vec arch pmake aff
IRun_@(prb): xprobe_@(prb) force_build
	- rm -f config2.out
	$(MAKE) atlas_run atldir=$(mydir) exe=xprobe_@(prb) args="$(args)" \
                redir=config2.out
	- cat config2.out
@endwhile

#
# Machine-level probes run on machine lib being compiled for
# These probes do not call system, but actually do something
#
IRun_NEON :
	$(CC) $(CCFLAGS) -mfpu=neon -o xprobe_neon \
              $(SRCdir)/backend/probe_svec.c $(SRCdir)/backend/probe_NEON.S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_neon args="$(args)" \
                redir=config0.out
	- cat config0.out
@multidef pre s    d    s       d   s
@whiledef asm SSE1 SSE2 AltiVec VSX 3DNow
IRun_@(asm) :
	$(CC) $(CCFLAGS) -o xprobe_@low@(asm) $(SRCdir)/backend/probe_@(pre)vec.c $(SRCdir)/backend/probe_@(asm).S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_@low@(asm) args="$(args)" \
                redir=config0.out
	- cat config0.out
   @undef pre
@endwhile
IRun_SSE3 :
	$(CC) $(CCFLAGS) -o xprobe_sse3 $(SRCdir)/backend/probe_dSSE3.c $(SRCdir)/backend/probe_SSE3.S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_sse3 args="$(args)" \
                redir=config0.out
	- cat config0.out
IRun_AVXMAC :
	$(CC) $(CCFLAGS) -o xprobe_avxmac $(SRCdir)/backend/probe_dAVX.c \
              $(SRCdir)/backend/probe_AVXMAC.S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_avxmac args="$(args)" \
                redir=config0.out
	- cat config0.out
IRun_AVX :
	$(CC) $(CCFLAGS) -o xprobe_avx $(SRCdir)/backend/probe_dAVX.c \
              $(SRCdir)/backend/probe_AVX.S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_avx args="$(args)" \
                redir=config0.out
	- cat config0.out
@whiledef aff BINDP PBIND PLPA RUNON SCHED SETAFFNP SETPROCNP CPUSET WIN WIN64
IRun_@(aff) :
	$(CC) $(CCFLAGS) -o xprobe_@(aff) $(SRCdir)/backend/probe_aff_@(aff).c \
              $(LIBS)
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_@(aff) args="$(args)" \
                redir=config0.out
	- cat config0.out
@endwhile

@whiledef asm GAS_x8632 GAS_x8664 GAS_PPC GAS_PARISC GAS_SPARC GAS_ARM GAS_S390
IRun_@(asm) :
	$(CC) $(CCFLAGS) -o xprobe_@low@(asm) $(SRCdir)/backend/probe_this_asm.c $(SRCdir)/backend/probe_@low@(asm).S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_@low@(asm) args="$(args)" \
                redir=config0.out
	- cat config0.out
@endwhile

IRunC2C :
	- rm -f config0.out xc2c c2cslave.o
	$(CC1) $(CC1FLAGS) -c $(SRCdir)/backend/c2cslave.c
	$(CC) $(CCFLAGS) -o xc2c $(SRCdir)/backend/c2cmaster.c c2cslave.o
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xc2c args="$(args)" \
                redir=config0.out
	- cat config0.out
IRunFlib :
	@ - rm config0.out
	@ $(F77) $(F77FLAGS) -v -o xtst $(SRCdir)/backend/comptestF.f 2>&1 | \
           fgrep -e '-L' > config0.out
	@ rm -f xtst
	@ - cat config0.out
IRunTestCFLink :
	@ - rm -f flibchk[F,C].o xflibchk
	$(F77) $(F77FLAGS) -c $(SRCdir)/backend/flibchkF.f
	$(CC) $(CCFLAGS) -o xflibchk $(SRCdir)/backend/flibchkC.c \
              flibchkF.o -l $(F77LIB) $(LIBS)
@whiledef nam name int str
IRunF2C_@(nam):
	- rm -f f2c@(nam)F.o f2c@(nam)C.o xfc@(nam) config0.out
	$(CC) $(CCFLAGS) -c $(SRCdir)/backend/f2c@(nam)C.c
	$(F77) $(F77FLAGS) -o xf2c@(nam) $(SRCdir)/backend/f2c@(nam)F.f \
               f2c@(nam)C.o
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xf2c@(nam) args="$(args)" \
                redir=config0.out
	- cat config0.out
@endwhile
IRunF77Comp :
	- rm -f xf77test comptestF.o config0.out
	$(F77) $(F77FLAGS) -o xf77test $(SRCdir)/backend/comptestF.f
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xf77test args="$(args)" \
                redir=config0.out
	- cat config0.out
IRunCComp :
	- rm -f xctest comptestC.o config0.out
	$(CC) $(CCFLAGS) -o xctest $(SRCdir)/backend/comptestC.c
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xctest args="$(args)" \
                redir=config0.out
	- cat config0.out

@whiledef prb x86 linux freebsd sunos irix aix sfu win
IRunArchInfo_@(prb): xarchinfo_@(prb)
	- rm -f config0.out
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xarchinfo_@(prb) args="$(args)" \
                redir=config0.out
	- cat config0.out
@endwhile
xarchinfo_x86: $(SRCdir)/backend/archinfo_x86.c $(SRCdir)/backend/cpuid.S
	$(CC) $(CCFLAGS) -o xarchinfo_x86 $(SRCdir)/backend/archinfo_x86.c \
              $(SRCdir)/backend/cpuid.S
@whiledef OS linux freebsd sunos irix aix sfu win
xarchinfo_@(OS) : $(SRCdir)/backend/archinfo_@(OS).c atlconf_misc_BE.o
	$(CC) $(CCFLAGS) -o xarchinfo_@(OS) $(SRCdir)/backend/archinfo_@(OS).c \
              atlconf_misc_BE.o
@endwhile
@whiledef file x8684 x8632 ppc sparc parisc
xprobe_@(file) : $(SRCdir)/backend/probe_this_asm.c $(SRCdir)/backend/probe_gas_@(file).S
	$(CC) $(CCFLAGS) -o xprobe_@(file) $(SRCdir)/backend/probe_this_asm.c \
              $(SRCdir)/backend/probe_gas_@(file).S
@endwhile

DoNothing:

make_subdirs:
	mkdir src bin tune interfaces
	cd src ; mkdir testing auxil blas lapack pthreads threads
	cd src/blas ; \
           mkdir f77reference reference gemv ger gemm kbmm \
                 level1 level2 level3 pklevel3
	cd src/blas/reference ; mkdir level1 level2 level3
	cd src/blas/level2 ; mkdir kernel
	cd src/blas/pklevel3 ; mkdir gpmm sprk
	cd src/blas/level3 ; mkdir rblas kernel
	cd src/pthreads ; mkdir blas misc
	cd src/pthreads/blas ; mkdir level1 level2 level3
	cd src/threads ; mkdir blas lapack
	cd src/threads/blas ; mkdir level3 level2
@skip	cd src/threads/blas/level3 ; mkdir omp
	cd tune ; mkdir blas sysinfo lapack threads
	cd tune/blas ; mkdir gemm gemv ger level1 level3
@beginskip
@whiledef rt sysinfo blas/gemm blas/gemv blasger blas/level1 blas/level3
        cd tune/@(rt) ; mkdir res
@endwhiledef
@endskip
	cd interfaces ; mkdir blas lapack
@whiledef rt blas lapack
	cd interfaces/@(rt) ; mkdir C F77
	cd interfaces/@(rt)/C ; mkdir src testing
	cd interfaces/@(rt)/F77 ; mkdir src testing
@endwhile
	cd interfaces/lapack ; mkdir C2F
	cd interfaces/lapack/C2F ; mkdir src
	mkdir ARCHS

#
# Simple test returns error if directory doesn't exist
#
DirIsThere :
	cd $(tdir)
$(arch)_defs : $(SRCdir)/CONFIG/$(arch).tar.gz
	$(GUNZIP) -c $(SRCdir)/CONFIG/$(ARCH).tar.gz | $(TAR) xvf -
archdef :
	$(MAKE) -f Make.top archdef
time : xatlbench
	$(MAKE) -f Make.top time
build :
	$(MAKE) -f Make.top build
	$(MAKE) clean
error_report:
	$(MAKE) -f Make.top error_report
startup : 
	$(MAKE) -f Make.top startup
refresh :
	$(MAKE) -f Make.top refresh
kill  :
	$(MAKE) -f Make.top kill
killall:
	$(MAKE) -f Make.top killall
C_test :
	$(MAKE) -f Make.top C_sanity_test
C_pttest :
	$(MAKE) -f Make.top C_ptsanity_test
check : $(TESTS)
ptcheck : $(PTTESTS)
full_test :
	$(MAKE) -f Make.top full_test
full_test_nh :
	$(MAKE) -f Make.top full_test_nh
scope_full_test :
	$(MAKE) -f Make.top scope_full_results
@whiledef la fl sl al
   @whiledef bl fb sb ab pt
scope_lapack_test_@(la)_@(bl) :
	$(MAKE) -f Make.top scope_lapack_test_@(la)_@(bl)
lapack_test_@(la)_@(bl) :
	$(MAKE) -f Make.top lapack_test_@(la)_@(bl)
   @endwhile
@endwhile
test :
	$(MAKE) -f Make.top sanity_test
pttest :
	$(MAKE) -f Make.top ptsanity_test
$(INCINSTdir) :
	mkdir -p $(INCINSTdir)
	chmod 0755 $(INCINSTdir)
$(INCINSTdir)/atlas :
	mkdir -p $(INCINSTdir)/atlas
	chmod 0755 $(INCINSTdir)/atlas
$(LIBINSTdir) :
	mkdir -p $(LIBINSTdir)
	chmod 0755 $(LIBINSTdir)
install : $(INCINSTdir) $(LIBINSTdir) $(INCINSTdir)/atlas
	$(MAKE) -f Make.top install_inc INSTdir=$(INCINSTdir) 
	$(MAKE) -f Make.top install_lib INSTdir=$(LIBINSTdir)

confclean: $(CLEANdep)
	rm -f *core* *.o config?.out
clean : $(CLEANdep)
	rm -f *.o x* config?.out *core*
cleanall: clean
	$(MAKE) -f Make.top clean
@ROUT atlas_asm.h
#ifndef ATLAS_ASM_H
   #define ATLAS_ASM_H

#ifndef Mjoin
   #define Mjoin(pre, nam) my_join(pre, nam)
   #define my_join(pre, nam) pre ## nam
#endif

#if (defined(ATL_OS_WinNT) && !defined(ATL_USE64BITS)) || \
    defined(ATL_OS_Win9x) || defined(ATL_OS_OSX) || defined(ATL_OS_WinSFU)
   #define ATL_asmdecor(nam) Mjoin(_,nam)
#elif defined(ATL_OS_AIX) && defined(ATL_GAS_PPC)
   #define ATL_asmdecor(nam) Mjoin(.,nam)
#elif !defined(ATL_OS_OSX) && defined(ATL_GAS_PPC) && defined(ATL_USE64BITS)
   #define ATL_asmdecor(nam) Mjoin(.,nam)
#else
   #define  ATL_asmdecor(nam) nam
#endif

#ifdef ATL_GAS_PARISC
   #ifdef ATL_OS_HPUX
      #define ATL_HPUX_PARISC
   #else
      #define ATL_LINUX_PARISC
   #endif
#endif

#ifdef ATL_GAS_PPC
   #ifdef ATL_OS_OSX
      #define ATL_AS_OSX_PPC
   #elif defined(ATL_OS_AIX)
      #define ATL_AS_AIX_PPC
   #else
      #define ATL_GAS_LINUX_PPC
   #endif
#endif

#if defined(ATL_GAS_LINUX_PPC) || defined(ATL_AS_AIX_PPC)

@define i @0@
@iwhile i < 32
   #define r@(i) @(i)
   #define f@(i) @(i)
   #define v@(i) @(i)
   @iexp i 1 @(i) +
@endiwhile
@iwhile i < 64
   #define v@(i) @(i)
   @iexp i 1 @(i) +
@endiwhile
@define i @0@
@iwhile i < 8
   #define cr@(i) @(i)
   @iexp i 1 @(i) +
@endiwhile
@iexp i 32 0 +


#endif

#ifdef ATL_OS_OSX
@multidef l   7  6  5  4 3 2 1
@whiledef b 128 64 32 16 8 4 2
   #define ALIGN@(b) .align @(l)
   @undef l
@endwhile
   #define global globl
   #define local  locl
#else
@whiledef b 128 64 32 16 8 4 2
   #define ALIGN@(b) .align @(b)
@endwhile
#endif

#if defined(ATL_SSE1) && !defined(ATL_3DNow)
   #define prefetchw prefetchnta
#endif
/*
 * Solaris doesn't allow division in integer expressions in assembly, but
 * many x86 kernels need to do $MB/mu; we work around this insanity with
 * this kludge
 */
#if defined(ATL_DIV_NUM) && defined(ATL_DIV_DEN)
   #if (ATL_DIV_NUM/ATL_DIV_DEN) == 0
      #define ATL_DivAns 0
@define i @1@
@iwhile i < 129
   #elif (ATL_DIV_NUM/ATL_DIV_DEN) == @(i)
      #define ATL_DivAns @(i)
   @iexp i 1 @(i) +
@endiwhile
   #endif
#endif

/*
 * For GNU/Linux, set no-execute bit for all ATLAS assembly
 */
#if defined(ATL_OS_Linux) && defined(__ELF__) && defined(__GNUC__) && \
    defined(ATL_SSE1)
.section .note.GNU-stack,"",%progbits
#endif

#endif
@ROUT probe_this_asm
#include <stdio.h>
#include <stdlib.h>

int main(int nargs, char **args)
{
   int asm_probe(int i);
   int i;
   i = asm_probe(7);
   if (i != 21)
   {
      fprintf(stdout, "FAILURE, i=%d!!\n", i);
      fprintf(stderr, "FAILURE, i=%d!!\n", i);
      exit(-1);
   }
   fprintf(stdout, "SUCCESS\n");
   return(0);
}
@ROUT probe_gas_arm.S
#define ATL_GAS_ARM
#include "atlas_asm.h"
#
# Linux ARM assembler for:
# int asm_probe(int i)
# RETURNS: i*3
#
.text
.code   32
.globl  ATL_asmdecor(asm_probe)
ATL_asmdecor(asm_probe):
        add     r0, r0, r0, LSL #1
        bx      lr
.size ATL_asmdecor(asm_probe),.-ATL_asmdecor(asm_probe)
@ROUT probe_gas_x8664.S
#include "atlas_asm.h"
# x86-64 assembler for:
# int asm_probe(int i)
# RETURNS: i*3
#
.text
.global ATL_asmdecor(asm_probe)
ATL_asmdecor(asm_probe):
        xor     %rax, %rax
        movl    %edi, %eax
        shl     $1, %eax
        addl    %edi, %eax
        ret
@ROUT probe_gas_x8632.S
#include "atlas_asm.h"
#
# x86-32 assembler for:
# int asm_probe(int i)
# RETURNS: i*3
#
.text
.globl ATL_asmdecor(asm_probe)
ATL_asmdecor(asm_probe):
        movl    4(%esp), %eax
        movl    %eax, %ecx
        shl     $1, %eax
        addl    %ecx, %eax
        ret
@ROUT probe_gas_mips.S
#include "atlas_asm.h"

; MIPS assembler for:
; int asm_probe(int i)
; RETURNS: i*3
.globl ATL_asmdecor(asm_probe)
ATL_asmdecor(asm_probe):
        daddu   $2, $4, $4
        j       $31
        daddu   $2, $2, $4    /* delay slot of return */
@ROUT probe_gas_ppc.S
#define ATL_GAS_PPC
#include "atlas_asm.h"
/*
 * Linux PPC assembler for:
 * int asm_probe(int i)
 * RETURNS: i*3
 */
.globl ATL_asmdecor(asm_probe)
ATL_asmdecor(asm_probe):
        add     r4, r3, r3
        add     r3, r3, r4
        blr
@ROUT probe_gas_sparc.S
!
! sparc assembler for:
! int asm_probe(int i)
! RETURNS: i*3
!
.section        ".text"
        .align 4
        .global asm_probe
@skip        .type   asm_probe,#function
asm_probe:
        sll     %o0, 1, %o1
        add     %o1, %o0, %o0
        retl
        nop
@ROUT probe_gas_parisc.S
        .LEVEL 2.0
#ifdef ATL_OS_HPUX
        .SPACE $TEXT$
        .SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY
#else
        .text
#endif
; PA-RISC assembler for:
; int asm_probe(int i)
; RETURNS: i*3
        .align 4
#ifdef ATL_OS_HPUX
        .SUBSPA $CODE$
        .EXPORT asm_probe,ENTRY,PRIV_LEV=3
asm_probe
#else
        .globl asm_probe
asm_probe:
#endif
        .PROC
        .CALLINFO FRAME=0,NO_CALLS
        .ENTRY
        depw,z  %r26, 29,30, %r28  ; r28 = 4 * i
        sub     %r28, %r26, %r28
        bve     (%r2)
        nop
        .EXIT
        .PROCEND
@ROUT probe_dSSE3
#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char **args)
{
   double *x, *y, *z, ans[2];
   void *vp;
   void do_vsum(double *z, double *x, double *y); 

   vp = malloc(2*3*sizeof(double) + 16);
   x = (double*) ( 16 + ((((size_t)(vp))>>4)<<4) );
   y = x + 2;
   z = y + 2;
   x[0] = 1.0; x[1] = 2.0;
   y[0] = 4.0; y[1] = 8.0;
   ans[0] = x[0] + x[1];
   ans[1] = y[0] + y[1];
   do_vsum(z, x, y);   /* z[0]=x[0]+x[1], z[1]=y[0]+y[1]; */
   if (z[0] != ans[0] || z[1] != ans[1])
   {
      fprintf(stderr, "wanted={%.2f,%.2f}, got={%.2f,%.2f}\n",
              ans[0], ans[1], z[0], z[1]);
      printf("FAILURE\n");
      free(vp);
      exit(1);
   }
   printf("SUCCESS\n");
   free(vp);
   return(0);
}
@ROUT probe_dAVX
#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char **args)
{
   double *x, *y, *z, ans[4];
   void *vp;
   void do_vmacc(double *z, double *x, double *y); 
   int i;

   vp = malloc(4*3*sizeof(double) + 32);
   x = (double*) ( 32 + ((((size_t)(vp))>>5)<<5) );
   y = x + 4;
   z = y + 4;
   x[0] = 1.0; x[1] = 2.0; x[2] = 4.0; x[3] = 8.0;
   y[0] = -4.0; y[1] = -8.0; y[2] = -16.0; y[3] = -32.0;
   z[0] = 0.0; z[1] = 1.0; z[2] = -1.0; z[3] = -4.0;
   for (i=0; i < 4; i++)
      ans[i] = z[i] + x[i] * y[i];
   do_vmacc(z, x, y);   /* z += x * y */
   if (z[0] != ans[0] || z[1] != ans[1] || z[2] != ans[2] || z[3] != ans[3])
   {
      fprintf(stderr, 
              "wanted={%.2f,%.2f,%.2f,%.2f}, got={%.2f,%.2f,%.2f,%.2f}\n",
              ans[0], ans[1], ans[2], ans[3], z[0], z[1], z[2], z[3]);
      printf("FAILURE\n");
      free(vp);
      exit(1);
   }
   printf("SUCCESS\n");
   free(vp);
   return(0);
}
@ROUT probe_dvec
#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char **args)
{
   double *x, *y, *z, ans[2];
   void *vp;
   void do_vsum(double *, double *, double *);

   vp = malloc(2*3*sizeof(double) + 16);
   x = (double*) ( 16 + ((((size_t)(vp))>>4)<<4) );
   y = x + 2;
   z = y + 2;
   x[0] = 1.0; x[1] = 2.0;
   y[0] = 4.0; y[1] = 8.0;
   ans[0] = x[0] + y[0];
   ans[1] = x[1] + y[1];
   do_vsum(z, x, y);
   if (z[0] != ans[0] || z[1] != ans[1])
   {
      fprintf(stderr, "wanted={%.2f,%.2f}, got={%.2f,%.2f}\n",
              ans[0], ans[1], z[0], z[1]);
      printf("FAILURE\n");
      free(vp);
      exit(1);
   }
   printf("SUCCESS\n");
   free(vp);
   return(0);
}
@ROUT probe_svec
#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char **args)
{
   float *x, *y, *z, ans[4];
   void *vp;
   void do_vsum(float *, float *, float *);

   vp = malloc(4*3*sizeof(float) + 16);
   x = (float*) ( 16 + ((((size_t)(vp))>>4)<<4) );
   y = x + 4;
   z = y + 4;
   x[0] = 8.0;  x[1] = 4.0;  x[2] = 2.0;  x[3] = 1.0;
   y[0] = 16.0; y[1] = 32.0; y[2] = 64.0; y[3] = 128.0;
   ans[0] = x[0] + y[0];
   ans[1] = x[1] + y[1];
   ans[2] = x[2] + y[2];
   ans[3] = x[3] + y[3];
   do_vsum(z, x, y);
   if (z[0] != ans[0] || z[1] != ans[1] || z[2] != ans[2] || z[3] != ans[3])
   {
      fprintf(stderr, 
              "wanted={%.2f,%.2f,%.2f,%.2f}, got={%.2f,%.2f,%.2f,%.2f}\n",
              ans[0], ans[1], ans[2], ans[3], z[0], z[1], z[2], z[3]);
      printf("FAILURE\n");
      free(vp);
      exit(1);
   }
   printf("SUCCESS\n");
   free(vp);
   return(0);
}
@ROUT probe_3DNow.S
#include "atlas_asm.h"
#
# x86 assembler for:
# void do_vsum(z, x, y)
# RETURNS: z = x + y;
#
.text
.globl ATL_asmdecor(do_vsum)
ATL_asmdecor(do_vsum):
#ifdef ATL_GAS_x8664
        movq    (%rsi), %mm0
        movq    8(%rsi), %mm1
        movq    (%rdx), %mm2
        movq    8(%rdx), %mm3
        pfadd   %mm2, %mm0
        pfadd   %mm3, %mm1
        movq    %mm0, (%rdi)
        movq    %mm1, 8(%rdi)
        emms
        ret
#else
        movl    12(%esp), %eax
        movq    (%eax), %mm0
        movq    8(%eax), %mm1
        movl    8(%esp), %eax
        movq    (%eax), %mm2
        movq    8(%eax), %mm3
        pfadd   %mm2, %mm0
        pfadd   %mm3, %mm1
        movl    4(%esp), %eax
        movq    %mm0, (%eax)
        movq    %mm1, 8(%eax)
        emms
        ret
#endif
@ROUT probe_NEON.S
#include "atlas_asm.h"
#
# ARM NEON assembler for:
# void do_vsum(float* z,float* x,float* y)
#  where x, y, and z are vectors of length 4
# RETURNS: z = x + y;
#
.text
.code   32
.globl  ATL_asmdecor(do_vsum)
ATL_asmdecor(do_vsum):
   vldm     r1,     {d0-d1}
   vldm     r2,     {d2-d3}
   vadd.f32 d0,     d0,      d2
   vadd.f32 d1,     d1,      d3
   vstm     r0,     {d0-d1}
   bx lr
.size ATL_asmdecor(do_vsum),.-ATL_asmdecor(do_vsum)
@ROUT probe_SSE1.S
#include "atlas_asm.h"
#
# x86 assembler for:
# void do_vsum(z, x, y)
# RETURNS: z = x + y;
#
.text
.globl ATL_asmdecor(do_vsum)
ATL_asmdecor(do_vsum):
#ifdef ATL_GAS_x8664
        movups  0(%rsi), %xmm0
        movups  0(%rdx), %xmm1
        addps   %xmm1, %xmm0
        movups  %xmm0, 0(%rdi)
        ret
#else
        movl    12(%esp), %eax
        movups  0(%eax), %xmm0
        movl    8(%esp), %eax
        movups  (%eax), %xmm1
        addps   %xmm1, %xmm0
        movl    4(%esp), %eax
        movups  %xmm0, 0(%eax)
        ret
#endif
@ROUT probe_SSE2.S
#include "atlas_asm.h"
#
# x86 assembler for:
# void do_vsum(z, x, y)
# RETURNS: z = x + y;
#
.text
.globl ATL_asmdecor(do_vsum)
ATL_asmdecor(do_vsum):
#ifdef ATL_GAS_x8664
        movupd  0(%rsi), %xmm0
        movupd  0(%rdx), %xmm1
        addpd   %xmm1, %xmm0
        movupd  %xmm0, 0(%rdi)
        ret
#else
        movl    12(%esp), %eax
        movupd  0(%eax), %xmm0
        movl    8(%esp), %eax
        movupd  (%eax), %xmm1
        addpd   %xmm1, %xmm0
        movl    4(%esp), %eax
        movupd  %xmm0, 0(%eax)
        ret
#endif
@ROUT probe_SSE3.S
#include "atlas_asm.h"
#
# x86 assembler for:
# void do_vsum(z, x, y)
# RETURNS: z[0] = x[0]+x[1]; z[1] = y[0]+y[1];
#
.text
.globl ATL_asmdecor(do_vsum)
ATL_asmdecor(do_vsum):
#ifdef ATL_GAS_x8664
        movupd  0(%rsi), %xmm0
        movupd  0(%rdx), %xmm1
        haddpd  %xmm1, %xmm0
        movupd  %xmm0, 0(%rdi)
        ret
#else
        movl    12(%esp), %eax
        movupd  0(%eax), %xmm0
        movl    8(%esp), %eax
        movupd  (%eax), %xmm1
        haddpd  %xmm0, %xmm1
        movl    4(%esp), %eax
        movupd  %xmm1, 0(%eax)
        ret
#endif
@ROUT probe_AVX.S probe_AVXMAC.S
#include "atlas_asm.h"
#
# x86 assembler for:
# void do_vmacc(z, x, y)
# RETURNS: z[0:3] += x[0:3] *  y[0:3];
#
.text
.globl ATL_asmdecor(do_vmacc)
ATL_asmdecor(do_vmacc):
#ifdef ATL_GAS_x8664
        vmovupd 0(%rdi), %ymm0                  /* load z */
        vmovupd 0(%rsi), %ymm1                  /* load x */
        vmovupd 0(%rdx), %ymm2                  /* load y */
@ROUT probe_AVX.S
        vmulpd %ymm1, %ymm2, %ymm3
        vaddpd %ymm3, %ymm0, %ymm0
@ROUT probe_AVXMAC.S
        vfmadd231pd %ymm2, %ymm1, %ymm0         /* z += x*y */
@ROUT probe_AVX.S probe_AVXMAC.S
        vmovupd %ymm0, 0(%rdi)                  /* store z */
        ret
#else
        movl    12(%esp), %eax
        vmovupd 0(%eax), %ymm2                  /* load y */
        movl    8(%esp), %eax
        vmovupd  (%eax), %xmm1                  /* load x */
        movl    4(%esp), %eax
        vmovupd  (%eax), %xmm0                  /* load z */
@ROUT probe_AVX.S
        vmulpd %ymm1, %ymm2, %ymm3
        vaddpd %ymm3, %ymm0, %ymm0
@ROUT probe_AVXMAC.S
        vfmadd231pd %ymm2, %ymm1, %ymm0         /* z += x*y */
@ROUT probe_AVX.S probe_AVXMAC.S
        vmovupd %xmm0, 0(%eax)                  /* store z */
        ret
#endif
@ROUT probe_AltiVec.S probe_VSX.S
#include "atlas_asm.h"
/*

 * void do_vsum(z, x, y)
 * RETURNS: z = x + y
 *
 */
.text
#if defined(ATL_USE64BITS) && defined (ATL_OS_Linux)
        .align 2
        .globl  ATL_asmdecor(do_vsum)
        .section        ".opd","aw"
        .align 3
#else
.globl ATL_asmdecor(do_vsum)
#endif
ATL_asmdecor(do_vsum):
@ROUT probe_AltiVec.S
        lvx     v0,0,r5
        lvx     v1,0,r4
        vaddfp  v3,v0,v1
        stvx    v3,0,r3
@ROUT probe_VSX.S
        lxvd2x  v0,0,r5
        lxvd2x  v1,0,r4
        xvadddp v3,v0,v1
        stxvd2x  v3,0,r3
@ROUT probe_AltiVec.S probe_VSX.S
        blr
@ROUT probe_vec
@extract -b @(topd)/gen.inc what=cw @(cw06)
#include "atlconf.h"

int RunISAProbe(char *isaxnam, int verb, char *targ, char *opt)
{
   char ln[512], ln2[512];
   if (targ)
      sprintf(ln2, "make IRun_%s atlrun=atlas_runX targ=%s MYFLAGS='%s' 2> /dev/null | fgrep SUCCESS",
              isaxnam, targ, opt);
   else
      sprintf(ln2, "make IRun_%s MYFLAGS='%s' 2> /dev/null | fgrep SUCCESS",
              isaxnam, opt);
   if(!CmndOneLine(NULL, ln2, ln))
   {
      if (strstr(ln, "SUCCESS"))
      {
         if (verb)
            fprintf(stdout, "   %s: DETECTED!\n", isaxnam);
         return(1);
      }
   }
   if (verb > 1)
      fprintf(stdout, "   cmnd='%s' out='%s'\n", ln2, ln);
   if (verb)
      fprintf(stdout, "   %s: NO.\n", isaxnam);
   return(0);
}

int GetAllISAExt(int verb, char *targ, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret=0;
   char ln[256];

   if (verb)
      fprintf(stdout, "\nProbing for supported ISA extensions:\n");

/*
 * For OS X, throw try throwing their random-ass annoyance flag
 */
   if (OS == OSOSX)
   {
      sprintf(ln, "-DATL_OS_%s -DATL_%s -force_cpusubtype_ALL", 
              osnam[OS], ASMNAM[asmb]);
      if (RunISAProbe(ISAXNAM[ISA_AV], verb, targ, ln))
         iret |= (1<<ISA_AV);
   }
   sprintf(ln, "-DATL_OS_%s -DATL_%s", osnam[OS], ASMNAM[asmb]);
   for (i=1; i < NISA; i++)
      if (RunISAProbe(ISAXNAM[i], verb, targ, ln))
         iret |= (1<<i);
   return(iret);
}

@beginskip
PrintUsage(char *name, int i)
{
   fprintf(stderr, "Error around argument %d.\n", i);
   fprintf(stderr, "USAGE: %s -O <OS> -s <asm> [-v <verb> -T <targ>]\n", name);
   exit(-1);
}
@endskip
@extract -b @(basd)/atlconf.base rout=GetFlags -def -O "" -def -s ""

int main(int nargs, char **args)
{
   int verb, iret;
   enum OSTYPE OS;
   enum ASMDIA asmb;
   char *targ;

   GetFlags(nargs, args, &verb, &OS, &asmb, &targ);
   iret = GetAllISAExt(verb, targ, OS, asmb);
   printf("VECFLAG=%d\n", iret);
   return(0);
}
@ROUT probe_aff
#include "atlconf.h"

#define NAFF 11
static char *AFFS[NAFF] = 
   {"NONE", "SETAFFNP", "SETPROCNP", "PBIND", "BINDP", "RUNON", "SCHED", 
    "PLPA", "CPUSET", "WIN64", "WIN"};
@multidef aff NONE SETAFFNP SETPROCNP PBIND BINDP RUNON SCHED PLPA CPUSET WIN64 WIN
@whiledef ii     0       1         2      3     4     5     6    7      8     9 10
#define IA_@(aff) @(ii)
   @undef aff
@endwhile

int RunAffProbe(int iaff, int verb, char *targ, int iproc)
{
   char ln[512], ln2[512];
   char *lib;

   if (iaff == IA_WIN)
      lib = "-lkernel32";
   else if (iaff == IA_WIN64)
      lib = "";    /* works w/o -l for 64-bit MinGW */
   else
      lib = "-lpthread";
   if (targ)
      sprintf(ln2, "make IRun_%s atlrun=atlas_runX targ=%s LIBS='%s' args='%d' 2> /dev/null | fgrep SUCCESS",
              AFFS[iaff], targ, lib, iproc);
   else
      sprintf(ln2, "make IRun_%s LIBS='%s' args='%d' 2> /dev/null | fgrep SUCCESS",
              AFFS[iaff], lib, iproc);
   if(!CmndOneLine(NULL, ln2, ln))
   {
      if (strstr(ln, "SUCCESS"))
      {
         if (verb)
            fprintf(stdout, "   %s: DETECTED!\n", AFFS[iaff]);
         return(1);
      }
   }
   if (verb > 1)
      fprintf(stdout, "   cmnd='%s' out='%s'\n", ln2, ln);
   if (verb)
      fprintf(stdout, "   %s: NO.\n", AFFS[iaff]);
   return(0);
}

int GetPreferredAffinity(enum OSTYPE OS, int OMP)
/*
 * RETURNS: most likely affinity to work according to the OS reading
 */
{
   #ifdef ATL_OS_Linux
      return(OMP ? IA_SCHED : IA_SETAFFNP);
   #elif defined(ATL_OS_SunOS)
      return(IA_PBIND);
   #elif defined(ATL_OS_IRIX)
      return(IA_RUNON);
   #elif defined(ATL_OS_AIX)
      return(IA_BINDP);
   #elif defined(ATL_OS_HPUX)
      return(OMP ? IA_SCHED : IA_SETPROCNP);
   #elif defined(ATL_OS_WinNT)
      return(IA_WIN64);
   #else
      int iret=1;
      if (OS == OSSunOS)
         iret = IA_PBIND;
      else if (OSIsWin(OS))
         iret = IA_WIN;
      else if (OS == OSAIX)
         iret = IA_BINDP;
      else if (OS == OSHPUX)
         iret = OMP ? IA_SCHED : IA_SETPROCNP;
      else if (OSIRIX)
         iret = IA_RUNON;
      else if (OS == OSLinux && OMP)
         iret = IA_SCHED;
      return(iret);
   #endif
}

int ProbeAffinity
(
   int verb,            /* verbosity */
   char *targ,          /* target machine */
   enum OSTYPE OS,      /* detected OS */
   int OMP              /* use OpenMP? */
)
/*
 * Searches all known affinities in AFFS for one that works to spawn to ID=0
 * RETURNS: integer indicating index in AFFS of the type of affinity
 */
{
   int ipref, iret, i;

   ipref = GetPreferredAffinity(OS, OMP);
   if (RunAffProbe(ipref, verb, targ, 0))
      return(ipref);

   for (i=1; i < NAFF; i++)
   {
/*
 *    For OpenMP, try only those methods you can use after thread startup
 */
      if (OMP && (i == IA_SETAFFNP || i == IA_SETPROCNP))
         continue;
      if (i != ipref)
      {
         if (RunAffProbe(i, verb, targ, 0))
            return(i);
      }
   }
   return(0);
}

int *ProbeAffIDs
(
   int verb,            /* verbosity */
   char *targ,          /* target machine */
   enum OSTYPE OS,      /* detected OS */
   int OMP,             /* use OpenMP? */
   int iaff             /* which entry in AFFS to search with */
)
/*
 * Finds list of IDs that can be successfully used in setting affinity
 * RETURNS: integer array, first entry is number of IDs, then IDs.
 *          If all sequential IDs work, then first entry is -maxID,
 *          and remaining entries are ignored.
 */
{
   int i, nID=0, *IDs=NULL, maxlog2, maxID, SEQ=1;

   if (!iaff)
      return(NULL);
/*
 * Find maximum power of two that works as an estimate on max assignable ID.
 * We work on the following assumptions:
 * 1. Systems that have unassignable virtual processors will have physical
 *    processors that are powers of two
 * 2. 128 is big enough to capture at least one physical processor
 * Try powers of two until at least 128.
 */
   if (verb)
      printf("FINDING LARGEST POWER OF 2 ID THAT CAN BE USED IN AFFINITY:\n");
   maxlog2 = -1;
   for (i=0; i < 8; i++)
   {
      if (RunAffProbe(iaff, 0, targ, (1<<i)))
      {
         printf("   ID=%d works.\n", (1<<i));
         maxlog2 = i;
      }
      else
         printf("   ID=%d FAILS.\n", (1<<i));
   }
   if (maxlog2 == -1)
   {
      fprintf(stderr, "ONLY ID=0 WORKS FOR AFFINITY!");
      return(NULL);
   }
/*
 * If 128 worked, continue to search for even more legal assignable IDs,
 * but don't search 4096
 */
   if (maxlog2 == 7)
   {
      for (i=maxlog2+1;  i < 12; i++)
      {
         if (RunAffProbe(iaff, 0, targ, (1<<i)))
         {
            printf("   ID=%d works.\n", (1<<i));
            maxlog2 = i;
         }
         else
            break;
      }
   }
   if (verb)
      printf("LARGEST SUCCESSFUL POWER OF 2 = %d\n\n", (1<<maxlog2));
/*
 * maxlog2 is now the largest (1<<maxlog2) that we successfully can use
 * affinity on.  Note that non-power2 systems like the 3 processor phenom,
 * 6-node MIPS, etc, will still detect something (2 & 4, respectively).
 * Estimate maxID as one beneath the next maxlog2 setting in order to
 * handle these non-power2 cases.  
 */
   maxID = (1 << (maxlog2+1));
   IDs = malloc(sizeof(int)*maxID);
   assert(IDs);
/*
 * Now simply try all IDs between these regions, and record the good ones
 */
   if (verb)
      printf("FINDING ALL VALID IDs BETWEEN 0 AND %d:\n", maxID-1);
   IDs[++nID] = 0;
   SEQ = 1;             /* assume all sequential IDs work */
   for (i=1; i < maxID; i++)
   {
      if (RunAffProbe(iaff, 0, targ, i))
      {
         printf("   ID=%d works.\n", i);
         IDs[++nID] = i;
      }
      else
      {
         printf("   ID=%d FAILS.\n", i);
         SEQ = 0;
      }
   }
/*
 * Indicate all IDs valid between 0 & maxID by setting nID = -maxID
 */
   IDs[0] = (SEQ) ? -IDs[nID] : nID;
   return(IDs);
}
@extract -b @(basd)/atlconf.base rout=GetFlags -def -O "" -def -o "" -def -t "" -def -t2 ""

void PrintResults
(
   char *outfile,  /* NULL or stdout, : stdout, else filename to print to */
   int iaff,       /* detected affinity entry in AFFS */
   int *IDs        /* valid ID list */
)
{
   FILE *fpout;
   if (!outfile || !strcmp(outfile, "stdout"))
      fpout = stdout;
   else if (!strcmp(outfile, "stderr"))
      fpout = stderr;
   else
   {
      fpout = fopen(outfile, "w");
      assert(fpout);
   }
   fprintf(fpout, "/* Generated by %s */\n", __FILE__);
   fprintf(fpout, "#ifndef ATL_TAFFINITY_H\n   #define ATL_TAFFINITY_H\n\n");

   switch(iaff)
   {
   case IA_WIN64:
   case IA_WIN:
      fprintf(fpout, "#include <windows.h>\n");
      break;
   case IA_SETAFFNP:
   case IA_SCHED:
      fprintf(fpout,
   "#define _GNU_SOURCE 1 /* what manpage says you need to get CPU_SET */\n");
      fprintf(fpout,
   "#define __USE_GNU   1 /* what actually works on linuxes I've seen */\n");
      fprintf(fpout, "#include <sched.h>    /* must be included with above defs before pthread.h */\n");
      fprintf(fpout, "\n");
      break;
   case IA_PLPA:
      fprintf(fpout, "#include <plpa.h>\n");
      break;
   case IA_PBIND:
      fprintf(fpout, "#include <sys/types.h>\n");
      fprintf(fpout, "#include <sys/processor.h>\n");
      fprintf(fpout, "#include <sys/procset.h>\n\n");
   case IA_BINDP:
      fprintf(fpout, "#include <sys/thread.h>    /* thread_self header */ \n");
      fprintf(fpout, "#include <sys/processor.h> /* bindprocessor header */\n");
      break;
   case IA_CPUSET:
      fprintf(fpout, "#include <sys/param.h>\n");
      fprintf(fpout, "#include <sys/cpuset.h>\n");
      break;
   }
   fprintf(fpout, "#define ATL_HAS_AFFINITY %d\n", iaff);
   fprintf(fpout, "#define ATL_PAFF_%s 1\n", AFFS[iaff]);
   if (iaff)
   {
      if (iaff == IA_SETAFFNP || iaff == IA_SETPROCNP)
         fprintf(fpout, 
"#define ATL_PAFF_LAUNCH 1  /* affinity can be set during thread launch */\n");
      else
         fprintf(fpout, 
"#define ATL_PAFF_SELF 1  /* affinity must be set by thr after launched */\n");
      if (IDs[0] < 0)
      {
         fprintf(fpout, "#define ATL_AFF_NUMID %d\n", -IDs[0]+1);
         fprintf(fpout, "#define ATL_AFF_IDSTRIDE 1\n");
         fprintf(fpout, 
                 "#define ATL_RANK_IS_PROCESSORID 1 /* good IDs [0,%d] */\n",
                 -IDs[0]);
      }
      else
      {
         int i, stride;
         fprintf(fpout, "#define ATL_AFF_NUMID %d\n", IDs[0]);
         fprintf(fpout, "static int ATL_affinityIDs[%d]\n", IDs[0]);
         fprintf(fpout, "   = {%d", IDs[1]);
         stride = IDs[2] - IDs[1];
         for (i=1; i < IDs[0]; i++)
         {
            fprintf(fpout, ", %d", IDs[i+1]);
            if (IDs[i+1] - IDs[i] != stride)
               stride = 0;
         }
         fprintf(fpout, "};\n");
         if (stride)
            fprintf(fpout, "#define ATL_IDSTRIDE %d\n", stride);
         else
            fprintf(fpout, 
"#define ATL_IDSTRIDE 0 /* valid IDs not separated by constant stride */\n");
      }
   }
   else /* no affinity detected */
   {
      fprintf(fpout, "#define ATL_NOAFFINITY 1\n");
      if (fpout != stderr && fpout != stdout)
      {
         FILE *fpo;
         fpo = fopen("res/aff.h", "w");
         fprintf(fpo, "#define ATL_TAFFINITY 0\n");
         fclose(fpo);
      }
   }
   fprintf(fpout, "\n#endif /* end multiple inclusion guard */\n");
   if (fpout != stderr && fpout != stdout)
      fclose(fpout);
}

int main(int nargs, char **args)
{
   int verb, iaff, maxT, OMP, AntThr, *IDs=NULL, i, max;
   enum OSTYPE OS;
   char *targ, *outfile;

   GetFlags(nargs, args, &verb, &OS, &maxT, &OMP, &AntThr, &outfile, &targ);
   iaff = ProbeAffinity(verb, targ, OS, OMP);
   if (iaff)
   {
      IDs = ProbeAffIDs(verb, targ, OS, OMP, iaff);
      assert(IDs);
   }

   printf("AFFINITY TYPE= '%s'\n", AFFS[iaff]);
   if (iaff)
   {
      if (IDs[0] < 0)
         printf("All IDs between [0, %d] are valid\n", -IDs[0]);
      else
      {
         max = IDs[0] + 1;
         printf("IDs[%d]=[%d", IDs[0], IDs[1]);
         for (i=2; i < max; i++)
            printf(", %d", IDs[i]);
         printf("]\n");
      }
   }
   PrintResults(outfile, iaff, IDs);
   free(IDs);
   return(0);
}
@ROUT probe_aff_WIN probe_aff_WIN64
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <windows.h>
#ifndef CREATE_SUSPENDED
   #define CREATE_SUSPENDED 0x00000004
#endif
#ifndef WAIT_FAILED
   #define WAIT_FAILED (~0)
#endif


static int rank=0;

void *DumbTest(void *vp)
{
@ROUT probe_aff_WIN   `   ExitThread((DWORD)(vp));`
@ROUT probe_aff_WIN64 `   _endthread((unsigned)vp);`
}
int main(int nargs, char **args)
{
   HANDLE thrH;
@ROUT probe_aff_WIN   `   DWORD thrID;`
@ROUT probe_aff_WIN64 `   unsigned thrID;`
   void *vp, *vpret;

   if (nargs > 1)
      rank = atoi(args[1]);
   vp = (void*) &thrID;
   vpret = NULL;
@ROUT probe_aff_WIN64
   thrH = (HANDLE)_beginthreadex(NULL, 0, DumbTest, vp, CREATE_SUSPENDED, 
                                 &thrID);
@ROUT probe_aff_WIN
   thrH = CreateThread(NULL, 0, DumbTest, vp, CREATE_SUSPENDED, &thrID);
@ROUT probe_aff_WIN probe_aff_WIN64
   assert(thrH);
   assert(SetThreadAffinityMask(thrH, (((long long)1)<<rank)));
   assert(ResumeThread(thrH) == 1);
   assert(WaitForSingleObject(thrH, INFINITE) != WAIT_FAILED);
   assert(CloseHandle(thrH));

   printf("SUCCESS rank %d\n", rank);
   exit(0);
}
@ROUT probe_aff_SETAFFNP probe_aff_SETPROCNP probe_aff_PLPA probe_aff_SCHED @\
      probe_aff_PBIND probe_aff_BINDP probe_aff_RUNON probe_aff_CPUSET 
@ROUT @push
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
@ROUT probe_aff_SCHED probe_aff_SETAFFNP
#define _GNU_SOURCE 1 /* what manpage says you need to get CPU_SET */
#define __USE_GNU   1 /* what you actually have to set on linuxes I've seen */
#include <sched.h>    /* must include this before pthreads */
@ROUT @peek
#include <pthread.h>
@ROUT probe_aff_PLPA `#include <plpa.h>`
@ROUT probe_aff_PBIND
#include <sys/types.h>
#include <sys/processor.h>
#include <sys/procset.h>
@ROUT probe_aff_BINDP
#include <sys/thread.h>      /* thread_self header */
#include <sys/processor.h>   /* bindprocessor header */
@ROUT probe_aff_CPUSET
#include <sys/param.h>      
#include <sys/cpuset.h>    
@ROUT @peek

static int rank=0;

void *DumbTest(void *vp)
{
@ROUT probe_aff_PLPA 
   plpa_cpu_set_t cpuset;
   PLPA_CPU_ZERO(&cpuset);
   PLPA_CPU_SET(rank, &cpuset);
   assert(!plpa_sched_setaffinity((pid_t)0, sizeof(cpuset), &cpuset));
@ROUT probe_aff_PBIND
   assert(!processor_bind(P_LWPID, P_MYID, rank, NULL));
@ROUT probe_aff_BINDP
   assert(!bindprocessor(BINDTHREAD, thread_self(), rank));
@ROUT probe_aff_RUNON
   assert(!pthread_setrunon_np(rank));
@ROUT probe_aff_CPUSET
   cpuset_t mycpuset;
   CPU_ZERO(&mycpuset);         /* no manpage, so guess works like linux */
   CPU_SET(bindID, &mycpuset);
   assert(!cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_TID, -1,
                              sizeof(mycpuset), &mycpuset));
@ROUT probe_aff_SCHED
   cpu_set_t cpuset;
   CPU_ZERO(&cpuset);
   CPU_SET(rank, &cpuset);
   assert(!sched_setaffinity((pid_t)0, sizeof(cpuset), &cpuset));
@ROUT @peek
   pthread_exit(vp);
}
int main(int nargs, char **args)
{
   pthread_attr_t attr;
   pthread_t thr;
@ROUT probe_aff_SETAFFNP `   cpu_set_t cpuset;`
   void *vp, *vpret;

   if (nargs > 1)
      rank = atoi(args[1]);
   vp = (void*) &thr;
   vpret = NULL;
   assert(!pthread_attr_init(&attr));
   #ifdef IBM_PT_ERROR
      assert(!pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_UNDETACHED));
   #else
      assert(!pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE));
   #endif
   pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM); /* OK to fail */
@ROUT probe_aff_SETAFFNP
   CPU_ZERO(&cpuset);
   CPU_SET(rank, &cpuset);
   assert(!pthread_attr_setaffinity_np(&attr, sizeof(cpuset), &cpuset));
@ROUT probe_aff_SETPROCNP
   assert(!pthread_attr_setprocessor_np(&attr, (pthread_spu_t)rank, 
                                        PTHREAD_BIND_FORCED_NP));
@ROUT @pop
   assert(!pthread_create(&thr, &attr, DumbTest, vp));
   assert(!pthread_attr_destroy(&attr));
   assert(!pthread_join(thr, &vpret));
   if (vpret == vp)
      printf("SUCCESS rank %d\n", rank);
   else
      printf("FAILURE rank %d\n", rank);
   exit(vpret == vp ? 0 : 1);
}
@ROUT probe_arch
#include "atlconf.h"

void PrintUsage(char *name, int iarg)
{
   fprintf(stderr, "error in arg %d USAGE: \n", iarg);
   fprintf(stderr, "   %s -O <os> -s <asm> -v <verb#> -c (cpu) -b (@ bits) -a (arch) -n (ncpu) -m (Mhz) -t (cpu throttling) -T <targ>\n", name);
   exit(iarg);
}

int GetFlags(int nargs, char **args, int *CacheLevel, enum OSTYPE *OS,
             enum ASMDIA *asmd, char **targ)
{
   int i, flag=0, k;
   *CacheLevel = 0;
   *targ = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0],i);
      switch(args[i][1])
      {
      case 'T':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *targ = args[i];
      case 's':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *asmd = atoi(args[i]);
         break;
      case 'O':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *OS = atoi(args[i]);
         break;
      case 'n':
         flag |= Pncpu;
         break;
      case 'c':
         flag |= Pncache;
         break;
      case 'C':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         *CacheLevel = atoi(args[i]);
         break;
      case 'v':
         if (++i >= nargs)
            PrintUsage(args[0], i);
         k = atoi(args[i]);
         if (k)
            flag |= Pverb;
         break;
      case 'm':
         flag |= PMhz;
         break;
      case 'a':
         flag |= Parch;
         break;
      case 'b':
         flag |= P64;
         break;
      case 't':
         flag |= Pthrottle;
         break;
      default:
         PrintUsage(args[0], i);
      }
   }
   if (!flag)
     flag = Parch;
   return(flag);
}

void strlowcpy(char *out, char *in)
{
   if (in && out)
   {
      do *out++ = tolower(*in);
      while (*in++);
   }
}

int ProbeOneInt(enum OSTYPE OS0, enum ASMDIA asmd0, char *targ0, 
                char *flag, char *find, int *sure)
/*
 * Handles calls to all available backend probes that return one int,
 * keeps trying them until out of probes or one returns good (non-zero) value
 */
{
   char cmnd[2048], res[2048], osname[128], targ[512];
   enum OSTYPE OS;
   enum ASMDIA asmd;
   int iret=0;

   *sure = 0;
   asmd = (asmd0 > ASM_None && asmd0 < NASMD) ? asmd0 : gas_x86_32;
   OS = (OS0 > OSOther && OS0 < NOS) ? OS0 : OSLinux;
   if (OS == OSOSX)
      strlowcpy(osname, osnam[OSFreeBSD]);
   else if (OSIsWin(OS))
      strcpy(osname, "win");
   else
      strlowcpy(osname, osnam[OS]);
   if (targ0)
      sprintf(targ, "atlrun=atlas_runX targ=%s", targ0);
   else targ[0] = '\0';

/* 
 * If Assembler right or unspecified, try x86 probe
 */
   if (asmd == gas_x86_32 || asmd == gas_x86_64)
   {
      sprintf(cmnd, "make IRunArchInfo_x86 MYFLAGS=\"-DATL_OS_%s -DATL_%s\" args=\"%s\" %s | fgrep '%s'",
              osnam[OS], ASMNAM[asmd], flag, targ, find);
      if (!CmndOneLine(NULL, cmnd, res))
      {
         iret = GetFirstInt(res);
         *sure = GetLastInt(res);
      }
   }
/*
 * If that didn't work, try OS-specific probe
 */
   if (!iret)
   {
      sprintf(cmnd, "make IRunArchInfo_%s MYFLAGS=\"-DATL_OS_%s -DATL_%s\" args=\"%s\" %s | fgrep '%s'",
              osname, osnam[OS], ASMNAM[asmd], flag, targ, find);
      if (!CmndOneLine(NULL, cmnd, res))
      {
         iret = GetFirstInt(res);
         *sure = GetLastInt(res);
      }
/*
 *    Interix has its own probe under Windows, if all else fails
 */
      if (!iret && OS == OSWinSFU)
      {
         sprintf(cmnd, "make IRunArchInfo_sfu MYFLAGS=\"-DATL_OS_%s -DATL_%s\" args=\"%s\" %s | fgrep '%s'",
              osnam[OS], ASMNAM[asmd], flag, targ, find);
      }
   }
   return(iret);
}

int ConfirmPtrbits(enum OSTYPE OS0, enum ASMDIA asmd0, char *targ0, 
                   char *flag, char *find, int *sure)
/*
 * Retries pointer width probe using -m64; OK to fail: use prior val in that
 * case
 */
{
   char cmnd[2048], res[2048], osname[128], targ[512];
   enum OSTYPE OS;
   enum ASMDIA asmd;
   int iret=0;

   *sure = 0;
   asmd = (asmd0 > ASM_None && asmd0 < NASMD) ? asmd0 : gas_x86_32;
   OS = (OS0 > OSOther && OS0 < NOS) ? OS0 : OSLinux;
   if (OS == OSOSX)
      strlowcpy(osname, osnam[OSFreeBSD]);
   else
      strlowcpy(osname, osnam[OS]);
   if (targ0)
      sprintf(targ, "atlrun=atlas_runX targ=%s", targ0);
   else targ[0] = '\0';

/*
 * Try OS-specific probe, compiling with -m64 (assumes gcc workalike)
 */
   sprintf(cmnd, "make IRunArchInfo_%s MYFLAGS=\"-m64 -DATL_OS_%s -DATL_%s\" args=\"%s\" %s | fgrep '%s'",
           osname, osnam[OS], ASMNAM[asmd], flag, targ, find);
   if (!CmndOneLine(NULL, cmnd, res))
   {
      iret = GetFirstInt(res);
      *sure = GetLastInt(res);
   }
   return(iret);
}

int main(int nargs, char **args)
{
   int flags, CacheLevel, osname[128], sure, bits, i, j;
   enum OSTYPE OS;
   enum ASMDIA asmd;
   enum MACHTYPE arch;
   char *targ;

   flags = GetFlags(nargs, args, &CacheLevel, &OS, &asmd, &targ);
   if (flags & Parch)
   {
      arch = ProbeOneInt(OS, asmd, targ, "-a", "MACHTYPE=", &sure);
      if (arch == MACHOther && (asmd == gas_x86_32 || asmd == gas_x86_64))
         arch = x86X;
      if (flags & Pverb)
         printf("Architecture detected as %s.\n", machnam[arch]);
      printf("MACHTYPE=%d\n", arch);
   }
   if (flags & Pncpu)
      printf("NCPU=%d\n", ProbeOneInt(OS, asmd, targ, "-n", "NCPU=", &sure));
   if (flags & PMhz)
      printf("CPU MHZ=%d\n", 
             ProbeOneInt(OS, asmd, targ, "-m", "CPU MHZ=", &sure));
   if (flags & Pthrottle)
      printf("CPU THROTTLE=%d\n", 
             ProbeOneInt(OS, asmd, targ, "-t", "CPU THROTTLE=", &sure));
   if (flags & P64)
   {
      if (asmd == gas_x86_64)
      {
         sure = 1;
         bits = 64;
      }
      else
      {
         bits = ProbeOneInt(OS, asmd, targ, "-b", "PTR BITS=", &sure);
         if (bits != 64)
         {
            i = ConfirmPtrbits(OS, asmd, targ, "-b", "PTR BITS=", &j);
            if (j)
            {
               bits = i;
               sure = j;
            }
         }
      }
      printf("PTR BITS=%d, SURE=%d\n", bits, sure);
   }
      
/*
 * Here for future, presently unsupported
 */
   if (flags & Pncache)
      printf("NCACHES=0\n");
   if (flags & PCacheSize)
      printf("%d Cache size (kb) = 0\n", CacheLevel);
   return(0);
}
@ROUT probe_pmake
#include "atlconf.h"

void GetPmake(int verb, enum OSTYPE OS, int ncpu, char *pmake)
{
   if (ncpu == 0) ncpu = 1;
   if (!OSIsWin(OS)&&CmndResults(NULL, "make DoNothing --version | fgrep GNU"))
   { /* using gnu make */
      if (ncpu == 1) sprintf(pmake, "$(MAKE) -j 2");
      else sprintf(pmake, "$(MAKE) -j %d", ncpu);
   }
   else
   {  /* AIX, HP-UX, SunOS make do not have parallel option */
      switch(OS)
      {
      case OSIRIX:
         strcpy(pmake, "$(MAKE) -P");
         break;
      case OSFreeBSD:
         if (ncpu == 1) sprintf(pmake, "$(MAKE) -j 2");
         else sprintf(pmake, "$(MAKE) -j %d", ncpu);
         break;
      default:
         strcpy(pmake, "$(MAKE)");
      }
   }
}

@extract -b @(basd)/atlconf.base rout=GetFlags -def -O "" -def -v "" -def -t ""

int main(int nargs, char **args)
{
   int verb, OS, arch, ncpu;
   char *targ;
   char pmake[256];
   GetFlags(nargs, args, &verb, &OS, &ncpu, &targ);
   GetPmake(verb, OS, ncpu, pmake);
   printf("PMAKE='%s'\n", pmake);
   return(0);
}
@ROUT probe_comp
#include "atlconf.h"

COMPNODE *GetCompNode(void)
{
   COMPNODE *p;
   p = calloc(1, sizeof(COMPNODE));
   assert(p);
   return(p);
}
COMPNODE *KillCompNode(COMPNODE *die)
{
   COMPNODE *p=NULL;
   if (die)
   {
      p = die->next;
      if (die->comp)
         free(die->comp);
      if (die->flags)
         free(die->flags);
      free(die);
   }
   return(p);
}

void KillAllCompNodes(COMPNODE *kill)
{
   while(kill)
      kill = KillCompNode(kill);
}

COMPNODE *CloneCompNode(COMPNODE *orig)
{
   COMPNODE *new;

   new = GetCompNode();
/*
 * Copy everything but strings wt memcopy
 */
   memcpy(new, orig, sizeof(COMPNODE));
   if (orig->comp)
   {
      new->comp = malloc(sizeof(char)*(strlen(orig->comp)+1));
      assert(new->comp);
      strcpy(new->comp, orig->comp);
   }
   if (orig->flags)
   {
      new->flags = malloc(sizeof(char)*(strlen(orig->flags)+1));
      assert(new->flags);
      strcpy(new->flags, orig->flags);
   }
   return(new);
}

void PrintCompNodes(FILE *fpout, COMPNODE *q, char *id)
{
   int i;
   COMPNODE *p;

   fprintf(fpout, "\nCompiler nodes: %s\n", id);
   if (!q)
      fprintf(fpout, "***NONE***\n");
   for (i=0, p=q; p; p=p->next, i++)
   {
      fprintf(fpout, 
         "%3d. priority=%d, comps,OS,arch[0]=(%d,%d,%d), comp='%s'\n",
              i, p->priority, p->comps[0], p->OS[0], p->arch[0], p->comp);
      fprintf(fpout, "     '%s'\n", p->flags);
   }
   fprintf(fpout, "\n");
}

COMPNODE *SortCompsByPriority(COMPNODE *q)
/* 
 * Builds new queue out of q, by first adding largest priority to newq, etc.
 */
{
   COMPNODE *newq=NULL, *p, *prev, *maxprev;
   int maxpri;

   while(q)  /* BFI N^2 sort */
   {
/*
 *    Find remaining element wt largest priority
 */
      maxprev = NULL;
      prev = q;
      maxpri = q->priority;
      for (p=q->next; p; p = p->next)
      {
         if (p->priority > maxpri)
         {
            maxpri = p->priority;
            maxprev = prev;
         }
         prev = p;
      }
/*
 *    Take max node off of q, add to newq
 */
      if (maxprev)  /* max elt wasn't stop of stack (q) */
      {
         p = maxprev->next->next;
         maxprev->next->next = newq;
         newq = maxprev->next;
         maxprev->next = p;
      }
      else
      {
         p = q->next;
         q->next = newq;
         newq = q;
         q = p;
      }
   }
   return(newq);
}

void DivideCompsByComp(COMPNODE *q, COMPNODE **comps)
/* 
 * Builds individual queues for each compiler camp, and then kills the original
 * queue.  Note that original q is sorted smallest-to-largest, and since we
 * add in order to a stack, we wind up with largest-to-smallest, as we want.
 * Note comps is really COMPNODE *comps[NCOMP], and can be indexed by ICC_, etc.
 */
{
   int i;
   COMPNODE *p, *new;

   for (i=0; i < NCOMP; i++)
      comps[i] = NULL;
   for (p=q; p; p = p->next)
   {
      for (i=0; i < NCOMP; i++)
      {
         if (IsBitSetInField(p->comps, i))
         {
            new = CloneCompNode(p);
            new->next = comps[i];
            comps[i] = new;
         }
      }
   }
   KillAllCompNodes(q);
}

static int OSMatches(enum OSTYPE OS, int *bits)
/*
 * RETURNS: 0 if no OS of arch in bitfield, nonzero otherwise
 */
{
   if (IsBitSetInField(bits, 0))   /* If 0 bit set, matches all OS */
      return(1);
   if (IsBitSetInField(bits, OS))  /* If OS bit set, matches this OS */
      return(2);
   return(0);
}

static int ArchMatches(enum MACHTYPE arch, int *bits)
/*
 * RETURNS: 0 if no match of arch in bitfield, nonzero otherwise
 */
{
   if (IsBitSetInField(bits, 0))     /* If 0 bit set, matches all archs */
      return(1);
   if (IsBitSetInField(bits, arch)) /* If arch bit set, matches this arch */
      return(2);
   return(0);
}

COMPNODE *KillBadArchOS(enum OSTYPE OS, enum MACHTYPE arch, COMPNODE *q)
/*
 * Deletes all non-matching OS/arch from queue; Note any node wt these
 * quantities set to 0 is a wildcard, and so stays
 */
{
   COMPNODE *prev, *next, *p;
   if (!OS && !arch)
      return(q);
/*
 * Delete all beginning nodes until we find one for this arch
 */
   while(q && (!ArchMatches(arch, q->arch) || !OSMatches(OS, q->OS)))
      q = KillCompNode(q);
/*
 * With good top of stack, delete trailing nodes that don't match
 */
   if (q)
   {
      prev = q;
      for (p=q->next; p; p = next)
      {
         next = p->next;
         if (!ArchMatches(arch, p->arch) || !OSMatches(OS, p->OS))
            prev->next = KillCompNode(p);
         else 
            prev = p;
      }
   }
   return(q);
}

int OSNameToInt(char *name)
{
   int i;
   for (i=1; i < NOS; i++)
   {
      if (!strcmp(name, osnam[i]))
         return(i);
   }
   return(0);
}

int MachNameToInt(char *name)
{
   int i;
   for (i=1; i < NMACH; i++)
   {
      if (!strcmp(name, machnam[i]))
         return(i);
   }
   return(0);
}
void NamesToBitField(int MACH, char *str, int *bits)
/*
 * Takes a list of machine (MACH=1) or OS (MACH=0) names and translates them
 * to their enumerated type numbers, and sets the appropriate bit in the
 * bits field
 */
{
   char name[128];
   int i=0;
   while(*str)
   {
      if (*str == ',' || *str == ' ' || *str == '\t' || *str == '\n' || 
          *str == '\0')
      {  /* finished a name */
         name[i] = '\0';
         if (!strcmp(name, "all") || !strcmp(name, "ALL")) 
            i = 0;
         else
         {
            if (MACH)
               i = MachNameToInt(name);
            else
               i = OSNameToInt(name);
            if (!i)
            {
               fprintf(stderr, "Nonsensical %s name in list: %s\n", 
                       MACH ? "machine" : "OS", str);
               exit(1);
            }
         }
         SetBitInField(bits, i);
         if (*str != ',')  /* anything but ',' ends list */
            return;
         str++;
         i = 0;
      }
      else 
         name[i++] = *str++;
   }
}

void NumListToBitfield(char *str, int *bits)
/*
 * Takes a list of number like : '5,3,2,8,0' and turns on those bits
 */
{
   char num[16], *sp;
   int i, j;

   while (*str)
   {
      for (sp=num,i=0; i < 15; i++)
      {
         if (!isdigit(str[i])) break;
         *sp++ = str[i];
      }
      assert(i != 15);
      *sp = '\0';
      j = atoi(num);
      SetBitInField(bits, j);
      if (str[i] != ',') break;
      str += i+1;
   }
}

COMPNODE *ParseNewCompLine(char *ln)
{
   COMPNODE *p;
   char *sp;
   p = GetCompNode();

   sp = strstr(ln, "MACH=");
   assert(sp);
   sp += 5;
/*   NumListToBitfield(sp, p->arch); */
   NamesToBitField(1, sp, p->arch);


   sp = strstr(ln, "OS=");
   assert(sp);
   sp += 3;
/*   NumListToBitfield(sp, p->OS); */
   NamesToBitField(0, sp, p->OS);

   sp = strstr(ln, "LVL=");
   assert(sp);
   sp += 4;
   p->priority = atoi(sp);
/*
 * Parse 'COMPS=[icc,smc,dmc,skc,dkc,xcc,gcc,f77]', at least one comp must exist
 */
   sp = strstr(ln, "COMPS=");
   assert(sp);
   sp += 6;
   while (*sp)
   {
      if (sp[0] == 'i' && sp[1] == 'c' && sp[2] == 'c')
         SetBitInField(p->comps, ICC_);
      else if (sp[0] == 's' && sp[1] == 'm' && sp[2] == 'c')
         SetBitInField(p->comps, SMC_);
      else if (sp[0] == 'd' && sp[1] == 'm' && sp[2] == 'c')
         SetBitInField(p->comps, DMC_);
      else if (sp[0] == 's' && sp[1] == 'k' && sp[2] == 'c')
         SetBitInField(p->comps, SKC_);
      else if (sp[0] == 'd' && sp[1] == 'k' && sp[2] == 'c')
         SetBitInField(p->comps, DKC_);
      else if (sp[0] == 'x' && sp[1] == 'c' && sp[2] == 'c')
         SetBitInField(p->comps, XCC_);
      else if (sp[0] == 'g' && sp[1] == 'c' && sp[2] == 'c')
         SetBitInField(p->comps, GCC_);
      else if (sp[0] == 'f' && sp[1] == '7' && sp[2] == '7')
         SetBitInField(p->comps, F77_);
      else
      {
         fprintf(stderr, "WTF(%d of %s): '%s'??\n", __LINE__, __FILE__, sp);
         exit(-1);
      }
      if (sp[3] != ',') break;
      sp += 4;
   }
   return(p);
}

char *CopySingleQuoteString(char *str, char *out)
/*
 * Finds the leading ' in str, and copies quoted text to out until closing '
 * is found or end of string.  
 * RETURNS: pointer in str at closing ', NULL if closing ' not found
 */
{
/*
 * Skip text before staring quote, return if quote not found
 */
   *out = '\0';
   while (*str != '\'' && *str) str++;
   if (*str == '\0')
      return(NULL);
/*
 * Copy quoted text, return pointer to end quote if it exists
 */
   str++;
   while (*str != '\'' && *str) *out++ = *str++;
   *out++ = '\0';
   if (*str == '\'')
      return(str);
   return(NULL);
}

COMPNODE *ParseCompLine(char *ln)
{
   static int NewComp=1;
   static COMPNODE *p=NULL;
   int i;
   char *sp;
   char ln2[2048];

   if (NewComp)
      p = ParseNewCompLine(ln);
/* 
 * Should be line of form "'compiler' 'flags'"
 */
   else
   {
      sp = CopySingleQuoteString(ln, ln2);
      assert(sp);
      i = strlen(ln2) + 1;
      p->comp = malloc(sizeof(char)*i);
      assert(p->comp);
      strcpy(p->comp, ln2);

      sp = CopySingleQuoteString(sp+1, ln2);
      i = strlen(ln2) + 1;
      p->flags = malloc(sizeof(char)*i);
      assert(p->flags);
      strcpy(p->flags, ln2);
   }
   NewComp = !NewComp;
   return(p);
}

COMPNODE *ReadComps(char *file)
/*
 * Reads in a file describing the compilers ATLAS knows about, and returns
 * a queue of them for later manipulation.
 */
{
   char ln[2048];
   FILE *fpin;
   COMPNODE *compq=NULL, *p;

   fpin = fopen(file, "r");
   while (fgets(ln, 2048, fpin))
   {
      if (ln[0] != '#')
      {
         KillUselessSpace(ln);
         if (ln[0] != '#' && ln[0] != '\0')
         {
            p = ParseCompLine(ln);
            if (p != compq)
            {
               p->next = compq;
               compq = p;
            }
         }
      }
   }
   fclose(fpin);
   return(compq);
}

COMPNODE **GetDefaultComps(enum OSTYPE OS, enum MACHTYPE arch, int verb)
/*
 * This routine reads the file atlcomp.txt, and returns them sorted by
 * order of priority for each compiler ATLAS needs.  This list can then
 * be matched with the user's input to give final compiler and flags.
 */
{
   COMPNODE *q, *p, **comps;
   int i;

   comps = malloc(sizeof(COMPNODE)*NCOMP);
   q = ReadComps("atlcomp.txt");    /* get all compiler lines */
   if (verb > 1)
      PrintCompNodes(stderr, q, "Fresh Read");
   q = KillBadArchOS(OS, arch, q);  /* discard comps for other platforms */
   if (verb > 1)
      PrintCompNodes(stderr, q, "Targeted");
   q = SortCompsByPriority(q);      /* q is smallest, bottom is largest */
   if (verb > 1)
      PrintCompNodes(stderr, q, "Sorted");
   DivideCompsByComp(q, comps);     /* split into individual queues */
   return(comps);
}

int CompTest(int verb, char *targ, int icomp, char *comp, char *flag)
/*
 * Tries to build simple program and run it.
 * RETURNS: result of system call (0: success, else error code)
 */
{
   char ln[1024], res[1024];
   int i, iret;

   if (icomp == ICC_)
      targ = NULL;
   if (icomp == F77_)
      i = sprintf(ln, "make IRunF77Comp F77='%s' F77FLAGS='%s' ", comp, flag);
   else
      i = sprintf(ln, "make IRunCComp CC='%s' CCFLAGS='%s' ", comp, flag);
   if (targ)
      i += sprintf(ln+i, "atlrun=atlas_runX targ=%s ", targ);
   i += sprintf(ln+i, "| fgrep SUCCESS");
   iret = CmndOneLine(NULL, ln, res);
   if (verb > 1)
      fprintf(stderr, "cmnd=%s\n", ln);
   if (!iret)
      iret = !strstr(res, "SUCCESS");
   if (verb)
      fprintf(stderr, "   %s %s : %s!\n", comp, flag, 
              iret ? "FAILURE":"SUCCESS");
   return(iret);
}

void CompError(int icomp)
/*
 * Prints out informative error message when we die because a compiler doesn't
 * work
 */
{
   fprintf(stderr, "\n\nUnable to find usable compiler for %s; aborting", 
           COMPNAME[icomp]);
   fprintf(stderr, "Make sure compilers are in your path, and specify good compilers to configure\n");
   fprintf(stderr, 
           "(see INSTALL.txt or 'configure --help' for details)");
   exit(icomp+1);
}

@ROUT probe_comp getptrbits
char *GetPtrbitsFlag(enum OSTYPE OS, enum MACHTYPE arch, int ptrbits, 
                     char *comp)
/*
 * RETURNS: string forcing setting of ptrbits for gcc
 */
{
   char *sp = "";
   int i, j, k;

   if (MachIsIA64(arch))
      return(sp);
   if (MachIsMIPS(arch))
      return((ptrbits == 64) ? "-mabi=64" : "-mabi=n32");
   if (MachIsS390(arch))
      return((ptrbits == 64) ? "-m64" : "-m31");
   if (!CompIsGcc(comp))
   {
/*
 *    Add correct 64/32 bit flags for Sun workshop compilers
 */
      if (MachIsUS(arch) && CompIsSunWorkshop(comp))
      {
         if (ptrbits == 64)
            sp = (arch == SunUSI || arch == SunUSII) ? 
                 "-xarch=v9" : "-xarch=v9b";
         else
            sp = (arch == SunUSI || arch == SunUSII) ? 
                 "-xarch=v8plusa" : "-xarch=v8plusb";
      }
      else if (CompIsIBMXL(comp))  /* IBM xl compilers */
         sp = (ptrbits == 64) ? "-q64" : "-q32";
      return(sp);
   }
   GetGccVers(comp, &k, &j, &k, &k);
   if ( !(j >= 3 && (OS != OSOSX || j > 3 || !CompIsAppleGcc(comp))) )
      return(sp);
@beginskip
   {
      if (OS == OSIRIX)
         sp = (ptrbits == 64) ? "-mabi=64" : "-mabi=32";
      else
         sp = (ptrbits == 64) ? "-mips64" : "-mips32";
   }
@endskip
@skip   else if (MachIsPPC(arch))
@skip      sp = (ptrbits == 64) ? "-mpowerpc64" : "-mpowerpc -mno-powerpc64";
   else if (OS == OSAIX)
      sp = (ptrbits == 64) ? "-maix64" : "-maix32";
   else if ((MachIsX86(arch) || MachIsPPC(arch) || MachIsUS(arch)) ||
            arch == IbmPwr7 || arch == IbmPwr6)
   {
      if (ptrbits == 64)
         sp = "-m64";
       else if (ptrbits == 32)
         sp = "-m32";
   }
   return(sp);
}
@ROUT getptrbits
  @endextract
@ROUT probe_comp
char *GetStandardCompName(char *comp)
{
   int i, j, k;
   char *ucomp;
/*
 * Recognize gnu compiler regardless of name string (eg. ev6-gcc-3.2)
 */
   if (CompIsGcc(comp))
   {
      GetGccVers(comp, &k, &j, &k, &k);
      if (j < 4)
      {
         if (i == F77_)
            ucomp = "g77";
         else
            ucomp = "gcc";
      }
      else if (i == F77_)
         ucomp = "gfortran";
      else
         ucomp = "gcc";
   }
   else
      ucomp = NameWithoutPath(comp);
   return(ucomp);
}
char *GetWinComp(enum OSTYPE OS, char *comp)
{
   char ln[1024];
   char *ucomp;
   if (!OSIsWin(OS))
      return(NULL);
   ucomp = GetStandardCompName(comp);
   if (!strcmp(ucomp, "icc") || !strcmp(ucomp, "icl"))
      ucomp = "ATLwin_icc";
   else if (!strcmp(ucomp, "ifort") || !strcmp(ucomp, "ivf"))
      ucomp = "ATLwin_ifort";
   else if (!strcmp(ucomp, "mvc") || !strcmp(ucomp, "cl"))
      ucomp = "ATLwin_cl";
   else /* not a recognized windows compiler that needs wrapping, done */
      return(NULL);
   sprintf(ln, "make wind=/usr/local/bin /usr/local/bin/%s.exe \n", ucomp);
   if (system(ln))
   {
      fprintf(stderr, "Unable to to build %s, quitting\n", ucomp);
      fprintf(stderr, "cmnd='%s'\n", ln);
      exit(-1);
   }
   return(ucomp);
}

void GetComps(enum OSTYPE OS, enum MACHTYPE arch, int verb, char *targ,
              int ptrbits, char **usrcomps, int nof77, char *goodgcc)
/*
 * This routine gives config a list of compilers to use.  The first NCOMP
 * entries in usrcomps indicate a user override of the default compiler,
 * and the next NCOMP entries indicate user override of flags.  The next
 * NCOMP entries indicate that those flags should be appended to prior flags.
 * A NULL in any entry says the user is happy to use the defaults (or no
 * appending).  Chosen compilers and flags are returned in usrcomps array.
 */
{
   COMPNODE **comps, *p;
   char *ucomp, *dcomp, *flg, *sp, *sp2, *mgwd=NULL, *mgwc=NULL, *mgwf=NULL;
   char cmnd[1024], res[1024];
   int i, j, k, h;
/*
 * Look through input compilers; any of them that is simply "gcc" gets replaced
 * with goodgcc;  If user has overridden with path or specific name (gcc-4) 
 * leave it at his choice
 */
   for (i=0; i < NCOMP; i++)
   {
      if (usrcomps[i])
      {
         if (!strcmp(usrcomps[i], "gcc") && goodgcc)
	 {
	    free(usrcomps[i]);
	    usrcomps[i] = NewStringCopy(goodgcc);
	 }
      }
   }

/*
 * If on Win64, build MinGW compiler wrappers. 
 * Look in /usr/bin/ for standard cygwin names for the cygwin compilers
 */
   if (OS == OSWinNT && ptrbits == 64)
   {
      int fndit;
/*
 *    Get the present directory, which is BLDdir, to have full path to
 *    MinGW compiler wrappers
 */
      assert(!CmndOneLine(NULL, "pwd", res));
      j = strlen(res);
      while (j > 0 && isspace(res[j-1])) 
         res[--j] = '\0';
      mgwd = malloc(sizeof(char)*(j+1));
      assert(mgwd);
      strcpy(mgwd, res);
      fndit = CmndOneLine(targ, "ls /usr/bin/x86_64-w64-mingw32-gcc-4*", res);
      if (fndit)
         fndit = CmndOneLine(targ, "ls /usr/bin/x86_64-w64-mingw32-gcc.exe", 
                             res);
      if (fndit)
      {
         fprintf(stderr, 
"Cannot find MinGW compilers in /usr/bin, with names beginning with\n");
         fprintf(stderr, 
"x86_64-w64-mingw32* ; Make sure they are installed, then try again.\n");
         fprintf(stderr, 
"If your MinGW compiler not named like this, make symbolic link in /usr/bin\n");
         fprintf(stderr, 
"eg., ln -s /my/comp /usr/bin/x86_64-w64-mingw32-gcc-4.exe\n");
         exit(fndit);
      }
      j = strlen(res);
      while (j > 1 && isspace(res[j-1])) 
         res[--j] = '\0';
      assert(j > 12);
      sprintf(cmnd, "make mgwgcc cmppath=%s\n", res);  /* build C comp */
      syschk(cmnd);
      i = strlen(mgwd);
      mgwc = malloc(sizeof(char)*(i+7+1));
      assert(mgwc);
      sprintf(mgwc, "%s/mgwgcc", mgwd);
/*
 *    Build the wrapper for ar and ranlib
 */
      assert(!CmndOneLine(targ, "ls /usr/bin/x86_64-w64-mingw32-ar.exe", res));
      j = strlen(res);
      while (j > 1 && isspace(res[j-1])) 
         res[--j] = '\0';
      sprintf(cmnd, "make mgwar cmppath=%s\n", res);  /* build ar wrapper */
      syschk(cmnd);
      assert(!CmndOneLine(targ, "ls /usr/bin/x86_64-w64-mingw32-ranlib.exe",
                          res));
      j = strlen(res);
      while (j > 1 && isspace(res[j-1])) 
         res[--j] = '\0';
      sprintf(cmnd, "make mgwranlib cmppath=%s\n", res);  /* build ar wrapper */
      syschk(cmnd);
/*
/*
 *    Build the gfortran wrapper unless doing an all-C install
 */
      if (!nof77)
      {
         fndit = CmndOneLine(targ, "ls /usr/bin/x86_64-w64-mingw32-gfortran*", 
                             res);
         if (fndit)
         {
            fprintf(stderr, "MinGW gfortran not found!\n");
            exit(-1);
         }
         sprintf(cmnd, "make mgwgfortran cmppath=%s\n", res);
         syschk(cmnd);
         mgwf = malloc(sizeof(char)*(i+12+1));
         assert(mgwf);
         sprintf(mgwf, "%s/mgwgfortran", mgwd);
      }
   }

   comps = GetDefaultComps(OS, arch, verb);
   if (verb > 1)
      fprintf(stdout, "Finding good compilers:\n");
   for (i=0; i < NCOMP; i++)
   {
      if (nof77 && i == F77_) continue;
/*
 *    If the user has not specified the compiler, look through all available
 *    compilers with one that works (with user flags, if specified)
 */
      if (!usrcomps[i])
      {
         for (p=comps[i]; p; p = p->next)
         {
            flg = NewStringCopy(usrcomps[NCOMP+i]?usrcomps[NCOMP+i]:p->flags);
            if (usrcomps[NCOMP*2+i])
               flg = NewAppendedString(flg, usrcomps[NCOMP*2+i]);
            sp = GetWinComp(OS, p->comp);
            if (!sp) 
            {
/*
 *             If mgwd is set, we must substitute MinGW wrap comps for gcc and
 *             gfortran
 */
               if (mgwd && i != XCC_)
               {
                  if (CompIsGcc(p->comp))
                  {
                     if (strstr(p->comp, "fortran") || strstr(p->comp, "f77"))
                        sp = mgwf;
                     else 
                        sp = mgwc;
                  }
                  else
                     sp = p->comp;
               }
               else
                  sp = p->comp;
            }
            if (ptrbits)
            {
               if (OS == OSWinNT && ptrbits == 64 && i == XCC_)
                  flg = NewAppendedString(flg, "-m32");
               else
                  flg = NewAppendedString(flg, 
                           GetPtrbitsFlag(OS, arch, ptrbits, sp));
            }
            if (sp == mgwf)
               flg = NewAppendedString(flg, "-static");
            if (!CompTest(verb, targ, i, sp, flg))
               break;
            free(flg);
         }                              /* end loop over compilers */
         if (!p)
            CompError(i);
         else
            free(flg);
	 if (mgwd)
	    usrcomps[i] = sp;
         else if (i == GCC_ || !strcmp(p->comp, "gcc"))
	    usrcomps[i] = NewStringCopy(goodgcc);
	 else
	 {
	    usrcomps[i] = p->comp;
            p->comp = NULL;                /* so it isn't deleted by Kill */
	 }
         if (!usrcomps[NCOMP+i])
         {
            usrcomps[NCOMP+i] = p->flags;
            p->flags = NULL;            /* so it isn't deleted by Kill */
         }
      }  
/*
 *    If user specified comp w/o flags, get default flags or error 
 */
      else if (!usrcomps[NCOMP+i])
      {
         p = comps[i];
         ucomp = NameWithoutPath(usrcomps[i]);
/*
 *       Recognize gnu compiler regardless of name string (eg. ev6-gcc-3.2)
 */
         if (CompIsGcc(usrcomps[i]))
         {
            GetGccVers(usrcomps[i], &k, &j, &k, &k);
            if (j < 4)
            {
               if (i == F77_)
                  ucomp = "g77";
               else
                  ucomp = "gcc";
            }
            else if (i == F77_)
               ucomp = "gfortran";
            else
               ucomp = "gcc";
         }
         for (p=comps[i]; p; p = p->next)
         {
            dcomp = NameWithoutPath(p->comp);
            if (!strcmp(p->comp, ucomp))
               break;
            free(dcomp);
         }
         if (!p)
         {
            fprintf(stderr, 
               "UNKNOWN COMPILER '%s' for %s: you must also supply flags!\n",
                    usrcomps[i], COMPNAME[i]);
            exit(i+1);
         }
         usrcomps[NCOMP+i] = p->flags;
         p->flags = NULL;
      } /* If user specifed both flags and compiler, accept them */
/*
 *    On windows, build compiler wrapper for MSVC++ or Intel compilers
 */
      sp = GetWinComp(OS, usrcomps[i]);
      if (sp)
      {
         free(usrcomps[i]);
         usrcomps[i] = NewStringCopy(sp);
      }
/*
 *    Test selected compiler and flags, and die if they don't work
 */
      flg = NewStringCopy(usrcomps[NCOMP+i]?usrcomps[NCOMP+i]:p->flags);
      if (usrcomps[NCOMP*2+i])
         flg = NewAppendedString(flg, usrcomps[NCOMP*2+i]);
      if (ptrbits)
      {
         if (OS == OSWinNT && ptrbits == 64 && i == XCC_)
            flg = NewAppendedString(flg, "-m32");
         else
            flg = NewAppendedString(flg, 
                     GetPtrbitsFlag(OS, arch, ptrbits,usrcomps[i]));
      }
      if (usrcomps[i] == mgwf)
         flg = NewAppendedString(flg, "-static");
      if (CompTest(verb, targ, i, usrcomps[i], flg))
         CompError(i);
      free(flg);
   } /* end of loop over compilers */
/*
 * modify base flags by appending user flags
 */
   for (i=2*NCOMP; i < 3*NCOMP; i++)
   {
      if (usrcomps[i])  /* user has appended flags for compiler i-2*NCOMP */
         usrcomps[i-NCOMP] = NewAppendedString(usrcomps[i-NCOMP], usrcomps[i]);
   }
/*
 * If nof77, set fortran compiler & flags to ICC to avoid linking problems
 */
   if (nof77)
   {
      usrcomps[F77_] = NewStringCopy(usrcomps[ICC_]);
      usrcomps[F77_+NCOMP] = NewStringCopy(usrcomps[ICC_+NCOMP]);
   }
/*
 * If ptrbits is set to manual override, add -m32/64 to gnu compilers
 * but not on Itaniums or Apple's munged gcc 3 compiler!
 */
   if (ptrbits && arch != IA64Itan && arch != IA64Itan2)
   {
      for (i=0; i < NCOMP; i++)
      {
         sp = GetPtrbitsFlag(OS, arch, ptrbits, usrcomps[i]);
         if (OS == OSWinNT && ptrbits == 64 && i == XCC_)
            usrcomps[i+NCOMP] = NewAppendedString(usrcomps[i+NCOMP], "-m32");
         else
            usrcomps[i+NCOMP] = NewAppendedString(usrcomps[i+NCOMP], sp);
      }
   }
/*
 * On windows, add required -mstackrealign to all gnu comps,
 * since gcc breaks the x86 ABI by default.
 */
   if (OSIsWin(OS) && ptrbits != 64)
   {
      for (i=0; i < NCOMP; i++)
      {
         if (i != F77_ && CompIsGcc(usrcomps[i]))
            usrcomps[i+NCOMP] = NewAppendedString(usrcomps[i+NCOMP], 
                                                  " -mstackrealign");
      }
   }
/*
 * Need to add target & bitwidth args for MIPSpro compilers on IRIX
 */
   if (OS == OSIRIX)
   {
      sprintf(cmnd, "%s -m", FindUname(targ));
      assert(!CmndOneLine(NULL, cmnd, res));
      sp = strstr(res, "IP");
      for (i=2; isdigit(sp[i]); i++);
      sp[i] = '\0';
      sprintf(cmnd, "-TARG:platform=%s", sp);
      if (ptrbits == 64 || !ptrbits)
         strcat(cmnd, " -64");
      else
         strcat(cmnd, " -32");
      for (i=0; i < NCOMP; i++)
      {
         if (CompIsMIPSpro(usrcomps[i]))
         {
            usrcomps[i+NCOMP] = NewAppendedString(usrcomps[i+NCOMP], cmnd);
         }
      }
      free(sp);
   }
}  /* end of routine GetComps */


int SelectBestGcc
(
   int verb,
   char *targ,
   int GMAJOR,
   int GMINOR,
   char **gccs   /* NULL-terminated list of possible gcc compilers */
)
/*
 * RETURNS: 0 if no gcc compiler,
 *          -i if ith compiler is best compiler we found
 *          i if ith compiler is gnu gcc with matching major & minor
 */
{
   int ibest=0, igood=0, ileastbad=0;
   int gmaj=0, gmin=0, lmaj=0, lmin=0, i;
   if (!gccs)
      return(0);
   for (i=0; gccs[i]; i++)
   {
      int icmp, major, minor, patch;
      GetGccVers(gccs[i], &icmp, &major, &minor, &patch);
      if (verb)
         printf("   icmp=%d, maj=%d, min=%d, pat=%d: %s\n", 
                icmp, major, minor, patch, gccs[i]);
      if (major == GMAJOR && minor == GMINOR)
      {
         if (!CompTest(verb, targ, GCC_, gccs[i], "-O"))
            return(i+1);
      }
      else if (major == GMAJOR && minor >= GMINOR)
      {
         if (!CompTest(verb, targ, GCC_, gccs[i], "-O"))
            ibest = i+1;
      }
      else if (major == GMAJOR)
      {
         if (major > gmaj || (major == gmaj && minor > gmin))
	 {
            if (!CompTest(verb, targ, GCC_, gccs[i], "-O"))
	    {
               igood = i+1;
	       gmaj = major;
	       gmin = minor;
	    }
         }
      }
      else if (major > lmaj || (major == lmaj && minor > lmin))
      {
         if (!CompTest(verb, targ, GCC_, gccs[i], "-O"))
	 {
            ileastbad = i+1;
	    lmaj = major;
	    lmin = minor;
         }
      }
   }
   if (ibest)
      return(ibest);
   else if (igood)
      return(-igood);
   return(-ileastbad);
}


#define GMAJOR 4  /* major version must be exactly this */
#define GMINOR 5  /* minor version must be >= to this (dangerous, but useful) */
char *FindGoodGcc(enum OSTYPE OS, enum MACHTYPE arch, int verb, char *targ)
{
   char *OSpaths=NULL, *sp, **gccs=NULL;
   char ln[4192];
   int i;
/*
 * See if we have some OS-specific places to search for good gcc
 */
   if (OS == OSOSX)  /* /sw is for fink, /opt is for macports */
   {
      OSpaths = "/sw/bin /opt/local/bin /opt/local/sbin";
   }
/*
 * We first look in any high-priority OS-specific spots for the right files
 */
   if (OSpaths)
   {
      sprintf(ln, "find %s -name '*gcc*' -exec ./xisgcc '{}' \\;", OSpaths);
      gccs = GetLinesFromFile(CmndResultsNoErr(NULL, ln), gccs);
      i = SelectBestGcc(verb, targ, GMAJOR, GMINOR, gccs);
      if (i > 1)
         return(FreeListGetString(gccs, i-1));
      if (i < 0)
         gccs = NewOneStringList(gccs, -(i+1));
      else
      {
         KillAllStringsInList(gccs);
	 gccs = NULL;
      }
   }
/*
 * If we are not satisfied with the places we've looked so far, 
 * try the user's path environment variable
 */
   sp = GetPathEnvVar();
   if (sp)
   {
      sprintf(ln, "find %s -name '*gcc*' -exec ./xisgcc '{}' \\;",
              sp);
      free(sp);
      gccs = GetLinesFromFile(CmndResultsNoErr(NULL, ln), gccs);
      i = SelectBestGcc(verb, targ, GMAJOR, GMINOR, gccs);
      if (i > 0)
         return(FreeListGetString(gccs, i-1));
      if (i < 0)
         gccs = NewOneStringList(gccs, -(i+1));
      else
      {
         KillAllStringsInList(gccs);
	 gccs = NULL;
      }
   }
/*
 * If we still haven't found it, try standard unix places
 */
   i = sprintf(ln, "find %s -name '*gcc*' -exec ./xisgcc '{}' \\;", 
   "/usr/local/ /bin /sbin/ /usr/bin /usr/sbin /opt/bin /opt/sbin");
   gccs = GetLinesFromFile(CmndResultsNoErr(NULL, ln), gccs);
   i = SelectBestGcc(verb, targ, GMAJOR, GMINOR, gccs);
   if (i > 1)
      return(FreeListGetString(gccs, i-1));
   if (i < 0)
      return(FreeListGetString(gccs, -(i+1)));
   else
      KillAllStringsInList(gccs);
   return(NULL);
}

char *FindGoodGfortran(enum OSTYPE OS, enum MACHTYPE arch, int verb, 
                       char *targ, char *gcc)
{
   char *OSpaths=NULL, *sp, **gccs=NULL;
   char ln[4192];
   int i;
   int ccomp, cmaj, cmin, cpat;
/*
 * Get gcc's version; we'll try to find a matching gfortran
 */
   GetGccVers(gcc, &ccomp, &cmaj, &cmin, &cpat);
/*
 * See if we can find gfortran in the same place we found gcc
 */
   sp = GetPathWithoutName(gcc);  /* get path to gcc */
   if (sp)
   {
      sprintf(ln, "find %s -name '*gfortran*' -exec ./xisgcc '{}' \\;", sp);
      gccs = GetLinesFromFile(CmndResultsNoErr(NULL, ln), gccs);
      i = SelectBestGcc(verb, targ, cmaj, cmin, gccs);
      if (i > 1)
         return(FreeListGetString(gccs, i-1));
      if (i < 0)
         gccs = NewOneStringList(gccs, -(i+1));
      else
      {
         KillAllStringsInList(gccs);
	 gccs = NULL;
      }
   }
/*
 * See if we have some OS-specific places to search for good gcc
 */
   if (OS == OSOSX)  /* /sw is for fink, /opt is for macports */
   {
      OSpaths = "/sw/bin /opt/local/bin /opt/local/sbin";
   }
/*
 * We first look in any high-priority OS-specific spots for the right files
 */
   if (OSpaths)
   {
      sprintf(ln, "find %s -name '*gfortran*' -exec ./xisgcc '{}' \\;",OSpaths);
      gccs = GetLinesFromFile(CmndResultsNoErr(NULL, ln), gccs);
      i = SelectBestGcc(verb, targ, cmaj, cmin, gccs);
      if (i > 1)
         return(FreeListGetString(gccs, i-1));
      if (i < 0)
         gccs = NewOneStringList(gccs, -(i+1));
      else
      {
         KillAllStringsInList(gccs);
	 gccs = NULL;
      }
   }
/*
 * If we are not satisfied with the places we've looked so far, 
 * try the user's path environment variable
 */
   sp = GetPathEnvVar();
   if (sp)
   {
      sprintf(ln, "find %s -name '*gfortran*' -exec ./xisgcc '{}' \\;",
              sp);
      free(sp);
      gccs = GetLinesFromFile(CmndResultsNoErr(NULL, ln), gccs);
      i = SelectBestGcc(verb, targ, cmaj, cmin, gccs);
      if (i > 0)
         return(FreeListGetString(gccs, i-1));
      if (i < 0)
         gccs = NewOneStringList(gccs, -(i+1));
      else
      {
         KillAllStringsInList(gccs);
	 gccs = NULL;
      }
   }
/*
 * If we still haven't found it, try standard unix places
 */
   i = sprintf(ln, "find %s -name '*gfortran*' -exec ./xisgcc '{}' \\;", 
   "/usr/local/ /bin /sbin/ /usr/bin /usr/sbin /opt/bin /opt/sbin");
   gccs = GetLinesFromFile(CmndResultsNoErr(NULL, ln), gccs);
   i = SelectBestGcc(verb, targ, cmaj, cmin, gccs);
   if (i > 1)
      return(FreeListGetString(gccs, i-1));
   if (i < 0)
      return(FreeListGetString(gccs, -(i+1)));
   else
      KillAllStringsInList(gccs);
   return(NULL);
}

void TestComps(enum OSTYPE OS, enum MACHTYPE arch, int verb, char *targ,
               char *targarg, char **comps, enum F2CNAME *f2cnam, 
               enum F2CINT *f2cint, enum F2CSTRING *f2cstr, int nof77)
/*
 * This file tests that all C compilers work and interact w/o any changes,
 * and figure out how to have the fortran compiler call the C compiler
 */
{
   char cmnd[2048], res[1024];
   char *sp;
   int i, ierr;
   if (verb)
      fprintf(stdout, "C compiler interoperation probe unimplemented!\n\n");
/* 
 * C interoperation checks
 */
   if (verb > 1)
      fprintf(stderr, "ICC interoperation tests:\n");
   for (i=0; i < NCOMP; i++)
   {
      if (i != XCC_ && i != F77_ && i != ICC_)
      {
         if (strcmp(comps[i], comps[ICC_])) /* only check if different */
         {
            sprintf(cmnd, 
   "make IRunC2C CC='%s' CCFLAGS='%s' CC1='%s' CC1FLAGS='%s' | fgrep SUCCESS",
                    comps[ICC_], comps[NCOMP+ICC_], comps[i], comps[i+NCOMP]);
            if (verb > 1)
               fprintf(stderr, "cmnd='%s'\n", cmnd);
            ierr = CmndOneLine(NULL, cmnd, res);
            if (!ierr)
               ierr = !strstr(res, "SUCCESS");
            if (ierr)
            {
               fprintf(stderr, "Compiler %d (%s) does not interoperate with interface compiler (%s), aborting!\n", i, comps[i], comps[ICC_]);
               fprintf(stderr, "ierr=%d, res='%s'\n", ierr, res);
               exit(ierr);
            }
            if (verb > 1)
               fprintf(stderr, 
                       "   C2C %s/%s -- SUCCESS\n", comps[ICC_], comps[i]);
         }
      }
   }
/*
 * F2c tests
 */
   if (nof77)
   {
      *f2cnam = f2c_NamErr;
      *f2cint = f2c_IntErr;
      *f2cstr = f2c_StrErr;
   }
   else
   {
      if (strstr(comps[F77_], "mgwgfortran"))
         sprintf(cmnd, "make IRun_f2c args=\"%s -C ic '%s' -F ic '%s' -C if '%s' -F if '%s -static'\" | fgrep 'F2C=('",
                 targarg, comps[ICC_], comps[ICC_+NCOMP], 
                 comps[F77_], comps[F77_+NCOMP]);
      else
         sprintf(cmnd, "make IRun_f2c args=\"%s -C ic '%s' -F ic '%s' -C if '%s' -F if '%s'\" | fgrep 'F2C=('",
                 targarg, comps[ICC_], comps[ICC_+NCOMP], 
                 comps[F77_], comps[F77_+NCOMP]);
      *f2cnam = f2c_NamErr;
      *f2cint = f2c_IntErr;
      *f2cstr = f2c_StrErr;
      if (verb > 1)
         fprintf(stderr, "cmnd='%s'\n", cmnd);
      if (!CmndOneLine(NULL, cmnd, res))
      {
         if (verb > 1)
            fprintf(stderr, "res='%s'\n", res);
         i = sscanf(res, " F2C=(%d,%d,%d)", f2cnam, f2cint, f2cstr);
         if (verb > 1)
            fprintf(stderr, "nread=%d, f2cname=%d, f2cint=%d, f2cstr=%d\n",
                    i, *f2cnam, *f2cint, *f2cstr);
         if (i != 3)
           *f2cnam = *f2cint = *f2cstr = 0;
      }
      if (verb)
      {
         printf("F2C name = %s\n", f2c_namestr[*f2cnam]);
         printf("F2C int  = %s\n", f2c_intstr[*f2cint]);
         printf("F2C str  = %s\n", f2c_strstr[*f2cstr]);
      }
   }
}

void PrintCompResults(char *file, char **comps, enum F2CNAME f2cnam, 
                      enum F2CINT f2cint, enum F2CSTRING f2cstr)
{
   FILE *fpout;
   int i;

   if (file)
      fpout = fopen(file, "w");
   else fpout = stdout;
   assert(fpout);

   for (i=0; i < NCOMP; i++)
   {
      if (comps[i])
         fprintf(fpout, "%d '%s' '%s'\n", i, comps[i], comps[i+NCOMP]);
   }
   if (comps[F77_])
      fprintf(fpout, "F2CNAME,F2CINT,F2CSTRING=(%d,%d,%d)\n",
              f2cnam, f2cint, f2cstr);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
}

@beginskip
void PrintUsage(char *name, int i)
{
   fprintf(stderr, "Error around argument %d.  USAGE:", i);
   fprintf(stderr, "%s [-O <OS> -v <verb> -A <mach> -T <targ>\n", name);
   fprintf(stderr, "   -C [xc,ic,if,sk,dk,sm,dm] <compiler>\n");
   fprintf(stderr, "   -F [xc,ic,if,sk,dk,sm,dm] '<comp flags>'\n");
   fprintf(stderr, 
           "   -Fa [xc,ic,if,sk,dk,sm,dm,al] '<comp flags to append>'\n");
   fprintf(stderr, "        al: append flags to all compilers\n");
   exit(-1);
}
@endskip

@extract -b @(basd)/atlconf.base rout=GetFlags -def -O "" -def -v "" -def -A "" -def -V "" -def -b "" -def -C "" -def -o "" -def -S "-S" -def -nof77 "-nof77"

int main(int nargs, char **args)
/*
 * probe_comp has the following responsibilities:
 * 1. Read in atlcomp.txt for recommended compiler and flags
 * 2. Find a GOODGCC to override generic "gcc" name and to assemble assembly codes
 * 3. If on Windows wt 64 bits, build MinGW compiler wrappers, for 64-bit comps
 * 4. Accept user override of compiler/flags
 * 5. Append any user appended flags
 * 6. Ensure all non-xcc C compilers interoperate by calling probe_ccomps
 * 7. Figure out F77/C interoperating rules by calling probe_f772c
 * 8. Printing out results of these probes for later use
 */
{
   enum OSTYPE OS;
   enum MACHTYPE mach;
   int ptrbits, verb, vecexts, i, nof77;
   char *usrcomps[3*NCOMP];
   char *outfile, *targ, *targarg, *goodgcc;
   enum F2CNAME f2cnam;
   enum F2CINT f2cint; 
   enum F2CSTRING f2cstr;

   GetFlags(nargs, args, &verb, &OS, &vecexts, &mach, &ptrbits, usrcomps, 
            &outfile, &nof77, &targ);

   if (verb > 1)
   {
      fprintf(stdout, "User Override Compilers:\n");
      for (i=0; i < NCOMP; i++)
         fprintf(stdout, "   '%s' : '%s' '%s'\n", 
            usrcomps[i] ? usrcomps[i]:"none", 
            usrcomps[i+NCOMP] ? usrcomps[i+NCOMP]:"none", 
            usrcomps[i+2*NCOMP] ? usrcomps[i+2*NCOMP]:"none");
      fprintf(stdout, "\n");
   }
   if (targ)
   {
      targarg = malloc(sizeof(char)*(strlen(targ)+24));
      assert(targarg);
      sprintf(targarg, "-T '%s'", targ);
   }
   else
      targarg = "";
   goodgcc = FindGoodGcc(OS, mach,  verb, targ);
   GetComps(OS, mach, verb, targ, ptrbits, usrcomps, nof77, goodgcc);
/* 
 * See if we need to search for gfortran
 */
   if (!nof77 && usrcomps[F77_] && !strcmp(usrcomps[F77_], "gfortran"))
   {
      free(usrcomps[F77_]);
      usrcomps[F77_] = FindGoodGfortran(OS, mach, verb, targ, goodgcc);
      if (!usrcomps[F77_])
         usrcomps[F77_] = NewStringCopy("gfortran");
   }
   TestComps(OS, mach, verb, targ, targarg, usrcomps, 
             &f2cnam, &f2cint, &f2cstr, nof77);
   if (verb)
   {
      fprintf(stdout, "Compilers:\n");
      for (i=0; i < NCOMP; i++)
         fprintf(stdout, "   '%s' : '%s'\n", usrcomps[i], usrcomps[NCOMP+i]);
      fprintf(stdout, "\n");
   }
   PrintCompResults(outfile, usrcomps,  f2cnam, f2cint, f2cstr);
   if (targ)
      free(targarg);
   return(0);
}
@ROUT flibchkF.f
       SUBROUTINE flibchk(A)
       COMPLEX*16  A(*)
       INTRINSIC   DIMAG
*
*      Perform complex arith and I/O to link in f77 libs
*
       A(1) = (A(1) * A(2)) / A(3)
       if (DIMAG(A(1)) .EQ. 99999.97) STOP
       PRINT*,' SUCCESS'

       RETURN
       END
@ROUT flibchkC
#include <stdio.h>
#include <stdlib.h>
#ifdef NoChange
   #define flibchk_ flibchk
#elif defined(UpCase)
   #define flibchk_ FLIBCHK
#endif
int main(int nargs, char **args)
{
   void flibchk_(double*);
   double A[6];
   A[0] = A[1] = A[2] = A[3] = A[5] = 0.0;
   A[4] = 1.0;
   flibchk_(A);
   return(0);
}
@ROUT probe_f2c
#include "atlconf.h"

int probe_name(char *targarg, int verb, char **usrcomps)
{
   char cmnd[2048], res[1024];
   enum F2CNAME f2cname = f2c_NamErr;

   sprintf(cmnd, "make IRunF2C_name %s F77=\"%s\" F77FLAGS=\"%s\" CC=\"%s\" CCFLAGS=\"%s\" | fgrep 'F2C name'", 
           targarg, usrcomps[F77_], usrcomps[F77_+NCOMP],
           usrcomps[ICC_], usrcomps[ICC_+NCOMP]);
   if (verb > 1)
      fprintf(stderr, "cmnd = '%s'\n", cmnd);
   if (!CmndOneLine(NULL, cmnd, res))
   {
      if (verb > 1)
         fprintf(stderr, "res = '%s'\n", res);
      if (strstr(res, "Add__"))
         f2cname = f2c_Add__;
      else if (strstr(res, "Add_"))
         f2cname = f2c_Add_;
      else if (strstr(res, "NoChange"))
         f2cname = f2c_NoChange;
      else if (strstr(res, "UpCase"))
         f2cname = f2c_UpCase;
   }
   if (verb)
      printf("F2C Name Decoration = %s\n", f2c_namestr[f2cname]);
   return(f2cname);
}

int probe_int(char *targarg, int verb, char **usrcomps, int f2cname)
{
   char cmnd[2048], res[1024];
   enum F2CINT f2c_int = f2c_IntErr;
   sprintf(cmnd, "make IRunF2C_int %s F77=\"%s\" F77FLAGS=\"%s\" CC=\"%s\" CCFLAGS=\"-D%s %s\" | fgrep 'F2C int'", 
           targarg, usrcomps[F77_], usrcomps[F77_+NCOMP],
           usrcomps[ICC_], f2c_namestr[f2cname], usrcomps[ICC_+NCOMP]);
   if (verb > 1)
      fprintf(stderr, "cmnd = '%s'\n", cmnd);
   if (!CmndOneLine(NULL, cmnd, res))
   {
      if (verb > 1)
         fprintf(stderr, "res = '%s'\n", res);
      if (strstr(res, " C int"))
         f2c_int = FintCint;
      else if (strstr(res, " C long long"))
         f2c_int = FintClonglong;
      else if (strstr(res, " C long"))
         f2c_int = FintClong;
      else if (strstr(res, " C short"))
         f2c_int = FintCshort;
   }
   if (verb)
      printf("F2C int = %s\n", f2c_intstr[f2c_int]);
   return(f2c_int);
}

int probe_str(char *targarg, int verb, char **usrcomps, int f2cname, int f2cint)
{
   char cmnd[2048], res[1024];
   enum F2CSTRING f2cstr = f2c_StrErr;
   int i;

   for (i=1; i < 5; i++)
   {
      sprintf(cmnd, "make IRunF2C_str %s F77=\"%s\" F77FLAGS=\"%s\" CC=\"%s\" CCFLAGS=\"-D%s -D%s -DString%s %s\" | fgrep 'F2C string'", 
              targarg, usrcomps[F77_], usrcomps[F77_+NCOMP],
              usrcomps[ICC_], f2c_namestr[f2cname], f2c_intstr[f2cint], 
              f2c_strstr[i], usrcomps[ICC_+NCOMP]);
      if (verb > 1)
         fprintf(stderr, "cmnd = '%s'\n", cmnd);
      if (!CmndOneLine(NULL, cmnd, res))
      {
         if (verb > 1)
            fprintf(stderr, "res = '%s'\n", res);
         f2cstr = i;
         break;
      }
   }
   if (verb)
      printf("F2C string = %s\n", f2c_strstr[f2cstr]);
   return(f2cstr);
}

@extract -b @(basd)/atlconf.base rout=GetFlags -def -v "v" -def -C "C"
int main (int nargs, char **args)
/*
 * This probe discovers the details of how fortran should call C for the
 * given compilers.  In particular, it discovers:
 *    (1) Name decoration C rout should do to be callable from fortran
 *    (2) What intergral type F77 integer corresponds to
 *    (3) How fortran strings are passed
 */
{
   int verb;
   int f2cname, f2cint, f2cstr;
   char *usrcomps[3*NCOMP];
   char *targ, *targarg;
   int ierr = 0;

   GetFlags(nargs, args, &verb, usrcomps, &targ);
   if (targ)
   {
      targarg = malloc(sizeof(char)*(strlen(targ)+24));
      assert(targarg);
      sprintf(targarg, "atlrun=atlas_runX targ=%s", targ);
   }
   else
      targarg = "";
   f2cname = probe_name(targarg, verb, usrcomps);
   if (f2cname)
   {
      f2cint = probe_int(targarg, verb, usrcomps, f2cname);
      f2cstr = probe_str(targarg, verb, usrcomps, f2cname, f2cint);
      printf("F2C=(%d,%d,%d)\n", f2cname, f2cint, f2cstr);
   }
   else
   {
      ierr = 1;
      if (verb)
         fprintf(stderr, "Cannot determine f2cname, quitting f2c probe!\n");
   }
   if (targ)
      free(targarg);
   return(ierr);
}
@ROUT f2cnameC
#include <stdio.h>
void c_routine_(double *d)  { *d = 1.0; }
void c_routine(double *d)   { *d = 2.0; }
void C_ROUTINE(double *d)  { *d = 3.0; }
void c_routine__(double *d) { *d = 4.0; }
@ROUT f2cnameF.f
      program namtst
      external c_routine
      double precision d

      d = 0.0
      call c_routine(d)
      if (d .eq. 1.0) then
         print*,'F2C name=-DAdd_'
      else if (d .eq. 2.0) then
         print*,'F2C name=-DNoChange'
      else if (d .eq. 3.0) then 
         print*,'F2C name=-DUpCase'
      else if (d .eq. 4.0) then
         print*,'F2C name=-DAdd__'
      else 
         print*, 'ERROR'
      endif

      stop
      end
@ROUT f2cnameC_old
#include <stdio.h>
void c_routine_(void)  { printf("F2C name=-DAdd_\n"); }
void c_routine(void)   { printf("F2C name=-DNoChange\n"); }
void C_ROUTINE(void)  { printf("F2C name=-DUpCase\n"); }
void c_routine__(void) { printf("F2C name=-DAdd__\n"); }
@ROUT f2cnameF.f_old
      program namtst
      external c_routine

      call c_routine()

      stop
      end
@ROUT f2cintF.f
       program f2cintf
       integer iarr(8)
       double precision d
       iarr(1) = 1
       iarr(2) = -1
       iarr(3) = -1
       iarr(4) = -1
       iarr(5) = -1
       iarr(6) = -1
       iarr(7) = -1
       iarr(8) = -1
       d = 0.0
       call f2cintc(iarr, d)
      if (d .eq. 1.0) then
         print*,'F2C int = C int'
      else if (d .eq. 2.0) then
         print*,'F2C int = C long'
      else if (d .eq. 3.0) then 
         print*,'F2C int = C long long'
      else if (d .eq. 4.0) then
         print*,'F2C int = C short'
      else 
         print*, 'ERROR'
      endif

       stop
       end
@ROUT f2cintC
#include <stdio.h>
#include <stdlib.h>
#if defined(Add_) || defined(Add__)
   #define f2cintc f2cintc_
#elif defined(UpCase)
   #define f2cintc F2CINTC
#endif
void f2cintc(void *vp, double *d)
{
   int *ip=vp;
   long *lp=vp;
   long long *llp=vp;
   short *sp=vp;

   *d = 0.0;
   if ( (sizeof(long) != sizeof(int)) && (*lp == 1) )
      *d = 2.0;
   else if (*ip == 1)  *d = 1.0;
   else if (*lp == 1)  *d = 2.0;
   else if (*llp == 1) *d = 3.0;
   else if (*sp == 1)  *d = 4.0;
}
@ROUT f2cintF.f_old
       program f2cintf
       integer iarr(8)
       iarr(1) = 1
       iarr(2) = -1
       iarr(3) = -1
       iarr(4) = -1
       iarr(5) = -1
       iarr(6) = -1
       iarr(7) = -1
       iarr(8) = -1
       call f2cintc(iarr)
       stop
       end
@ROUT f2cintC_old
#include <stdio.h>
#include <stdlib.h>
#if defined(Add_) || defined(Add__)
   #define f2cintc f2cintc_
#elif defined(UpCase)
   #define f2cintc F2CINTC
#endif
void f2cintc(void *vp)
{
   int *ip=vp;
   long *lp=vp;
   long long *llp=vp;
   short *sp=vp;

   if ( (sizeof(long) != sizeof(int)) && (*lp == 1) )
      printf("F2C int = C long\n");
   else if (*ip == 1)  printf("F2C int = C int\n");
   else if (*lp == 1)  printf("F2C int = C long\n");
   else if (*llp == 1) printf("F2C int = C long long\n");
   else if (*sp == 1)  printf("F2C int = C short\n");
}
@ROUT f2cstrF.f
      program chartst
      external crout
      double precision d

      d = 0.0
      call crout(d, '123', -1, '12345', -2)
      if (d .eq. 1.0) then
         print*,'F2C string = -DStringSunStyle'
      else if (d .eq. 2.0) then
         print*,'F2C string = -DStringCrayStyle'
      else if (d .eq. 3.0) then 
         print*,'F2C string = -DStringStructVal'
      else if (d .eq. 4.0) then
         print*,'F2C string = -DStringStructPtr'
      else 
         print*, 'ERROR'
      endif

      stop
      end
@ROUT f2cstrC
#include <stdlib.h>
#if defined(Add_) || defined(Add__)
   #define crout crout_
#elif defined(UpCase)
   #define crout CROUT
#endif
#ifdef StringSunStyle

void crout(double *d, char *str1, F77_INTEGER *n1, char *str2, F77_INTEGER *n2, 
           F77_INTEGER three, F77_INTEGER five)
{
   if ( (*n1 != -1) || (*n2 != -2) || (three != 3) || (five != 5) ) exit(-1);
   if (str1[0] != '1' || str1[1] != '2' || str1[2] != '3') exit(-1);
   if (str2[0] != '1' || str2[1] != '2' || str2[2] != '3' ||
       str2[3] != '4' || str2[4] != '5') exit(-1);
   *d = 1.0;
@skip   printf("F2C string = -DStringSunStyle\n");
}

#elif defined(StringCrayStyle)

#include <fortran.h>
void crout(double *d, _fcd str1, F77_INTEGER *n1, _fcd str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) ) exit(-1);
   if (*(_fcdtocp(str1)) != '1' || *(_fcdtocp(str2)) != '1' ) exit(-1);
   *d = 2.0;
@skip   printf("F2C string = -DStringCrayStyle\n");
}

#elif defined(StructVal)

typedef struct {char *cp; F77_INTEGER len;} F77_CHAR;
void crout(double *d, F77_CHAR str1, F77_INTEGER *n1, 
           F77_CHAR str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1.len != 3) || (str2.len != 5) )
      exit(-1);
   if (str1.cp[0] != '1' || str1.cp[1] != '2' || str1.cp[2] != '3') exit(-1);
   if (str2.cp[0] != '1' || str2.cp[1] != '2' || str2.cp[2] != '3' ||
       str2.cp[3] != '4' || str2.cp[4] != '5') exit(-1);
   *d = 3.0;
@skip   printf("F2C string = -DStringStructVal\n");
}
#elif defined(StructPtr)
typedef struct {char *cp; F77_INTEGER len;} *F77_CHAR;
void crout(double *d, F77_CHAR str1, F77_INTEGER *n1, 
           F77_CHAR str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1->len != 3) || (str2->len != 5) )
      exit(-1);
   if (str1->cp[0] != '1' || str1->cp[1] != '2' || str1->cp[2] != '3') exit(-1);
   if (str2->cp[0] != '1' || str2->cp[1] != '2' || str2->cp[2] != '3' ||
       str2->cp[3] != '4' || str2->cp[4] != '5') exit(-1);
   *d = 4.0;
@skip   printf("F2C string = -DStringStructPtr\n");
}
#endif
@ROUT f2cstrF.f_old
      program chartst
      external crout

      call crout('123', -1, '12345', -2)

      stop
      end
@ROUT f2cstrC_old
#if defined(Add_) || defined(Add__)
   #define crout crout_
#elif defined(UpCase)
   #define crout CROUT
#endif
#ifdef StringSunStyle

void crout(char *str1, F77_INTEGER *n1, char *str2, F77_INTEGER *n2, 
           F77_INTEGER three, F77_INTEGER five)
{
   if ( (*n1 != -1) || (*n2 != -2) || (three != 3) || (five != 5) ) exit(-1);
   if (str1[0] != '1' || str1[1] != '2' || str1[2] != '3') exit(-1);
   if (str2[0] != '1' || str2[1] != '2' || str2[2] != '3' ||
       str2[3] != '4' || str2[4] != '5') exit(-1);
   printf("F2C string = -DStringSunStyle\n");
}

#elif defined(StringCrayStyle)

#include <fortran.h>
void crout(_fcd str1, F77_INTEGER *n1, _fcd str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) ) exit(-1);
   if (*(_fcdtocp(str1)) != '1' || *(_fcdtocp(str2)) != '1' ) exit(-1);
   printf("F2C string = -DStringCrayStyle\n");
}

#elif defined(StructVal)

typedef struct {char *cp; F77_INTEGER len;} F77_CHAR;
void crout(F77_CHAR str1, F77_INTEGER *n1, F77_CHAR str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1.len != 3) || (str2.len != 5) )
      exit(-1);
   if (str1.cp[0] != '1' || str1.cp[1] != '2' || str1.cp[2] != '3') exit(-1);
   if (str2.cp[0] != '1' || str2.cp[1] != '2' || str2.cp[2] != '3' ||
       str2.cp[3] != '4' || str2.cp[4] != '5') exit(-1);
   printf("F2C string = -DStringStructVal\n");
}
#elif defined(StructPtr)
typedef struct {char *cp; F77_INTEGER len;} *F77_CHAR;
void crout(F77_CHAR str1, F77_INTEGER *n1, F77_CHAR str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1->len != 3) || (str2->len != 5) )
      exit(-1);
   if (str1->cp[0] != '1' || str1->cp[1] != '2' || str1->cp[2] != '3') exit(-1);
   if (str2->cp[0] != '1' || str2->cp[1] != '2' || str2->cp[2] != '3' ||
       str2->cp[3] != '4' || str2->cp[4] != '5') exit(-1);
   printf("F2C string = -DStringStructPtr\n");
}
#endif
@ROUT c2cmaster
#include <stdio.h>
#include <stdlib.h>
int main(int nargs, char **args)
{
   int i;
   int c2cslave(char, int, double, float);
   i = c2cslave('y', 2, 2.0, 3.0);
   if (i != -2)
   {
      printf("FAILURE\n");
      exit(1);
   }
   printf("SUCCESS\n");
   return(0);
}
@ROUT c2cslave
int c2cslave(char c, int i, double d, float f)
{
   if (c == 'y' && i == 2 && d == 2.0 && f == 3.0)
      return(-2);
   return(0);
}
@ROUT comptestF.f
      program comptest
      print*, 'SUCCESS'
      stop
      end
@ROUT comptestC
#include <stdio.h>
#include <stdlib.h>

int main(int nargs, char **args)
{
   printf("SUCCESS");
   return(0);
}
@ROUT atlcomp.txt
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end)
#
# The file has the following format:
# MACH=<#>,...,<#> OS=<#>,...,<#> LVL=<#> COMPS=[icc,smc,dmc,skc,dkc,xccf77]
#  'compiler' 'flags'
# Where MACH indicates the MACHTYPE(s) that the compiler should be available
# on, the OS indicates which Operating systems that compiler is available on,
# and both of these can take the value of 0, which means the compiler and
# associated flags can be used for any machine/OS.  There should be no
# space in the #,# strings.
#
# LVL gives a priority, and the highest available priority compiler is used
# by ATLAS by default.  If the user overrides to a compiler that's listed
# as a possiblity, the flags given in this line will be used (if the user
# does not also override flags) regardless of priority.  In general, here
# are some reserved priorities:
#   1000: Default compiler for particular OS/flag
#    500: Alternative compiler getting roughly same performance
#    100: Alternative compiler getting crappier performance
#     50: Default compiler for particular OS / general family
#     10: Default compiler for particular OS / completely unknown arch
#      0: Fallback compiler when nothing is known
#
# COMPS is a list saying which of ATLAS's compiler this comp/flag combo are
#  to be used for:
#  icc: Used to compiler interface; perf neutral, so set to anything user
#       uses for interoperability
#  f77: Same as above but for f77 interface.
#  dkc: Used to compile all non-matmul double prec computational kernels.
#  skc: Used to compile all non-matmul single prec computational kernels.
#  dmc: Used to compile all matmul single prec computational kernels.
#  smc: Used to compile all matmul single prec computational kernels.
#*****************************************************************************
#
# All non-core x86 like these params for MMFLAGS (probably want -O3 for
# Level 1 & 2, but must confirm)
#
# Core2/Corei1/Corei2
MACH=Corei2 OS=Win9x,WinNT LVL=1005 COMPS=smc,dmc,skc,dkc,icc
   'gcc-4' '-fomit-frame-pointer -mfpmath=sse -mavx -O2 -fno-schedule-insns2'
MACH=Corei2 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -mavx -O2 -fno-schedule-insns2'
MACH=Corei2 OS=ALL LVL=500 COMPS=smc,dmc,skc,dkc,icc,gcc
   'clang' '-fomit-frame-pointer -mavx -O2 -m64 -Wno-parentheses'
MACH=Corei1 OS=Win9x,WinNT LVL=1005 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc-4' '-fomit-frame-pointer -mfpmath=sse -msse3 -O2 -fno-schedule-insns2'
MACH=Corei1 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -msse3 -O2 -fno-schedule-insns2'
MACH=Core2 OS=Win9x,WinNT LVL=1005 COMPS=smc,dmc,skc,dkc,icc
   'gcc-4' '-fomit-frame-pointer -mfpmath=sse -msse3 -O2'
MACH=Core2 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -msse3 -O2'
MACH=Atom OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc
   'gcc' '-O3 -fno-schedule-insns2 -funroll-all-loops -fno-tree-ch'
MACH=Atom OS=ALL LVL=1000 COMPS=icc,gcc
   'gcc' '-O'
@skip # PPRO,PII,PIII,P4,P4E,K7,HAMMER
@skip MACH=PPRO,PII,PIII,P4,P4E,K7,HAMMER OS=ALL LVL=2000 COMPS=smc,dmc,skc,dkc
@skip    'gcc32' '-fomit-frame-pointer -mfpmath=387 -O2 -falign-loops=4'
# PPRO,PII,PIII,P4,P4E,K7,HAMMER
MACH=PPRO,PII,PIII,P4,P4E,K7,HAMMER OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-fomit-frame-pointer -mfpmath=387 -O2 -falign-loops=4'
MACH=PPRO,PII,PIII,P4,P4E,K7,HAMMER OS=Win9x,WinNT LVL=1005 COMPS=smc,dmc,skc,dkc,icc
   'gcc-4' '-fomit-frame-pointer -mfpmath=387 -O2 -falign-loops=4'
MACH=PPRO,PII,PIII,P4,P4E,K7,HAMMER OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=387 -O2 -falign-loops=4'
# CoreSolo,CoreDuo
MACH=CoreSolo,CoreDuo OS=WinNT,Win9x LVL=1005 COMPS=smc,dmc,skc,dkc,icc
   'gcc-4' '-fomit-frame-pointer -O3 -mfpmath=387'
MACH=CoreSolo,CoreDuo OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -O3 -mfpmath=387'
# 3rd generation opteron (Barcelona and descendents)
MACH=AMD64K10h OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-fomit-frame-pointer -mfpmath=sse -msse3 -O2 -falign-loops=32'
MACH=AMD64K10h OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -msse3 -O2 -falign-loops=32'
MACH=AMD64K10h OS=Win9x,WinNT LVL=1005 COMPS=smc,dmc,skc,dkc,icc,gcc
   'gcc' '-fomit-frame-pointer -mfpmath=sse -msse3 -O2 -falign-loops=32'
# UltraSPARC T2
MACH=UST2 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-mcpu=niagara2 -mtune=niagara2 -Os'
MACH=UST2 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-mcpu=niagara2 -mtune=niagara2 -Os'
# UltraSPARC III & IV
MACH=USIII,USIV OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc
   'gcc' '-mcpu=ultrasparc3 -mtune=ultrasparc3 -O3 -funroll-all-loops'
MACH=USIII,USIV OS=ALL LVL=1000 COMPS=icc,xcc,gcc
   'gcc' '-mcpu=ultrasparc3 -mtune=ultrasparc3 -O'
MACH=USIII,USIV OS=ALL LVL=1000 COMPS=f77
   'f77' '-dalign -native -xO5'
MACH=USIII,USIV OS=ALL LVL=100 COMPS=f77
   'gfortran' '-O -mcpu=ultrasparc3 -mtune=ultrasparc3'
MACH=USIII,USIV OS=ALL LVL=10 COMPS=f77
   'g77' '-O -mcpu=ultrasparc3 -mtune=ultrasparc3'
#
# Itanium & Itanium 2 
#
# These gcc 4 default flags will die on gcc3, allowing gcc3's flags to be used
MACH=IA64Itan,IA64Itan2 OS=ALL LVL=1010 COMPS=smc,dmc,skc,dkc
   'gcc' '-fomit-frame-pointer -O2 -fno-tree-loop-optimize'
MACH=IA64Itan,IA64Itan2 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc
   'gcc' '-fomit-frame-pointer -O2'
MACH=IA64Itan,IA64Itan2 OS=ALL LVL=1010 COMPS=f77
   'gfortran' '-fomit-frame-pointer -O2 -fno-tree-loop-optimize'
#
# IRIX/MIPS
#
MACH=MIPSR1xK OS=IRIX LVL=1000 COMPS=smc,dmc,skc,dkc
   'cc' '-O3 -OPT:Olimit=15000 -LNO:blocking=OFF -LOPT:alias=typed'
MACH=MIPSR1xK OS=IRIX LVL=1000 COMPS=icc,xcc,gcc
   'cc' '-O2 -OPT:Olimit=15000 -LNO:blocking=OFF'
MACH=MIPSR1xK OS=IRIX LVL=1000 COMPS=f77
   'f77' '-O2'
#
# Linux/MIPSICE9
# pathcc priorities set below gcc because threaded syrk won't work with
# pathcc at -O2 -- seems to be a compiler error
#
MACH=MIPSICE9 OS=ALL LVL=500 COMPS=icc,smc,dmc,skc,dkc,xcc,gcc
   'gcc' '-O2 -mips64 -march=5kf -mtune=5kf -fno-schedule-insns -fschedule-insns2 -fno-peephole -fno-peephole2'
MACH=MIPSICE9 OS=ALL LVL=1000 COMPS=f77
   'pathf95' '-march=auto -O2'
MACH=MIPSICE9 OS=ALL LVL=1 COMPS=skc,dkc
   'pathcc' '-O3 -OPT:Olimit=15000 -LNO:blocking=OFF -LOPT:alias=typed -march=auto'
MACH=MIPSICE9 OS=ALL LVL=1 COMPS=smc,dmc
   'pathcc' '-O3 -OPT:Olimit=15000 -LNO:blocking=OFF -LOPT:alias=typed -march=auto -LNO:opt=0 -LNO:full_unroll_outer=OFF -LNO:fusion=0 -LNO:prefetch=2'
MACH=MIPSICE9 OS=ALL LVL=1 COMPS=icc,xcc
   'pathcc' '-march=auto -O2 -OPT:Olimit=15000 -LNO:blocking=OFF'
#
# G4 flags, has a slightly less important case of the gcc perf bug of the POWER5
# confirmed in gcc 4.3.2.
#
MACH=PPCG4 OS=ALL LVL=1000 COMPS=dmc
   'gcc' '-maltivec -mabi=altivec -mcpu=7400 -mtune=7400 -fno-schedule-insns -fschedule-insns2 -Os'
MACH=PPCG4 OS=ALL LVL=1000 COMPS=smc
   'gcc' '-maltivec -mabi=altivec -mcpu=7400 -mtune=7400 -fno-schedule-insns -fschedule-insns2 -Os -funsafe-loop-optimizations -fno-tree-dominator-opts'
MACH=PPCG4 OS=ALL LVL=1000 COMPS=icc,skc,dkc,xcc,gcc
   'gcc' '-O3 -maltivec -mabi=altivec -mcpu=7400 -mtune=7400'
#MACH=PPCG4 OS=OSX LVL=1001 COMPS=icc,smc,dmc,skc,dkc,xcc,gcc
#   'gcc' '-O3 -maltivec -mabi=altivec -mcpu=7400 -mtune=7400 -no-cpp-precomp -faltivec -fno-schedule-insns'

#
# OS X / PowerPC970; the
# The flags -fno-schedule-insns -fno-rerun-loop-opt are a workaround for
# a compiler error in gcc 4.2.  If you have gcc4.1.1, can get back some
# performance by removing them (for all PowerPC platforms)
#
MACH=PPCG5 OS=OSX LVL=1001 COMPS=icc,smc,dmc,skc,dkc,xcc,gcc
   'gcc' '-mpowerpc64 -maltivec -mabi=altivec -mcpu=970 -mtune=970 -faltivec -O3'
MACH=PPCG5 OS=OSX LVL=1010 COMPS=smc,dmc
   'gcc' '-mpowerpc64 -maltivec -mabi=altivec -mcpu=970 -mtune=970 -faltivec -force_cpusubtype_ALL -fno-rerun-loop-opt -fno-schedule-insns -Os -fno-tree-ter'
MACH=PPCG5 OS=OSX LVL=1010 COMPS=icc,skc,dkc,xcc,gcc
   'gcc' '-mpowerpc64 -maltivec -mabi=altivec -mcpu=970 -mtune=970 -faltivec -force_cpusubtype_ALL -O3 -fno-schedule-insns -fno-rerun-loop-opt'
MACH=PPCG5 OS=ALL LVL=1000 COMPS=smc,dmc
   'gcc' '-mpowerpc64 -maltivec -mabi=altivec -mcpu=970 -mtune=970 -O3'
MACH=PPCG5 OS=ALL LVL=1000 COMPS=icc,skc,dkc,xcc,gcc
   'gcc' '-mpowerpc64 -maltivec -mabi=altivec -mcpu=970 -mtune=970 -fno-rerun-loop-opt -fno-schedule-insns -Os -fno-tree-ter'
MACH=POWER7 OS=ALL LVL=1010 COMPS=icc,smc,skc,dkc,xcc,gcc
   'gcc' '-O3 -mvsx -mcpu=power7 -mtune=power7 -fno-schedule-insns -fschedule-insns2'
MACH=POWER7 OS=ALL LVL=1010 COMPS=dmc
   'gcc' '-Os -mvsx -mcpu=power7 -mtune=power7 -fno-schedule-insns -fschedule-insns2'
MACH=POWER6 OS=ALL LVL=1010 COMPS=icc,smc,dmc,skc,dkc,xcc,gcc
   'gcc' '-mcpu=power6 -mtune=power6 -maltivec -O3 -fno-schedule-insns -fschedule-insns2 -minsert-sched-nops=2'
MACH=POWER5 OS=ALL LVL=1010 COMPS=icc,smc,dmc,skc,dkc,xcc,gcc
   'gcc' '-mcpu=power5 -mtune=power5 -O3 -fno-schedule-insns -fno-rerun-loop-opt'
MACH=POWER7 OS=ALL LVL=1010 COMPS=f77
   'gfortran' '-O3 -mvsx -mcpu=power7 -mtune=power7 -fno-schedule-insns -fschedule-insns2'
MACH=POWER6 OS=ALL LVL=1010 COMPS=f77
   'gfortran' '-mcpu=power6 -mtune=power6 -maltivec -O3 -fno-schedule-insns -fschedule-insns2 -minsert-sched-nops=2'
MACH=POWER5 OS=ALL LVL=1010 COMPS=f77
   'gfortran' '-mcpu=power5 -mtune=power5 -O3 -fno-schedule-insns -fno-rerun-loop-opt'
MACH=POWER7 OS=ALL LVL=1010 COMPS=f77
   'xlf' '-qtune=pwr7 -qarch=pwr7 -O3 -qmaxmem=-1 -qfloat=hsflt'
MACH=POWER5 OS=ALL LVL=1010 COMPS=f77
   'xlf' '-qtune=pwr5 -qarch=pwr5 -O3 -qmaxmem=-1 -qfloat=hsflt'
MACH=POWER4 OS=ALL LVL=1010 COMPS=icc,dmc,smc,dkc,skc,xcc,gcc
   'gcc' '-mcpu=power4 -mtune=power4 -O3 -fno-schedule-insns -fno-rerun-loop-opt'
MACH=POWER4 OS=ALL LVL=1010 COMPS=f77
   'xlf' '-qtune=pwr4 -qarch=pwr4 -O3 -qmaxmem=-1 -qfloat=hsflt'
#
# IBM System z or zEnterprise.
# These compiler flags given by IBM; -O3 -funroll-loops are chosen because
# its what their compiler group supports, not necessarily because they are best
MACH=IBMz9 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=z9-109 -O3 -funroll-loops'
MACH=IBMz10 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=z10 -O3 -funroll-loops -fno-prefetch-loop-arrays'
# Try to fallback to z9 for older compilers
MACH=IBMz10 OS=ALL LVL=600 COMPS=f77
   'gfortran' '-march=z9-109 -O3 -funroll-loops'
MACH=IBMz10 OS=ALL LVL=600 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=z9-109 -O3 -funroll-loops -fno-prefetch-loop-arrays'
# z196
MACH=IBMz196 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-march=z196 -O3 -funroll-loops -fno-prefetch-loop-arrays'
MACH=IBMz196 OS=ALL LVL=1000 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=z196 -O3 -funroll-loops -fno-prefetch-loop-arrays'
# We also try to fallback to z10 or z9 for older compilers
MACH=IBMz196 OS=ALL LVL=800 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=z10 -O3 -funroll-loops -fno-prefetch-loop-arrays'
MACH=IBMz196 OS=ALL LVL=800 COMPS=f77
   'gfortran' '-march=z10 -O3 -funroll-loops -fno-prefetch-loop-arrays'
MACH=IBMz196 OS=ALL LVL=600 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-march=z9-109 -O3 -funroll-loops'
MACH=IBMz196 OS=ALL LVL=600 COMPS=f77
   'gfortran' '-march=z9-109 -O3 -funroll-loops'
# ALL march options failed, go back to conservative defaults
MACH=IBMz9,IBMz10,IBMz196 OS=ALL LVL=500 COMPS=f77
   'gfortran' '-O3 -funroll-loops'
MACH=IBMz9,IBMz10,IBMz196 OS=ALL LVL=500 COMPS=smc,dmc,skc,dkc,icc,xcc,gcc
   'gcc' '-O3 -funroll-loops'
#
# Windows defaults ; need to make SSE/SSE2 arch dep.
#
MACH=P5,P5MMX,PPRO,PII OS=WinNT LVL=4 COMPS=icc,dmc,smc,dkc,skc,xcc
   'cl' '-Oy -Ox'
MACH=PIII,K7 OS=WinNT LVL=4 COMPS=icc,dmc,smc,dkc,skc,xcc
   'cl' '-Oy -Ox -arch:SSE -nologo'
MACH=ALL OS=WinNT LVL=0 COMPS=icc,dmc,smc,dkc,skc,xcc
   'cl' '-Oy -Ox -arch:SSE2 -nologo'
MACH=ALL OS=WinNT LVL=0 COMPS=f77
   'ifort' '-O2 -fltconsistency -nologo'
MACH=P4,PM OS=WinNT LVL=0 COMPS=icc,dmc,smc,dkc,skc,xcc
   'icl' '-QxN -O3 -Qprec -fp:extended -fp:except -nologo -Oy'
#
# ARM defaults
#
MACH=ARMv7 OS=ALL LVL=1000 COMPS=icc,xcc
   'gcc' '-mcpu=cortex-a8 -O'
MACH=ARMv7 OS=ALL LVL=1000 COMPS=smc,skc,gcc
   'gcc' '-mcpu=cortex-a8 -mfpu=vfpv3 -O2 -fschedule-insns -fschedule-insns2 -fprefetch-loop-arrays'
MACH=ARMv7 OS=ALL LVL=1000 COMPS=dmc,dkc
   'gcc' '-mcpu=cortex-a8 -mfpu=vfpv3 -O2 -fschedule-insns -fno-schedule-insns2 -fprefetch-loop-arrays'
MACH=ARMv7 OS=ALL LVL=1000 COMPS=f77
   'gfortran' '-mcpu=cortex-a8 -O'
#
# Generic defaults
#
MACH=ALL OS=ALL LVL=5 COMPS=icc,smc,dmc,skc,dkc,xcc,gcc
   'gcc' '-O -fomit-frame-pointer'
MACH=ALL OS=ALL LVL=5 COMPS=f77
   'gfortran' '-O'
MACH=ALL OS=ALL LVL=4 COMPS=f77
   'g77' '-O'
MACH=ALL OS=ALL LVL=0 COMPS=f77
   'f77' '-O'
@ROUT config
#include "atlconf.h"

char *GetStrProbe(int verb, char *targarg, char *prb, char *id, char *str)
/*
 * Performs probe where output is string delimited by '', returning string
 * RETURNS: NULL on error, else requested string.
 */
{
   char *sp;
   char ln[2048], ln2[2048];
   char *ln, *res;
   int ierr=0, i;

   i = strlen(targarg) + strlen(prb) + strlen(id) + 48;
   ln = malloc(i*sizeof(char));
   sprintf(ln, "make IRun_%s args=\"-v %d %s\" | fgrep '%s='", 
           prb, verb, targarg, id);
   if (verb > 1)
      printf("cmnd=%s\n", ln);
   ierr = CmndOneLine(NULL, ln, ln2);
   if (!ierr)
   {
      sprintf(ln, "%s='", id);
      sp = strstr(ln2, ln);
      if (sp)
      {
         for (sp += strlen(ln); *sp && *sp != '\''; sp++)
            *str++ = *sp;
         if (!(*sp)) ierr = -2;
         *str = '\0';
      }
      else ierr = -4;
   }
   return(ierr);
}

int GetIntProbe(int verb, char *targarg, char *prb, char *id, int N)
{
   char ln[2048], ln2[2048];
   int iret=0, ierr;

   ln[0] = ln2[0] = '\0';
   sprintf(ln, "make IRun_%s args=\"-v %d %s\" | fgrep '%s='", 
           prb, verb, targarg, id);
   if (verb > 1)
      printf("cmnd=%s\n", ln);
   ierr = CmndOneLine(NULL, ln, ln2);
   if (!ierr)
      iret = GetLastInt(ln2);
   if (N)
   {
      if (iret > N || iret < 1)
      {
         printf("\nBad %s value=%d, ierr=%d, ln2='%s'\n", id, iret, ierr, ln2);
         iret = 0;
      }
   }
   return(iret);
}

int GetIntProbeSure(int verb, char *targarg, char *prb, char *id, 
                    int *sure)
{
   char ln[2048], ln2[2048];
   int iret=0, ierr;

   ln[0] = ln2[0] = '\0';
   sprintf(ln, "make IRun_%s args=\"-v %d %s\" | fgrep '%s='", 
           prb, verb, targarg, id);
   if (verb > 1)
      printf("cmnd=%s\n", ln);
   ierr = CmndOneLine(NULL, ln, ln2);
   if (!ierr)
   {
      iret = GetFirstInt(ln2);
      *sure = GetLastInt(ln2);
   }
   return(iret);
}

void TransCompsToFlags(char **comps, char *flags)
{
   int i, j;
/*
 * WARNING: if you change the order of the ICC_, etc, must change
 *          compnames!
 */
   char *compnames[7] = {"ic", "sm", "dm", "sk",  "dk", "xc", "if"};

   *flags = '\0';
/*
 * Pass any override compilers/flags and appends to probe
 */
   for (j=i=0; i < NCOMP; i++)
   {
      if (comps[i])
         j += sprintf(flags+j, "-C %s '%s' ", compnames[i], comps[i]);
      if (comps[NCOMP+i])
         j += sprintf(flags+j, "-F %s '%s' ", compnames[i], comps[NCOMP+i]);
      if (comps[2*NCOMP+i])
         j += sprintf(flags+j, "-Fa %s '%s' ", compnames[i], comps[2*NCOMP+i]);
   }
}

char *ProbeComp(int verb, char *targarg, enum OSTYPE OS, enum MACHTYPE arch, 
                 char **comps, int nof77, int nocygwin, int ptrbits)
/*
 * RETURNS: f2c define string
 */
{
   char ln[4096], flags[2048], comp[512];
   int f2cname, f2cint, f2cstr;
   char *f2cdefs;
   int i, if77=0;
   FILE *fpin;

   TransCompsToFlags(comps, flags);
   i = sprintf(ln, 
   "make IRun_comp args=\"-v %d -o atlconf.txt -O %d -A %d -Si nof77 %d %s %s",
               verb, OS, arch, nof77, targarg, flags);
   if (ptrbits == 64 || ptrbits == 32)
      i += sprintf(ln+i, " -b %d", ptrbits);
   sprintf(ln+i, "\"");
   if (verb > 1)
      fprintf(stderr, "cmnd='%s'\n", ln);
@skip   assert(CmndResults(NULL, ln));
   syschk(ln);
   fpin = fopen("atlconf.txt", "r");
   assert(fpin);
   while (fgets(ln, 4096, fpin))
   {
      if (ln[0] != '#')
      {
         if (isdigit(ln[0]))
         {
            assert(sscanf(ln, "%d '%[^']' '%[^']", &i, comp, flags) == 3);
            assert(i >= 0 && i < NCOMP);
            comps[i] = NewStringCopy(comp);
            comps[NCOMP+i] = NewStringCopy(flags);
         }
         else
         {
            for (i=0; ln[i] && ln[i] != '('; i++);
            assert(ln[i] = '(');
            assert(sscanf(ln+i+1, "%d,%d,%d", &f2cname, &f2cint, &f2cstr) == 3);
            if77 = 1;
         }
      }
   }
   fclose(fpin);
/*
 * For windows only, all non-XCC gnu compilers get -mnocygwin flag if user has
 * asked for it
 */
   if (nocygwin && OSIsWin(OS))
   {
      for (i=0; i < NCOMP; i++)
      {
         if (i != XCC_)
         {
            if (CompIsGcc(comps[i]))
               comps[i+NCOMP] = NewAppendedString(comps[i+NCOMP],"-mno-cygwin");
         }
      }
   }
/*
 * Add the flag to build shared objects, if we know what it is
 */
#ifdef ATL_DYLIBS
   for (i=0; i < NCOMP; i++)
   {
      if (i != XCC_)
      {
         if (CompIsGcc(comps[i]) || CompIsAppleGcc(comps[i]) || 
             CompIsPathScale(comps[i]))
         {
            if (!OSIsWin(OS))  /* windows/gcc bitches about -fPIC flag */
               comps[i+NCOMP] = NewAppendedString(comps[i+NCOMP],"-fPIC");
         }
         else if (CompIsMIPSpro(comps[i]))
            comps[i+NCOMP] = NewAppendedString(comps[i+NCOMP],"-KPIC");
         else if (CompIsSunWorkshop(comps[i]))
            comps[i+NCOMP] = NewAppendedString(comps[i+NCOMP],"-KPIC");
#if 0 /* I don't think a special flag is needed for shared obj wt xlc */
         else if (CompIsIBMXL(comps[i]))
            comps[i+NCOMP] = NewAppendedString(comps[i+NCOMP],"????");
#endif
      }
   }
#endif
/*
 * Only f77 and xcc allowed to be NULL
 */
   for (i=0; i < NCOMP; i++)
   {
      if (comps[i] == NULL)
      {
         if (i == XCC_)
         {
            comps[XCC_] = NewStringCopy(comps[ICC_]);
            comps[NCOMP+XCC_] = NewStringCopy(comps[ICC_+NCOMP]);
         }
         else assert(i == F77_);
      }
      if (comps[i+NCOMP] == NULL)
      {
         if (i == XCC_)
            comps[XCC_+NCOMP] = NewStringCopy(comps[ICC_+NCOMP]);
         else assert(i == F77_);
      }
   }
/*
 * Echo compiler info to screen if user has asked for verbose output
 */
   if (verb)
   {
      fprintf(stdout, "Selected compilers:\n");
      for (i=0; i < NCOMP; i++)
      {
         fprintf(stdout, "%s = '%s' '%s'\n", COMPNAME[i], 
                 comps[i] ? comps[i]:"none", 
                 comps[NCOMP+i]?comps[NCOMP+i]:"none");
      }
      if (if77)
      {
         fprintf(stdout, "\nF77 calling C interface information:\n");
         fprintf(stdout, "   Name decoration = %s\n", f2c_namestr[f2cname]);
         fprintf(stdout, "   Integer style   = %s\n", f2c_intstr[f2cint]);
         fprintf(stdout, "   String style    = %s\n", f2c_strstr[f2cstr]);
      }
      else
         fprintf(stderr, "F77/C interface not defined!");
   }
   if (!if77)
      f2cdefs = NULL;
   else
   {
      sprintf(ln, "-D%s -D%s -DString%s", 
              f2c_namestr[f2cname], f2c_intstr[f2cint], f2c_strstr[f2cstr]);
      f2cdefs = malloc(sizeof(char)*(strlen(ln)+1));
      assert(f2cdefs);
      strcpy(f2cdefs, ln);
   }
   return(f2cdefs);
}

int PathLength(char *str)
/*
 * Given string, finds end unix path, allowing \ to mean sticky space, stops at 
 * first non-sticky pass.  Skips any leading spaces.
 * RETURNS: index of first non-sticky space
 * NOTE: Assumes str[-1] valid 
 */
{
   int i;
   for (i=0; isspace(str[i]); i++);  /* skip leading spaces */
   for (; str[i]; i++)
      if (str[i] == ' ' && str[i-1] != '\\') break;
   return(i);
}

int TestF77LIB(int verb, char *targarg, enum OSTYPE OS, enum MACHTYPE arch, 
               char **comps, char *incd, char *f77lib)
{
   const char *frm ="make IRunTestCFLink F77='%s' F77FLAGS='%s' CC='%s' CCFLAGS='%s -L%s' F77LIB='%s' LIBS='-lm'";
   char *ln;
   int i;

   i = strlen(frm) + strlen(incd) + strlen(f77lib) +
       strlen(comps[F77_]) + strlen(comps[ICC_]) +
       strlen(comps[NCOMP+F77_]) + strlen(comps[NCOMP+ICC_]) + 1;
   ln = malloc(i*sizeof(char));
   assert(ln);
   sprintf(ln, frm, comps[F77_], comps[NCOMP+F77_], 
           comps[ICC_], comps[NCOMP+ICC_], incd, f77lib);
   if (verb > 1)
      fprintf(stderr, "cmnd = %s\n", ln);
   if (verb) 
      fprintf(stderr, "Trying F77 link path of %s ... ", incd);
   if (!system(ln))
   {
      if (verb) fprintf(stderr, "SUCCESS!\n");
      free(ln);
      return(1);
   }
   else if (verb)
      fprintf(stderr, "REJECTED!!!!\n");
   free(ln);
   return(0);
}

char *FindF77LIBInList(int verb, char *targarg, enum OSTYPE OS, 
                       enum MACHTYPE arch, char **comps, char *f77lib, 
                       char **paths)
{
   int i;
   if (!paths)
      return(NULL);
   for (i=0; paths[i]; i++)
   {
      char *path;
      path = GetPathWithoutName(paths[i]);
      if (path && TestF77LIB(verb, targarg, OS, arch, comps, path, f77lib))
      {
         free(path);
         return(FreeListGetString(paths, i));
      }
      free(path);
   }
   KillAllStringsInList(paths);
   return(NULL);
}

char *FindF77LIB0(int verb, char *targarg, enum OSTYPE OS, enum MACHTYPE arch, 
                  char **comps, char *f77lib, char *f77libnam, char *path)
{
   char *frm="find %s -name '%s'", *cmnd;
   char **libs=NULL;
   int i;
   i = strlen(frm) + strlen(f77libnam) + strlen(path) + 1;
   cmnd = malloc(i*sizeof(char));
   assert(cmnd);
   sprintf(cmnd, frm, path, f77libnam);
fprintf(stderr, "cmnd='%s'\n", cmnd);
   libs = GetLinesFromFile(CmndResultsNoErr(NULL, cmnd), NULL);
PrintAllStringsInList("FOUND:", libs);
   free(cmnd);
   if (!libs)
      return(NULL);

   return(FindF77LIBInList(verb, targarg, OS, arch, comps, f77lib, libs));
}

char *FindF77LIB(int verb, char *targarg, enum OSTYPE OS, enum MACHTYPE arch, 
                 char **comps, char *f77lib, char *f77libnam)
{
   char *path, *sp;
   int i;

/*
 * See if we can find by substituting "lib" for "bin" in compiler path
 */
   path = GetPathWithoutName(comps[F77_]);
   if (path)
   {
      sp = strstr(path, "/bin");
      if (sp)
      {
         sp[1] = 'l';
         sp[2] = 'i';
         sp[3] = 'b';
      }
      sp = FindF77LIB0(verb, targarg, OS, arch, comps, f77lib, f77libnam, path);
      free(path);
      if (sp)
         return(sp);
   }
/*
 * Scope some OS-specific places
 */
   if (OS == OSOSX)  /* /sw is for fink, /opt for macports */
   {
      sp = FindF77LIB0(verb, targarg, OS, arch, comps, f77lib, f77libnam, 
                       "/sw/lib /opt/lib /opt/local/lib");
      if (sp)
         return(sp);
   }
/*
 * Scope standard unix places
 */
   sp = FindF77LIB0(verb, targarg, OS, arch, comps, f77lib, f77libnam, 
           "/lib /usr/lib /usr/local/lib /lib64 /usr/lib64 /usr/local/lib64");
   if (verb)
   {
      if (sp)
         printf("F77libdir = %s\n", sp);
      else
         printf("F77LIB left blank\n");
   }
   return(sp);
}

char *BuildF77LinkLine(enum OSTYPE OS, char *path, char *libnam)
{
   char *sp, *OSextra="";
   int i;

   if (OSIsWin(OS))
      OSextra = "-lgcc";
   i = strlen(path) + strlen(libnam) + strlen(OSextra) + 2 + 2 + 1 + 1;
   sp = malloc(i*sizeof(char));
   assert(sp);
   sprintf(sp, "-L%s -l%s %s", path, libnam, OSextra);
   return(sp);
}

char *ProbeF77LIB(int verb, char *targarg, enum OSTYPE OS, 
                  enum MACHTYPE arch, char **comps, char *f2cdefs, int nof77)
/*
 * Tries to find the directory that needs to be included to link in f77
 * routines
 */
{
   char cmnd[1024], res[2048];
   char *f77lib, *F77LIBdir, *sp, *suff, *f77libnam;
   int i;
   char ch;

   if (nof77 || !f2cdefs) return(NULL);
   if (CompIsGcc(comps[F77_]))
   {
      if  (strstr(comps[F77_], "g77")) f77lib = "g2c";
      else f77lib = "gfortran";
   }
   else
   {
      if (verb > 1)
         fprintf(stderr, "Unknown F77 compiler, leaving F77LIBS blank!\n");
      return(NULL);
   }
/*
 * Figure out full name of the libgfortran we are looking ofr
 */
   if (OS == OSOSX)
      suff = ".dylib";
   else if (OSIsWin(OS))
      suff = ".dll";
   else
      suff = ".so";
   i = 3 + strlen(f77lib) + strlen(suff) + 1;
   f77libnam = malloc(i*sizeof(char));
   assert(f77libnam);
   sprintf(f77libnam, "lib%s%s", f77lib, suff);
/*
 * First, see if we can use 'gfortran -print-file-name=<f77libnam>' to
 * get definitive answer.  If so, return it.
 */
   i = strlen(comps[F77_]) + strlen(comps[F77_+NCOMP]) + strlen(f77libnam) + 21;
   sp = malloc(i*sizeof(char));
   assert(sp);
   sprintf(sp, "%s %s -print-file-name=%s", 
           comps[F77_], comps[F77_+NCOMP], f77libnam);
   if (!CmndOneLine(NULL, sp, res))
   {
      free(sp);
      fprintf(stdout, "REPORTED: res=%s\n", res);
      sp = GetPathWithoutName(res);
      F77LIBdir = BuildF77LinkLine(OS, sp, f77lib);
      free(sp);
      if (verb)
         fprintf(stderr, "F77LIB = %s\n", F77LIBdir);
      return(F77LIBdir);
   }
   free(sp);
/*
 * If we are using a gfortran without the above option, try to parse
 * a verbose link line for the answer
 */
   sprintf(cmnd,  "make IRunFlib F77='%s' F77FLAGS='%s'",
           comps[F77_], comps[NCOMP+F77_]);
   if (verb > 1)
      fprintf(stderr, "LIBDIR cmnd = %s\n", cmnd);
   CmndOneLine(NULL, cmnd, res);
   if (verb > 1)
      fprintf(stderr, "LIBDIR res = %s\n", res);
/*
 * Find which -L leads us to f77lib
 */
   sp = res;
   while (sp = strstr(sp, "-L"))
   {
      sp += 2;
      i = PathLength(sp); 
      if (i)
      {
         char *sp2;
         ch = sp[i];
         sp[i] = '\0';
         sp2 = NewStringCopy(sp);
         sp2 = NewAppendedString(sp2, f77libnam);
         if (FileIsThere(sp2) &&
             TestF77LIB(verb, targarg, OS, arch, comps, sp, f77lib))
         {
            F77LIBdir = NewStringCopy(sp-2);
            F77LIBdir = NewAppendedString(F77LIBdir, "-l");
            F77LIBdir = NewAppendedString0(F77LIBdir, f77lib);
            if (OSIsWin(OS))
               F77LIBdir = NewAppendedString(F77LIBdir, "-lgcc");
            if (verb)
               fprintf(stderr, "F77LIB = %s\n", F77LIBdir);
            free(sp2);
            free(f77libnam);
            return(F77LIBdir);
         }
         free(sp2);
         sp[i] = ch;
         sp += i;
      }
   }
   sp = FindF77LIB(verb, targarg, OS, arch, comps, f77lib, f77libnam);
   free(f77libnam);
   if (sp)
   {
      F77LIBdir = NewStringCopy("-L");
      suff = GetPathWithoutName(sp);
      F77LIBdir = NewAppendedString0(F77LIBdir, suff);
      free(suff);
      free(sp);
      F77LIBdir = NewAppendedString(F77LIBdir, "-l");
      F77LIBdir = NewAppendedString0(F77LIBdir, f77lib);
      if (OSIsWin(OS))
         F77LIBdir = NewAppendedString(F77LIBdir, "-lgcc");
      if (verb)
         fprintf(stderr, "F77LIB = %s\n", F77LIBdir);
   }
   return(NULL);
}

enum OSTYPE ProbeOS(int verb, char *targarg)
{
   enum OSTYPE iret;

   iret = GetIntProbe(verb, targarg, "OS", "OS", NOS);
   printf("\nOS configured as %s (%d)\n", osnam[iret], iret);
   assert(iret);
   return(iret);
}

enum ASMDIA ProbeAsm(int verb, char *targarg, enum OSTYPE OS)
{
   enum ASMDIA asmd=ASM_None;
   char ln[1024];

   sprintf(ln, "%s -O %d", targarg, OS);
   asmd = GetIntProbe(verb, ln, "asm", "ASM", NASMD);
   printf("\nAssembly configured as %s (%d)\n", ASMNAM[asmd], asmd);
   return(asmd);
}

int ProbeVecs(int verb, char *targarg, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret;
   char ln[1024];

   sprintf(ln, "%s -O %d -s %d", targarg, OS, asmb);
   iret = GetIntProbe(verb, ln, "vec", "VECFLAG", (1<<NISA));
   for (i=0; i < NISA && (iret & (1<<i)) == 0; i++);
   if (i == NISA)
      i = 0;
   printf("\nVector ISA Extension configured as  %s (%d,%d)\n", 
          ISAXNAM[i], i, iret);
   return(iret);
}

int ProbeArch(int verb, char *targarg, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret;
   char ln[1024];

   sprintf(ln, "%s -O %d -s %d -a", targarg, OS, asmb);
   iret = GetIntProbe(verb, ln, "arch", "MACHTYPE", NMACH);
   printf("\nArchitecture configured as  %s (%d)\n", 
          machnam[iret], iret);
   return(iret);
}

int ProbeMhz(int verb, char *targarg, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret;
   char ln[1024];

   sprintf(ln, "%s -O %d -s %d -m", targarg, OS, asmb);
   if (verb > 2)
      printf("Mhz Probe = '%s'\n", ln);
   iret = GetIntProbe(verb, ln, "arch", "CPU MHZ", 16384);
   printf("\nClock rate configured as %dMhz\n", iret);
   return(iret);
}

int ProbeNcpu(int verb, char *targarg, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret;
   char ln[1024];

   sprintf(ln, "%s -O %d -s %d -n", targarg, OS, asmb);
   iret = GetIntProbe(verb, ln, "arch", "NCPU", 2048);
   printf("\nMaximum number of threads configured as  %d\n", iret);
   return(iret);
}

int ProbePtrbits(int verb, char *targarg, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret;
   char ln[1024];

   sprintf(ln, "%s -O %d -s %d -b", targarg, OS, asmb);
   iret = GetIntProbeSure(verb, ln, "arch", "PTR BITS", &i);
/*
 * If it's not 64-bit, make sure it's not just because of flag setting
 */
   if (iret != 64)
   {
   }
   if (iret != 64)
      iret = 32;
   printf("\nPointer width configured as %d\n", iret);
   return(iret);
}

int ProbeCPUThrottle(int verb, char *targarg, enum OSTYPE OS, enum ASMDIA asmb)
{
   int i, iret;
   char ln[1024];
   sprintf(ln, "%s -O %d -s %d -t", targarg, OS, asmb);
   iret = GetIntProbe(verb, ln, "arch", "CPU THROTTLE", 0);
   if (iret) printf("CPU Throttling apparently enabled!\n");
   else printf("Cannot detect CPU throttling.\n");
   return(iret);
}

@beginskip
void GetArchDef(int verb, enum MACHTYPE arch, char **comps, char **archdefs)
/*
 * Unpacks arch-specific tarfile (if any) and sees what archdefaults
 * we have (if any) for each kernel compiler
 * RETURNS: archdef array, with NULL entries for no archdef, or path to 
 *          defaults when they exist
 */
{
   int i;
   int adcomps[NARDEF] = {SKC_, DKC_, SMC_, DMC_};
   char *sp;
   char *adsubds[NARDEF] = {"skern", "dkern", "smm", "dmm"};
   char ln[1024], path[512];

   for (i=0; i < NARDEF; i++)
      archdefs[i] = NULL;
   sprintf(ln, "make %s_defs arch=%s", machnam[arch], machnam[arch]);
   if (system(ln))
      return;
   for (i=0; i < NARDEF; i++)
   {
      assert(comps[adcomps[i]]);
      sp = NameWithoutPath(comps[adcomps[i]]);
      assert(sp);
      sprintf(path, "%s_def/%s/%s", machnam[arch], adsubds[i], sp);
      free(sp);
      sprintf(ln, "make DirIsThere tdir=%s", path);
      if (!system(ln))
      {
         archdefs[i] = malloc(sizeof(char)*(strlen(path)+1));
         assert(archdefs[i]);
         strcpy(archdefs[i], path);
      }
   }
}
@endskip

void Comps2Flags(char **comps, char *ln)
/*
 * Takes the comps array (1st NCOMP entries are compilers, next NCOMP entries
 * flags for those compilers) and translates them into the corresponding flags
 * for xspew (or indeed this config.c)
 * NOTE: assumes appended flags (2*NCOMP+i) already appended to flags (NCOMP+i)
 */
{
   char *cname[NCOMP] = {"ic", "sm", "dm", "sk", "dk", "xc", "gc", "if"};
   int i, j=0;
   ln[0] = '\0';
   for (i=0; i < NCOMP; i++)
   {
      if (comps[i])
         j += sprintf(ln+j, "-C %s '%s' ", cname[i], comps[i]);
      if (comps[NCOMP+i])
         j += sprintf(ln+j, "-F %s '%s' ", cname[i], comps[NCOMP+i]);
   }
}

char *ProbePmake(int verb, enum OSTYPE OS, int ncpu)
/*
 * WARNING: if cross-comp really worked, this would be ncpu of front-end,
 *          not backend!
 */
{
   char args[256], res[1024];
   char *sp;

   sprintf(args, "-O %d -t %d", OS, ncpu);
   if (!GetStrProbe(verb, args, "pmake", "PMAKE", res))
   {
      sp = malloc((strlen(res)+1)*sizeof(char));
      strcpy(sp, res);
   }
   else sp = NULL;
   if (sp) printf("Parallel make command configured as '%s'\n", sp);
   else printf("Parallel make not configured.\n");
   return(sp);
}

void SpewItForth(int verb, enum OSTYPE OS, enum MACHTYPE arch, int mhz,
                 enum ASMDIA asmb, int vecexts, int ptrbits, 
                 int ncpu, int omp, int AntThr,
                 int l2size, char *srcdir, char *bindir, int bozol1, 
                 int archdef, int latune,  int nof77, char **comps, 
                 char *gccflags,
                 char *f2cdefs, char *cdefs, char *pmake, char *flapack, 
                 char *smaflags, char *dmaflags, char *f77libs)
/*
 * Calls xspew with correct arguments to build required Make.inc
 */
{
   char ln[4096], compsflags[1024], archflags[1024];
   int i;
   assert(CmndResults(NULL, "make xspew"));
/*
 * Translate compiler/flag array to xspew flags
 */
   Comps2Flags(comps, compsflags);
   i = sprintf(ln, "./xspew -v %d -O %d -A %d -m %d -s %d -V %d -b %d -t %d -f %d -d s '%s' -d b '%s' -D c '%s' -D f '%s' %s -Si archdef %d -Si bozol1 %d -Si latune %d -Si nof77 %d -o Make.inc",
               verb, OS, arch, mhz, asmb, vecexts, ptrbits, ncpu, l2size,
               srcdir, bindir, cdefs ? cdefs:"", f2cdefs? f2cdefs : "", 
               compsflags, archdef, bozol1, latune, nof77);
   if (pmake)
      i += sprintf(ln+i, " -Ss pmake '%s'", pmake);
   if (flapack)
      i += sprintf(ln+i, " -Ss flapack '%s'", flapack);
   if (smaflags)
      i += sprintf(ln+i, " -Ss smaflags '%s'", smaflags);
   if (dmaflags)
      i += sprintf(ln+i, " -Ss dmaflags '%s'", dmaflags);
   if (f77libs)
      i += sprintf(ln+i, " -Ss f77lib '%s'", f77libs);
   if (omp)
      i += sprintf(ln+i, " -Si omp %d", omp);
   if (AntThr)
      i += sprintf(ln+i, " -Si antthr %d", AntThr);
   if (gccflags)
      i += sprintf(ln+i, " -Fa gc '%s'", gccflags);
   if (verb > 1)
      fprintf(stderr, "cmnd='%s'\n", ln);
   syschk(ln);
}

@extract -b @(basd)/atlconf.base rout=GetFlags -def allflags "1" -def -thrchk "1" -def -nocygwin "1"

int main(int nargs, char **args)
{
   enum OSTYPE OS;
   enum MACHTYPE mach;
   int i, verb, asmb, f2cname, f2cint, f2cstr, ncpu, nof77, nocygwin;
   int thrchk, mhz, omp, AntThr, lapackref;
   int j, k, h, vecexts;
   int ptrbits, l2size, bozol1, latune, archdef;
   char *targ, *f2cdefs, *cdefs, *srcdir, *bindir, *outfile, *sp;
   char targarg[256];
   char *comps[3*NCOMP], *gccflags;
   char *pmake, *flapack, *smaflags, *dmaflags, *f77libs;
@skip   char *archdefs[NARDEF], *ad2[NARDEF];

   GetFlags(nargs, args, &verb, &OS, (enum ASMDIA*) &asmb, &vecexts, &mach, 
            &mhz, &ptrbits, &ncpu, &omp, &AntThr, comps, &gccflags, &outfile, 
            &srcdir, &bindir, &bozol1, &archdef, &latune, &nof77, &nocygwin, 
            &thrchk, &lapackref, &f2cdefs, &cdefs, &pmake, &flapack, 
            &smaflags, &dmaflags, &f77libs, &l2size, &targ);
   if (targ)
      sprintf(targarg, "-T %s", targ);
   else
      targarg[0] = '\0';
   if (OS == OSOther)
      OS = ProbeOS(verb, targarg);
   if (asmb == ASM_None)
      asmb = ProbeAsm(verb, targarg, OS);
   else if (asmb < 0)
      asmb = 0;
   if (!vecexts)
      vecexts = ProbeVecs(verb, targarg, OS, asmb);
   else if (vecexts < 0)
      vecexts = 0;
   if (mach == MACHOther)
      mach = ProbeArch(verb, targarg, OS, asmb);
   if (!mhz)
      mhz = ProbeMhz(verb, targarg, OS, asmb);
   if (ncpu < 0)
      ncpu = ProbeNcpu(verb, targarg, OS, asmb);
   if (!pmake && ncpu > 1)
      pmake = ProbePmake(verb, OS, ncpu);
   if (ptrbits == 0)
   {
      if (asmb == gas_x86_64)
         ptrbits = 64;
      else
         ptrbits = ProbePtrbits(verb, targarg, OS, asmb);
   }
   if (ProbeCPUThrottle(verb, targarg, OS, asmb))
   {
      fprintf(stderr, 
         "It appears you have cpu throttling enabled, which makes timings\n");
      fprintf(stderr, 
              "unreliable and an ATLAS install nonsensical.  Aborting.\n");
      fprintf(stderr, 
              "See ATLAS/INSTALL.txt for further information\n");
      if (thrchk) exit(1);
      else fprintf(stderr, "Ignoring CPU throttling by user override!\n\n");
   }
/* 
 * Override 32/64 bit assembler if asked
 */
   if (asmb == gas_x86_64 && ptrbits == 32)
      asmb = gas_x86_32;
   else if (asmb == gas_x86_32 && ptrbits == 64)
      asmb = gas_x86_64;

   sp = ProbeComp(verb, targarg, OS, mach, comps, nof77, nocygwin, ptrbits);
   if (nof77)
      f2cdefs = "-DATL_NoF77";
   else if (!f2cdefs) f2cdefs = sp;
   if (!f77libs)
      f77libs = ProbeF77LIB(verb, targarg, OS, mach, comps, f2cdefs, nof77);
/*
 * If user has not specified muladd flags (which are suffixed to kernel flags),
 * add flags to keep gcc 4 from hanging, if necessary
 */
   if (!smaflags)
   {
      if (CompIsGcc(comps[SKC_]))
      {
         GetGccVers(comps[SKC_], &h, &i, &j, &k);
         if (i >= 4)
            smaflags = "-fno-tree-loop-optimize";
         else if (i == 3) /* reduce opt to avoid compiler hang */
            smaflags = "-O0";
      }
      else if ((OS == OSIRIX && CompIsMIPSpro(comps[SKC_])) || 
               CompIsPathScale(comps[SKC_]))
         smaflags = " -O2";
   }
   if (!dmaflags)
   {
      if (CompIsGcc(comps[DKC_]))
      {
         GetGccVers(comps[DKC_], &h, &i, &j, &k);
         if (i >= 4)
            dmaflags = "-fno-tree-loop-optimize";
         else if (i == 3) /* reduce opt to avoid compiler hang */
            dmaflags = "-O0";
      }
      else if (OS == OSIRIX && CompIsMIPSpro(comps[DKC_]) ||
               CompIsPathScale(comps[DKC_]))
         dmaflags = " -O2";
   }
   SpewItForth(verb, OS, mach, mhz, asmb, vecexts, ptrbits, ncpu, omp, AntThr,
               l2size, srcdir, bindir, bozol1, archdef, latune, nof77, 
               comps, gccflags, f2cdefs, cdefs, pmake, flapack, 
               smaflags, dmaflags, f77libs);
/*
 * Cleanup directory, and exit
 */
   system("make confclean");
   return(0);
}
@ROUT ATLrun.sh
#!/bin/sh
atldir=$1
shift
$atldir/$*
#mach=MyMach
#rdir=/tmp
#atldir=$1
#shift
#exe=$1
#shift
#scp $atldir/$exe $mach:$(rdir)/$exe
#ssh $mach "cd $rdir ; ./$exe $*"
@ROUT configure
#!/bin/sh
#
# BFI configure-like script to bootstrap ATLAS's C-based config scripts
# dependencies: sed, pwd
# shell built-in deps: echo, test
#
cc=gcc
cflags="-g -w"
prefix=/usr/local/atlas
incinstdir=ATL_NoOverride
libinstdir=ATL_NoOverride
flapack=ATL_NoOverride
flapacktar=ATL_NoOverride
f77=1
fulllapack=0
#
# path is configure path without trailing configure :)
#
path=`echo $0 | sed -e "s/configure$//"`
#
# blddir is present directory
#
blddir=`pwd`
#
# If on cygwin, prefix blddir with /cygdrive/[c,d]/
#
if [ -d /cygdrive ]
then
   if [ -d /cygdrive/c/cygwin/$blddir ]
   then
        blddir=/cygdrive/c/cygwin/$blddir
   else
      if [ -d /cygdrive/d/cygwin/$blddir ]
      then
        blddir=/cygdrive/d/cygwin/$blddir
      fi
   fi
fi
#
# topdir is simply path if the line does not begin with "../" and is
#  blddir/path otherwise
chk=`echo "$path" | sed -e "s/^\.\.\///"`
if test "$chk" = "$path"
then
   topdir="$path"
else
   topdir="$blddir"/"$path"
fi
#
# Error out if topdir == blddir
#
touch $blddir/TstBld973.txt
if [ -f "$topdir/TstBld973.txt" ]
then
   echo "ATLAS can no longer be  configured in the exact source directory,"
   echo "create a subdir such as MyObj.  See ATLAS/INSTALL.txt for help."
   rm $blddir/TstBld973.txt
   exit 1
fi
rm $blddir/TstBld973.txt

#
# grab --cc=<c comp> and --cflags=<flags> to be used to build ATLAS's ANSI C
# config.c, and save the rest of the arguments to by passed to the 
# soon-to-be-built xconfig
#
#echo other args=$*
bitwidth=0
rdbitwidth=0
dylib=0
for arg in "$@"
do
   handled=0
   flag=`echo "$arg" | sed -e "s/--help//"`
   if test "$flag" != "$arg"
   then
      echo "ATLAS config includes this script, and probes written in C."
      echo "Therefore, configure flags are union of script and probe flags."
      echo "This configure script accepts the following flags:"
      echo "   --cc=<C compiler> : compiler to compile configure probes"
      echo "   --cflags='<flags>' : flags for above"
      echo "   --prefix=<dirname> : Toplevel installation directory."
      echo "                        Default: /usr/local/atlas"
      echo "   --incdir=<dirname> : Installation dir for include files"
      echo "                        Default: $prefix/include"
      echo "   --libdir=<dirname> : Installation dir for libraries"
      echo "                        Default: $prefix/lib"
      echo "   --shared : same as --dylibs"
      echo "   --dylibs : build dynamic/shared libs in addition to static libs"
      echo "   --nof77 : You have no Fortran compiler installed.  Note that"
      echo "             this will disallow building the F77 interface, and"
      echo "             some of the tests (eg, standard BLAS testers)"
      echo "  --with-netlib-lapack-tarfile=<path to lapack tarfile>"
@beginskip
      echo "  --with-netlib-lapack=<path to lapack.a>"
      echo "     Use this library to build a mixed netlib/ATLAS LAPACK."
      echo "     The two libs will be merged so they must be built wt compatible compilers."
@endskip
      echo "Attempting to build xconfig to get probe flags:"
      rm -f Makefile > /dev/null 2>&1
      echo BLDdir="$blddir" > Makefile
      echo TOPdir="$topdir" >> Makefile
      echo CC="$cc" >> Makefile
      echo CFLAGS="$cflags" >> Makefile
      cat "$path"/CONFIG/src/Makefile >> Makefile
      make xconfig > /dev/null 2>&1
      ./xconfig --help
      rm -f Makefile xconfig atlconf_misc.o > /dev/null 2>&1
      exit 1
   fi
#
# Look for config flag -b <bidwidth>, if we find it set bitwidth to read next
# args val, but don't set handled, since flag must be passed to config as well
#
   if test $rdbitwidth -eq 1
   then
      rdbitwidth=0
      if test "$arg" -eq "64"
      then
         bitwidth=64
      fi
      if test "$arg" -eq "32"
      then
         bitwidth=32
      fi
   fi
   if test "$arg" = "-b"
   then
      rdbitwidth=1
   fi
#
   flag=`echo "$arg" | sed -e "s/--prefix=//"`
   if test "$flag" != "$arg"
   then
      prefix="$flag"
      handled=1
   fi
#
   flag=`echo "$arg" | sed -e "s/--libdir=//"`
   if test "$flag" != "$arg"
   then
      libinstdir="$flag"
      handled=1
   fi
#
   flag=`echo "$arg" | sed -e "s/--incdir=//"`
   if test "$flag" != "$arg"
   then
      incinstdir="$flag"
      handled=1
   fi
   flag=`echo "$arg" | sed -e "s/--shared//"`
   if test "$flag" != "$arg"
   then
      dylib=1
      pass="$pass -D c -DATL_DYLIBS"
      cflags="$cflags -DATL_DYLIBS"
      handled=1
   fi
   flag=`echo "$arg" | sed -e "s/--dylibs//"`
   if test "$flag" != "$arg"
   then
      dylib=1
      pass="$pass -D c -DATL_DYLIBS"
      cflags="$cflags -DATL_DYLIBS"
      handled=1
   fi
#
   flag=`echo "$arg" | sed -e "s/--with-netlib-lapack-tarfile=//"`
   if test "$flag" != "$arg"
   then
      flapacktar="$flag"
      pass="$pass -Si lapackref 1"
@skip      pass="$pass -Ss lasrc $blddir/src/lapack/reference/src/"
      handled=1
      fulllapack=1
   fi
#
@beginskip
   flag=`echo "$arg" | sed -e "s/--with-netlib-lapack=//"`
   if test "$flag" != "$arg"
   then
      flapack="$flag"
      pass="$pass -Ss flapack $flapack"
      handled=1
      fulllapack=1
   fi
@endskip
#
   flag=`echo "$arg" | sed -e "s/--nof77//"`
   if test "$flag" != "$arg"
   then
      f77=0
      pass="$pass -Si nof77 1"
      handled=1
      fulllapack=0
   fi
#
   flag=`echo "$arg" | sed -e "s/--cc=//"`
   if test "$flag" != "$arg"
   then
      cc="$flag"
       handled=1
   else
      flag=`echo "$arg" | sed -e "s/--cflags=//"`
      if test "$flag" != "$arg"
      then
         handled=1
         if test $dylib -eq 0
         then
            cflags="$flag"
         else
            cflags="$flag -DATL_DYLIBS"
         fi
      fi
   fi
   if test $handled -eq 0
   then
#
#     Get rid of leading and trailing spaces
#
      arg=`echo "$arg" | sed -e "s/^ +//"`
      arg=`echo "$arg" | sed -e "s/ +$//"`
# 
#     If flag have internal spaces, surround it with ''
#
      flag=`echo "$arg" | sed -e "s/ //"`
      if (test "$flag" != "$arg")
      then
         pass="$pass '`echo "$arg"`'"
      else
         pass="$pass $arg"
      fi
   fi
done
OSGUESS=`uname`
#
# Need to do some special crap for AIX installs
#
flag=`echo "$OSGUESS" | sed -e "s/AIX//"`
if test "$flag" != "$OSGUESS"
then
   if test $bitwidth -eq 64
   then
      export OBJECT_MODE=64
      if test $cc = "gcc"
      then
         flag=`echo "$cflags" | sed -e "s/-maix//"`
         if test "$flag" = "$cflags"
         then
             cflags="$cflags -maix64"
         fi
      fi
   else
      export OBJECT_MODE=32
   fi
fi
if test $incinstdir = "ATL_NoOverride"
then
   incinstdir='$(DESTDIR)/include'
fi
if test $libinstdir = "ATL_NoOverride"
then
   libinstdir='$(DESTDIR)/lib'
fi
#
# Create the Makefile and copy the compiler info file
#
echo BLDdir="$blddir" > Makefile
echo TOPdir="$topdir" >> Makefile
echo DESTDIR="$prefix" >> Makefile
echo INCINSTdir="$incinstdir" >> Makefile
echo LIBINSTdir="$libinstdir" >> Makefile
echo CC="$cc" >> Makefile
echo CFLAGS="$cflags" >> Makefile
if test $f77 -eq 0
then
   fulllapack=0
   echo TESTS=C_test >> Makefile
   echo PTTESTS=C_pttest >> Makefile
else
   echo TESTS=test >> Makefile
   echo PTTESTS=pttest >> Makefile
fi
#
# Setup targets to build dynamic/shared libs if user has requested it
#
echo "def : build" >> Makefile
echo "shared : dylibs" >> Makefile
echo "dylibs:" >> Makefile
if test $dylib -ne 0
then
   echo "	cd lib ; \$(MAKE) shared_all" >> Makefile
fi
#
# OS X/Darwin 10.5 or later needs special clean commands to get rid of *.dSYM
# directories that gcc creates whenever -g is thrown
# If we are doing dynamic/shared libs, we also need to look for Apple's libtool
# in preference to the gnu version
#
LIBTOOL=libtool
flag=`echo "$OSGUESS" | sed -e "s/Darwin//"`
if test "$flag" != "$OSGUESS"
then
   echo "CLEANdep = OSXClean" >> Makefile
   if test $dylib -eq 1
   then
      OUTTMP=`$LIBTOOL -V`
      flag=`echo "$OUTTMP" | sed -e "s/Apple//"`
      if test "$flag" != "$OUTTMP"
      then
         OUTTMP=`/usr/bin/libtool -V`
         flag=`echo "$OUTTMP" | sed -e "s/Apple//"`
         if test "$flag" != "$OUTTMP"
         then
            LIBTOOL=/usr/bin/libtool
         else
            echo "Cannot find Apple libtool for making shared libraries!"
            exit 10 
         fi
      fi
   fi
else
   echo "CLEANdep = " >> Makefile
fi
cat "$path"/CONFIG/src/Makefile >> Makefile
flag=`echo "$OSGUESS" | sed -e "s/Darwin//"`
if test "$flag" != "$OSGUESS"
then
   echo "OSXClean:" >> Makefile
   echo "	rm -rf *.dSYM" >> Makefile
fi
cp "$path"/CONFIG/src/atlcomp.txt .
#
# Build and run xconfig
#
make -f Makefile xconfig
@skip ./xconfig -d s "$topdir" -d b "$blddir" `echo "$pass"`
echo ./xconfig -d s "$topdir" -d b "$blddir" "$pass"
#./xconfig -d s "$topdir" -d b "$blddir" `echo "$pass"`
if test $fulllapack -eq 0
then
   echo ./xconfig -d s "$topdir" -d b "$blddir" "$pass" | /bin/sh
else
   echo ./xconfig -d s "$topdir" -d b "$blddir" "$pass" \
        -D c -DATL_FULL_LAPACK | /bin/sh
fi
ierr=$?
if test $ierr -ne 0
then
   echo xconfig exited with $ierr
   exit $ierr
fi
#
# Build subdirectory structure and copy all makefiles
#
make -f Makefile make_subdirs
cp -f "$path"/Make.top .
cp -f "$path"/CONFIG/src/ATLrun.sh bin/.
make -f Makefile startup
if test $flapacktar != "ATL_NoOverride"
then
    chk=`echo "$flapacktar" | sed -e "s/^\.\.\///"`
    if test "$chk" = "$flapacktar"
    then
       flatar="$flapacktar"
    else
       flatar="$blddir"/"$flapacktar"
    fi
    if [ -e "$flatar" ]
    then
#
#      Unpack the LAPACK tarfile into $blddir/src/lapack/reftmp
#
       mkdir $blddir/src/lapack/reftmp
       cd  $blddir/src/lapack/reftmp
       flag=`echo "$flatar" | sed -e "s/\.bz2//"`
       if (test "$flag" != "$flatar")
       then
          bunzip2 -c $blddir/$flatar | tar xf -
       else
          flag=`echo "$flatar" | sed -e "s/\.gz//"`
          if (test "$flag" != "$flatar")
          then
             gunzip -c $flatar | tar xf -
          else
             flag=`echo "$flatar" | sed -e "s/\.tgz//"`
             if (test "$flag" != "$flatar")
             then
                gunzip -c $flatar | tar xf -
             else
                tar xf $flatar
             fi
          fi
       fi
#
#      LAPACK directory name changes with version, so we untar it to a temp
#      directory, and then move it to a  fixed name (reference).  We don't
#      use tar's ability to ignore the first directory, because this doesn't
#      port to all OSes tars (would require gnu-tar specifically)
#      Should only be one file!
#
       for file in *
       do
          if [ -d "$file" ]
          then
             mv $file ../reference
          fi
       done
       cd ..
       rm -rf reftmp
@beginskip
#
#      Go into subdir for needed files, should only be one file created by tar
#      Done in this brain-dead way 'cause we can't count on gnu tar
#
       for file in *
       do
          if [ -d "$file" ]
          then
             cd $file 
             if [ -d "SRC" ]
             then
                mv SRC ../src
             else
                echo "No SRC directory in $blddir/src/lapack/reference/$file!!"
                exit -2
             fi
             if [ -d "INSTALL" ]
             then
                mkdir ../INSTALL
                mv INSTALL/?lamch.f ../INSTALL/.
             else
             echo "No INSTALL directory in $blddir/src/lapack/reference/$file!!"
                exit -3
             fi
             if [ -e "COPYING" ]
             then
                mv COPYING ../.
             fi
             if [ -e "README" ]
             then
                mv README ../.
             fi
             cd ..
             rm -rf $file
          fi
       done
@endskip
    else
       echo "Cannot find '$flatar'"
       exit -1
    fi
fi
cd $blddir
if test $flapack != "ATL_NoOverride"
then
   cp -f $flapack lib/liblapack.a
   ar d lib/liblapack.a lsame.o xerbla.o csrot.o zdrot.o
fi
#
# Provide INSTALL directories to lib/Makefile
#
mv lib/Makefile lib/Make.tmp
echo LIBTOOL="$LIBTOOL" > lib/Makefile
echo DESTDIR="$prefix" >> lib/Makefile
echo INCINSTdir="$incinstdir" >> lib/Makefile
echo LIBINSTdir="$libinstdir" >> lib/Makefile
#
# Create standard target for making dynamic/shared according to flags
#
if test $dylib -eq 1
then
#
#  OS X uses the dylib/libtool targets
#
   flag=`echo "$OSGUESS" | sed -e "s/Darwin//"`
   if test "$flag" != "$OSGUESS"
   then
      if test $f77 -eq 0
      then
         echo "shared_all :" >> lib/Makefile
         echo "	\$(MAKE) cdylib" >> lib/Makefile
         echo "	- \$(MAKE) ptcdylib" >> lib/Makefile
      else
         echo "shared_all :" >> lib/Makefile
         echo "	\$(MAKE) dylib" >> lib/Makefile
         echo "	- \$(MAKE) ptdylib" >> lib/Makefile
      fi
   else
#
#     Cygwin uses dll targets
#
      flag=`echo "$OSGUESS" | sed -e "s/CYGWIN//"`
      if test "$flag" != "$OSGUESS"
      then
         if test $f77 -eq 0
         then
            echo "shared_all :" >> lib/Makefile
            echo "	\$(MAKE) cdlls" >> lib/Makefile
            echo "	- \$(MAKE) ptcdlls" >> lib/Makefile
         else
            echo "shared_all :" >> lib/Makefile
            echo "	\$(MAKE) dlls" >> lib/Makefile
            echo "	- \$(MAKE) ptdlls" >> lib/Makefile
         fi
#
#     For everybody else, we use the .so/shared targets (only tested on Linux)
#
      else
         if test $f77 -eq 0
         then
            echo "shared_all :" >> lib/Makefile
            echo "	\$(MAKE) cshared" >> lib/Makefile
            echo "	- \$(MAKE) cptshared" >> lib/Makefile
         else
            echo "shared_all :" >> lib/Makefile
            echo "	\$(MAKE) shared" >> lib/Makefile
            echo "	- \$(MAKE) ptshared" >> lib/Makefile
         fi
     fi
   fi
fi
cat lib/Make.tmp >> lib/Makefile
rm -f lib/Make.tmp
echo "DONE configure"
#
@ROUT SpewMakeInc
#include "atlconf.h"

@extract -b @(basd)/atlconf.base rout=GetFlags -punymac -def allflags ""
@extract -b @(basd)/atlconf.base rout=getptrbits -punymac

int main(int nargs, char **args)
{
   enum OSTYPE OS;
   enum MACHTYPE mach;
   int h, i, j, k, verb, asmb, nof77, mhz;
   int vecexts, ISAX;
   int ptrbits, l2size;
   int delay=0;  /* change this to come from "special" ints in GetFlags */
   int THREADS=0;
   int Use3DNow=0;  /* this needs to come from getflags */
   int ncpu, omp, AntThr, lapackref;
   int USEDEFL1, USEARCHDEF, LATUNE;
   #define NPREC 4
   char pres[NPREC] = {'s', 'd', 'c', 'z'};
   char *targ, *sp, *pmake, *flapack;
   char *comps[3*NCOMP], *comp, *flags, *srcdir, *blddir, *f2cdefs, *cdefs;
   char *outfile, *smaflags, *dmaflags, *f77lib, *gccflags, *goodgcc;
   char targarg[256], ln[1024];
   FILE *fpout;
   char *adnames[NARDEF] = {"sKERNDEF", "dKERNDEF", "sMMDEF", "dMMDEF"};

   GetFlags(nargs, args, &verb, &OS, (enum ASMDIA*) &asmb, &vecexts, &mach, 
            &mhz, &ptrbits, &ncpu, &omp, &AntThr, comps, &gccflags, &outfile, 
            &srcdir, &blddir, &USEDEFL1, &USEARCHDEF, &LATUNE, &nof77, 
            &lapackref, &f2cdefs, &cdefs, &pmake, &flapack, 
            &smaflags, &dmaflags, &f77lib, &l2size, &targ);
   if (ncpu > 1) THREADS = 1;
   if (!outfile)
      fpout = stdout;
   else
      fpout = fopen(outfile, "w");
   assert(fpout);
   assert(srcdir && blddir);
/*
 * Update l2size, and set f2cdefs/cdefs if they are null 
 */
   if (!l2size) l2size = 4*1024*1024;
   else l2size *= 1024;
   if (!f2cdefs) f2cdefs = "";
/*
 * Append any appended flags, and then we have just compilers and flags
 */
   for (i=2*NCOMP; i < 3*NCOMP; i++)
   {
      if (comps[i])
      {
         comps[i-NCOMP] = NewAppendedString(comps[i-NCOMP], comps[i]);
         free(comps[i]);
         comps[i] = NULL;
      }
   }
/*
 * If any C compiler is unspecified, use it to specify the others
 * Use DKC preferentially if it is specified
 */
   if (comps[DKC_] && comps[NCOMP+DKC_])
      k = DKC_;
   else
   {
      k = -1;
      for (i=0; i < F77_; i++)
      {
         if (comps[i] && comps[NCOMP+i])
         {
            k = i;
            break;
         }
      }
      if (k < 0)
      {
         fprintf(stderr, "Need a valid C compiler and flags\n");
         exit(100);
      }
   }
   for (i=0; i < F77_; i++)
   {
      if (!comps[i])
         comps[i] = comps[k];
      if (!comps[NCOMP+i])
         comps[NCOMP+i] = comps[NCOMP+k];
   }
/*
 * If F77 compiler unspecified or nof77 asserted, set it to ICC for linking
 */
   if (!comps[F77_] || nof77)
   {
      comps[F77_] = comps[ICC_];
      comps[NCOMP+F77_] = comps[NCOMP+ICC_];
   }
/*
 * Find dominant ISA extension
 */
   ISAX = 0;
   for (i=1; i < NISA && !ISAX; i++)
      if (vecexts & (1<<i))
         ISAX = i;

   fprintf(fpout, "#  ----------------------------\n");
   fprintf(fpout, "#  Make.inc for ATLAS@(ver)\n");
   fprintf(fpout, "#  ----------------------------\n\n");

   fprintf(fpout, "#  ----------------------------------\n");
   fprintf(fpout, "#  Make sure we get the correct shell\n");
   fprintf(fpout, "#  ----------------------------------\n");
   fprintf(fpout, "   SHELL = /bin/sh\n\n");

   fprintf(fpout, "#  -------------------------------------------------\n");
   fprintf(fpout, "#  Name indicating the platform to configure BLAS to\n");
   fprintf(fpout, "#  -------------------------------------------------\n");
   fprintf(fpout, "   ARCH = %s", machnam[mach]);
   fprintf(fpout, "%d", ptrbits);
   if (ISAX)
      fprintf(fpout, "%s", ISAXNAM[ISAX]);
   fprintf(fpout, "\n\n");

   fprintf(fpout, "#  ----------------------------\n");
   fprintf(fpout, "#  Paths to various directories\n");
   fprintf(fpout, "#  ----------------------------\n");
   fprintf(fpout, "   BLDdir = %s\n", blddir);
   fprintf(fpout, "   SRCdir = %s\n", srcdir);
   fprintf(fpout, "   INCAdir = $(BLDdir)/include\n");
   fprintf(fpout, "   INCSdir = $(SRCdir)/include\n");
   fprintf(fpout, "   BINdir = $(BLDdir)/bin\n");
   fprintf(fpout, "   LIBdir = $(BLDdir)/lib\n\n");
   fprintf(fpout, "   SYSdir = $(BLDdir)/tune/sysinfo\n");
   fprintf(fpout, "   GMMdir = $(BLDdir)/src/blas/gemm\n");
   fprintf(fpout, "   GMVdir = $(BLDdir)/src/blas/gemv\n");
   fprintf(fpout, "   GR1dir = $(BLDdir)/src/blas/ger\n");
   fprintf(fpout, "   L1Bdir = $(BLDdir)/src/blas/level1\n");
   fprintf(fpout, "   L2Bdir = $(BLDdir)/src/blas/level2\n");
   fprintf(fpout, "   L3Bdir = $(BLDdir)/src/blas/level3\n");
   fprintf(fpout, "   TSTdir = $(BLDdir)/src/testing\n");
   fprintf(fpout, "   AUXdir = $(BLDdir)/src/auxil\n");
   fprintf(fpout, "   CBLdir = $(BLDdir)/interfaces/blas/C/src\n");
   fprintf(fpout, "   FBLdir = $(BLDdir)/interfaces/blas/F77/src\n");
   fprintf(fpout, "   MMTdir = $(BLDdir)/tune/blas/gemm\n");
   fprintf(fpout, "   MVTdir = $(BLDdir)/tune/blas/gemv\n");
   fprintf(fpout, "   R1Tdir = $(BLDdir)/tune/blas/ger\n");
   fprintf(fpout, "   L1Tdir = $(BLDdir)/tune/blas/level1\n");
   fprintf(fpout, "   L3Tdir = $(BLDdir)/tune/blas/level3\n");
   fprintf(fpout, "   FLAdir = $(BLDdir)/src/lapack/reference\n");
   fprintf(fpout, "\n");

   fprintf(fpout,
"#  ---------------------------------------------------------------------\n");
   fprintf(fpout,
"#  Name and location of scripts for running executables during tuning\n");
   fprintf(fpout,
"#  ---------------------------------------------------------------------\n");
   fprintf(fpout, "   ATLRUN = $(BLDdir)/bin/ATLrun.sh\n");
   fprintf(fpout, "   ATLFWAIT = $(BLDdir)/bin/xatlas_waitfile\n\n");

   fprintf(fpout, "#  ---------------------\n");
   fprintf(fpout, "#  Libraries to be built\n");
   fprintf(fpout, "#  ---------------------\n");
   fprintf(fpout, "   ATLASlib = $(LIBdir)/libatlas.a\n");
   fprintf(fpout, "   CBLASlib = $(LIBdir)/libcblas.a\n");
   fprintf(fpout, "   F77BLASlib = $(LIBdir)/libf77blas.a\n");
   fprintf(fpout, "   LAPACKlib = $(LIBdir)/liblapack.a\n");
@skip   fprintf(fpout, "   CLAPACKlib = $(LIBdir)/libclapack.a\n");
@skip   fprintf(fpout, "   F77LAPACKlib = $(LIBdir)/libf77lapack.a\n");
@skip   fprintf(fpout, "   CLALIBS = $(CLAPACKlib) $(LAPACKlib)\n");
@skip   fprintf(fpout, "   FLALIBS = $(F77LAPACKlib) $(LAPACKlib)\n");
@skip   fprintf(fpout, "   FCLALIBS = $(F77LAPACKlib) $(CLAPACKlib)\n");
   if (THREADS)
   {
      fprintf(fpout, "   PTCBLASlib = $(LIBdir)/libptcblas.a\n");
      fprintf(fpout, "   PTF77BLASlib = $(LIBdir)/libptf77blas.a\n");
      fprintf(fpout, "   PTLAPACKlib = $(LIBdir)/libptlapack.a\n");
@skip      fprintf(fpout, "   PTCLAPACKlib = $(LIBdir)/libptclapack.a\n");
@skip      fprintf(fpout, "   PTF77LAPACKlib = $(LIBdir)/libptf77lapack.a\n");
@skip      fprintf(fpout, "   PTCLALIBS = $(PTCLAPACKlib) $(LAPACKlib)\n");
@skip      fprintf(fpout, "   PTFLALIBS = $(PTF77LAPACKlib) $(LAPACKlib)\n");
@skip      fprintf(fpout, 
@skip         "   PTFCLALIBS = $(PTF77LAPACKlib) $(PTCLAPACKlib)\n");
   }
   fprintf(fpout, "   TESTlib = $(LIBdir)/libtstatlas.a\n\n");

   fprintf(fpout, "#  -------------------------------------------\n");
   fprintf(fpout, "#  Upper bound on largest cache size, in bytes\n");
   fprintf(fpout, "#  -------------------------------------------\n");
   fprintf(fpout, "   L2SIZE = -DL2SIZE=%d\n\n", l2size);

   fprintf(fpout, "#  ---------------------------------------\n");
   fprintf(fpout, "#  Command setting up correct include path\n");
   fprintf(fpout, "#  ---------------------------------------\n");
   fprintf(fpout, 
           "   INCLUDES = -I$(INCAdir) -I$(INCSdir) -I$(INCSdir)/contrib\n\n");

   fprintf(fpout, "#  -------------------------------------------\n");
   fprintf(fpout, "#  Defines for setting up F77/C interoperation\n");
   fprintf(fpout, "#  -------------------------------------------\n");
   fprintf(fpout, "   F2CDEFS = %s\n\n", f2cdefs);

   fprintf(fpout, "#  ------------------------------\n");
   fprintf(fpout, "#  Architecture identifying flags\n");
   fprintf(fpout, "#  ------------------------------\n");
   fprintf(fpout, "   ARCHDEFS =");
   if (OS != OSOther) 
      fprintf(fpout, " -DATL_OS_%s", osnam[OS]);
   if (mach != MACHOther) 
      fprintf(fpout, " -DATL_ARCH_%s", machnam[mach]);
   if (mhz) 
      fprintf(fpout, " -DATL_CPUMHZ=%d", mhz);
   if (OS == OSSunOS) 
      fprintf(fpout, " -DSUN_HR");
   if (OSIsWin(OS))
      fprintf(fpout, " -DGCCWIN -DUseClock");
   for (i=1; i < NISA; i++)
      if (vecexts & (1<<i))
         fprintf(fpout, " -DATL_%s", ISAXNAM[i]);
   if (Use3DNow) fprintf(fpout, " -DATL_3DNowFLOPS");
@skip   if (vecexts & (1<<ISA_3DNow))
@skip      fprintf(fpout, " -DATL_Has3DNow");
   if (ptrbits == 64)
      fprintf(fpout, " -DATL_USE64BITS");
   if (mach == IA64Itan || mach == IA64Itan2 )
      fprintf(fpout, " -DATL_MAXNREG=128");
   if (asmb != ASM_None) fprintf(fpout, " -DATL_%s", ASMNAM[asmb]);
   if (mach == IA64Itan2)
      fprintf(fpout, " -DATL_IntelIccBugs");
/* 
 * Need up update handling of apple vs. gnu gcc for altivec
 */
   if ((ISAX == ISA_AV || ISAX == ISA_VSX) && CompIsGcc(comps[DMC_]) && 
        !CompIsAppleGcc(comps[DMC_]))
      fprintf(fpout, " -DATL_AVgcc");
   fprintf(fpout, "\n\n");

   fprintf(fpout,
   "#  -------------------------------------------------------------------\n");
   fprintf(fpout,
   "#  NM is the flag required to name a compiled object/executable\n");
   fprintf(fpout,
   "#  OJ is the flag required to compile to object rather than executable\n");
   fprintf(fpout, "#  These flags are used by all compilers.\n");
   fprintf(fpout,
   "#  -------------------------------------------------------------------\n");
   fprintf(fpout, "   NM = -o\n");
   fprintf(fpout, "   OJ = -c\n\n");

   sprintf(ln, "%s/CONFIG/src/CompMake.txt", srcdir);
   DisplayFile(ln, fpout, 0);
   fprintf(fpout, "   NPROC=%d\n", ncpu);
   fprintf(fpout, "   CDEFS = $(L2SIZE) $(INCLUDES) $(F2CDEFS) $(ARCHDEFS)");
   if (cdefs) fprintf(fpout, " %s", cdefs);
   if (THREADS)
   {
      fprintf(fpout, " -DATL_NCPU=$(NPROC)");
@skip      if (OS == OSLinux || OS == OSIRIX || OS == OSOSF1 || OS == OSAIX ||
@skip          OS == SunOS) fprintf(fpout, " -DDUseSystemScope");
      if (OS == OSFreeBSD) fprintf(fpout, " -D_THREAD_SAFE -D_REENTRANT");
      if (OS == OSAIX) fprintf(fpout, " -DIBM_PT_ERROR");
      if (OS == OSIRIX) fprintf(fpout, " -D_POSIX_C_SOURCE=199506L");
      if (AntThr) fprintf(fpout, " -DATL_TRUST_ANTPT");
      else if (omp) fprintf(fpout, " -DATL_OMP_THREADS");
      if (AntThr > 1) fprintf(fpout, " -DATL_ANTOINE_THREADS");
   }
   if (delay) fprintf(fpout, " -DATL_FOPENDELAY");
   fprintf(fpout, "\n\n");
   for (i=0; i < NCOMP; i++)
   {
      fprintf(fpout, "   %s = %s\n", COMPNAME[i], comps[i]);
      if (i == F77_)
         fprintf(fpout, "   %sFLAGS = %s\n", COMPNAME[i], comps[NCOMP+i]);
      else if (i == ICC_ || i == XCC_)
         fprintf(fpout, "   %sFLAGS = $(CDEFS) %s\n", 
                 COMPNAME[i], comps[NCOMP+i]);
      else /* non-interf comps don't include CDEFS by default (added later) */
         fprintf(fpout, "   %sFLAGS = %s\n", 
                 COMPNAME[i], comps[NCOMP+i]);
   }
   fprintf(fpout, "   F77NOOPT = -O0   # turn off optimization\n");
   fprintf(fpout, "   SMAFLAGS =");
   if (smaflags) 
      fprintf(fpout, " %s", smaflags);
   fprintf(fpout, "\n   DMAFLAGS =");
   if (dmaflags) 
      fprintf(fpout, " %s", dmaflags);
   fprintf(fpout, "\n");
   fprintf(fpout, "   CKC = $(SKC)\n");
   fprintf(fpout, "   ZKC = $(DKC)\n");
   fprintf(fpout, "   sKCFLAGS = $(CDEFS) $(SKCFLAGS)\n");
   fprintf(fpout, "   dKCFLAGS = $(CDEFS) $(DKCFLAGS)\n");
   fprintf(fpout, "   cKCFLAGS = $(CDEFS) $(SKCFLAGS)\n");
   fprintf(fpout, "   zKCFLAGS = $(CDEFS) $(DKCFLAGS)\n");

   for (i=0; i < NCOMP; i++)
   {
      if (i == XCC_) continue;  /* do not accept cross-compiler */
      j = strlen(comps[i]);
      if (j >= 3 && comps[i][j-3] == 'g' && 
          comps[i][j-2] == 'c' && comps[i][j-1] == 'c')
         break;
   }
   goodgcc = (i < NCOMP) ? comps[i] : "gcc";
   fprintf(fpout, "   GOODGCC = %s", goodgcc);
   if (gccflags)
      fprintf(fpout, " %s", gccflags);
   GetGccVers(goodgcc, &i, &j, &k, &k);
   if (OS == OSOSX && j > 3)  /* need bullshit apple annoyance flag */
      fprintf(fpout, " -force_cpusubtype_ALL");
   if (OSIsWin(OS) && ptrbits != 64)  /* stop gcc breaking ABI */
      fprintf(fpout, " -mstackrealign");
   sp = GetPtrbitsFlag(OS, mach, ptrbits, goodgcc);
   if (strlen(sp) > 0)
       fprintf(fpout, " %s", sp);
   #ifdef ATL_DYLIBS
      if (!OSIsWin(OS))
         fprintf(fpout, " -fPIC");
   #endif
   fprintf(fpout, "\n");

   fprintf(fpout, "   LDFLAGS =");
   if (MachIsX86(mach))
   {
      if (OSIsWin(OS))
         fprintf(fpout, " -mi386pe");
      else
      {
         if (ptrbits == 32)
            fprintf(fpout, " -melf_i386");
         else if (ptrbits == 64)
            fprintf(fpout, " -melf_x86_64");
         if (OS == OSFreeBSD)
            fprintf(fpout, "_fbsd");
      }
   }
   if (MachIsS390(mach))
      fprintf(fpout, ptrbits == 32 ? "-m31" : "-m64");
   fprintf(fpout, "\n   F77SYSLIB = %s\n", f77lib ? f77lib : "");
   fprintf(fpout, "   BC = $(ICC)\n");
   fprintf(fpout, "   NCFLAGS = $(ICCFLAGS)\n");
   fprintf(fpout, "\n   CLINKER = $(ICC)\n   CLINKFLAGS = $(ICCFLAGS)\n");
   fprintf(fpout, "   FLINKER = $(F77)\n");
   if (strstr(comps[F77_], "mgwgfortran"))
      fprintf(fpout, "   FLINKFLAGS = $(F77FLAGS) -static\n");
   else
      fprintf(fpout, "   FLINKFLAGS = $(F77FLAGS)\n");
   fprintf(fpout, "   FCLINKFLAGS = $(FLINKFLAGS)");
   if (strstr(comps[F77_], "ifort") && !OSIsWin(OS))
      fprintf(fpout, " -nofor_main");
   if (OS == OSWinNT && ptrbits == 64)
      fprintf(fpout, "\n   ARCHIVER = $(BLDdir)/mgwar\n");
   else
      fprintf(fpout, "\n   ARCHIVER = ar\n");
   fprintf(fpout, "   ARFLAGS  = r\n");
/*
 * JF Mertens says that even x86 OS X still need ranlib for safety
 */
   if (OS == OSOSX)
      fprintf(fpout, "   RANLIB   = ranlib\n\n");
   else if (OS == OSWinNT && ptrbits == 64)
      fprintf(fpout, "   RANLIB   = $(BLDdir)/mgwranlib\n\n");
   else
      fprintf(fpout, "   RANLIB   = echo\n\n");

   fprintf(fpout, "#  -------------------------------------\n");
   fprintf(fpout, "#  tar, gzip, gunzip, and parallel make\n");
   fprintf(fpout, "#  -------------------------------------\n");
   fprintf(fpout, "   TAR    = tar\n");
   fprintf(fpout, "   GZIP   = gzip\n");
   fprintf(fpout, "   GUNZIP = gunzip\n");
   fprintf(fpout, "   PMAKE  = %s\n\n", pmake ? pmake : "$(MAKE)");
/*
 * Need to add libs to GetFlags and update GetSysLib to do this right
*/
   fprintf(fpout, "#  ------------------------------------\n");
   fprintf(fpout, "#  Reference and system libraries\n");
   fprintf(fpout, "#  ------------------------------------\n");
   fprintf(fpout, "   FBLASlib = $(LIBdir)/libf77refblas.a\n");
   fprintf(fpout, "   FLAPACKlib = ");
   if (flapack) fprintf(fpout, "%s", flapack);
   else if (lapackref) fprintf(fpout, "$(FLAdir)/lapack_$(ARCH).a");
   fprintf(fpout, "\n");
   fprintf(fpout, "   SBLASlib = $(FBLASlib)  # should be serial sysblas\n");
   fprintf(fpout, "   BLASlib = $(FBLASlib)   # should be parallel sysblas\n");
   fprintf(fpout, "   SLAPACKlib =   # set to parallel system lapack\n");
   fprintf(fpout, "   SSLAPACKlib =  # set to serial system lapack\n");
   if (THREADS)
   {
      fprintf(fpout, "   LIBS = -lpthread");
      if (OSIsWin(OS) && ptrbits == 32)
         fprintf(fpout, " -lkernel32");
   }
   else
      fprintf(fpout, "   LIBS =");
@skip   if (!OSIsWin(OS))
   fprintf(fpout, " -lm");
   fprintf(fpout, "\n\n");

   fprintf(fpout, 
   "#  --------------------------------------------------------------------\n");
   fprintf(fpout, 
   "#  Compiler names for architectural defaults and flags to atlas_install\n");
   fprintf(fpout, 
   "#  --------------------------------------------------------------------\n");
   for (i=0; i < NCOMP; i++)
   {
      sp = NewStringCopy(COMPNAME[i]);
      for (j=0; sp[j]; j++)
        sp[j] = tolower(sp[j]);
      fprintf(fpout, "   %sD = ", sp);
      free(sp);
/*
 *    Regardless of actual names, use standard gnu compiler names for defs
 */
      if (CompIsGcc(comps[i]))
      {
         if (i == F77_)
         {
            GetGccVers(comps[i], &k, &j, &k, &k);
            if (j < 4) 
               sp = NewStringCopy("g77");
            else
               sp = NewStringCopy("gfortran");
         }
         else sp = NewStringCopy("gcc");
      }
      else
      {
         sp = NameWithoutPath(comps[i]);
         if (!strncmp(sp, "ATLwin_", 7))
            sp = NewStringCopy(comps[i]+7);
      }
@skip      if (!strcmp(sp, "gcc32")) sp[3] = '\0'; /* count gcc32 as gcc */
      fprintf(fpout, "%s\n", sp);
      free(sp);
   }
   fprintf(fpout, "   INSTFLAGS = -1 %d -a %d -l %d\n\n", 
           USEDEFL1, USEARCHDEF, LATUNE);
@beginskip
   fprintf(fpout,
      "#  --------------------------------------------------------\n");
   fprintf(fpout,
      "#  ATLAS install flags (controlling architectural defaults)
   fprintf(fpout,
      "#  --------------------------------------------------------\n");
   fprintf(fpout, "   INSTFLAGS = -1 %d -a %d\n\n", USEDEFL1, USEARCHDEF);
@endskip

fprintf(fpout,
   "#  -------------------------------------------------------------------\n");
fprintf(fpout,
   "#  Dependence info for building optional external threading interfaces\n");
fprintf(fpout,
   "#  -------------------------------------------------------------------\n");
   for (i=0; i < NPREC; i++)
   {
      fprintf(fpout, "   %cextthr =", pres[i]);
@skip      if (omp)
@skip         fprintf(fpout, " %comp", pres[i]);
      if (AntThr)
         fprintf(fpout, " %cpt", pres[i]);
      fprintf(fpout, "\n");
   }
@beginskip
   fprintf(fpout, 
  "#\n# Hack to get around gcc ABI violation when using winthreads\n#\n");
   if (OS == OSWinNT && ptrbits == 32)
      fprintf(fpout, "   tstackfix = ATL_gccstackfix.o\n");
   else
      fprintf(fpout, "   tstackfix = "\n");
@endskip
   fprintf(fpout, "#  ---------------------------------------\n");
   fprintf(fpout, "#  Generic targets needed by all makefiles\n");
   fprintf(fpout, "#  ---------------------------------------\n");
   fprintf(fpout, "do_it: all\n");
   if (delay)
   {
      fprintf(fpout, "   waitfile = wfdefault\n");
      fprintf(fpout, "waitfile:\n\tcd $(BINdir) ; $(MAKE) xatlas_waitfile\n");
      fprintf(fpout, "\t$(ATLFWAIT) -s %d -f $(waitfile)\n", delay);
   }
   else fprintf(fpout, "waitfile:\n");
   if (fpout != stdout && fpout != stderr) fclose(fpout);
   return(0);
}
@ROUT atlbench
#include "atlconf.h"

/*
 * The number of results, and their ordering (this must match the file).
 */
#define NBENCH 8
#define SELKMM 0
#define GENKMM 1
#define KMM_NT 2
#define KMM_TN 3
#define KMV_N  4
#define KMV_T  5
#define KGER   6
#define MM_BIG 7
#define CLKRATE 8

char *BNCHNAMES[NBENCH] = 
   {"kSelMM", "kGenMM", "kMM_NT", "kMM_TN", "kMV_N", "kMV_T", "kGER", "BIG_MM"};

void PrintUsage(char *name, int iarg, char *flag)
{
   if (iarg) 
      fprintf(stderr, "Error around argument %d (%s)!\n", iarg, flag);
   fprintf(stderr, "USAGE: %s [flags]\n", name);
   fprintf(stderr, "   -dp <prior benchmark directory>\n");
   fprintf(stderr, "   -dc <current benchmark directory>\n");
   fprintf(stderr, "   -f <filename w/o prefix>\n");
   fprintf(stderr, "   -o <outfile> : default=stdout\n");
   exit(iarg ? iarg : -1);
}

FILE *GetFlags(int nargs, char **args, char **fname, char **currd, char **oldd)
{
   char *sp;
   FILE *fpout;
   int i;

   *fname = "PerfSumm.txt";
   *currd = "bin/INSTALL_LOG";
   *oldd = NULL;
   fpout = stdout;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'd':
         if (++i >= nargs)
            PrintUsage(args[0], i, "Out of args");
         sp = args[i];
         if (args[i-1][2] == 'p') *oldd = sp;
         else if (args[i-1][2] == 'c') *currd = sp;
         else PrintUsage(args[0], i-1, args[i-1]);
         break;
      case 'f':
         if (++i >= nargs)
            PrintUsage(args[0], i, "Out of args");
         *fname = args[i];
         break;
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i, "Out of args");
         fpout = fopen(args[i], "w");
         assert(fpout);
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (*oldd == NULL)
      fprintf(stderr, 
      "No prior benchmark directory given, no comparison will be made.\n");
   return(fpout);
}

@beginskip
long GetInt(FILE *fpin, long Default, char *spc, char *expstr)
/*
 * Gets a signed integral type from fpin.  If nothing or garbage is entered,
 * Default is returned.
 */
{
   char str[64];
   long iin;
   if (expstr) fprintf(stdout, "%sEnter %s [%d]: ", spc, expstr, Default);
   if (fgets(str, 64, fpin) == NULL) return(Default);
   if (sscanf(str, " %ld ", &iin) != 1) return(Default);
   return(iin);
}
@endskip

double RunBigMM(char pre, double clkrate, int *N)
/*
 * Calls gemmtst to find asymptotic performance.
 * RETURNS: mflop of large matmul of precision pre.
 */
{
   char cmnd[2048], res[2048];
   int i, n=1600, offset;
   double mf0, mf1;
   FILE *fpin;

   offset = (pre == 's' || pre == 'd') ? 50 : 61;
   sprintf(cmnd, "cd bin ; make x%cmmtst_big", pre);
   syschk(cmnd);
/*
 * Don't run case taking longer than 1 minute, assuming 1flop/cycle
 */
   mf0 = clkrate*1000000.0 * 60.0;
   while (((pre=='c' || pre=='z') ? 8.0 : 2.0)*n*n*n > mf0)
      n -= 200;
   n = (n >= 1200) ? n :1200;
/*
 * May fail for lack of memory, so keep reducing N until we have success
 */
   do
   {
      assert(n > 200);
      remove("big.out");
      sprintf(cmnd, "./bin/x%cmmtst_big -n %d -Test 0 > big.out\n", pre, n);
      n -= 200;
/*      fprintf(stderr, "cmnd='%s'", cmnd); */
   }
   while(system(cmnd));
   *N = n + 200;
/*
 * This section parses xdmmtst output to get mflop; note that it is fragile,
 * so if we change the formatting of xdmmtst, we must change this!
 */
   fpin = fopen("big.out", "r");
   assert(fpin);
/*
 * Skip headers/blank lines, get 1st line of output
 */
   for (i=0; i < 5; i++)
      assert(fgets(res, 2048, fpin));
   mf0 = atof(res+offset);
   fprintf(stderr, "res+off=%s\n", res+offset);
   assert(fgets(res, 2048, fpin));
   mf1 = atof(res+offset);
   fclose(fpin);
   fprintf(stderr, "BIG_MM N=%d, mf=%.2f,%.2f!\n", *N, mf0, mf1);
   return((mf0 >= mf1) ? mf0 : mf1);
}

double **ReadBenchmarks(char *dir, char *basename)
/*
 * Allocates a benchmark array with 4 (one for each precision) vectors of
 * NBENCH+1 length.  The MM_BIG element may not be present, in which case it is
 * filled in as 0. The extra element is the clock rate.
 */
{
   char ln[2048];
   char pre[4] = {'s', 'c', 'd', 'z'};
   int i, j, RECOMPUTE=0, N;
   FILE *fpin;
   double *mf, **res;

   if (dir == NULL || basename == NULL)
      return(NULL);
/*
 * If no files exist, return NULL
 */
   for (fpin=NULL, i=0; i < 4 && !fpin; i++)
   {
      sprintf(ln, "%s/%c%s", dir, pre[i], basename);
      fpin = fopen(ln, "r");
   }
   if (!fpin)
      return(NULL);
   fclose(fpin);

   res = malloc(sizeof(double*)*4);
   assert(res);
   for (i=0; i < 4; i++)
   {
      res[i] = mf = malloc(sizeof(double)*(NBENCH+1));
      assert(mf);
      sprintf(ln, "%s/%c%s", dir, pre[i], basename);
      fpin = fopen(ln, "r");
      if (!fpin)
      {
         for (j=0; j <= NBENCH; j++)
            mf[j] = 0.0;
         continue;
      }
      assert(fgets(ln, 2048, fpin));
      assert(ln[10] == '=');
      mf[CLKRATE] = atof(ln+11);
      if (mf[CLKRATE] < 100) 
         RECOMPUTE = 8;
      else RECOMPUTE = 0;
      if (i)
         mf[CLKRATE] = res[i-1][CLKRATE];
      else
      {
         while (mf[CLKRATE] < 100.0)
            mf[CLKRATE] = GetInt(stdin, 0, "", "Clock rate in Mhz");
      }
/*
 *    Skip table headers
 */
      assert(fgets(ln, 2048, fpin));
      assert(fgets(ln, 2048, fpin));
/*
 *    Read mandatory NBENCH-1 elements of table
 */
      for (j=0; j < NBENCH-1; j++)
      {
         assert(fgets(ln, 2048, fpin));
         mf[j] = atof(ln+RECOMPUTE);
         if (RECOMPUTE)
            mf[j] = (mf[j]/mf[CLKRATE])*100.0;
      }
/*
 *    If large-case MM in file, read as normal
 */
      if (fgets(ln, 2048, fpin) != NULL)
      {
         mf[j] = atof(ln+RECOMPUTE);
         if (RECOMPUTE)
            mf[j] = (mf[j]/mf[CLKRATE])*100.0;
      }
/*
 *    If large-case MM not in file, must run it, and then add to file
 */
      else
      {
         fclose(fpin);
         mf[j] = RunBigMM(pre[i], mf[CLKRATE], &N);
         sprintf(ln, "%s/%c%s", dir, pre[i], basename);
         fpin = fopen(ln, "a");
         assert(fpin);
         fprintf(fpin, "%7.1f %10.1f  N=%d GEMM\n", 
                 (mf[j]/mf[CLKRATE])*100.0, mf[j], N);
         mf[j] = (mf[j]/mf[CLKRATE])*100.0;
      }
      fclose(fpin);
   }
   return(res);
}

void PrintNameDefs(FILE *fpout)
{
   fprintf(fpout, 
"\nThe times labeled Reference are for ATLAS as installed by the authors.\n");
   fprintf(fpout, "NAMING ABBREVIATIONS:\n");
   fprintf(fpout, "   kSelMM : selected matmul kernel (may be hand-tuned)\n");
   fprintf(fpout, "   kGenMM : generated matmul kernel\n");
   fprintf(fpout, "   kMM_NT : worst no-copy kernel\n");
   fprintf(fpout, "   kMM_TN : best no-copy kernel\n");
   fprintf(fpout, "   BIG_MM : large GEMM timing (usually N=1600); estimate of asymptotic peak\n");
   fprintf(fpout, "   kMV_N  : NoTranspose matvec kernel\n");
   fprintf(fpout, "   kMV_T  : Transpose matvec kernel\n");
   fprintf(fpout, "   kGER   : GER (rank-1 update) kernel\n");
   fprintf(fpout, 
           "Kernel routines are not called by the user directly, and their\n");
   fprintf(fpout, "performance is often somewhat different than the total\n");
   fprintf(fpout, "algorithm (eg, dGER perf may differ from dkGER)\n\n");
}

void PrintComparison(FILE *fpout, double **oldres, double **newres)
{
   int i, j, k;

   PrintNameDefs(fpout);
   fprintf(fpout, "\nReference clock rate=%dMhz, new rate=%dMhz\n",
           (int) oldres[0][NBENCH], (int) newres[0][NBENCH]);
   fprintf(fpout, 
      "   Refrenc : %% of clock rate achieved by reference install\n");
   fprintf(fpout, 
      "   Present : %% of clock rate achieved by present ATLAS install\n\n");

   fprintf(fpout, "                    single precision                  double precision\n");
   fprintf(fpout, "            ********************************   *******************************\n");
   fprintf(fpout, "                  real           complex           real           complex\n");
   fprintf(fpout, "            ---------------  ---------------  ---------------  ---------------\n");
   fprintf(fpout, "Benchmark   Refrenc Present  Refrenc Present  Refrenc Present  Refrenc Present\n");
   fprintf(fpout, "=========   ======= =======  ======= =======  ======= =======  ======= =======\n");
   for (i=0; i < NBENCH; i++)
   {
      if (i == KMV_N) j = MM_BIG;
      else if (i > KMV_N) j = i-1;
      else j = i;
      fprintf(fpout, "%8.8s  ", BNCHNAMES[j]);
      for (k=0; k < 4; k++)
         fprintf(fpout, " %8.1f %7.1f", oldres[k][j], newres[k][j]);
      fprintf(fpout, "\n");
   }
}

void PrintSum(FILE *fpout, double **res)
{
   int i, j, k;

   PrintNameDefs(fpout);
   fprintf(fpout, "\nClock rate=%dMhz\n", (int) res[0][NBENCH]);

   fprintf(fpout, 
           "               single precision        double precision\n");
   fprintf(fpout, 
           "            *********************    ********************\n");
   fprintf(fpout, 
           "               real      complex       real      complex\n");
   fprintf(fpout, 
           "Benchmark   %%   Clock   %%   Clock   %%   Clock   %%   Clock\n");
   fprintf(fpout, 
           "=========   =========   =========   =========   =========\n");
   for (i=0; i < NBENCH; i++)
   {
      if (i == KMV_N) j = MM_BIG;
      else if (i > KMV_N) j = i-1;
      else j = i;
      fprintf(fpout, "%8.8s  ", BNCHNAMES[j]);
      for (k=0; k < 4; k++)
         fprintf(fpout, " %9.1f ", res[k][j]);
      fprintf(fpout, "\n");
   }
}

int main(int nargs, char **args)
/*
 * This program benchmarks an ATLAS install, and compares it against a prior
 * install, if such a prior install exists.  If necessary, it runs 
 * gemmtst to figure out asymptotic performance of GEMM.
 */
{
   char *fname, *currd, *oldd;
   FILE *fpout;
   double **refres=NULL, **newres;

   fpout = GetFlags(nargs, args, &fname, &currd, &oldd);
   newres = ReadBenchmarks(currd, fname);
   assert(newres);
   refres = ReadBenchmarks(oldd, fname);
   if (refres)
      PrintComparison(fpout, refres, newres);
   else PrintSum(fpout, newres);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
   return(0);
}
@ROUT mgwcmp
@extract -b @(topd)/cw.inc lang=c -define cwdate 2011
/*
 * This is a BFI wrapper around MinGW compilers/ar for use in cygwin build
 * framework.  Its only job is to substutute 'c:' for 'cygdrive/c' (where
 * 'c' can be any single letter) in all paths (except that of the
 * compiler itself).
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#define Mstr2(m) # m
#define Mstr(m) Mstr2(m)
#ifndef DEFDF
   #ifdef WRAP_FORTRAN
      #define DEFDF /usr/bin/x86_64-w64-mingw32-gfortran.exe
   #elif defined(WRAP_AR)
      #define DEFDF /usr/bin/x86_64-w64-mingw32-ar.exe
   #else
      #define DEFDF /usr/bin/x86_64-w64-mingw32-gcc-4.5.3.exe
   #endif
#endif

int cygdrivesub(char *ln)
/*
 * replaces /cygdrive/c/ with c://, returns change in string length
 */
{
   char *sp;
   int i=0;

/*
 * 01234567890
 * /cygdrive/L...
 */
   while(sp = strstr(ln, "/cygdrive/"))
   {
      i++;
      sp[0] = sp[10];
      sp[1] = ':';
      sp[2] = '/';
      sp += 3;
      while (*sp = sp[8]) sp++;
   }
   return(i*8);
}

#ifdef DEBUG
   #define system SYSTEM
   int system(char *ln)
   {
      fprintf(stdout, "%s\n", ln);
      return(0);
   }
#endif

char *GetLongerString(char *old, int len)
{
   char *sp;

   assert(len);
   sp = malloc(sizeof(char)*(len+1));
   assert(sp);
   if (old)
   {
      assert(len > strlen(old));
      strcpy(sp, old);
      free(old);
   }
   return(sp);
}

int main(int nargs, char **args)
{
   char *ln;
   int i, j, k, lnlen=0, ierr, ii;

/*
 * The path to the compiler does not substitute c:/, since it is cygwin
 * handling it, not MinGW
 */
   lnlen = (strlen(Mstr(DEFDF))+2)*2;
   ln = GetLongerString(NULL, lnlen);
   ii = sprintf(ln, "%s", Mstr(DEFDF));

/*
 * Just paste all commandline arguments together, getting rid of // from make
 * and then substituting c:// for any /cygdrive/c/
 */
   for (i=1; i < nargs; i++)
   {
      char *sp;
      j = strlen(args[i]) + 1;
      if (lnlen < ii+j)
      {
         lnlen = (lnlen+j)*2;
         ln = GetLongerString(ln, lnlen);
      }
      ln[ii++] = ' ';
      strcpy(ln+ii, args[i]);
/*
 *    ATLAS makefiles often put in // by accident, which is no problem under
 *    Unix, but means something special in Windows.  Therefore replace all
 *    // with / before doing cygdrivesub
 */
      while (sp = strstr(ln+ii, "//"))
      {
         strcpy(sp, sp+1);
         j--;
      }
      j -= cygdrivesub(ln+ii);   /* sub c:// for /cygdrive/c */
      ii += j - 1;
   }
//   fprintf(stdout, "%s", ln);
   ierr = system(ln);
   if (ierr)
      fprintf(stderr, "\nMINGW COMPILER WRAP '%s' GAVE ERROR FOR `%s'\n\n", 
              args[0], ln);
   return(ierr);
}

@ROUT wincc winar winf77
@extract -b @(topd)/gen.inc what=cw @(cw99)
#include <stdio.h>
#include <stdlib.h>
@ROUT wincc winf77
#include <string.h>
#include <assert.h>
@ROUT wincc winar winf77
#define Mstr2(m) # m
#define Mstr(m) Mstr2(m)
@ROUT wincc
#ifndef DEFDF
/*   #define DEFDF "c:/Program Files/Microsoft Visual Studio/VC/BIN/CL.EXE" */
   #define DEFDF CL.EXE
#endif
@ROUT winf77
#ifndef DEFDF
   #define DEFDF IFORT.EXE
#endif
@ROUT wincc winar winf77

int slashdrivesub(char *ln)
/*
 * replaces \\c\ with c:\, returns change in string length
 * this version required for older cygwins
 */
{
   char *sp, *lp=ln, ctmp;
   int nrep=0;
   do
   {
      sp = strstr(lp, "\\\\");
      if (sp && strlen(sp) > 3)
      {
         if (sp[2] == 'a' || sp[2] == 'b' || sp[2] == 'c' || sp[2] == 'd' ||
             sp[2] == 'e' || sp[2] == 'f' || sp[2] == 'g' || sp[2] == 'h')
         {
            if (sp[3] == '\\')
            {
               ctmp = sp[2];
               sp[0] = sp[2];
               sp[1] = ':';
               sp[2] = '\\';
               for (lp=sp+3; *lp = lp[1]; lp++);
               lp = sp + 3;
               nrep++;
            }
            else lp = sp + 2;
         }
         else lp = sp + 2;
      }
      else lp = sp + 2;
   }
   while (sp);
   return(-nrep);
}

int cygdrivesub(char *ln)
/*
 * replaces \cygdrive\c\ with c:\, returns change in string length
 * this version works cygnus version 1.1.0
 */
{
   char *sp;
   int i=0;

   while(sp = strstr(ln, "\\cygdrive\\"))
   {
      i++;
      sp[0] = sp[10];
      sp[1] = ':';
      sp[2] = '\\';
      sp += 3;
      while (*sp = sp[9]) sp++;
   }
   return( slashdrivesub(ln) - (i*9) );
}

void slashsub(char *ln)
/* 
 * changes forward slash of unix to backslash of windoze
 */
{
   int i;
   for (i=0; ln[i]; i++) if (ln[i] == '/') ln[i] = '\\';
}

void doto2dotobj(char *ln)
/*
 * changes all occurences of unix's .o extension to windoze-friendly obj
 */
{
   char ln2[4096];
   int i, j=0;
   for (i=0; ln[i]; i++)
   {
      ln2[j++] = ln[i];
      if (ln[i] == '.' && ln[i+1] == 'o' && isspace(ln[i+2]))
      {
         ln2[j] = 'o';
         ln2[j+1] = 'b';
         ln2[j+2] = 'j';
         ln2[j+3] = ln[i+2];
         j += 4;
         i += 2;
      }
   }
   ln2[j] = '\0';
   sprintf(ln, "%s", ln2);
}

@ROUT wincc winf77
#ifdef DEBUG

#define system SYSTEM
int system(char *ln)
{
   fprintf(stdout, "%s\n", ln);
   return(0);
}

#endif

typedef struct wOrDs WORDS;
struct wOrDs
{
   char *word;
   WORDS *next;
};

void KillWords(WORDS *wp)
{
   WORDS *wpn;

   while (wp)
   {
      free(wp->word);
      wpn = wp->next;
      free(wp);
      wp = wpn;
   }
}

WORDS *AddWord(WORDS *wbas, char *wrd, int wlen)
{
   WORDS *wp;
   int i;

   wp = malloc(sizeof(WORDS));
   assert(wp);
   wp->word = malloc( (wlen+1) * sizeof(char) );
   for (i=0; i != wlen; i++) wp->word[i] = wrd[i];
   wp->word[i] = '\0';
   wp->next = wbas;
   return(wp);
}

WORDS *AddFile(WORDS *wbase, char *fnam)
{
   int i, len;
   len = strlen(fnam);
   assert(len > 2);
@ROUT wincc
   if (fnam[len-1] = 'c' && fnam[len-2] == '.');
@ROUT winf77
   if (fnam[len-1] = 'f' && fnam[len-2] == '.');
@ROUT wincc winf77
   {
      for (i=len-3; i > 0; i--)
      {
         if (fnam[i] == ' ' || fnam[i] == '/' || fnam[i] == '\\')
         {
            i++;
            break;
         }
      }
      wbase = AddWord(wbase, fnam+i, len-i-2);
   }
   return(wbase);
}

int RenameFiles(WORDS *wbase)
{
   WORDS *wp;
   char ln[4096];

   for (wp=wbase; wp; wp = wp->next)
   {
      sprintf(ln, "MOVE %s.obj %s.o\n", wp->word, wp->word);
      fprintf(stdout, "%s", ln);
      if (system(ln)) return(1);
   }
   return(0);
}

int NeedsQuotes(char *str)
/*
 * This func added 07/20/07, as cygwin now requires us to put quotes
 * around any path containing windows \ path character or space.
 * Note that you need to compile prog without -mno-cygwin.  With
 * -mno-cygwin, seem to get same shell as when compiled with cl, which
 * seems to not work at all
 * RETURNS: 1 if need quotes, 0 else
 */
{
   int i, k;
   return(0);
   for (i=0; str[i]; i++)
   {
       if (str[i] == '\\') return(1);
       else if (str[i] == '/') return(2);
       else if (str[i] == ' ')
       {
          for (k=0; str[k]; k++)
             if (str[k] != ' ') return(4);
       }
   }
   return(0);
}

int main(int nargs, char **args)
{
   char ln[4096], *cptr=NULL;
   int i, j, k, ierr, ic, ii;
   int COMP=0, RENAME=0;
   WORDS *wbase=NULL;

@skip   ic = sprintf(ln, "\"%s\" /iface:cref ", DEFDF);
   ic = sprintf(ln, "\"%s\" ", Mstr(DEFDF));
@skip   assert(ln[2] == ':');
@skip   ln[2] == ln[1];
@skip   ln[1] = '/';
   slashsub(ln);
@ROUT winf77
   ic += sprintf(ln+ic, "/iface:cref ");
@ROUT wincc winar winf77

@skip   ic = sprintf(ln, "\"c:\\Program Files\\DevStudio\\DF\\BIN\\DF.EXE\" /iface:cref ");
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] == '-')  /* compiler flag */
      {
         if (args[i][1] == 'o') /* handle renaming, guess exe not .obj */
         {
            RENAME = 1;
            k = strlen(args[++i]);
            if (NeedsQuotes(args[i]))
               j = sprintf(ln+ic, "'/Fe%s.exe' ", args[i]);
            else
               j = sprintf(ln+ic, "/Fe%s.exe ", args[i]);
            cptr = ln+ic;
            slashsub(ln+ic+3);
         }
         else if (args[i][1] == 'l') /* library to link against */
         {
            if (NeedsQuotes(args[i]))
               j = sprintf(ln+ic, "'/link:DEFAULTLIB:%s'", &args[i][2]);
            else
               j = sprintf(ln+ic, "/link:DEFAULTLIB:%s", &args[i][2]);
            slashsub(ln+ic+17);
         }
         else
         {
            if (args[i][1] == 'c') COMP=1;
            if (NeedsQuotes(args[i]))
            {
               j = sprintf(ln+ic, "'/%s' ", &args[i][1]);
               slashsub(ln+ic+2);
            }
            else
            {
               j = sprintf(ln+ic, "/%s ", &args[i][1]);
               slashsub(ln+ic+1);
            }
         }
      }
      else  /* must be files, not flags */
      {
         if (NeedsQuotes(args[i]))
         {
            ii = 1;
            j = sprintf(ln+ic, "'%s' ", args[i]);
         }
         else
         {
            ii = 0;
            j = sprintf(ln+ic, "%s ", args[i]);
         }
@ROUT wincc
         if (j+ii > 3 && ln[ic+j-2-ii] == 'c' && ln[ic+j-3-ii] == '.')
@ROUT winf77
         if (j+ii > 3 && ln[ic+j-2-ii] == 'f' && ln[ic+j-3-ii] == '.')
@ROUT wincc winf77
         { /* add this file to list of files to be moved to .o */
            wbase = AddFile(wbase, args[i]);
         }
         slashsub(ln+ic);
      }
      ic += j;
   }
   sprintf(ln+ic, "\n");
   cygdrivesub(ln);
   if (RENAME && COMP) /* gotta use different rename command if not exe */
   {
      cptr = strstr(ln, "/Fe");
      assert(cptr);
      cptr[2] = 'o';
      cptr = strstr(cptr, ".exe");
      assert(cptr);
      cptr[0] = cptr[1] = cptr[2] = cptr[3] = ' ';
   }
   fprintf(stdout, "%s", ln);
   ierr = system(ln);
   if (!ierr && COMP && !RENAME) /* rename the .obj to .o */
      ierr = RenameFiles(wbase);
   KillWords(wbase);
   return(ierr);
}
@ROUT atlas_sys.h
#ifndef ATLAS_SYS_H
   #define ATLAS_SYS_H
/*
 * This file contains routines to interact with the system (as in the C 
 * `system' command), and related I/O
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

static char *NewStringCopy(char *old)
/*
 * RETURNS: newly allocates string containing copy of string old
 * NOTE: old is not modified.
 */
{
   char *new;
   new = malloc(sizeof(char)*(strlen(old)+1));
   strcpy(new, old);
   return(new);
}

static char *NewAppendedString(char *old, char *app)
/*
 * RETURNS: string holding : old + app
 * NOTE: frees old string after copy
 */
{
   char *new;
   if (!old)
   {
      new = malloc(sizeof(char)*(strlen(app)+1));
      assert(new);
      strcpy(new, app);
   }
   else
   {
      new = malloc(sizeof(char)*(strlen(old) + strlen(app)+1));
      assert(new);
      strcpy(new, old);
      strcat(new, app);
      free(old);
   }
   return(new);
}

static char *NewSpaceAppendedString(char *old, char *app)
/*
 * RETURNS: string holding : old + " " + app
 * NOTE: frees old string after copy
 */
 
{
   char *new;
   if (!old)
   {
      new = malloc(sizeof(char)*(strlen(app)+1));
      assert(new);
      strcpy(new, app);
   }
   else
   {
      new = malloc(sizeof(char)*(strlen(old) + strlen(app)+2));
      assert(new);
      strcpy(new, old);
      strcat(new, " ");
      strcat(new, app);
      free(old);
   }
   return(new);
}

static char *ATL_fgets(char *sout, int *plen, FILE *fpin)
/*
 * This routine returns a pointer to a single line of of file fpin.
 * If the size-len string sout is long enough to hold the file's line,
 * then sout will be the return value.  Otherwise sout will be freed and
 * a new string will be returned.  
 * Upon EOF/error: sout is de-allocated, *len=0, & NULL is returned;
 * *len is the length of sout in input, and of the returned string on output.
 */
{
   int len = *plen;
   if (!sout || len < 1)
   {
      *plen = len = 128;
      sout = malloc(len*sizeof(char));
      assert(sout);
   }
/*
 * See if there is a line left in file
 */
   if (fgets(sout, len, fpin))
   {
      int i;
      for (i=0; sout[i]; i++);
      assert(i > 0);
      if (sout[i-1] == '\n')    /* if this is complete line */
         return(sout);          /* we are done, return it */
/*
 *    Continue doubling string length until we can fit the whole string
 */
      while (sout[i-1] != '\n')
      {
         char *sp;
         int len0 = len;

         *plen = (len += len);
         sp = malloc(len*sizeof(char));
         assert(sp);
         strcpy(sp, sout);
         free(sout);
         sout = sp;
         sp += i;
         if (!fgets(sp, len0, fpin))
            return(sout);
         for (; sout[i]; i++);
      }
      return(sout);

   }
   else
   {
      *plen = 0;
      free(sout);
   }
   return(NULL);
}

static char *ATL_fgets_CWS(char *sout, int *plen, FILE *fpin)
/*
 * This routine returns a pointer to a single line of of file fpin.
 * It then compresses the whitespace in the line for ease of parsing:
 * (1) The first character in the line is non-whitespace
 * (2) The last character in the line is non-whitespace
 * (3) Any whitespace string of 1 or more ws chars is replaced with 1 ' '
 * (4) If the entire line is whitespace, get another until EOF or non-ws
 * If the size-len string sout is long enough to hold the file's line,
 * then sout will be the return value.  Otherwise sout will be freed and
 * a new string will be returned.  
 * Upon EOF/error: sout is de-allocated, *len=0, & NULL is returned;
 * *len is the length of sout in input, and of the returned string on output.
 */
{
   int i, j;
   char *sp;
/* 
 * Find the end of any preceding whitespace line; if the whole line is 
 * whitespace, keep getting lines until we've got one with some non-ws chars
 */
   do
   {
      sout = ATL_fgets(sout, plen, fpin);
      if (!sout)
         return(NULL);
      for (i=0; isspace(sout[i]); i++);
   }
   while (sout[i] == '\0');
/*
 * Now, go through line, replacing all whitespace with single ' '
 */
   for (sp=sout+i,j=0; sp[j]; j++)
   {
      if (isspace(sp[j]))
      {
         sout[j] = ' ';
         while (isspace(sp[j])) sp++;
         sp--;
      }
      else
         sout[j] = sp[j];
   }
/*
 * Shave off any trailing ws (can only be one due to above)
 */
   if (isspace(sout[j-1]))
      sout[j-1] = '\0';
   else
      sout[j] = '\0';
   return(sout);
}

static char *ATL_tmpnam(void)
{
   static char tnam[L_tmpnam];
   static char FirstTime=1;
   if (FirstTime)
   {
      FirstTime = 0;
      assert(tmpnam(tnam));
   }
   return(tnam);
}

FILE *atlsys(char *targ, char *cmnd, int verb, int IgnoreErr)
/*
 * Executes command cmnd, returns open ("r" mode) file stream to output of 
 * command.  If IgnoreErr is 0, then return NULL on error.
 */
{
   char *tnam, *sp;
   int i;
   FILE *output=NULL;

   tnam = ATL_tmpnam();
   if (targ)
   {
      i = strlen(targ) + strlen(cmnd) + strlen(tnam) + 24;
      sp = malloc(i*sizeof(char));
      assert(sp);
      sprintf(sp, "ssh %s \"%s\" > %s 2>&1 \n", targ, cmnd, tnam);
   }
   else
   {
      i = strlen(cmnd) + strlen(tnam) + 16;
      sp = malloc(i*sizeof(char));
      assert(sp);
      sprintf(sp, "%s > %s 2>&1\n", cmnd, tnam);
   }
   i = system(sp);
   if (i && verb)
   {
      fprintf(stderr, "\nierr=%d in command='%s'!\n\n", i, cmnd);
      if (verb > 1)
      {
         fprintf(stderr, "OUTPUT:\n=======\n");
         sprintf(sp, "cat %s", tnam);
         system(sp);
      }
   }
   if (!i || IgnoreErr)
      output = fopen(tnam, "r");
   return(output);
}

char *atlsys_L1(char *targ, char *cmnd, int verb, int CWS)
/*
 * Executes system(cmnd), returns 1st line as allocated string.  Returns NULL
 * on error.
 */
{
   FILE *fp;
   char *ln=NULL;
   int len=0;

   fp = atlsys(targ, cmnd, verb, 0);
   if (fp)
   {
      if (CWS)
         ln = ATL_fgets_CWS(ln, &len, fp);
      else
         ln = ATL_fgets(ln, &len, fp);
      fclose(fp);
   }
   return(ln);
}
#endif
