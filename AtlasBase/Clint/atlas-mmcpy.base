@ROUT storage.idx scopy.idx dcopy.idx ccopy.idx zcopy.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
@ROUT storage.idx
# This file indexes the user-supplied storage schemes, and has the following
# format:
# The file has the following format (default values in []):
# ID=<id> FLAG=<bitfield> BLKSZF='iexp' EXTELTF='iexp'
# ID must be a unique >100 number identifying the storage scheme.  A copy
#    routine with a matching STGID must be found for both copy directions
#    in the appropriate [s,c,d,z]blkcpy.idx types.  The storage IDs that
#    are so far in use by ATLAS itself (<100) are:
#      0: access major storage as used in generator, details in struct
#      1: access major (unvectorized or m-vec) storage for A or B
#      2: access major (unvectorized or m-vec) storage for C
#      3: K-vectorized access major storage for A or B
#      4: K-vectorized access major storage for C
#      5: block major (ATLAS 3.10 or older code gen support)
# 'iexp': must contain in '' a valid ANSI C integer expression which computes
#         the indicated storage using only constants and the key-specific
#         variables.
# BLKSZF [((M+mu-1)/mu)*((N+nu-1)/nu)*mu*nu]
#        must contain in '' a valid ANSI C integer expression which computes
#        iexp computes the number of elements to store one block using this
#        storage pattern.  ATLAS assumes real & imag components stored 
#        separately, so complex size should be half of total size.
#        The only variables that can be used will be chosen by the search after
#        tuning and passed to a function with the following prototype:
#           int getsz(int M, int N, int mu, int nu, int vlen);
#        to allow ATLAS to allocate storage for an individual block. j
#        The expression may use the following variables, in addition
#        to any constants (these args themselved might be constants for some
#        storage formats):
#          M : number of rows chosen for block factor
#          N : number of cols chosen for block factor
#         mu : unroll&jam chosen for M dim
#         nu : unroll&jam chosen for N dim
#       vlen : length of vectorization employed
# EXTELTF: [4*mu*nu]
#          how many elements must be allocated past the end of allocated
#          block memory so that advanced loads don't seg fault.  This number
#          should be small.  The generated size function will have prototype:
#            int getsz(int mu, int nu, int vlen);
#
@ROUT scopy.idx dcopy.idx ccopy.idx zcopy.idx
# This file indexes the user-supplied copy routines for the storage schemes
# indexed in storage.ids, and has the following format (non-mandatory
# keys show the default in []):
# ID=<id> STGID=<stgid> CBLK=[0,1] TOBLK=[0,1] TRANS=[0,1] CONJ=[0,1] \
#    MU=<mu> NU=<nu> VLEN=<vlen> ROUT='rt' AUTH='name' \
#    COMP='gcc' CFLAGS='flags' ALPHA=lst BETA=lst
# ID: Mandatory.  Unique (in this file only) int >= 0.  
# STGID: Mandatory.  Number >0 matching and ID in storage.idx.  Predefined:
#    0: access major, scope TOBLKCBLK,VLEN,KVEC to determine what type
#    X: user defined type
# TOBLK: Mandatory. 
#         0: copies from STGID block storage to column-major
#         1: copies from column-major to STGID block storage
# MU/NU: [0] unrolling along rows/cols
# TRANS: [n] Needed only for A/B storage, indicates transpose being done:
#    N: cols of matrix stored contiguously, rows strided (col-major)
#    T: rows of matrix stored contiguously, cols strided (row-major)
# ALPHA: mandatory.  What alpha cases handled by kern.  For A/B, full list
#        is 1,N,X, for C it is 0,1,N,X.
# BETA: mandatory for C ignored for A/B.  Full list is 0,1,N,X.
#
# NOTE: for a storage format to be used by ATLAS, enough copy funcs must
#       be supplied for use, and the number required varies by whether the
#       format is for GEMM's A/B or C matrix:
#       A&B: TOBLK=1 and for real TRANS=N&T, cplx TRANS=N&T&C&H
#            TOBLK=0 must be present for testing & custom uses.
#       C  : TOBLK=0 required. TOBLK=1 needed for testing & custom uses.
#
@ROUT scopy.idx dcopy.idx
ID=1 STGID=0 CBLK=1 TOBLK=0 MU=12 NU=4 ALPHA=X BETA=X \
     ROUT='ATL_cpammC12x4_aXbX.c' AUTH='R. Clint Whaley'
ID=2 STGID=0 CBLK=1 TOBLK=0 MU=12 NU=4 ROUT='ATL_cpammC12x4_aXbX.c' \
     AUTH='R. Clint Whaley' ALPHA=X BETA=X COMP='gcc' CFLAGS='-O2 -mfpmath=387'
@ROUT cptst.c
/* 
 * This is a sanity check that takes a known-good copy implementation in
 * CPK_GOOD, and one to test in CPK_TEST.  It then applies these routines
 * on duplicate matrices, and looks for errors greater than expected due to
 * fp arithmetic.  This version specialized for col-major to blk copies.
 */
void cpyblksN(const int mb, const int nb, const size_t M, const size_t N, 
              SCALAR alpha, TYPE *A, size_t lda, TYPE *B, size_ldb, TYPE *wrk)
/*
 * B <-- alpha*A; A&B both MxN, copy by blocks
 */
{
   const size_t nmblks=M/mb, Mb=nmblks*mb, mr=M-Mb;
   const size_t nnblks=N/nb, Nb=nnblks*nb, nr=N-Nb;
   size_t i, j;
   const int NB=nb SHIFT;
   #ifdef TCPLX
      TYPE ralpha[2];
   #else
      TYPE ralpha = ATL_rone / alpha;
   #endif
   #ifdef TCPLX
      Mjoin(PATL,cplxinvert)(1, alpha, 1, ralpha, 1);
   #endif

   for (j=0; j < Nb; j += nb, A += lda*NB, B += ldb*NB)
   {
      for (i=0; i < Mb; i += mb)
      {
         mycpyN(mb, nb, alpha, A+(i SHIFT), lda, wrk);
         myrcpyN(mb, nb, ralpha, B+(i SHIFT), ldb, wrk);
      }
   }
}
int cntErr(int verb, int M, int N, TYPE *A, size_t lda, TYPE *E, size_t lde, 
           TYPE tol)
{
   int j, nerr=0;
   for (j=0; j < N; j++, A += lda SHIFT, E += lde SHIFT)
   {
      for (i=0; i < M; i++)
      {
         diff = A[i] - E[i];
         if (diff > tol)
         {
            
         }
      }
   }
}
int main(int nargs, char **args)
{
   int mb=28, nb=36, lda, m=27, n=33, N=nb+4;
   int lda=mb+55;
   size_t szA, szW, csz, lda=mb+55, lda2, i;
   #ifdef TCPLX
      TYPE alpha[2]={ATL_rone, ATL_rzero}, beta[2]={ATL_rone, ATL_rzero};
   #else
      TYPE alpha=ATL_rone, beta=ATL_rone;
   #endif
   TYPE *A, *G, *T;
   char *cp;

   lda2 = lda SHIFT:
   sz = N*lda2;
   A = malloc(sz*sizeof(TYPE))
   assert(A);
   for (i=0; i < sz; i++)
      A[i] = i;
   szW = mb * nb;
   csz = 2*(szW SHIFT)*sizeof(TYPE) + 3*ATL_Cachelen;
   cp = malloc(2*csz);
   assert(cp);
   cp = (char*)w;
   for (i=0; i < 2*csz; i++)
      cp[i] = 0xFF;
   T = ATL_AlignPtr(cp) + ATL_Cachelen;
   G = (TYPE*) (((char)T) + csz);

}
@ROUT cpysearch
#include "atlas_cpparse.h"
#include "atlas_cptesttime.h"
#include "atlas_mmparse.h"
#include "atlas_mmtesttime.h"
#include "atlas_mmgen.h"

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -m [c,t,n] : matrix to copy\n");
   fprintf(stderr, "   -d [I,F] : copy Into or From block\n");
   fprintf(stderr, "   -v <verb> : set verbosity (1)\n");
   fprintf(stderr, "   -a [0,1,-1,2] : alpha to time, 2 means X\n");
   fprintf(stderr, "   -b [0,1,-1,2] : beta  to time, 2 means X\n");
   fprintf(stderr, 
      "   -K <file> : non-gemm kern support; repeat for multiple\n");
   exit(ierr ? ierr : -1);
}

ATL_mmnode_t *GetFlags
   (int nargs, char **args, int *VERB, int *FLAG, int *MINSZ, ATL_mmnode_t **KB)
/*
 * RETURNS: list of all kerns/blk factors to tune copies for
 */
{
   ATL_mmnode_t *mb, *mp;
   char pre='d', mat='C', dir='I', ta;
   int i, ibe=1, ial=1, k, n;

   *KB = NULL;
   *VERB = 0;
   *MINSZ = 24*24;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 'm':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        mat = toupper(args[i][0]);
        if (mat == 'N')
        {
           ta = mat;
           mat = 'A';
        }
        else if (mat == 'T')
        {
           ta = mat;
           mat = 'A';
        }
        else 
           assert(mat == 'C');
        break;
      case 'd':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        dir = toupper(args[i][0]);
        assert(dir == 'I' || dir == 'F');
        break;
      case 'K':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        if (!(*KB))
           *KB = ReadMMFile(args[i]);
        else
        {
           mp = ATL_LastMMNode(*KB);
           mp->next = ReadMMFile(args[i]);
        }
        break;
      @multidef iv ial ibe
      @whiledef ch a    b
      case '@(ch)':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         @(iv) = atoi(args[i]);
         break;
         @undef iv
      @endwhile
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   i = CopyEncode(pre, dir, mat, ta);
   *FLAG = CopyEncodeScal(i, ial, ibe);
   mb = ReadMMFileWithPath(pre, "res", "geAMMRES.sum");
   mp = ATL_LastMMNode(mb);
   mp->next = ReadMMFileWithPath(pre, "res", "rkAMMRES.sum");
   assert(mb);
/*
 * Timing for copy needs to be MOVC, dont move A or B
 */
   for (mp=mb; mp; mp=mp->next)
   {
      mp->flag = (mp->flag & (~MMF_MVSET)) | MMF_MVC;
   }
   return(mb);
}

unsigned long GetRep(unsigned long reps, unsigned int mb, unsigned int nb)
{
   double ratio;
   unsigned long nrep;
   ratio = 16.0 / (((double)mb)*nb);
   nrep = reps*ratio;
   nrep = (nrep > 0) ? nrep : 1;
   return(nrep);
}

void DoHandTimings
   (char pre, int verb, unsigned long rep4, unsigned int flag, ATL_cpnode_t *cb)
{
   ATL_cpnode_t *hb, *cp, *hp, *prv=NULL;
   int ialp, ibet=0;
   unsigned long nrep;

   ialp = CopyGetAlphaI(flag);
   if (flag & (1<<CPF_CBLK))
      ibet = CopyGetBetaI(flag);
   hb = ReadCPFileWithPath(pre, "CPYCASES", "copy.idx");
   hb = CopyApplyTypeScal2Hand(hb, flag);
   if (!hb)
   {
      printf("NO USER-SUPPLIED COPY ROUTINES!\n");
      return;
   }
   PrefixStrAllNodes(hb, GetOffset(&hb->next, hb), GetOffset(&hb->rout, hb),
                     "CPYCASES/");

   printf("FINDING BEST HAND-TUNED COPY:\n");
   for (cp=cb; cp; cp=cp->next)
   {
      double mf;
      const unsigned int mb=cp->mb, nb=cp->nb;
/*
 *    Try any hand-tuned cases that work
 */
      nrep = GetRep(rep4, mb, nb);
      hp = FindEquivCopy(hb, cp);
      if (hp)
      {
         printf("   TIMINGS B=(%d,%d), U=(%d,%d), reps=%lu:\n", 
                cp->mb, cp->nb, cp->mu, cp->nu, nrep);
         do
         {
            double mf;
            mf = TimeCPKernel(verb, 0, hp, mb, nb, ialp, ibet, nrep, -1);
            printf("      ID=%6d VL=%2d: mf=%.0f\n", hp->ID, hp->vlen, mf);
            if (mf > cp->mflop[0])
            {
               CopyCPNode(cp, hp);
               cp->mflop[0] = mf;
               cp->mb = mb;
               cp->nb = nb;
               cp->flag = CopyEncodeScal(flag, ialp, ibet);
            }
            hp = hp->next;
         }
         while( (hp = FindEquivCopy(hp, cp)) );
         printf("   DONE\n");
      }
   }
   if (hb)
      KillAllCPNodes(hb);
}

void DoGenTimings(char pre, int verb, unsigned long rep4, unsigned int flag, 
                  ATL_cpnode_t *cb)
{
   ATL_cpnode_t *cp;
   char *fnam;
   int ialp, ibet=0;

   fnam = GetCpySumNam(flag, 'g');
   ialp = CopyGetAlphaI(flag);
   if (flag & (1<<CPF_CBLK))
      ibet = CopyGetBetaI(flag);
   printf("FINDING BEST GENERATED COPY: %s\n", fnam);
   for (cp=cb; cp; cp = cp->next)
   {
      double mf, mfB;
      unsigned long nrep;

      nrep = GetRep(rep4, cp->mb, cp->nb);
      printf("   TIMINGS B=(%d,%d), U=(%d,%d), reps=%lu:\n", 
             cp->mb, cp->nb, cp->mu, cp->nu, nrep);
      cp->vlen = 1;
      if (!cp->rout)
         cp->rout = DupString("ATL_tmp.c");
      if (cp->genstr)
         free(cp->genstr);
      cp->genstr = GetCopyGenStr(cp);
      mfB = TimeCPKernel(verb, 0, cp, cp->mb, cp->nb, ialp, ibet, nrep, -1);
      printf("      ID=     0 VL= 1: mf=%.0f\n", mfB);
      cp->mflop[0] = mfB;
/*
 *    See if we can use vectorized generator.
 *    Present vector generator only supports SSE/AVX for real GEMM C copy
 */
      #if defined(ATL_AVX) || defined(ATL_SSE2) || defined(ATL_SSE)
         if (!(cp->flag & CPF_ALLKERN) && (pre == 's' || pre == 'd'))
         {
            char *gens;
            int VL0=cp->vlen, VL = (pre == 's') ? 4 : 2;

         #if defined(ATL_SSE2) || defined(ATL_SSE1)
            #if defined(ATL_SSE2)
            if (cp->mu % VL == 0 && (pre == 'd' || pre == 's') && 
                !(cp->flag&CPF_ALLKERN))
            #else
            if (cp->mu % VL == 0 && pre == 's' && !(cp->flag&CPF_ALLKERN))
            #endif
            {
               gens = cp->genstr;
               cp->vlen = VL;
               cp->genstr = GetCopyGenStr(cp);
               mf = TimeCPKernel(verb, 0, cp, cp->mb, cp->nb, ialp, ibet, 
                                 nrep, -1);
               printf("      ID=     0 VL=%2d: mf=%.0f\n", VL, mf);
               if (mf > mfB)
               {
                  free(gens);
                  cp->mflop[0] = mfB = mf;
               }
               else
               {
                  free(cp->genstr);
                  cp->genstr = gens;
                  cp->vlen = VL0;
               }
            } /* end SSE if */
         #endif
         #ifdef ATL_AVX
            VL0 = cp->vlen;
            VL <<= 1;
            if (cp->mu % VL == 0)
            {
               gens = cp->genstr;
               cp->vlen = VL;
               cp->genstr = GetCopyGenStr(cp);
               mf = TimeCPKernel(verb, 0, cp, cp->mb, cp->nb, ialp, ibet, 
                                 nrep, -1);
               printf("      ID=     0 VL=%2d: mf=%.0f\n", VL, mf);
               if (mf > mfB)
               {
                  free(gens);
                  cp->mflop[0] = mfB = mf;
               }
               else
               {
                  free(cp->genstr);
                  cp->genstr = gens;
                  cp->vlen = VL0;
               }
            } /* end AVX if */
         #endif
         }    /* end if over trying old vec-basefile */
      #endif  /* end #if on Intel SSE/AVX */
   }
   WriteCPFileWithPath(pre, "res", fnam, cb);
   printf("DONE, output in: res/%c%s\n", pre, fnam);
}

void DoTimings
   (char pre, int verb, unsigned long rep4, unsigned int flag, ATL_cpnode_t *cb)
{
   ATL_cpnode_t *cp;
   char *fnam;
   const int ials[3] = {1,-1,2}, ibes[4]={0,1,-1,2};
   int ia, ib;

   for (ib=0; ib < 4; ib++)
   {
      const int ibet=ibes[ib];
      for (ia=0; ia < 3; ia++)
      {
         const int ialp=ials[ia];

if (ialp != 2 || ibet != 2)
   continue;
         CopyEncodeAllScal(cb, flag, ialp, ibet);
         flag = cb->flag;
         DoGenTimings(pre, verb, rep4, flag, cb);
         DoHandTimings(pre, verb, rep4, flag, cb);
         for (cp=cb; cp; cp=cp->next)
         {
            if (cp->flag & (1L<<CPF_SYRK))
               cp->mflop[0] = 2e-6 / cp->mflop[0]; /* time per elt */
            else
               cp->mflop[0] = 1e-6 / cp->mflop[0]; /* time per elt */
         }
         fnam = GetCpySumNam(flag, 'f');
         WriteCPFileWithPath(pre, "res", fnam, cb);
         printf("DONE, output in: res/%c%s\n", pre, fnam);
      }
   }
}

unsigned long GetReps4x4(int verb, double res)
/*
 * Find how many repititions to do for 4x4 copy to get timing interval to
 * around res seconds
 */
{
   ATL_cpnode_t *cp;
   double tim, mf;
   unsigned long nrep = 32;
   FILE *fp;

   fp = fopen("res/ncprep4x4.txt", "r");
   if (fp)
   {
      fscanf(fp, " %lu", &nrep);
      fclose(fp);
      return(nrep);
   }
   cp = GetCPNode();
   cp->mu = 4; 
   cp->nu = 1;
   cp->flag = (1<<CPF_BE0)|(1<<CPF_AL1)|(1<<CPF_CBLK)|
              (1<<CPF_SINGLE)|(1<<CPF_REAL);
   cp->rout = DupString("ATL_tmp.c");
   cp->genstr = GetCopyGenStr(cp);

   printf("FINDING NREP:\n");
   do
   {
      nrep += nrep;
      mf = TimeCPKernel(verb, 1, cp, 4, 4, 1, 0, nrep, -1);
      tim = (mf / 16e6) * nrep;
      printf("   NREP=%16lu, tim=%e\n", nrep, tim);
   }
   while (tim < res && nrep < 100000);
   printf("DONE.\n");
   KillCPNode(cp);
   fp = fopen("res/ncprep4x4.txt", "w");
   fprintf(fp, "%lu", nrep);
   fclose(fp);
   return(nrep);
}

int main(int nargs, char **args)
/*
 * For now read geAMMRES.sum, later add rkAMMRES.sum & SYRK.
 * Will use this info to find unique lists of AB & C copiers.
 * -> Later must extend for A & B using possibly different copiers.
 * It then finds the fastest working copy routine for each case, 
 * trying each of following:
 * (1) Codes generated from atlas-mmkg.base (all standard formats)
 * (2) atlas-mmg.base (vector ops, but only mu%vlen Cblk formats)
 * (3) User-contributed cases
 */
{
   char pre;
   int verb, minSz, ialp, ibet=0;
   unsigned int flag;
   ATL_mmnode_t *mb, *kb, *mp;
   ATL_cpnode_t *cb;
   unsigned long nrep;

   mb = GetFlags(nargs, args, &verb, &flag, &minSz, &kb);
   pre = CopyGetPre(flag);
   ialp = CopyGetAlphaI(flag);
   if (flag&(1<<CPF_CBLK))
      ibet = CopyGetBetaI(flag);
   nrep = GetReps4x4(verb, 0.10);
@beginskip
/*
 * Special non-GEMM copy must have kernID set specially
 */
   mp = kb;
   while(mp)
   {
      int kernID;
      ATL_mmnode_t *nxt = mp->next;
      if ((flag&(1<<CPF_CBLK)) && mp->blask == ATL_KSYRK)
         MMCopyTimePrep1(pre, (flag&(1<<CPF_TOBLK)) ? ATL_KSKCPFC:ATL_KSKCP2C,
                         ialp, ibet, mp);
@beginskip
      else if (mp->blask == ATL_KGEMM || 
          (!(flag&(1<<CPF_CBLK)) && mp->blask == ATL_KSYRK))
      {
         mp->blask = ATL_KGEMM;
         kb = RemoveMMNodeFromQ(kb, mp);
         mp->next = mb;
         mb = mp;
      }
@endskip
      else
         assert(0);
      mp = nxt;
   }
   mb = MMNoCopyRep(flag, minSz, mb);
   MMCopyTimePrep(pre, flag, mb);
@endskip
   if (kb)
   {
      mp = ATL_LastMMNode(kb);
      mp->next = mb;
      mb = kb;
   }
   cb = GetAllCopyNodesFromMM(flag, mb);
   cb = NoCopyRep(flag, minSz, cb);
@skip   PrintCPNodes(stdout, cb);
   DoTimings(pre, verb, nrep, flag, cb);

   KillAllMMNodes(mb);
   KillAllCPNodes(cb);
   return(0);
}
@ROUT cpcgen
#include "atlas_cpparse.h"
#include "atlas_mmgen.h"
void GenMake(ATL_cpnode_t *cb, char *path)
{
   FILE *fp;
   ATL_cpnode_t *cp;
   int len;
   char *fnam;
   char pre;
   char UPR;
   char dcomp[7] = {'$','(', 'D', 'K', 'C',')', '\0'};
   char dflag[12] = {'$','(','D','K','C', 'F','L','A','G','S', ')', '\0'};

   if (!cb)
      return;
   pre = CopyGetPre(cb->flag);
   len = strlen(path) + 13;  /* <pre>Make.[Into,From]C */
   fnam = malloc(len);
   assert(fnam);
   sprintf(fnam, "%s/%cMake%sC", path, pre, CopyGetDirect(cb->flag));
   fp = fopen(fnam, "w");
   assert(fp);
   free(fnam);

   UPR = (pre == 'c' || pre == 's') ? 'S' : 'D';
   dflag[2] = dcomp[2] = UPR;
   fprintf(fp, "include Make.inc\n");
   fprintf(fp, "\n   objs =");
   for (cp=cb; cp; cp = cp->next)
      fprintf(fp, " \\\n          %s.o", cp->rout);
         
   PrintMakeTargs(fp, pre);
/*
 * Print compilation rules 
 */
   for (cp=cb; cp; cp = cp->next)
   {
      if (cp->comp || cp->cflags)
      {
         fprintf(fp, "%s.o : %s.%c\n", cp->rout, cp->rout,
                 (cp->flag&(1<<CPF_ASM)) ? 'S':'c');
         fprintf(fp, "\t$%s %s\\\n", cp->comp ? cp->comp:dcomp, 
                 cp->cflags ? cp->cflags : dflag);
      }
   }
/*
 * Print default rules
 */
   fprintf(fp, ".S.o:\n");
   fprintf(fp, "\t%s $(CDEFS) %s -c $*.S\n", dcomp, dflag);
   fprintf(fp, ".s.o:\n");
   fprintf(fp, "\t%s $(CDEFS) %s -c $*.s\n", dcomp, dflag);
   fprintf(fp, ".c.o:\n");
   fprintf(fp, "\t%s $(CDEFS) %s -c $*.c\n", dcomp, dflag);

   fclose(fp);
}

void GenProtos(ATL_cpnode_t *cb, char *path)
{
   ATL_cpnode_t *cp;
   int i;
   char *dir, *args, *fnam, *sp;
   char pre;
   FILE *fp;

   if (!cb)
      return;
   pre = CopyGetPre(cb->flag);
   if (cb->flag & (1<<CPF_TOBLK)) /* copy from C into blk */
   {
      dir = "From";
      if (cb->flag & (1<<CPF_REAL))
         args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,"
                "const SCALAR, TYPE *";
      else
         args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,"
                "const SCALAR, TYPE*,TYPE*";
   }
   else /* copy from block into C */
   {
      dir = "Into";
      if (cb->flag & (1<<CPF_REAL))
         args = "ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,"
                "const SCALAR,TYPE*,ATL_CSZT";
      else
         args = "ATL_CSZT,ATL_CSZT,const SCALAR,constTYPE*,const TYPE*,"
                "const SCALAR,TYPE*,ATL_CSZT";
   }
/*
 * Set up basic filename of form atlas_<pre>[From,Into]C_aXbX.h 
 */
   i = strlen(path);
   fnam = malloc(i+22);
   assert(fnam);
   sp = fnam + i+1;
   sprintf(fnam, "%s/atlas_%c%sC.h", path, pre, dir);
   fp = fopen(fnam, "w");
   for (i=0; sp[i]; i++)
   {
      if (sp[i] != '.')
        sp[i] = toupper(sp[i]);
      else
        sp[i] = '_';
   }
   fprintf(fp, "#ifndef %s /* Genned by ATLAS/src/blas/gemm/cpcgen.c */\n", sp);
   fprintf(fp, "   #define %s 1\n\n#include \"atlas_amm.h\"\n", sp);
   free(fnam);
   for (cp=cb; cp; cp = cp->next)
      fprintf(fp, "void %s(%s);\n", cp->rout, args);
   fprintf(fp, "\n#endif\n");
   fclose(fp);
}

void GenCopyC(ATL_cpnode_t *cb, char *path)
{
   ATL_cpnode_t *cp;
   char *sp, *typs;
   int len, plen;
   char pre;

   if (!cb)
      return;

   plen = strlen(path);
   pre = CopyGetPre(cb->flag);
   if (pre == 'z')
      typs = "#define DCPLX 1\n#define TYPE double\n#define SCALAR TYPE*\n";
   else if (pre == 'c')
      typs = "#define SCPLX 1\n#define TYPE float\n#define SCALAR TYPE*\n";
   else if (pre == 'd')
      typs = "#define DREAL 1\n#define TYPE double\n#define SCALAR TYPE\n";
   else if (pre == 's')
      typs = "#define SREAL 1\n#define TYPE float\n#define SCALAR TYPE\n";

   for (cp=cb; cp; cp = cp->next)
   {
      char *nam, *fnam=NULL, *rt=cp->rout;
      char calp, cbet, fe = 'c';
      FILE *fp;

      calp = CopyGetAlphaC(cp->flag);
      cbet = CopyGetBetaC(cp->flag);
      nam = GetCopyName(cp, 0);
      if (cp->ID)
      {
         char *onam;
         assert(rt);
         for (onam=rt; *onam; onam++);
         fe = onam[-1];
         if (fe != 'c' && fe != 'S' && fe != 's')
            fe = 'c';
         
         len = 10 + strlen(rt);
         cp->rout = malloc(len);
         assert(cp->rout);
         sprintf(cp->rout, "CPYCASES/%s", rt);
      }
      else
      {
         char *gens=cp->genstr;
         cp->rout = "ATL_tmp.c";
         cp->genstr = GetCopyGenStr(cp);
         MMDoGenString(0, cp->genstr);
         free(cp->genstr);
         cp->genstr = gens;
      }
      if (rt)
         free(rt);
      if (fe == 's' || fe == 'S')
         cp->flag |= 1L<<CPF_ASM;
      len = strlen(path) + 1 + strlen(nam) + 2 + 1;
      fnam = malloc(len);
      sprintf(fnam, "%s/%s.%c", path, nam, fe);
      fp = fopen(fnam, "w");
      assert(fp);
      fprintf(fp, typs);
      fprintf(fp, "#define ATL_MU %u\n#define ATL_NU %u\n", cp->mu, cp->nu);
      fprintf(fp, "#define ATL_USERCPMM %s\n\n", nam);
      fclose(fp);
      len = 10 + strlen(cp->rout) + strlen(fnam);
      sp = malloc(len);
      assert(sp);
      sprintf(sp, "cat %s >> %s", cp->rout, fnam);
      free(fnam);
      assert(!system(sp));
      free(sp);
      if (cp->ID)
         free(cp->rout);
      cp->rout = nam;
   }
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -F cpyout.sum: repeat for multiple\n");
@skip   fprintf(stderr, "   -v <verb> : set verbosity (1)\n");
   exit(ierr ? ierr : -1);
}

ATL_cpnode_t *GetFlags(int nargs, char **args, char **OUTD)
{
   ATL_cpnode_t *cb=NULL, *cp;
   char *outd=NULL;
   int i;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'F':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        if (!cb)
           cb = ReadCPFile(args[i]);
        else
        {
           cp = ATL_LastCPNode(cb);
           cp->next = ReadCPFile(args[i]);
        }
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (!outd)
      outd = DupString("tmp/");
   *OUTD = outd;
   return(cb);
}

int main(int nargs, char **args)
{
   ATL_cpnode_t *cb;
   char *outd;

   cb = GetFlags(nargs, args, &outd);
   assert(cb);
   GenCopyC(cb, outd);   /* sets info for Protos&Make! */
   GenProtos(cb, outd);
   GenMake(cb, outd);
   free(outd);
   KillAllCPNodes(cb);
   return(0);
@beginskip
   ATL_cpnode_t *gb, *hb;  /* generated & hand-tuned */
   hb = GetFlags(nargs, args);
   gb = YankCPNodesByIntVal(&hb, &(hb->ID), 0);
@endskip
}
@ROUT cpagen
