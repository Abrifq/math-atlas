@ROUT ATL_trsm
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 -def contrib "Antoine Petitet"
#include "atlas_misc.h"
#include "atlas_level3.h"
/*
 * RETURNS: recursion depth (starting from 0)
 */
static unsigned int trsm_recLL
(
   const int             bv,    /* 0:Upper, 1:TransA, 2: Conj, 3:NonUnit */
   ATL_CSZT               N,    /* size of triangle, will recur on this dim */
   ATL_CSZT               NRHS, /* don't recur on RHS */
   const SCALAR           alpha,
   const TYPE             *T,
   ATL_CSZT               ldt,
   ATL_CSZT               rincT, /* rowinc: 1/2 for NoTrans, else ldt2 */
   ATL_CSZT               cincT, /* colinc: ldt2 for NoTrans, else 1/2 */
   TYPE                   *Z,
   ATL_CSZT               ldz
)
{
   unsigned int iret=0;
   if (Mjoin(PATL,trsmL_IP)(bv, N, NRHS, alpha, T, ldt, Z, ldz))
   {
      #ifdef TCPLX
         enum ATLAS_TRANS TA;
         const TYPE none[2] = {ATL_rnone, ATL_rzero};
         const TYPE one[2]  = {ATL_rone,  ATL_rzero};
      #else
         #define none ATL_rnone
         #define one ATL_rone
         const enum ATLAS_TRANS TA = (bv&2) ? AtlasTrans : AtlasNoTrans;
      #endif

      #ifdef TCPLX
         if (bv&2)
            TA = (bv&4) ? AtlasConjTrans : AtlasTrans;
         else
            TA = (bv&4) ? AtlasConj : AtlasNoTrans;
      #endif
      ATL_CSZT NL = (N>>1), NR = N - NL;
      TYPE *C = Z + (NL SHIFT);
      const TYPE *A = T + NL*rincT;
      iret = 2 + trsm_recLL(bv, NL, NRHS, alpha, T, ldt, rincT, cincT, Z, ldz);
      Mjoin(PATL,gemm)(TA, AtlasNoTrans, NR, NRHS, NL, none, A, ldt, Z, ldz, 
                       alpha, C, ldz);
      A += NL*cincT;
      iret += trsm_recLL(bv, NR, NRHS, one, A, ldt, rincT, cincT, C, ldz);
      return(iret);
   }
   return(iret);
}
void Mjoin(PATL,trsm)
(
   const enum ATLAS_SIDE  SD,
   const enum ATLAS_UPLO  UL,
   const enum ATLAS_TRANS TA,
   const enum ATLAS_DIAG  DI,
   ATL_CSZT               M,
   ATL_CSZT               N,
   const SCALAR           alpha,
   const TYPE             *A,
   ATL_CSZT               lda,
   TYPE                   *B,
   ATL_CSZT               ldb
)
/*
 * Purpose
 * =======
 * ATL_trsm solves one of the matrix equations
 *    op( A ) * X = alpha * B,   or  X * op( A ) = alpha * B,
 *
 * where alpha is a scalar, X and B are m by n matrices, A is a unit, or
 * non-unit, upper or lower triangular matrix and op( A ) is one of
 *    op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ).
 *
 * The matrix X is overwritten on B.
 */
{
   unsigned int d;
   if (!M || !N)  /* if either array is of size 0 */
      return;     /* return as there is nothing to do */
   if (SCALAR_IS_ZERO(alpha))                   /* alpha == 0 means */
   {                           
      Mjoin(PATL,gescal)(M, N, alpha, B, ldb);  /* only need to scale B */
      return;
   }
/*
 * LEFT: op(A) * X = alpha * B, A is MxM, X is MxN, B is MxN
 */
   if (SD == AtlasLeft && UL == AtlasLower) 
   {
      ATL_SZT incR, incC;
      ATL_UINT bv;  /* 0:Upper, 1:TransA, 2: Conj, 3:NonUnit */
      bv = (UL == AtlasUpper) ? 1 : 0;
      #ifdef TCPLX
         if (TA == AtlasConjTrans)
            bv |= (4|2);
         else
            bv |= TA == (AtlasTrans) ? 2 : 0;
      #else
         bv |= (TA == AtlasTrans) ? 2:0;
      #endif
      bv |= (DI == AtlasNonUnit) ? 8 : 0;
      if (bv & 2)
      {
         incR = lda SHIFT;
         incC = 1 SHIFT;
      }
      else
      {
         incR = 1 SHIFT;
         incC = lda SHIFT;
      }
      d = trsm_recLL(bv, M, N, alpha, A, lda, incR, incC, B, ldb);
      printf("Solved with %u recusive calls.\n", d);
   }
/*
 * RIGHT: X * op( A ) = alpha * B, A is NxN, X is NxM, B, is NxM
 */
   else
   {
      Mjoin(PATL,trsm_APR)(SD, UL, TA, DI, M, N, alpha, A, lda, B, ldb);
   }
}
@ROUT ATL_trsmL_IP
#include "atlas_misc.h"
#include "atlas_level3.h"
#include Mstr(Mjoin(ATLAS_PRE,utrsmL_LN.h))
#include Mstr(Mjoin(ATLAS_PRE,utrsmL_LT.h))
#include Mstr(Mjoin(ATLAS_PRE,trsmLN_view.h))
#include Mstr(Mjoin(ATLAS_PRE,trsmLT_view.h))
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 
int Mjoin(PATL,trsmL_IP)
(
   ATL_UINT bv,  /* 0:Upper, 1:TransA, 2: Conj, 3:NonUnit */
   ATL_CSZT               M,
   ATL_CSZT               N,
   const SCALAR           alpha,
   const TYPE             *A,
   ATL_CSZT               lda,
   TYPE                   *B,
   ATL_CSZT               ldb
)
{
   @BEGINSKIP
   ATL_UINT NB, RB;
   if (M > ATL_VWtrsml_LAST_MB)
      return(2);
   for (idx=ATL_VWtrsml_LAST_IDX-1; i; i--)
      if (ATL_GetVWtrsmlMB(idx) >= M)
         break;
/*
 * Need to get allTRANS encoded in view, or recorded somehow!
 */
   ATL_GetVWtrsmlInfo(idx, spf, MB, NB, k, imm, icpA, icpB, k, k, k, k);
   @ENDSKIP
   #if 0
   void *vp;
   TYPE *diag, *T, *R, *w;
   ipinfo_t ip;
   vp = Mjoin(PATL,utrsmL_alloc)(&ip, N, &diag, &T, &R, &w);
   if (!vp)
      return(1);
   #else
      if (M > 1)
         return(1);
      if (bv&8)
      #ifdef TCPLX
      {
         double inv[2];
         CXINV(inv, A);
         Mjoin(PATL,scal)(N, inv, B, ldb);
      }
      #else
         Mjoin(PATL,scal)(N, ATL_rone / *A, B, ldb);
      #endif
   #endif
   return(0);
}
@ROUT ATL_utrsmR_alloc
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 -def cwauth "Rakib Hasan" -def contrib "R. Clint Whaley"
void* Mjoin(PATL,utrsmR_alloc)
   (ipinfo_t *ip, int N, TYPE **Diag, TYPE **L, TYPE **R, TYPE **w)
{
   const int MU=ip->mu, NU=ip->nu;
   int mb = (N + NU - 1) / NU;
   const int NUNU = NU*NU;
   const int MUNU = MU*NU;
   void *vp;
   vp = malloc( ATL_MulBySize( N + (NUNU*mb*(mb+1)/2) + mb*MUNU + 2*MUNU )
                           + 4*ATL_Cachelen);
   if (vp)
   {
      *Diag = ATL_AlignPtr(vp);
      *L = (*Diag) + (N SHIFT);
      *L = ATL_AlignPtr(*L);
      *R = (*L) + ((NUNU*mb*(mb+1)/2) SHIFT);
      *R = ATL_AlignPtr(*R);
      *w = (*R) + ((mb*MUNU) SHIFT);
      *w = ATL_AlignPtr(*w);
   }
   return(vp);
}
   @endextract
@ROUT ATL_utrsmL_alloc
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 -def cwauth "Rakib Hasan" -def contrib "R. Clint Whaley"
#include "atlas_amm.h"
void* Mjoin(PATL,utrsmL_alloc)
   (ipinfo_t*ip, int N, TYPE **Diag, TYPE **L, TYPE **R, TYPE **w)
{
   const int MU = ip->mu, NU=ip->nu;
   int mb = (N + MU - 1) / MU;
   const int MUMU = MU*MU;
   const int MUNU = MU*NU;
   void *vp;
   vp = malloc( ATL_MulBySize( N + (MUMU*mb*(mb+1)/2) + mb*MUNU + 2*MUNU )
                           + 4*ATL_Cachelen);
   if (vp)
   {
      *Diag = ATL_AlignPtr(vp);
      *L = (*Diag) + (N SHIFT);
      *L = ATL_AlignPtr(*L);
      *R = (*L) + ((MUMU*mb*(mb+1)/2) SHIFT);
      *R = ATL_AlignPtr(*R);
      *w = (*R) + ((mb*MUNU) SHIFT);
      *w = ATL_AlignPtr(*w);
   }
   return(vp);
}
   @endextract
@BEGINSKIP
   All TRSM microkernels variants are generated from this file.
   Written by Rakib Hasan, heavily modifed by R. Clint Whaley to work
   with new framework and to be separately compilable.
@ENDSKIP
@ROUT ATL_utrsmL_LT_UN ATL_utrsmL_LN_UT ATL_utrsmR_LT_UN ATL_utrsmR_LN_UT
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 -def cwauth "Rakib Hasan" -def contrib "R. Clint Whaley"
#include "atlas_misc.h"
#include "atlas_amm.h"
@ROUT ATL_utrsmL_LT_UN ATL_utrsmL_LN_UT `@define SD @L@`
@ROUT ATL_utrsmR_LT_UN ATL_utrsmR_LN_UT `@define SD @R@`
#ifdef Conj_
   #define IsConj 1
#else
   #define IsConj 0
#endif

@ROUT ATL_utrsmL_LT_UN
#ifdef Upper_
   #define ATL_ntrcopy ATL_ntrcopyL
   #define ATL_ntrsm ATL_ntrsmUN
   #define ATL_ntrsm_RR ATL_ntrsmUN_RR
   void ATL_utrsmL_UN
#else
   #define ATL_ntrcopy ATL_ntrcopyU
   #define ATL_ntrsm ATL_ntrsmLT
   #define ATL_ntrsm_RR ATL_ntrsmLT_RR
   void ATL_utrsmL_LT
#endif
   (ipinfo_t *ip, const enum ATLAS_DIAG Diag, 
    ATL_CINT N, ATL_CINT R, const SCALAR alpha, const TYPE *A, ATL_CSZT lda, 
    TYPE *X, ATL_CSZT ldx, TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   cm2am_t r2a = ip->b2blk;
   cm2am_t l2a = ip->a2blk;
   ATL_CSZT ainc = ip->incAm;
   ammkern_t amm_b0 = ip->amm_b0, amm_b1 = ip->amm_b1;
   #ifdef TCPLX
      ammkern_t amm_bn = ip->amm_bn;
      TYPE ONE[3] = {ATL_rone, ATL_rzero, ATL_rzero}, *ZERO=ONE+1;
      TYPE NONE[2] = {ATL_rnone, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define NONE ATL_rnone
   #endif
   const int MU = ip->mu, NU = ip->nu;
   const int MUMU = MU*MU, MUNU = MU*NU;
   const int UnitAlpha = SCALAR_IS_ONE(alpha);
   const int NeedCopyA = (A != NULL);
   @BEGINSKIP
   #ifdef Trans_
      #define ainc 1
   #else
      #define ainc lda
   #endif
   @ENDSKIP
@skip   const int ainc = (TA != AtlasNoTrans) ? 1 : lda;
@skip   const int IsConj = (TA == AtlasConjTrans);
   TYPE *l, *x=X;
   int mb = (N + MU - 1) / MU;
   const int iRWoff = mb*MUNU;
   ATL_SZT r;
   int i, ix=-1, mbi;

@skip   GetInfo(TA, &amm_b0, &amm_b1, &amm_bn, &l2a, &r2a);
   for (r=0; r < R; r += NU, x += (NU SHIFT)*ldx)
   {
      int mu, nu = R - r;
      const int DoCopy = (!r && NeedCopyA);
      TYPE *d, *Ac = ((TYPE*)A), *xc = x;
      nu = Mmin(nu, NU);
      mu = Mmin(MU, N);
      Ac += ((N - mu) SHIFT) * (lda+1);
      xc += ((N - mu) SHIFT);

      /* do the first triangle */
      if (Diag == AtlasUnit) d = NULL;
      else d = diag;
      if (DoCopy)
         ATL_ntrcopy(IsConj, mu, Ac, lda, L, MU, d);
      if (mu == MU)
      {
         if (!UnitAlpha) { ATL_nscal(nu, alpha, xc, ldx); }
         ATL_ntrsm(nu, d, L, MU, xc, ldx);
      }
      else
      {
         if (!UnitAlpha) { ATL_nscal_RR(mu, nu, alpha, xc, ldx); }
         ATL_ntrsm_RR(mu, nu, d, L, MU, xc, ldx);
      }

      for (i=N-mu, mbi=1, l=L+(MUMU SHIFT); 
            i > 0; i -= MU, mbi++, l+=(MUMU SHIFT))
      {
         mu = Mmin(i, MU);
         Ac -= (mu SHIFT) * (lda+1);
         xc -= (mu SHIFT);
         #ifdef TCPLX
         {
            TYPE *rL, *iL, *rR, *iR;
            iR = RW + (mb-mbi)*MUNU;
            rR = iR + iRWoff;
            rL = l + mbi*MUMU;
            iL = l;
            r2a(MU, nu, ONE, xc+(mu SHIFT), ldx, rR, iR);
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(N-i, mu, NONE, Ac+mu*ainc, lda, rL, iL);
            #ifndef USE_TRANS
               amm_b0(1, 1, N-i, iL, iR, w, rL, iR, w+MUNU);
               amm_b0(1, 1, N-i, rL, iR, w+MUNU, rL, rR, w);
               amm_bn(1, 1, N-i, rL, rR, w, iL, rR, w+MUNU);
               amm_b1(1, 1, N-i, iL, rR, w+MUNU, 
                      l+(mbi SHIFT)*MUMU, RW+(mb-mbi-1)*MUNU, w);
            #else
               amm_b0(1, 1, N-i, iR, iL, w, rR, iL, w+MUNU);
               amm_b0(1, 1, N-i, rR, iL, w+MUNU, rR, rL, w);
               amm_bn(1, 1, N-i, rR, rL, w, iR, rL, w+MUNU);
               amm_b1(1, 1, N-i, iR, rL, w+MUNU, 
                      RW+(mb-mbi-1)*MUNU, l+(mbi SHIFT)*MUMU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, w+MUNU, alpha, xc, ldx);
         }
         #else
            r2a(MU, nu, ONE, xc+mu, ldx, RW+((mb-mbi)*MUNU));
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(N-i, mu, NONE, Ac+mu*ainc, lda, l);
            #ifndef USE_TRANS
               amm_b0(1, 1, N-i, l, RW+(mb-mbi)*MUNU, w, 
                     l+mbi*MUMU, RW+(mb-mbi-1)*MUNU, w);
            #else
               amm_b0(1, 1, N-i, RW+(mb-mbi)*MUNU, l, w, 
                     RW+(mb-mbi-1)*MUNU, l+mbi*MUMU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, alpha, xc, ldx);
         #endif
         /* now do the diagonal trsm */
         l += (mbi SHIFT) * MUMU;
         if (Diag == AtlasUnit) d = NULL;
         else d = diag + ((N-i) SHIFT);
         if (DoCopy)
            ATL_ntrcopy(IsConj, mu, Ac, lda, l, MU, d);
         if (mu == MU)
            ATL_ntrsm(nu, d, l, MU, xc, ldx);
         else
            ATL_ntrsm_RR(mu, nu, d, l, MU, xc, ldx);
      }
   }
}
@skip #undef ainc
@ROUT ATL_utrsmL_LN_UT
#ifdef Upper_
   #define ATL_ntrcopy ATL_ntrcopyU
   #define ATL_ntrsm ATL_ntrsmUT
   #define ATL_ntrsm_RR ATL_ntrsmUT_RR
@skip   #define ainc 1
   void ATL_utrsmL_UT
#else
   #define ATL_ntrcopy ATL_ntrcopyL
   #define ATL_ntrsm ATL_ntrsmLN
   #define ATL_ntrsm_RR ATL_ntrsmLN_RR
@skip   #define ainc lda
   void ATL_utrsmL_LN
#endif
   (ipinfo_t *ip, const enum ATLAS_DIAG Diag, 
    ATL_CINT N, ATL_CINT R, const SCALAR alpha, const TYPE *A, ATL_CINT lda, 
    TYPE *X, ATL_CINT ldx, TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   cm2am_t l2a = ip->a2blk;
   cm2am_t r2a = ip->b2blk;
   ammkern_t amm_b0 = ip->amm_b0, amm_b1 = ip->amm_b1;
   ATL_CSZT ainc = ip->incAm;
   #ifdef TCPLX
      ammkern_t amm_bn = ip->amm_bn;
      TYPE ONE[3] = {ATL_rone, ATL_rzero, ATL_rzero}, *ZERO=ONE+1;
      TYPE NONE[2] = {ATL_rnone, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define NONE ATL_rnone
   #endif
   const int MU = ip->mu, NU = ip->nu;
   const int MUMU = MU*MU, MUNU = MU*NU;
   const int UnitAlpha = SCALAR_IS_ONE(alpha);
   const int NeedCopyA = (A != NULL);
   TYPE *l, *x=X;
   int mb = (N + MU - 1) / MU;
   const int iRWoff = mb*MUNU;
   ATL_SZT r;
   int i, ix=-1, mbi;

@skip   GetInfo(TA, &amm_b0, &amm_b1, &amm_bn, &l2a, &r2a);
   for (r=0; r < R; r += NU, x += (NU SHIFT)*ldx)
   {
      int mu, nu = R - r;
      const int DoCopy = (!r && NeedCopyA);
      TYPE *d, *Ac = ((TYPE*)A), *xc = x;
      nu = Mmin(nu,NU);
      mu = Mmin(MU, N);

      /* do the first triangle */
      if (Diag == AtlasUnit) d = NULL;
      else d = diag;
      if (DoCopy)
         ATL_ntrcopy(IsConj, mu, Ac, lda, L, MU, d);
      if (mu == MU)
      {
         if (!UnitAlpha) { ATL_nscal(nu, alpha, xc, ldx); }
         ATL_ntrsm(nu, d, L, MU, xc, ldx);
      }
      else
      {
         if (!UnitAlpha) { ATL_nscal_RR(mu, nu, alpha, xc, ldx); }
         ATL_ntrsm_RR(mu, nu, d, L, MU, xc, ldx);
      }

      for (i=mu, mbi=1, l=L+(MUMU SHIFT); 
            i < N; i += MU, mbi++, l+=(MUMU SHIFT))
      {
         mu = Mmin(N-i, MU);
         Ac += (MU SHIFT) * (lda+1);
         xc += (MU SHIFT);
         #ifdef TCPLX
         {
            TYPE *rL, *iL, *rR, *iR;
            iR = RW + (mbi-1)*MUNU;
            rR = iR + iRWoff;
            rL = l + mbi*MUMU;
            iL = l;
            r2a(MU, nu, ONE, xc-(MU SHIFT), ldx, rR, iR);
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(i, mu, NONE, Ac-i*ainc, lda, rL, iL);
            iR = RW;
            rR = iR + iRWoff;
            #ifndef USE_TRANS
               amm_b0(1, 1, i, iL, iR, w, rL, iR, w+MUNU);
               amm_b0(1, 1, i, rL, iR, w+MUNU, rL, rR, w);
               amm_bn(1, 1, i, rL, rR, w, iL, rR, w+MUNU);
               amm_b1(1, 1, i, iL, rR, w+MUNU, l+(mbi SHIFT)*MUMU, RW, w);
            #else
               amm_b0(1, 1, i, iR, iL, w, rR, iL, w+MUNU);
               amm_b0(1, 1, i, rR, iL, w+MUNU, rR, rL, w);
               amm_bn(1, 1, i, rR, rL, w, iR, rL, w+MUNU);
               amm_b1(1, 1, i, iR, rL, w+MUNU, RW, l+(mbi SHIFT)*MUMU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, w+MUNU, alpha, xc, ldx);
         }
         #else
            r2a(MU, nu, ONE, xc-MU, ldx, RW+(mbi-1)*MUNU);
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(i, mu, NONE, Ac-i*ainc, lda, l);
            #ifndef USE_TRANS
               amm_b0(1, 1, i, l, RW, w, l+mbi*MUMU, RW, w);
            #else
               amm_b0(1, 1, i, RW, l, w, RW, l+mbi*MUMU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, alpha, xc, ldx);
         #endif
         /* now do the diagonal trsm */
         l += (mbi SHIFT) * MUMU;
         if (Diag == AtlasUnit) d = NULL;
         else d = diag + (i SHIFT);
         if (DoCopy)
            ATL_ntrcopy(IsConj, mu, Ac, lda, l, MU, d);
         if (mu == MU)
            ATL_ntrsm(nu, d, l, MU, xc, ldx);
         else
            ATL_ntrsm_RR(mu, nu, d, l, MU, xc, ldx);
      }
   }
}
@ROUT
void Mjoin(PATL,utrsmLUN)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R, 
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx, 
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmL_LTUN)(AtlasNoTrans, Diag, N, R, alpha, A, lda, 
         X, ldx, diag, L, RW, w);
}

void Mjoin(PATL,utrsmLUT)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R, 
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx, 
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmL_LNUT)(AtlasTrans, Diag, N, R, alpha, A, lda, 
         X, ldx, diag, L, RW, w);
}

#ifdef TCPLX
void Mjoin(PATL,utrsmLUC)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R, 
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx, 
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmL_LNUT)(AtlasConjTrans, Diag, N, R, alpha, A, lda, 
         X, ldx, diag, L, RW, w);
}
#endif

void Mjoin(PATL,utrsmLLN)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R, 
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx, 
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmL_LNUT)(AtlasNoTrans, Diag, N, R, alpha, A, lda, 
         X, ldx, diag, L, RW, w);
}

void Mjoin(PATL,utrsmLLT)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R, 
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx, 
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmL_LTUN)(AtlasTrans, Diag, N, R, alpha, A, lda, 
         X, ldx, diag, L, RW, w);
}

#ifdef TCPLX
void Mjoin(PATL,utrsmLLC)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R, 
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx, 
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmL_LTUN)(AtlasConjTrans, Diag, N, R, alpha, A, lda, 
         X, ldx, diag, L, RW, w);
}
#endif

#ifdef NO_AMM_NAME
   void Mjoin(PATL,trsm)
      (const enum ATLAS_SIDE Side, const enum ATLAS_UPLO Uplo, 
       const enum ATLAS_TRANS TA, const enum ATLAS_DIAG Diag, 
       ATL_CINT N, ATL_CINT R, const SCALAR alpha, 
       const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx)
#else
   int Mjoin(PATL,utrsmKL)
      (const enum ATLAS_UPLO Uplo, 
       const enum ATLAS_TRANS TA, const enum ATLAS_DIAG Diag, 
       ATL_CINT N, ATL_CINT R, const SCALAR alpha, 
       const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx)
#endif
{
   const int UPPER = (Uplo == AtlasUpper);
   void *vp;
   TYPE *diag, *L, *RW, *w;
   vp = GetWorkspaceL(N, &diag, &L, &RW, &w);
   #ifndef NO_AMM_NAME
      if (!vp) return(-1);
   #endif
   if (!UPPER)
   {
      if (TA == AtlasNoTrans)
         Mjoin(PATL,utrsmLLN)(Diag, N, R, alpha, A, lda, X, ldx, 
               diag, L, RW, w);
      else if (TA == AtlasTrans)
         Mjoin(PATL,utrsmLLT)(Diag, N, R, alpha, A, lda, X, ldx, 
               diag, L, RW, w);
      #ifdef TCPLX
         else /* (TA == AtlasConjTrans) */
            Mjoin(PATL,utrsmLLC)(Diag, N, R, alpha, A, lda, X, ldx, 
                  diag, L, RW, w);
      #endif
   }
   else
   {
      if (TA == AtlasNoTrans)
         Mjoin(PATL,utrsmLUN)(Diag, N, R, alpha, A, lda, X, ldx, 
               diag, L, RW, w);
      else if (TA == AtlasTrans)
         Mjoin(PATL,utrsmLUT)(Diag, N, R, alpha, A, lda, X, ldx, 
               diag, L, RW, w);
   #ifdef TCPLX
      else /* (TA == AtlasConjTrans) */
         Mjoin(PATL,utrsmLUC)(Diag, N, R, alpha, A, lda, X, ldx, 
               diag, L, RW, w);
   #endif
   }
   free(vp);
   #ifndef NO_AMM_NAME
      return(0);
   #endif
}
@ROUT ATL_utrsmR_LT_UN
#ifndef Upper_
   #define ATL_ntrcopy ATL_ntrcopyL
   #define ATL_ntrsm ATL_ntrsmLT
   #define ATL_ntrsm_RR ATL_ntrsmLT_RR
@skip   #define ainc lda
   void ATL_utrsmR_LT
#else
   #define ATL_ntrcopy ATL_ntrcopyU
   #define ATL_ntrsm ATL_ntrsmUN
   #define ATL_ntrsm_RR ATL_ntrsmUN_RR
@skip   #define ainc 1
   void ATL_utrsmR_UN
#endif
   (ipinfo_t *ip, const enum ATLAS_DIAG Diag,
    ATL_CINT R, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda,
    TYPE *X, ATL_CINT ldx, TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   cm2am_t l2a = ip->a2blk, r2a = ip->b2blk;
   ammkern_t amm_b0 = ip->amm_b0, amm_b1 = ip->amm_b1;
   ATL_CSZT ainc = ip->incAm;
   #ifdef TCPLX
      ammkern_t amm_bn = ip->amm_bn;
      TYPE ONE[3] = {ATL_rone, ATL_rzero, ATL_rzero}, *ZERO=ONE+1;
      TYPE NONE[2] = {ATL_rnone, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define NONE ATL_rnone
   #endif
   const int MU = ip->mu, NU = ip->nu;
   const int NUNU = NU*NU, MUNU = MU*NU;
   const int UnitAlpha = SCALAR_IS_ONE(alpha);
   const int NeedCopyA = (A != NULL);
   TYPE *l, *x=X;
   int mb = (N + NU - 1) / NU;
   const int iRWoff = mb*MUNU;
   ATL_SZT r;
   int i, ix=-1, mbi;

@skip   GetInfo(TA, &amm_b0, &amm_b1, &amm_bn, &l2a, &r2a);
   for (r=0; r < R; r += MU, x += (MU SHIFT))
   {
      int nu, mu = R - r;
      const int DoCopy = (!r && NeedCopyA);
      TYPE *d, *Ac = ((TYPE*)A), *xc = x;
      mu = Mmin(mu, MU);
      nu = Mmin(NU, N);
      /* do the first triangle */
      if (Diag == AtlasUnit) d = NULL;
      else d = diag;
      if (DoCopy)
         ATL_ntrcopy(IsConj, nu, Ac, lda, L, NU, d);
      if (nu == NU)
      {
         if (!UnitAlpha) { ATL_nscal(mu, alpha, xc, ldx); }
         ATL_ntrsm(mu, d, L, NU, xc, ldx);
      }
      else
      {
         if (!UnitAlpha) { ATL_nscal_RR(mu, nu, alpha, xc, ldx); }
         ATL_ntrsm_RR(mu, nu, d, L, NU, xc, ldx);
      }

      for (i=nu, mbi=1, l=L+(NUNU SHIFT); 
            i < N; i += NU, mbi++, l+=(NUNU SHIFT))
      {
         nu = Mmin(N-i, NU);
         Ac += (NU SHIFT) * (lda+1);
         xc += (NU SHIFT) * ldx;
         #ifdef TCPLX
         {
            TYPE *rL, *iL, *rR, *iR;
            iR = RW + (mbi-1)*MUNU;
            rR = iR + iRWoff;
            rL = l + mbi*NUNU;
            iL = l;
            r2a(NU, mu, ONE, xc-(NU SHIFT)*ldx, ldx, rR, iR);
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(i, nu, NONE, Ac-i*ainc, lda, rL, iL);
            iR = RW;
            rR = iR + iRWoff;
            #ifdef USE_TRANS
               amm_b0(1, 1, i, iL, iR, w, rL, iR, w+MUNU);
               amm_b0(1, 1, i, rL, iR, w+MUNU, rL, rR, w);
               amm_bn(1, 1, i, rL, rR, w, iL, rR, w+MUNU);
               amm_b1(1, 1, i, iL, rR, w+MUNU, l+(mbi SHIFT)*NUNU, RW, w);
            #else
               amm_b0(1, 1, i, iR, iL, w, rR, iL, w+MUNU);
               amm_b0(1, 1, i, rR, iL, w+MUNU, rR, rL, w);
               amm_bn(1, 1, i, rR, rL, w, iR, rL, w+MUNU);
               amm_b1(1, 1, i, iR, rL, w+MUNU, RW, l+(mbi SHIFT)*NUNU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, w+MUNU, alpha, xc, ldx);
         }
         #else
            r2a(NU, mu, ONE, xc-(NU*ldx), ldx, RW+(mbi-1)*MUNU);
            if (DoCopy) /* do the copy as needed for in-cache comp. */
            {
               l2a(i, nu, NONE, Ac-i*ainc, lda, l);
            }
            #ifdef USE_TRANS
               amm_b0(1, 1, i, l, RW, w, l+mbi*NUNU, RW, w);
            #else
               amm_b0(1, 1, i, RW, l, w, RW, l+mbi*NUNU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, alpha, xc, ldx);
         #endif
         /* now do the diagonal trsm */
         l += (mbi SHIFT) * NUNU;
         if (Diag == AtlasUnit) d = NULL;
         else d = diag + (i SHIFT);
         if (DoCopy)
            ATL_ntrcopy(IsConj, nu, Ac, lda, l, NU, d);
         if (nu == NU)
            ATL_ntrsm(mu, d, l, NU, xc, ldx);
         else
            ATL_ntrsm_RR(mu, nu, d, l, NU, xc, ldx);
      }
   }
}
@ROUT ATL_utrsmR_LN_UT
#ifdef Upper_
@skip   #define ainc lda
   #define ATL_ntrcopy ATL_ntrcopyU
   #define ATL_ntrsm ATL_ntrsmUT
   #define ATL_ntrsm_RR ATL_ntrsmUT_RR
   void ATL_utrsmR_UT
#else
@skip   #define ainc 1
   #define ATL_ntrcopy ATL_ntrcopyL
   #define ATL_ntrsm ATL_ntrsmLN
   #define ATL_ntrsm_RR ATL_ntrsmLN_RR
   void ATL_utrsmR_LN
#endif
   (ipinfo_t *ip, const enum ATLAS_DIAG Diag,
    ATL_CINT R, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda,
    TYPE *X, ATL_CINT ldx, TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   ATL_CSZT ainc = ip->incAm;
   cm2am_t l2a = ip->a2blk, r2a = ip->b2blk;
   ammkern_t amm_b0 = ip->amm_b0, amm_b1 = ip->amm_b1;
   #ifdef TCPLX
      ammkern_t amm_bn = ip->amm_bn;
      TYPE ONE[3] = {ATL_rone, ATL_rzero, ATL_rzero}, *ZERO=ONE+1;
      TYPE NONE[2] = {ATL_rnone, ATL_rzero};
   #else
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      #define NONE ATL_rnone
   #endif
   const int MU = ip->mu, NU = ip->nu;
   const int NUNU = NU*NU, MUNU = MU*NU;
   const int UnitAlpha = SCALAR_IS_ONE(alpha);
   const int NeedCopyA = (A != NULL);
   TYPE *l, *x=X;
   int mb = (N + NU - 1) / NU;
   const int iRWoff = mb*MUNU;
   ATL_SZT r;
   int i, ix=-1, mbi;

@skip   GetInfo(TA, &amm_b0, &amm_b1, &amm_bn, &l2a, &r2a);
   for (r=0; r < R; r += MU, x += (MU SHIFT))
   {
      int nu, mu = R - r;
      const int DoCopy = (!r && NeedCopyA);
      TYPE *d, *Ac = ((TYPE*)A), *xc = x;
      mu = Mmin(mu, MU);
      nu = Mmin(NU, N);
      Ac += ((N - nu) SHIFT) * (lda+1);
      xc += ((N - nu) SHIFT) * ldx;
      /* do the first triangle */
      if (Diag == AtlasUnit) d = NULL;
      else d = diag;
      if (DoCopy)
         ATL_ntrcopy(IsConj, nu, Ac, lda, L, NU, d);
      if (nu == NU)
      {
         if (!UnitAlpha) { ATL_nscal(mu, alpha, xc, ldx); }
         ATL_ntrsm(mu, d, L, NU, xc, ldx);
      }
      else
      {
         if (!UnitAlpha) { ATL_nscal_RR(mu, nu, alpha, xc, ldx); }
         ATL_ntrsm_RR(mu, nu, d, L, NU, xc, ldx);
      }

      for (i=N-nu, mbi=1, l=L+(NUNU SHIFT); 
            i > 0; i -= NU, mbi++, l+=(NUNU SHIFT))
      {
         nu = Mmin(i, NU);
         Ac -= (nu SHIFT) * (lda+1);
         xc -= (nu SHIFT) * ldx;
         #ifdef TCPLX
         {
            TYPE *rL, *iL, *rR, *iR;
            iR = RW + (mb-mbi)*MUNU;
            rR = iR + iRWoff;
            rL = l + mbi*NUNU;
            iL = l;
            r2a(NU, mu, ONE, xc+(nu SHIFT)*ldx, ldx, rR, iR);
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(N-i, nu, NONE, Ac+nu*ainc, lda, rL, iL);
            #ifdef USE_TRANS
               amm_b0(1, 1, N-i, iL, iR, w, rL, iR, w+MUNU);
               amm_b0(1, 1, N-i, rL, iR, w+MUNU, rL, rR, w);
               amm_bn(1, 1, N-i, rL, rR, w, iL, rR, w+MUNU);
               amm_b1(1, 1, N-i, iL, rR, w+MUNU, 
                      l+(mbi SHIFT)*NUNU, RW+(mb-mbi-1)*MUNU, w);
            #else
               amm_b0(1, 1, N-i, iR, iL, w, rR, iL, w+MUNU);
               amm_b0(1, 1, N-i, rR, iL, w+MUNU, rR, rL, w);
               amm_bn(1, 1, N-i, rR, rL, w, iR, rL, w+MUNU);
               amm_b1(1, 1, N-i, iR, rL, w+MUNU, 
                      RW+(mb-mbi-1)*MUNU, l+(mbi SHIFT)*NUNU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, w+MUNU, alpha, xc, ldx);
         }
         #else
            r2a(NU, mu, ONE, xc+nu*ldx, ldx, RW+((mb-mbi)*MUNU));
            if (DoCopy) /* do the copy as needed for in-cache comp. */
               l2a(N-i, nu, NONE, Ac+nu*ainc, lda, l);
            #ifdef USE_TRANS
               amm_b0(1, 1, N-i, l, RW+(mb-mbi)*MUNU, w, 
                     l+mbi*NUNU, RW+(mb-mbi-1)*MUNU, w);
            #else
               amm_b0(1, 1, N-i, RW+(mb-mbi)*MUNU, l, w, 
                     RW+(mb-mbi-1)*MUNU, l+mbi*NUNU, w);
            #endif
            ATL_ntrsm_cpC(mu, nu, ONE, w, alpha, xc, ldx);
         #endif
         /* now do the diagonal trsm */
         l += (mbi SHIFT) * NUNU;
         if (Diag == AtlasUnit) d = NULL;
         else d = diag + ((N-i) SHIFT);
         if (DoCopy)
            ATL_ntrcopy(IsConj, nu, Ac, lda, l, NU, d);
         if (nu == NU)
            ATL_ntrsm(mu, d, l, NU, xc, ldx);
         else
            ATL_ntrsm_RR(mu, nu, d, l, NU, xc, ldx);
      }
   }
}
@ROUT
void Mjoin(PATL,utrsmRUN)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R,
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx,
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmR_LTUN)(AtlasNoTrans, Diag, N, R, alpha, A, lda,
         X, ldx, diag, L, RW, w);
}

void Mjoin(PATL,utrsmRUT)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R,
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx,
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmR_LNUT)(AtlasTrans, Diag, N, R, alpha, A, lda,
         X, ldx, diag, L, RW, w);
}

#ifdef TCPLX
void Mjoin(PATL,utrsmRUC)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R,
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx,
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmR_LNUT)(AtlasConjTrans, Diag, N, R, alpha, A, lda,
         X, ldx, diag, L, RW, w);
}
#endif

void Mjoin(PATL,utrsmRLN)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R,
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx,
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmR_LNUT)(AtlasNoTrans, Diag, N, R, alpha, A, lda,
         X, ldx, diag, L, RW, w);
}

void Mjoin(PATL,utrsmRLT)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R,
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx,
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmR_LTUN)(AtlasTrans, Diag, N, R, alpha, A, lda,
         X, ldx, diag, L, RW, w);
}

#ifdef TCPLX
void Mjoin(PATL,utrsmRLC)
      (const enum ATLAS_DIAG Diag, ATL_CINT N, ATL_CINT R,
       const SCALAR alpha, const TYPE *A, ATL_CINT lda, TYPE *X, ATL_CINT ldx,
       TYPE *diag, TYPE *L, TYPE *RW, TYPE *w)
{
   Mjoin(PATL,utrsmR_LTUN)(AtlasConjTrans, Diag, N, R, alpha, A, lda,
         X, ldx, diag, L, RW, w);
}
#endif
@ROUT trsmsrch
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017 
#define ATL_WANT ILCM 1
#include "atlas_iopt.h"
#include "atlas_cache.h"
#include "atlas_genparse.h"
#include "atlas_mmtesttime.h"

#define TSM_RIGHT  0
#define TSM_UPPER  1
#define TSM_TRANSA 2
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -S [L/R] : search Left or Right TRSM\n");
   exit(ierr ? ierr : -1);
}

ATL_mmnode_t *getAllCandKerns(char pre, int flag)
{
   ATL_mmnode_t *mb, *mp;
   mb = ReadMMFileWithPath(pre, "res", "opmek.sum");
   mb = ATL_JoinMMQs(mb, ReadMMFileWithPath(pre, "res", "opnek.sum"));
   mb = ATL_JoinMMQs(mb, ReadMMFileWithPath(pre, "res", "opgen.sum"));
   mb = ATL_JoinMMQs(mb, ReadMMFileWithPath(pre, "res", "ipgen.sum"));
   mb = ATL_JoinMMQs(mb, ReadMMFileWithPath(pre, "res", "ipmen.sum"));
   mp = AddUniqueMMKernsToList(NULL, mb);
   KillAllMMNodes(mb);
   mb = mp;
   while (mp)
   {
      ATL_mmnode_t *nxt = mp->next;
      int KILL;
      KILL = !(mp->flag & (1<<MMF_KRUNTIME));  /* kill compile-time K */
      if (flag&(1<<TSM_RIGHT))      /* Right case requires */
         KILL |= (mp->nu % mp->ku); /* nu a multiple of ku */
      else                          /* Left case requires */
         KILL |= (mp->mu % mp->ku); /* mu a multiple of ku */
      if (KILL)
         mb = KillMMNodeFromQ(mb, mp);
      else
      {
         mp->blask = ATL_KTRSM;
         mp->flag = (mp->flag&(~MMF_MVSET))|MMF_MVDEF;
      }
      mp = nxt;
   }
   assert(mb);  /* later create one in this case, for now assert */
   return(mb);
}

char GetFlags(int nargs, char **args, int *FLG)
{
   char pre = 'd';
   int flg=0;
   int i;

   for (i=1; i < nargs; i++)
   {
      int wch, *ip, **ipp, TST=0;
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'S':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        wch = args[i][0];
        if (wch == 'R' || wch == 'r')
           flg |= 1<<TSM_RIGHT;
        else
           flg &= ~(1<<TSM_RIGHT);
        break;
      case 'U':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        wch = args[i][0];
        if (wch == 'U' || wch == 'u')
           flg |= 1<<TSM_UPPER;
        else
           flg &= ~(1<<TSM_UPPER);
        break;
      case 'A':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        wch = args[i][0];
        if (wch == 'T' || wch == 't')
           flg |= 1<<TSM_TRANSA;
        else
           flg &= ~(1<<TSM_TRANSA);
        break;
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *FLG = flg;
   return(pre);
}

double timeTRSM(char pre, int flag, int B, int R, ATL_mmnode_t *mmp)
{
   double mfB = 0.0;
   int it;
   const int RIGHT=(flag&(1<<TSM_RIGHT));
   int tflag= ((RIGHT) ? 4:0);
   const char TA[2] = {'N', 'T'};

   if (flag&(1<<TSM_UPPER))
      tflag |= 16;
   if (flag&(1<<TSM_TRANSA))
      tflag |= 32;
   for (it=0; it < 2; it++)
   {
      const int tfl = tflag | ((it)?8:0);
      int DOIT, NR;
      const int TR = (RIGHT) ? !it : it;
      if (TR)
      {
         DOIT = (mmp->nu % mmp->ku) == 0;
         NR = (R > mmp->mu) ? (R/mmp->mu)*mmp->mu : R;
      }
      else
      {
         DOIT = (mmp->mu % mmp->ku) == 0;
         NR = (R > mmp->nu) ? (R/mmp->nu)*mmp->nu : R;
      }
      if (DOIT)
      {
         double mf;
         int blask = mmp->blask;
         int mvflags = mmp->flag;
         ATL_MMF_MVPUT(mmp->flag, 4);
         mmp->blask = ATL_KTRSM;
         mf = TimeMMKernel(0, tfl, mmp, pre, NR, NR, B, 1, 0, -1);
         mmp->blask = blask;
         mmp->flag = mvflags;
         printf("      ID=%d : B=%u, NRHS=%u U=(%2u,%2u) TRANS=%c, mf=%.2f\n", 
                mmp->ID, B, R, mmp->mu, mmp->nu, TA[it], mf);
         if (mf > mfB)
         {
            mmp->TA = mmp->TB = it ? AtlasTrans : AtlasNoTrans;
            mfB = mmp->mflop[0] = mf;
         }
      }
   }
   return(mfB);
}

ATL_mmnode_t *timeAllTRSM(char pre, int flag, int B, int R, ATL_mmnode_t *mb)
/*
 * Times all TRSM in mb with kb=B and NRHS roughly R, returns pointer to
 * cloned node of best performing
 */
{
   double mfB=0.0;
   ATL_mmnode_t *mp, *mmB=NULL;
   const int RIGHT=(flag&(1<<TSM_RIGHT));

      printf("   FINDING BEST TRSM KERNEL B=(%u,%u):\n", B, R);
   for (mp=mb; mp; mp = mp->next)
   {
      double mf;
      mf = timeTRSM(pre, flag, B, R, mp);
      if (mf > mfB)
      {
         mfB = mf;
         mmB = mp;
      }
   }
   if (!mmB)
   {
      printf("   NO CASE FOUND FOR B=(%u,%u)\n", B, R);
      return(NULL);
   }
   mmB = CloneMMNode(mmB);
   assert(mmB->mflop[0] == mfB);
   mmB->mbB = mmB->nbB = mmB->kbB = B;
   if (RIGHT)
      mmB->mbB = R;
   else
      mmB->nbB = R;
      
   printf(
      "   BEST CASE FOR B=(%u,%u): ID=%u, U=(%u,%u,%u), TRANS=%c, mf=%.2f\n",
          B, R, mmB->ID, mmB->mu, mmB->nu, mmB->ku,
          (mmB->TA == AtlasTrans)?'T':'N', mfB);
   return(mmB);
}

ATL_mmnode_t *findBestU(char pre, int flag, int B, int R, int U)
/*
 * Finds the best case with ku=1, and either mu OR nu = U
 */
{
   ATL_mmnode_t *mmb, *mmp, *mmB=NULL;
   int mb, nb, transB=0;
   double mfB=0.0;
   const int RIGHT=(flag&(1<<TSM_RIGHT));

   mmp = mmb = ReadMMFileWithPath(pre, "res", "WORKING.sum");
   while (mmp)
   {
      ATL_mmnode_t *nxt=mmp->next;
      if ((mmp->mu != U && mmp->nu != U) || (U%(mmp->ku)) || 
          !FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
         mmb = KillMMNodeFromQ(mmb, mmp);
      mmp = nxt;
   }
   printf("\nTIMING U=%u CASES FOR B=%u, NRHS=%u:\n", U, B, R);
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      double mf;
      int it;
      mmp->blask = ATL_KTRSM;
      mf = timeTRSM(pre, flag, B, R, mmp);
      if (mf > mfB)
      {
         mmB = mmp;
         mfB = mf;
         transB = (mmp->TA == AtlasTrans) ? 1:0;
      }
   }
   if (mmB)
   {
      mmb = RemoveMMNodeFromQ(mmb, mmB);
      mmB->mbB = mmB->kbB = mmB->nbB = B;
      if (RIGHT)
         mmB->mbB = R;
      else
         mmB->nbB = R;
      mmB->mflop[0] = mfB;
      mmB->TA = mmB->TB = transB;
      printf(
      "BEST U=%u CASE FOR B=%u,%u: ID=%u, U=(%u,%u,%u), TRANS=%c, mf=%.2f\n\n",
             U, B, R, mmB->ID, mmB->mu, mmB->nu, mmB->ku, transB?'T':'N', mfB);
   }
   else
      printf("NO USER CASES FOUND FOR U=%u.\n\n", U);
   KillAllMMNodes(mmb);
   return(mmB);
}

void findBestTRSM(char pre, int flag, ATL_mmnode_t *kb)
{
   ATL_mmnode_t *bb;   /* blocking base det by left or right setting */
   ATL_mmnode_t *tb=NULL; /* trsm best case queue, 1 for each entry in opmek */
   ATL_mmnode_t *bp, *mp;
   int R=1, maxB=1, BN, BNN;
   double mf;
   char fnout[16];
   sprintf(fnout, "trsm%c_%c%c.sum", (flag&(1<<TSM_RIGHT))?'R':'L',
           (flag&(1<<TSM_UPPER))?'U':'L',(flag&(1<<TSM_TRANSA))?'T':'N');
/*
 * Get NB that we will tune TRSM for
 */
   if (flag & (1<<TSM_RIGHT))
      bb = ReadMMFileWithPath(pre, "res", "opnek.sum");
   else
      bb = ReadMMFileWithPath(pre, "res", "opmek.sum");
/*
 * Compute RHS (R) to use, and find maxNB we'll see
 */
   for (mp=kb; mp; mp = mp->next)
   {
      R = ATL_iLCM(R, mp->nu);
      R = ATL_iLCM(R, mp->mu);
   }
   for (mp=bb; mp; mp = mp->next)
   {
      maxB = Mmax(maxB, mp->kbB);
      R = ATL_iLCM(R, mp->nu);
      R = ATL_iLCM(R, mp->mu);
   }
   if (maxB > R)
      R = (maxB/R)*R;  /* NRHS to time */
   else
      R = maxB;
   BN = bb->kbB;
/*
 * This is commented out, because it is bringing in very slow kerns
 * and I don't want to hassle with new kerns showing up due to TRSM.
 * Once install is working, we'll extend so it can cause new amm to be
 * added, then we need to add a version of this that adds kerns only
 * when the perform well on small problems!
 */
   #if 0
/*
 * Find best user U=[1-3] cases, so we have kerns that can do very small
 * block factors w/o huge performance loss
 */
   mp = findBestU(pre, flag, bb->kbB, R, 1);
   if (mp)
   {
      mp->next = kb;
      kb = mp;
      mf = mp->mflop[0];
   }
   else
      mf = 0.0;
   if (bb->next)
   {
      BN = bb->next->kbB;
      if (bb->next->next)
         BNN = bb->next->next->kbB;
      else
         BNN = BN;
   }
   else
      BNN = BN;
   mp = findBestU(pre, flag, BN, R, 2);
   if (mp)
   {
      if (mp->mflop[0] > mf)
      {
         mf = mp->mflop[0];
         mp->next = kb;
         kb = mp;
      }
      else
          KillMMNode(mp);
   }
   mp = findBestU(pre, flag, BNN, R, 3);
   if (mp)
   {
      if (mp->mflop[0] > mf)
      {
         mp->next = kb;
         kb = mp;
      }
      else
          KillMMNode(mp);
   }
   #endif
/*
 * Now look thru block sizes, and pick best-performing
 */
   printf("FINDING BEST TRSM KERNEL FOR %u BLOCK FACTORS:\n", 
          ATL_CountNumberOfMMNodes(bb));
   for (bp=bb; bp; bp = bp->next)
   {
      BN = bp->kbB;
      double mfB = 0.0;
      ATL_mmnode_t *mmB=NULL;
      @BEGINSKIP
      printf("   FINDING BEST TRSM KERNEL B=(%u,%u):\n", BN, R);
      for (mp=kb; mp; mp = mp->next)
      {
         mf = timeTRSM(pre, flag, BN, R, mp);
         if (mf > mfB)
         {
            mfB = mf;
            mmB = mp;
         }
      }
      printf(
      "   BEST CASE FOR B=(%u,%u): ID=%u, U=(%u,%u,%u), TRANS=%c, mf=%.2f\n",
             BN, R, mmB->ID, mmB->mu, mmB->nu, mmB->ku,
             (mmB->TA == AtlasTrans)?'T':'N', mfB);
      @ENDSKIP
      mmB = timeAllTRSM(pre, flag, BN, R, kb);
      assert(mmB);
      mmB->next = tb;
      tb = mmB;
   }
   tb = ReverseMMQ(tb);
   printf("\nBEST CASES:\n");
   PrintMMNodes(stdout, tb);
   WriteMMFileWithPath(pre, "res", fnout, tb);
   KillAllMMNodes(tb);
   KillAllMMNodes(bb);
   KillAllMMNodes(kb);
}

int main(int nargs, char **args)
{
   char pre;
   int flag;
   ATL_mmnode_t *mb;

   pre = GetFlags(nargs, args, &flag);
   mb = getAllCandKerns(pre, flag);
   PrintMMNodes(stdout, mb);
   findBestTRSM(pre, flag, mb);
   return(0);
}
@ROUT trsmgen
/*
 * Actually generates TRSM micro & nano kernels and their Makefile, and
 * moves this to BLDdir/src/blas/ukernel/<pre>UTRSM
 * Actual performance data is handled by views.
 */
#include "atlas_mmgen.h"
#include "atlas_type.h"
void GenTrsmALLT(char pre, FILE *fp, ATL_mmnode_t *mb)
{
   ATL_mmnode_t *mp;
   unsigned long long flg=0;
   int k, L, n;

   for (n=0, mp=mb; mp; n++, mp=mp->next)
   {
      if (mp->TA == AtlasTrans && mp->TB == AtlasTrans)
         flg |= (1L<<n);
   }
   assert(sizeof(long long) >= ATL_PSIZE);
   assert((ATL_PSIZE<<3) >= n);
   fprintf(fp, "#define ATL_trsm_allT(i_) ((0x%lxL>>(i_))&1)\n", flg);
}

char *GetTrsmDecor(char pre, char sd, char up, char ta, ATL_mmnode_t *mp)
{
   static char fn[64];
   char ALLT = (mp->TA == AtlasTrans && mp->TB == AtlasTrans) ? 'T':'N';
   if (ALLT == 'T')
      sprintf(fn, "%c_%c%c%ux%u%c", sd, up, ta, mp->nu, mp->mu, ALLT);
   else
      sprintf(fn, "%c_%c%c%ux%u%c", sd, up, ta, mp->mu, mp->nu, ALLT);
   return(fn);
}

void genTrsmHead(char pre, char *outd, char sd, char up, char ta,
                 ATL_mmnode_t *mb, ATL_mmnode_t *ub)
{
   char *of;
   FILE *fp;
   ATL_mmnode_t *mp;
   int k, L, n, muoff, nuoff, nxtoff;
   L = strlen(outd) + 24;
   of = malloc(L);
   assert(of);

   k = sprintf(of, "%s/atlas_%cutrsm%c_%c%c.h", outd, pre, sd, up, ta);
   assert(k<L);
   fp = fopen(of, "w");
   assert(fp);
   fprintf(fp, "#ifndef ATLAS_%cTRSM%c_%c%c_H\n", 
           toupper(pre), toupper(sd), toupper(up), toupper(ta));
   fprintf(fp, "   #define ATLAS_%cTRSM%c_%c%c_H 1\n\n", 
           toupper(pre), toupper(sd), toupper(up), toupper(ta));

   fprintf(fp, "#include \"atlas_amm.h\"\n");
   GenTrsmALLT(pre, fp, mb);
   fprintf(fp, "/*\n * TRSM microkernel prototypes\n */\n");
   for (mp=ub; mp; mp = mp->next)
   {
      char *nm;
      nm = GetTrsmDecor(pre, sd, up, ta, mp);
      fprintf(fp, "void ATL_%cutrsm%s\n", pre, nm);
      fprintf(fp, "   (ipinfo_t *ip, const enum ATLAS_DIAG Diag,\n"
              "    ATL_CINT N, ATL_CINT R, const SCALAR alpha, const TYPE *A,"
              " ATL_CINT lda,\n    TYPE *X, ATL_CINT ldx, TYPE *diag, "
              "TYPE *L, TYPE *RW, TYPE *w);\n");
   }
   fprintf(fp, "\n#ifndef ATL_NOLOOKUP\n");
   fprintf(fp, "static INLINE void *findutrsm%c_%c%c(ATL_UINT idx, "
           "ATL_UINT mu, ATL_UINT nu)\n", sd, up, ta);
   fprintf(fp, "{\n");
   fprintf(fp, "   ATL_UINT ALLT;\n");
   fprintf(fp, "   void *vp=NULL;\n");
   fprintf(fp, "\n");
   fprintf(fp, "   ALLT = ATL_trsm_allT(idx);\n");
   fprintf(fp, "   switch(mu)\n   {\n");
   ub = CloneMMQueue(ub);
   muoff = GetOffset(&ub->mu, ub);
   nuoff = GetOffset(&ub->nu, ub);
   nxtoff = GetOffset(&mb->next, mb);
   ub = SortListByIval_G2L(ub, nxtoff, muoff);
   while(ub)
   {
      char *nm;
      int mu=ub->mu, nu=ub->nu;
      int n;
      ATL_mmnode_t *mub, *mp, *last;

      fprintf(fp, "   case %u:\n", mu);
/*
 *    Remove all identical mu kernels from queue
 */
      last = mub = ub;
      for (n=0,mp=mub->next; mp && mp->mu == mu; mp = mp->next, n++)
         last = mp;
      ub = mp;
      last->next = NULL;
/*
 *    Find if there's another utrsm with same mu & nu, then one must be
 *    using transpose case while other does not
 */
      mp = FindNodeWithIval(mub->next, nxtoff, nuoff, mub->nu);
      if (mp)
      {
         mub = RemoveNodeFromList(mub, mp, nxtoff);
         n--;
      }
      nm = GetTrsmDecor(pre, sd, up, ta, mub);
      if (n == 1)  /* is there only 1 kernel with this mu? */
      {
         if (mp)
         {
            int ALLT = (mub->TA == AtlasTrans && mub->TB == AtlasTrans);
            fprintf(fp, "         vp = (%s) ? ATL_%cutrsm%s :",
                    ALLT ? "ALLT":"!ALLT", pre, nm);
            nm = GetTrsmDecor(pre, sd, up, ta, mp);
            fprintf(fp, " ATL_%cutrsm%s;\n", pre, nm);
            KillMMNode(mp);
         }
         else
            fprintf(fp, "         vp = ATL_%cutrsm%s;\n", pre, nm);
         mub = KillMMNode(mub);
      }
      else
      {
         while(mub)
         {
            n = CountListEntries(mub, nxtoff);
            if (n > 1)
            {
               fprintf(fp, "      switch(nu)\n      {\n");
               fprintf(fp, "      case %u:\n", mub->nu);
            }
            if (mp)
            {
               int ALLT = (mub->TA == AtlasTrans && mub->TB == AtlasTrans);
               fprintf(fp, "         vp = (%s) ? ATL_%cutrsm%s :",
                       ALLT ? "ALLT":"!ALLT", pre, nm);
               nm = GetTrsmDecor(pre, sd, up, ta, mp);
               fprintf(fp, " ATL_%cutrsm%s;\n", pre, nm);
               KillMMNode(mp);
            }
            else
               fprintf(fp, "         vp = ATL_%cutrsm%s;\n", pre, nm);
            if (n > 1)
               fprintf(fp,    "         break;\n");
            mub = KillMMNode(mub);
            if (mub)
            {
               nm = GetTrsmDecor(pre, sd, up, ta, mub);
               mp = FindNodeWithIval(mub->next, nxtoff, nuoff, mub->nu);
               if (mp)
                  mub = RemoveNodeFromList(mub, mp, nxtoff);
            }
            if (n > 1)
               fprintf(fp, "      } /* end switch on nu */\n");
         }
      }
      fprintf(fp, "      break;\n");
   }
   fprintf(fp, "   } /* end switch on mu */\n");
   fprintf(fp, "} /* end findUtrsm */\n");
   fprintf(fp, "#endif /* end no-lookup guard */\n");

   fprintf(fp, "\n#endif /* end multiple inclusion guard */\n");
   fclose(fp);
   free(of);
}

ATL_mmnode_t *getUniqueTrsmCases(char pre, ATL_mmnode_t *ub, ATL_mmnode_t *mb)
/*
 * Adds all cases of unique cases in mb to ub; mb nodes are cloned, so
 * mb is unchanged.  ub is already assumed unique on entry, so it is only
 * added to.
 * RETURNS: possibly changed ub
 */
{
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
   {
      ATL_mmnode_t *p;
      int mu=mp->mu, nu=mp->nu;
      char ALLT=(mp->TA == AtlasTrans && mp->TB == AtlasTrans) ? 'T' : 'N';
      assert(mp->TA == mp->TB);
      for (p=ub; p; p = p->next)
      {
         int mu0=p->mu, nu0=p->nu;
         char ALLT0=(p->TA == AtlasTrans && p->TB == AtlasTrans) ? 'T' : 'N';
         if (mu0 == mu && nu0 == nu && ALLT0 == ALLT) /* already seen this */
            break;                                    /* case so stop */
      }
      if (p == NULL)  /* this case not already in unique queueu */
      {
         p = CloneMMNode(mp);
         p->next = ub;
         ub = p;
      }
   }
   return(ub);
}

ATL_mmnode_t *GenMicroTrsm(char pre, char *outd, char sd, char up, char ta,
                           ATL_mmnode_t *mb)
{
   ATL_mmnode_t *mp, *ub;
   int *mus, *nus;
   char *fn;
   int i, L;
   int nmu, nnu;
   char *ln;

   L = strlen(outd) + 256;
   ln = malloc(L);
   assert(ln);
   ub = getUniqueTrsmCases(pre, NULL, mb);
   for (mp=ub; mp; mp = mp->next)
   {
      int mu=mp->mu, nu=mp->nu;
      char *nm;
      char ALLT=(mp->TA == AtlasTrans && mp->TB == AtlasTrans) ? 'T' : 'N';

      assert(mu > 0 && nu > 0 && mu < 1000 && nu < 1000);
      nm = GetTrsmDecor(pre, sd, up, ta, mp);
      i = sprintf(ln, "make gen_utrsm tALL=%c mu=%u nu=%u sd=%c up=%c ta=%c"
                  " cx=\"%s\" cnj=N rt=\"%s/ATL_utrsm%s.c\"", 
                  ALLT, mu, nu, sd, up, ta, (pre == 'c' || pre == 'z')?"c":"",
                  outd, nm);
      assert(i < L);
      assert(!Sys2File(ln, NULL));
   }
   free(ln);
   return(ub);
}

void GenMakeTrsm(char pre, char *outd, char up, char *sds, char *tas, 
                 ATL_mmnode_t **MBs)
{
   int k, i;
   FILE *fp;
   char *fn, *typ, *comp;

   k = strlen(outd) + 10;
   fn = malloc(k);
   assert(fn);
   i = sprintf(fn, "%s/Makefile", outd);
   fp = fopen(fn, "w");
   assert(fp);
   free(fn);
   fprintf(fp, "include ../Make.inc\n\n");

   fprintf(fp, "lib : %clib.grd\n", pre);
   fprintf(fp, "all : %clib.grd\n", pre);
   fprintf(fp, "clean : %cclean\n\n", pre);

   fprintf(fp, "obj = ");
   if (pre == 'c' || pre == 's')
      comp = "$(SKC)";
   else
      comp = "$(DKC)";
   if (pre == 'z')
      typ = "DCPLX";
   else if (pre == 'c')
      typ = "SCPLX";
   else if (pre == 's')
      typ = "SREAL";
   else
      typ = "DREAL";
   for (k=0; k < 2; k++)
   {
      int s;
      for (i=s=0; s < 2; s++)
      {
         char sd=sds[s];
         int it;

         for (it=0; it < 2; it++)
         {
            ATL_mmnode_t *mp;
            char ta = tas[it];
            const int NCNJ = (ta == 'T' && (pre == 'c' || pre == 'z')) ? 2:1;

            for (mp=MBs[i++]; mp; mp=mp->next)
            {
               int c;
               for (c=0; c < NCNJ; c++)
               {
                  char *nm;
                  nm = GetTrsmDecor(pre, sd, up, ta, mp);
                  if (c)
                     nm[3] = 'H';
                  if (!k)
                     fprintf(fp, "\\\n      ATL_%cutrsm%s.o ", pre, nm);
                  else
                  {
                     fprintf(fp, "ATL_%cutrsm%s.o : ", pre, nm);
                     if (c)
                        nm[3] = 'T';
                     fprintf(fp, "ATL_utrsm%s.c $(deps)\n", nm);
                     if (c)
                        fprintf(fp, 
                "\t%s $(%cKCFLAGS) -c -o $@ -D%s=1 -DConj_=1 ATL_utrsm%s.c\n",
                           comp, pre, typ, nm);
                     else
                        fprintf(fp, 
                           "\t%s $(%cKCFLAGS) -c -o $@ -D%s=1 ATL_utrsm%s.c\n", 
                                comp, pre, typ, nm);
                  }
               }
            }
         }
      }
      if (!k)
      {
         fprintf(fp, "\n\n%clib : %clib.grd\n", pre, pre);
         fprintf(fp, "%clib.grd : $(obj)\n", pre);
         fprintf(fp, "\t$(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(obj)\n");
         fprintf(fp, "\t$(RANLIB) $(ATLASlib)\n\ttouch %clib.grd\n\n", pre);
      }
   }
   fclose(fp);
}

void GenAllTrsm(char pre, char *outd)
{
   int L, i, s;
   char sds[2] = {'L', 'R'};
   char tas[2] = {'N', 'T'};
   char up='L';
   char *od;
   char fn[16];
   ATL_mmnode_t *MBs[4];
/*
 * Delete and the re-create <pre>UTRSM subdir
 */
   L = strlen(outd) + 8 + 7;
   od = malloc(L);
   assert(od);
   i = sprintf(od, "rm -rf %s/%cUTRSM", outd, pre);
   assert(i < L);
   Sys2File(od, NULL);
   od[0]='m'; od[1]='k'; od[2]='d'; od[3]='i'; od[4]='r'; od[5]=' ';
   assert(!Sys2File(od, NULL));
   strcpy(fn, "trsmS_LN.sum");

   for (i=s=0; s < 2; s++)
   {
      char sd=sds[s];
      int it;

      for (it=0; it < 2; it++)
      {
         char ta = tas[it];
         ATL_mmnode_t *mb;
         fn[4] = sd;
         fn[7] = ta;
         mb = ReadMMFileWithPath(pre, "res", fn);
         MBs[i] = GenMicroTrsm(pre, od+7, sd, up, ta, mb);
         genTrsmHead(pre, od+7, sd, 'L', ta, mb, MBs[i]);
         KillAllMMNodes(mb);
         i++;
      }
   }
   GenMakeTrsm(pre, od+7, up, sds, tas, MBs);
   for (i=0; i < 4; i++)
      KillAllMMNodes(MBs[i]);
   free(od);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   fprintf(stderr,
"This will create the <pre>UTRSM subdir in <outdir>, and populate it with\n"
"all utrsm kernels and their Makefile.\n");
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr,"USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -o <path>: what directory to output all files to?\n");
   fprintf(stderr, "   -p [s,d]: set type/precision prefix (d) \n"
           "      s/d will generate for complex (c/z) as well\n");

   exit(ierr ? ierr : -1);
}

char *GetFlags(int nargs, char **args, char *PRE)
{
   FILE *fpin=stdin;
   ATL_mmnode_t *mb=NULL, *bkb=NULL, *mp;
   char *outd=NULL;
   int i;
   char pre='d';

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 'o':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         outd = DupString(args[i]);
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (!outd)
      outd = DupString("tmp");

   *PRE = pre;
   return(outd);
}

int main(int nargs, char **args)
{
   char *outd;
   char pre;
   outd = GetFlags(nargs, args, &pre);
   GenAllTrsm(pre, outd);
   free(outd);
   return(0);
}
@ROUT !
