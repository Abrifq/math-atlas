@ROUT damcases.idx samcases.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
# The file has the following format:
# ROUT='routine name' AUTH='author names' COMP='compiler name' CFLAGS='flags'
# ID=<id> NU=<nu> MU=<mu> KU=<ku> KBMAX=<kbmax> KBMIN=<kbmin>
# SSE=[0,1,2,3] X87=[0,1] BMABC=<0/1> BMAB=<0/1> JKMAB=<0/1> JKMABC=<0/1>
# AOUTER=<0/1> BETAN1=<0/1> KRUNTIME=<0/1> LDCTOP=<0/1> X87=<0/1>
# ASM=[asmlist], eg., asmlist is "GAS_x8664,GAS_x8632" or "GAS_SPARC"
# ASM defaults to no assembly dialect required.
# If NU/MU is negative, then the routine can only handle multiples of NU/MU.
#
@ROUT damcases.idx
ID=1 MU=4 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm2x4x1_sse2.S' \
     SSE=3 KRUNTIME=1 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=2 MU=4 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm2x4x256_sse2.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=3 MU=6 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm3x3x256_sse2.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
#ID=4 MU=4 NU=1 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_dammm_nb4_sse2.S' \
#     SSE=3 KBMIN=4 KBMAX=4 ASM=GAS_x8664 KUISKB=1 \
#     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=5 MU=2 NU=12 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm2x12x2_sse2.S' \
     SSE=3 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=6 MU=2 NU=12 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm2x12x256_sse2.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=7 MU=12 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm12x3x256_avx.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=8 MU=6 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm6x3x256_sse3.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=9 MU=6 NU=3 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_damm6x3x4_sse3.S' \
     SSE=3 KBMIN=4 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=10 MU=2 NU=12 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm2x12x2_sse2.S' \
     SSE=3 KRUNTIME=1 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=11 MU=12 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm12x3x1_avx.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=12 MU=4 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm4x4x2rp_arm.S' \
     ASM=GAS_ARM KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3'
ID=13 MU=12 NU=3 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm12x3x2_avx.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 KBMIN=6 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=14 MU=16 NU=2 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_damm16x2_kb4_avx.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=0 KBMIN=4 KBMAX=4 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=15 MU=5 NU=5 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm5x5x2_arm.S' \
     KBMIN=2 ASM=GAS_ARM KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3'
ID=16 MU=6 NU=1 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_amm6x1x1_x87.S' \
     ASM=GAS_x8664,GAS_x8632 KRUNTIME=1 x87=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp'
ID=17 MU=24 NU=1 KU=8 AUTH="R. Clint Whaley" ROUT='ATL_damm24x1x8_sse2.S' \
     SSE=3 KRUNTIME=1 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=18 MU=24 NU=1 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm24x1x1_sse2.S' \
     SSE=3 KRUNTIME=1 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=19 MU=5 NU=5 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm5x5x2_armpf.S' \
     KBMIN=2 ASM=GAS_ARM KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3'
ID=20 MU=5 NU=5 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm5x5x1_armpf.S' \
     KBMIN=2 ASM=GAS_ARM KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3'
ID=21 MU=12 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm12x4x1_fma3.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx -mfma'
ID=22 MU=3 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm3x4x1_armpf.S' \
     KBMIN=2 ASM=GAS_ARM KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3-fp16'
ID=23 MU=4 NU=2 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_amm4x2x4_kb4.c' \
     KRUNTIME=0 KBMIN=4 KBMAX=4 
ID=24 MU=6 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm6x4x1_fma3.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx -mfma'
ID=25 MU=6 NU=3 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm6x3x2_sse3.S' \
     SSE=3 KBMIN=4 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=26 MU=4 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm4x4x256_sse3.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=27 MU=24 NU=1 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm24x1x256_sse3.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=28 MU=6 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm6x4x256_fma3.S' \
     SSE=5 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3 -mfma'
ID=29 MU=12 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm12x4x256_fma3.S' \
     SSE=5 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3 -mfma'
ID=30 MU=12 NU=4 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm12x4x2_fma3.S' \
     SSE=3 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx -mfma'
ID=31 MU=6 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm6x3r2x256_sse3.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=32 MU=14 NU=1 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_dkmmm14x1x256_sse3.S' \
     SSE=3 KMAJ=2 ASM=GAS_x8664 KBMIN=2 KBMAX=256 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=33 MU=14 NU=1 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_dkmmm14x1x2_sse3.S' \
     SSE=3 KMAJ=2 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3'
ID=34 MU=24 NU=8 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm24x8x1_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=35 MU=32 NU=4 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm32x4x2rp_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
#ID=36 MU=32 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm32x4x256_avxz.S' \
#      ASM=GAS_x8664 KBMAX=320 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=37 MU=32 NU=6 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm32x6x1_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=38 MU=16 NU=8 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_damm16x8x4_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=40 MU=24 NU=8 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm24x8x2_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=41 MU=8 NU=8 KU=8 AUTH="R. Clint Whaley" ROUT='ATL_amm8x8x8_avxz.S' \
      KRUNTIME=0 KBMAX=8 KBMIN=8 ASM=GAS_x8664 \
      COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
@ROUT samcases.idx
ID=1 MU=16 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_samm16x4x1_av.c' \
     KRUNTIME=1 COMP='gcc' CFLAGS='-Os -maltivec -mabi=altivec -mcpu=970 -mtune=970 -mvrsave -fschedule-insns2 -fno-schedule-insns'
ID=2 MU=4 NU=6 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_samm4x6x2_arm.S' \
     ASM=GAS_ARM KRUNTIME=1 KBMIN=4 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3'
ID=3 MU=4 NU=6 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_samm4x6x1_arm.S' \
     ASM=GAS_ARM KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mfpu=vfpv3'
ID=7 MU=24 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_samm24x3x256_avx.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
ID=8 MU=8 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_sammm8x4x256_sse2.S' \
     SSE=2 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=16 MU=6 NU=1 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_amm6x1x1_x87.S' \
     ASM=GAS_x8664,GAS_x8632 KRUNTIME=1 x87=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp'
ID=23 MU=4 NU=2 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_amm4x2x4_kb4.c' \
     KRUNTIME=0 KBMIN=4 KBMAX=4 
ID=24 MU=24 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_sammm24x4x256_fma3.S' \
     SSE=5 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse3 -mfma'
ID=25 MU=24 NU=4 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_samm24x4x2_fma3.S' \
     SSE=5 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx -mfma'
ID=26 MU=12 NU=1 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_skmmm12x1x4_sse3.S' \
     SSE=3 KMAJ=4 ASM=GAS_x8664 KRUNTIME=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=27 MU=12 NU=1 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_skmmm12x1x256_sse3.S' \
     SSE=3 KMAJ=4 ASM=GAS_x8664 KRUNTIME=0 KBMIN=4 KBMAX=256 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
#ID=26 MU=12 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_sammm12x3d2x256_sse3.S' \
#     SSE=3 DUPB=2 KBMAX=256 ASM=GAS_x8664 \
#     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=34 MU=48 NU=8 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm24x8x1_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=35 MU=64 NU=4 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm32x4x2rp_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
#ID=36 MU=64 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm32x4x256_avxz.S' \
#      ASM=GAS_x8664 KBMAX=320 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=37 MU=64 NU=6 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm32x6x1_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=38 MU=32 NU=8 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_damm16x8x4_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
ID=40 MU=48 NU=8 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm24x8x2_avxz.S' \
      ASM=GAS_x8664 KRUNTIME=1 COMP='icc' CFLAGS='-x assembler-with-cpp -mmic'
@ROUT atlas_gnuvec.h
#ifndef ATLAS_GNUVEC
   #define ATLAS_GNUVEC 1
   #ifndef TYPE
      #if defined(SREAL) || defined(SCPLX)
         #define TYPE float
      #else
         #define TYPE double
      #endif
   #endif
   #ifdef ATL_VSX
      #define ATL_NVREG 64
      #define ATL_VLENb 16
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_VLEN 4
      #else
         #define ATL_VLEN 2
      #endif
   #elif defined(ATL_AltiVec)
      #define ATL_NVREG 32
      #define ATL_VLENb 16
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_VLEN 4
      #else
         #define ATL_VLEN 2
      #endif
   #elif defined(ATL_AVXZ)
      #include "immintrin.h"
      #define ATL_NVREG 32
      #define ATL_VLENb 64
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_VLEN 16
         #define ATL_gvbcast(ptr_, v_) \
            v_ = _mm512_extload_ps((void*)(ptr_), _MM_UPCONV_PS_NONE, \
                                   _MM_BROADCAST_1X16, 0)
      #else
         #define ATL_VLEN 8
         #define ATL_gvbcast(ptr_, v_) \
            v_ = _mm512_extload_pd((void*)(ptr_), _MM_UPCONV_PD_NONE, \
                                   _MM_BROADCAST_1X8, 0)
      #endif
   #elif defined(ATL_AVXMAC) || defined(ATL_AVXFMA4) || defined(ATL_AVX)
      #ifdef ATL_GAS_x8664
         #define ATL_NVREG 16
      #else
         #define ATL_NVREG 8
      #endif
      #define ATL_VLENb 32
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_VLEN 8
      #else
         #define ATL_VLEN 4
      #endif
      #define ATL_gvbcast(ptr_, v_) \
         (v_) = __builtin_ia32_vbroadcastsd256((void*)(ptr_));
   #elif defined(ATL_SSE3) || defined(ATL_SSE2)
      #ifdef ATL_GAS_x8664
         #define ATL_NVREG 16
      #else
         #define ATL_NVREG 8
      #endif
      #define ATL_VLENb 16
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_VLEN 4
      #else
         #define ATL_VLEN 2
         #ifdef ATL_SSE3
            #define ATL_gvbcast(ptr_, v_) \
               (v_) = __builtin_ia32_loaddup(ptr_);
         #endif
      #endif
   #elif defined(SREAL) || defined(SCPLX)   /* single-only stuff */
      #ifdef ATL_AltiVec
         #define ATL_NVREG 32
         #define ATL_VLENb 16
         #define ATL_VLEN 4
      #elif defined(ATL_SSE1)
         #ifdef ATL_GAS_x8664
            #define ATL_NVREG 16
         #else
            #define ATL_NVREG 8
         #endif
         #define ATL_VLENb 16
         #define ATL_VLEN 4
      #elif defined(ATL_NONIEEE) && ATL_NONIEEE != 0
         #ifdef ATL_NEON
            #define ATL_NVREG 16
            #define ATL_VLENb 8
            #define ATL_VLEN 2
         #elif defined(ATL_3DNow)
            #define ATL_NVREG 8
            #define ATL_VLENb 16
            #define ATL_VLEN 4
         #endif
      #endif
   #endif
   #ifndef ATL_VLENb
      #define ATL_VLEN 1
      #if defined(SREAL) || defined (SCPLX)
         #define ATL_VLENb 4
      #else
         #define ATL_VLENb 8
      #endif
      #if defined(ATL_GAS_x8664) || defined(ATL_GAS_x8632)
         #define ATL_NVREG 8
      #else
         #define ATL_NVREG 32
      #endif
   #endif
   #ifndef ATL_vec_t
      #if ATL_VLEN > 1
         typedef TYPE ATL_vec_t  __attribute__ ((vector_size (ATL_VLENb)));
      #else
         #define ATL_vec_t TYPE
      #endif
   #endif
/*
 * Setup macros to multiply and divide by VLEN using shifts
 */
   #if ATL_VLEN == 1
      #define ATL_DivByVLEN(i_) (i_)
      #define ATL_MulByVLEN(i_) (i_)
@iexp s 1 0 +
@iexp i 2 0 +
@iwhile i < 64
   #elif ATL_VLEN == @(i)
      #define ATL_DivByVLEN(i_) ((i_)>>@(s))
      #define ATL_MulByVLEN(i_) ((i_)<<@(s))
   @iexp s @(s) 1 +
   @iexp i @(i) 2 *
@endiwhile
   #else
      #define ATL_DivByVLEN(i_) ((i_)/ATL_VLEN)
      #define ATL_MulByVLEN(i_) ((i_)*ATL_VLEN)
   #endif
   #ifndef ATL_gvbcast
      #if ATL_VLEN == 1
         #define ATL_gvbcast(ptr_, v_) \
            { ATL_vec_t z={*(ptr_)}; v_ = z; }
      #elif ATL_VLEN == 2
         #define ATL_gvbcast(ptr_, v_) \
            { ATL_vec_t z={*(ptr_),*(ptr_)}; v_ = z; }
      #elif ATL_VLEN == 4
         #define ATL_gvbcast(ptr_, v_) \
            { ATL_vec_t z={*(ptr_),*(ptr_),*(ptr_),*(ptr_)}; v_ = z; }
      #elif ATL_VLEN == 8
         #define ATL_gvbcast(ptr_, v_) \
            v_ = {*(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                  *(ptr_), *(ptr_), *(ptr_), *(ptr_)}
      #elif ATL_VLEN == 16
         #define ATL_gvbcast(ptr_, v_) \
         { \
            ATL_vec_t z_ = {*(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                  *(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                  *(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                  *(ptr_), *(ptr_), *(ptr_), *(ptr_), \
                 } \
            v_ = z_; \
         }
      #else
         #error "Cannot create gvbcast"
      #endif
   #endif
   
#endif
@ROUT atlas_amm.h
#ifndef ATLAS_AMM_H
   #define ATLAS_AMM_H

#include "atlas_misc.h"

#ifndef ATL_MaxMalloc
   #define ATL_MaxMalloc 67108864  /* 64 MB */
#endif
#ifdef TREAL
   typedef void (*cm2am_t)(const size_t, const size_t, const SCALAR,
                          const TYPE*, const size_t, TYPE*);
   typedef void (*ablk2cmat_t)(const size_t, const size_t, const SCALAR,
                               const TYPE*, const SCALAR, TYPE *, const size_t);
   typedef void (*cmat2ablk_t)(const size_t, const size_t, const SCALAR,
                               const TYPE*, const size_t, const SCALAR,TYPE*);
#else
   typedef void (*cm2am_t)(const size_t, const size_t, const SCALAR,
                          const TYPE*, const size_t, TYPE*, TYPE*);
   typedef void (*ablk2cmat_t)(const size_t, const size_t, const SCALAR,
                               const TYPE*, const TYPE*, const SCALAR, 
                               TYPE *, const size_t);
   typedef void (*cmat2ablk_t)(const size_t, const size_t, const SCALAR,
                               const TYPE*, const size_t, const SCALAR,
                               TYPE*,TYPE*);
#endif
typedef void (*ammkern_t)(ATL_CSZT,ATL_CSZT,ATL_CSZT,const TYPE*,const TYPE*,
                          TYPE*, const TYPE*, const TYPE*, const TYPE*);
typedef struct amminfo amminfo_t;
struct amminfo
{
   cm2am_t a2blk, b2blk;
   ablk2cmat_t Cblk2cm;
   cmat2ablk_t cm2Cblk;
   ammkern_t amm_b0, amm_b1, amm_bn, amm_k1_b0, amm_k1_b1, amm_k1_bn;
   unsigned short IDX, mb, nb, kb, kbmin;
   unsigned char flag, mu, nu, ku;
};

enum ATL_AMMALG {ATL_amm1b, ATL_ammrkK, ATL_NMK};

@whiledef info GetAmmmInfo GetRankKInfo
int Mjoin(PATL,@(info))
   (amminfo_t *out, enum ATLAS_TRANS TA, enum ATLAS_TRANS TB, ATL_CSZT M, 
    ATL_CSZT N, ATL_CSZT K, const SCALAR alpha, const SCALAR beta);
@endwhile
int Mjoin(PATL,ammm_rk2)
   (enum ATLAS_TRANS,enum ATLAS_TRANS,ATL_CSZT,ATL_CSZT, const SCALAR,
    const TYPE*,ATL_CSZT,const TYPE*,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT);
@whiledef rt ammm ammm_1b ammm_rkK ammm_IP ammm_tN ammm_aliased_rkK ammmMNK
int Mjoin(PATL,@(rt))
   (enum ATLAS_TRANS,enum ATLAS_TRANS,ATL_CSZT,ATL_CSZT,ATL_CSZT, const SCALAR,
    const TYPE*,ATL_CSZT,const TYPE*,ATL_CSZT,const SCALAR,TYPE*,ATL_CSZT);
@endwhile
int Mjoin(PATL,ammmNMK)
   (enum ATLAS_TRANS,enum ATLAS_TRANS,ATL_CSZT,ATL_CSZT,ATL_CSZT, 
    const SCALAR,const TYPE*,ATL_CSZT,const TYPE*,ATL_CSZT,const SCALAR,
    TYPE*,ATL_CSZT);
#endif  /* end include file guard */
@ROUT emit_uamm
   @define up @u@
   @define UP @U@
@extract -b @(topd)/cw.inc lang=C -def cwdate 2013
@ROUT emit_amm
   @define up @@
   @define UP @@
@extract -b @(topd)/cw.inc lang=C -def cwdate 2012 -def cwdate 2013
@ROUT emit_amm emit_uamm
#include "atlas_misc.h"
#define ATL_JKMDEF 1
#include "atlas_mmparse.h"
#include "atlas_sys.h"
@ROUT emit_uamm `   static int UID=0, UIL=1;`
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr, 
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -d <outdir>: directory to dump files to\n");
   fprintf(stderr, "   -i <infile> : can be repeated for multiple files\n");
   fprintf(stderr, "   -k <unique K cleanup index file> : \n");
   fprintf(stderr, "   -K <K cleanup by NB file> : \n");
   fprintf(stderr, "   -r <rank-K kernel file> : \n");
@ROUT emit_uamm `
   fprintf(stderr, 
      "   -I <ID> : unique non-negative ID for header/kern files\n");
@ROUT emit_amm emit_uamm
   exit(ierr ? ierr : -1);
}

ATL_mmnode_t *GetFlags(int nargs, char **args, char *PRE, char **DOUT, 
                       char **UKIN, char **KCIN, char **RKIN)
{
   int i, j=0, n, k;
   char pre='d';
   *RKIN = *UKIN = *KCIN = *DOUT = NULL;
   ATL_mmnode_t *mmb=NULL, *mmp, *mp;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      
      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 'k':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *UKIN = DupString(args[i]);
        break;
      case 'K':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *KCIN = DupString(args[i]);
        break;
@ROUT emit_uamm
      case 'I':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        UID = atol(args[i]);
        for (k=10; k <= UID; k *= 10)
           UIL++;
        break;
@ROUT emit_amm
      case 'r':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *RKIN = DupString(args[i]);
        break;
@ROUT emit_amm emit_uamm
      case 'd':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *DOUT = DupString(args[i]);
        break;
      case 'i':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        mmp = ReadMMFile(args[i]);
        if (mmb)
        {
           ATL_mmnode_t *mp;
           for (mp=mmb; mp->next; mp = mp->next);
           mp->next = mmp;
        }
        else
           mmb = mmp;
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *PRE = pre;
   if (!(*DOUT))
   {
      *DOUT = DupString("dMake_amm");
      (*DOUT)[0] = pre;
   }
   return(mmb);
}

char *GetVecStr(char pre, int vlen)
{
   if (vlen == 1)
      return("scalar");
   #ifdef ATL_AVX
      if (pre == 'd')
      {
         if (vlen == 4)
            return("avx");
         else if (vlen == 2)
            return("sse");
      }
      else if (pre == 's')
      {
         if (vlen == 8)
            return("avx");
         else if (vlen == 4)
            return("sse");
      }
   #elif defined(ATL_SSE1)
      #ifdef ATL_SSE2
         if (pre == 'd' && vlen == 2)
               return("sse");
      #endif
      if (pre == 's' && vlen == 4)
         return("sse");
   #endif
/*
 * Any vector length > 1 that isn't one of our known cases uses gnuvec
 */
   return("gvec");
}

void FillInGenStrings
(
   char pre,
   ATL_mmnode_t *mmb,  /* queue to look through */
   char *dir           /* output directory to generate into */
)
/*
 * Creates GenString for any ID=0 in mmb
 */
{
   ATL_mmnode_t *mp;
   char *frm="make gen_amm_%s lat=%d mu=%d nu=%d ku=%d kb=%d vlen=%d rt=%s/%s kmaj=%d";
   int frml;

   frml = strlen(frm);
   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->ID == 0)  /* is generated file */
      {
         int ll;
         char *sp, *vec;
         int vlen = mp->vlen;

         assert(mp->rout);  /* should have been filled in by search */
         ll = frml + strlen(dir) + strlen(mp->rout) + 8;
         sp = malloc(ll*sizeof(char));
         assert(sp);

         vec = GetVecStr(pre, mp->vlen);
         if (vec[0] == 'g' && vec[1] == 'v' && vec[2] == 'e' && vlen != 1)
            vlen *= (pre == 'd') ? 8:4;

         sprintf(sp, frm, vec, mp->lat, mp->mu, mp->nu,
                 mp->ku, FLAG_IS_SET(mp->flag, MMF_KRUNTIME) ? 0 : mp->kbB,
                 vlen, dir, mp->rout, mp->kmaj);
         mp->genstr = sp;
      }
   }
}

void PrintBegBlock(char pre, ATL_mmnode_t *mmb, char *nam, FILE *fp)
{
   ATL_mmnode_t *mp;
   char PRE = toupper(pre);
   int i;

   if (nam)
   {
      fprintf(fp, "#ifndef ATLAS_%c@(UP)AMM_%s_H\n   #define ATLAS_%c@(UP)AMM_%s_H\n\n",
              PRE, nam, PRE, nam);
      fprintf(fp, "#include \"atlas_amm.h\"\n");
   }
   else
      fprintf(fp, "#ifndef ATLAS_%c@(UP)AMM_H\n   #define ATLAS_%c@(UP)AMM_H\n\n",
              PRE, PRE);
/*
 * Count mmb, and print def of NCASES
 */
   if (!nam || strstr(nam, "RANKK") == NULL)
   {
      for (mp=mmb,i=0; mp; i++, mp = mp->next);
   
      fprintf(fp, "#ifdef ATL_@(UP)AMM_NCASES\n");
      fprintf(fp, "   #if ATL_@(UP)AMM_NCASES != %d\n", i);
      fprintf(fp, "      #error \"NCASES MISMATCH!\"\n");
      fprintf(fp, "   #endif\n");
      fprintf(fp, "#else\n");
      fprintf(fp, "   #define ATL_@(UP)AMM_NCASES %d\n", i);
      fprintf(fp, "#endif\n");
   }
}

char *GetHName(char pre, char *outd, char *bnam)
{
   int i, NOBASE=0;
   char *fnam;
   if (!bnam)
   {
      NOBASE = 1;
      bnam = "";
   }
@ROUT emit_amm `   i = strlen(outd) + strlen(bnam) + 16;`
@ROUT emit_uamm `   i = strlen(outd) + strlen(bnam) + 16+UIL;`

   fnam = malloc(i*sizeof(char));
   assert(fnam);
@ROUT emit_amm
   if (NOBASE)
      sprintf(fnam, "%s/atlas_%camm.h", outd, pre);
   else
      sprintf(fnam, "%s/atlas_%camm_%s.h", outd, pre, bnam);
@ROUT emit_uamm
   if (NOBASE)
      sprintf(fnam, "%s/atlas_%cu%damm.h", outd, pre, UID);
   else
      sprintf(fnam, "%s/atlas_%cu%damm_%s.h", outd, pre, UID, bnam);
@ROUT emit_amm emit_uamm
   return(fnam);
}

FILE *StandHStart(char pre, ATL_mmnode_t *mmb, char *outd, char *bnam)
{
   char *fnam;
   FILE *fp;
   int i;

   assert(outd);
   fnam = GetHName(pre, outd, bnam);
   fp = fopen(fnam, "w");
   assert(fp);
   if (bnam)
   {
      for (i=0; bnam[i]; i++)
         fnam[i] = toupper(bnam[i]);
      fnam[i] = '\0';
      PrintBegBlock(pre, mmb, fnam, fp);
   }
   else
      PrintBegBlock(pre, mmb, NULL, fp);
   free(fnam);
   return(fp);
}

@extract -b @(basd)/atlas.base rout=Mylcm

void GenAmmSum(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *rkb, char *outd)
{
   ATL_mmnode_t *mp, *p66;
   char *fnam;
   FILE *fp;
   char *type = "unsigned short";
   int i, n, maxb, maxNB, maxMB, maxKB, maxkmaj;
   char PRE = toupper(pre), bc[3] = {'M', 'N', 'K'};
   double mfB;

   fp = StandHStart(pre, mmb, outd, "sum");
   maxkmaj = maxNB = maxKB = maxMB = 0;
   mfB = 0.0;
   for (n=0,mp=mmb; mp; n++, mp = mp->next)
   {
      maxkmaj = Mmax(maxkmaj, mp->kmaj);
      maxMB = Mmax(maxMB, mp->mbB);
      maxNB = Mmax(maxNB, mp->nbB);
      maxKB = Mmax(maxKB, mp->kbB);
      mfB = Mmax(mfB, mp->mflop[0]);
   }
   if (maxkmaj == 1)
      maxkmaj = 0;
   maxb = Mmax(maxMB, maxNB);
   maxb = Mmax(maxb, maxKB);
   fprintf(fp, "\n#define ATL_@(UP)AMM_MAXMB %d\n", maxMB);
   fprintf(fp, "#define ATL_@(UP)AMM_MAXNB %d\n", maxNB);
   fprintf(fp, "#define ATL_@(UP)AMM_MAXKB %d\n", maxKB);
   fprintf(fp, "#define ATL_@(UP)AMM_MAXKMAJ %d\n\n", maxkmaj);

   for (mp=mmb; mp && mp->next; mp = mp->next);
   assert(mp);
   fprintf(fp, "#define ATL_AMM_LMU %d\n", mp->mu);
   fprintf(fp, "#define ATL_AMM_LNU %d\n", mp->nu);
   fprintf(fp, "#define ATL_AMM_LKU %d\n", mp->ku);
   fprintf(fp, "#define ATL_AMM_LLCMMN %d\n\n", Mylcm(mp->mu, mp->nu));
   fprintf(fp, "#define ATL_AMM_LLCMU %d\n\n", 
           Mylcm(Mylcm(mp->mu, mp->nu),mp->ku));
/*
 * Find smallest case achieving 2/3 of maximal performance
 */
   for (i=0,mp=mmb; mp && mp->mflop[0]*1.5 < mfB; i++, mp = mp->next);
   assert(mp);
   fprintf(fp, "#define ATL_@(UP)AMM_66IDX %d\n", i);
   fprintf(fp, "#define ATL_@(UP)AMM_66NB %d\n", mp->mbB);
   fprintf(fp, "#define ATL_@(UP)AMM_66MB %d\n", mp->nbB);
   fprintf(fp, "#define ATL_@(UP)AMM_66KB %d\n", mp->kbB);
   fprintf(fp, "#define ATL_AMM_66LCMMN %d\n\n", Mylcm(mp->mu, mp->nu));
   fprintf(fp, "#define ATL_AMM_66LCMU %d\n\n", 
           Mylcm(Mylcm(mp->mu, mp->nu),mp->ku));
   fprintf(fp, "#define ATL_@(UP)AMM_66RATIO %1.4lf\n\n", mp->mflop[0]/mfB);
/*
 * Find smallest case achieving 98% of maximal performance
 */
   for (i=0,mp=mmb; mp && mp->mflop[0] < 0.98*mfB; i++, mp = mp->next);
   assert(mp);
   fprintf(fp, "#define ATL_@(UP)AMM_98IDX %d\n", i);
   fprintf(fp, "#define ATL_@(UP)AMM_98NB %d\n", mp->mbB);
   fprintf(fp, "#define ATL_@(UP)AMM_98MB %d\n", mp->nbB);
   fprintf(fp, "#define ATL_@(UP)AMM_98KB %d\n", mp->kbB);
   fprintf(fp, "#define ATL_AMM_98LCMMN %d\n\n", Mylcm(mp->mu, mp->nu));
   fprintf(fp, "#define ATL_AMM_98LCMU %d\n\n", 
           Mylcm(Mylcm(mp->mu, mp->nu),mp->ku));
   fprintf(fp, "#define ATL_@(UP)AMM_98RATIO %1.4lf\n\n", mp->mflop[0]/mfB);
@ROUT emit_uamm
   assert(rkb == NULL);
@ROUT emit_amm
   assert(rkb);
   maxkmaj = maxNB = maxKB = maxMB = 0;
   mfB = 0.0;
   for (n=0,mp=rkb; mp; n++, mp = mp->next)
   {
      maxkmaj = Mmax(maxkmaj, mp->kmaj);
      maxMB = Mmax(maxMB, mp->mbB);
      maxNB = Mmax(maxNB, mp->nbB);
      maxKB = Mmax(maxKB, mp->kbB);
      mfB = Mmax(mfB, mp->mflop[0]);
   }
   if (maxkmaj == 1)
      maxkmaj = 0;
   fprintf(fp, "#define ATL_MAXM_RKK %d\n", maxMB);
   fprintf(fp, "#define ATL_MAXN_RKK %d\n", maxNB);
   fprintf(fp, "#define ATL_MAXK_RKK %d\n", maxKB);
   fprintf(fp, "#define ATL_MAXKMAJ_RKK %d\n\n", maxkmaj);
/*
 * Find smallest case achieving 2/3 of maximal performance
 */
   for (i=0,mp=rkb; mp && mp->mflop[0]*1.5 < mfB; i++, mp = mp->next);
   assert(mp);
   fprintf(fp, "#define ATL_66IDX_RKK %d\n", i);
   fprintf(fp, "#define ATL_66NB_RKK %d\n", mp->mbB);
   fprintf(fp, "#define ATL_66MB_RKK %d\n", mp->nbB);
   fprintf(fp, "#define ATL_66KB_RKK %d\n", mp->kbB);
   fprintf(fp, "#define ATL_66RATIO_RKK %1.4lf\n\n", mp->mflop[0]/mfB);
@ROUT emit_amm emit_uamm

   fprintf(fp, "#define ATL_AMMFLG_KRUNTIME(flg_) ((flg_) & 1)\n");
   fprintf(fp, "#define ATL_AMMFLG_KMAJOR(flg_) ((flg_) & 2)\n");

   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenBlockingFile(char pre, ATL_mmnode_t *mmb, char *outd, char *nm)
{
   ATL_mmnode_t *mp;
   char *fnam;
   FILE *fp;
   char *type = "unsigned short";
   int i, n, maxb, maxNB, maxMB, maxKB, maxkmaj;
   char PRE = toupper(pre), bc[3] = {'M', 'N', 'K'};

   fp = StandHStart(pre, mmb, outd, nm);
   maxkmaj = maxNB = maxKB = maxMB = 0;
   for (n=0,mp=mmb; mp; n++, mp = mp->next)
   {
      maxkmaj = Mmax(maxkmaj, mp->kmaj);
      maxMB = Mmax(maxMB, mp->mbB);
      maxNB = Mmax(maxNB, mp->nbB);
      maxKB = Mmax(maxKB, mp->kbB);
   }
   if (maxkmaj == 1)
      maxkmaj = 0;
   maxb = Mmax(maxMB, maxNB);
   maxb = Mmax(maxb, maxKB);
   fprintf(fp, "#define ATL_@(UP)AMM_MAXMB %d\n", maxMB);
   fprintf(fp, "#define ATL_@(UP)AMM_MAXNB %d\n", maxNB);
   fprintf(fp, "#define ATL_@(UP)AMM_MAXKB %d\n", maxKB);
   fprintf(fp, "#define ATL_@(UP)AMM_MAXKMAJ %d\n", maxkmaj);
   fprintf(fp, "\n");

   if (maxb <= 255)
      type = "unsigned char";
   for (i=0; i < 3; i++)
   {
      int j;
      fprintf(fp, "static %s ATL_@(UP)AMM_%cBs[%d] =\n{\n", type, bc[i], n);
      for (j=0,mp=mmb; mp; j++,mp = mp->next)
      {
         int b;
         if (bc[i] == 'M')
            b = mp->mbB;
         else if (bc[i] == 'N')
            b = mp->nbB;
         else if (bc[i] == 'K')
            b = mp->kbB;
         if (mp->next)
            fprintf(fp, "%8d,  /* index %d */\n", b, j);
         else
            fprintf(fp, "%8d   /* index %d */\n", b, j);
      }
      fprintf(fp, "};\n\n");
   }
   for (i=0; i < 3; i++)
   {
      int j;
      fprintf(fp, "static %s ATL_@(UP)AMM_%cUs[%d] =\n{\n", type, bc[i], n);
      for (j=0,mp=mmb; mp; j++,mp = mp->next)
      {
         int b;
         if (bc[i] == 'M')
            b = mp->mu;
         else if (bc[i] == 'N')
            b = mp->nu;
         else if (bc[i] == 'K')
         {
            if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
               b = mp->ku;
            else
               b = (mp->kmaj > 1) ? mp->ku : mp->kbB;
         }
         if (mp->next)
            fprintf(fp, "%8d,  /* index %d */\n", b, j);
         else
            fprintf(fp, "%8d   /* index %d */\n", b, j);
      }
      fprintf(fp, "};\n\n");
   }
   fprintf(fp, "static %s ATL_@(UP)AMM_KBMINs[%d] =\n{\n", type, n);
   for (i=0,mp=mmb; mp; i++,mp = mp->next)
   {
      if (mp->next)
         fprintf(fp, "%8d,  /* index %d */\n", mp->kbmin, i);
      else
         fprintf(fp, "%8d   /* index %d */\n", mp->kbmin, i);
   }
   fprintf(fp, "};\n\n");
   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenFlagH(char pre, ATL_mmnode_t *mmb, char *outd, char *nm)
{
   FILE *fp;
   int j, n;
   ATL_mmnode_t *mp;

   fp = StandHStart(pre, mmb, outd, nm);

   for (n=0,mp=mmb; mp; n++,mp = mp->next);

   fprintf(fp, "static unsigned char ATL_@(UP)AMM_KFLAG[%d] =\n{\n", n);
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      unsigned char flag=FLAG_IS_SET(mp->flag, MMF_KRUNTIME) ? 1 : 0;
      if (mp->kmaj)
         flag |= 2;
      if (mp->next)
         fprintf(fp, "%6d,  /* index %d */\n", flag, j);
      else
         fprintf(fp, "%6d   /* index %d */\n", flag, j);
   }
   fprintf(fp, "};\n\n");
   fprintf(fp, "#define ATL_AMM_KRUNTIME(idx_) (ATL_AMM_KFLAG[idx_] & 1)\n");
   fprintf(fp, "#define ATL_AMM_KMAJOR(idx_) (ATL_AMM_KFLAG[idx_] & 2)\n");
   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void SpewForthC2MProto(char pre, FILE *fp0, FILE *fp1, int mu, int nu)
{
   char ac[3] = {'1', 'n', 'X'};
   char bc[4] = {'0', '1', 'n', 'X'};
   int ia, ib;
   for (ia=0; ia < 3; ia ++)
   {
      for (ib=0; ib < 4; ib++)
      {
@ROUT emit_amm
         fprintf(fp0, "void ATL_%cablk2cmat_%dx%d_a%c_b%c\n", 
                 pre, mu, nu, ac[ia], bc[ib]);
@ROUT emit_uamm
         fprintf(fp0, "void ATL_%cu%dablk2cmat_%dx%d_a%c_b%c\n", 
                 pre, UID, mu, nu, ac[ia], bc[ib]);
@ROUT emit_amm emit_uamm
         if (pre == 'z' || pre == 'c')
            fprintf(fp0, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const TYPE*,const SCALAR,TYPE *,ATL_CSZT);\n");
         else
            fprintf(fp0, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const SCALAR,TYPE *,ATL_CSZT);\n");
@ROUT emit_amm
         fprintf(fp1, "void ATL_%ccmat2ablk_%dx%d_a%c_b%c\n", 
                 pre, mu, nu, ac[ia], bc[ib]);
@ROUT emit_uamm
         fprintf(fp1, "void ATL_%cu%dcmat2ablk_%dx%d_a%c_b%c\n", 
                 pre, UID, mu, nu, ac[ia], bc[ib]);
@ROUT emit_amm emit_uamm
         if (pre == 'z' || pre == 'c')
            fprintf(fp1, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,const SCALAR,TYPE*,TYPE*);\n");
         else
            fprintf(fp1, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,const SCALAR,TYPE*);\n");
      }
   }
}

void SpewForthC2BDecl(char pre, ATL_mmnode_t *mmb, FILE *fp, char *rt, 
                      char alp, char bet)
{
   ATL_mmnode_t *mp;
   int j;

   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
@ROUT
@ROUT emit_amm
      fprintf(fp, "   ATL_%c%s_%dx%d_a%c_b%c", 
              pre, rt, mp->mu,mp->nu, alp, bet);
@ROUT emit_uamm
      fprintf(fp, "   ATL_%cu%d%s_%dx%d_a%c_b%c", 
              pre, UID, rt, mp->mu,mp->nu, alp, bet);
@ROUT emit_amm emit_uamm
      if (mp->next)
         fprintf(fp, ",  /* index %d */\n", j);
      else
         fprintf(fp, "   /* index %d */\n", j);
      }
      fprintf(fp, "};\n\n");
}

void GenC2BLK(char pre, ATL_mmnode_t *mmb, char *outd, char *suff)
{
   FILE *fp0, *fp1;
   ATL_mmnode_t *mp;
   int ia, ib;
   char ac[3] = {'1', 'n', 'X'};
   char bc[4] = {'0', '1', 'n', 'X'};
   char *fnam;

   if (!suff)
   {
      fp0 = StandHStart(pre, mmb, outd, "ablk2cmat");
      fp1 = StandHStart(pre, mmb, outd, "cmat2ablk");
   }
   else
   {
      fnam = malloc(sizeof(char)*(strlen(suff) + 10));
      assert(fnam);
      strncpy(fnam, "ablk2cmat", 9);
      strcpy(fnam+9, suff);
      fp0 = StandHStart(pre, mmb, outd, fnam);
      strncpy(fnam, "cmat2ablk", 9);
      fp1 = StandHStart(pre, mmb, outd, fnam);
   }
   fprintf(fp0, "\n");
   fprintf(fp1, "\n");
/*
 * Crank out prototypes
 */
   SpewForthC2MProto(pre, fp0, fp1, mmb->mu, mmb->nu);
   for (mp=mmb->next; mp; mp = mp->next)
   {
      ATL_mmnode_t *p;
      const int mu=mp->mu, nu=mp->nu;
      for (p=mmb; p->mu != mu || p->nu != nu; p = p->next);
      if (p == mp)  /* first occurance of this mu,nu pair */
         SpewForthC2MProto(pre, fp0, fp1, mp->mu, mp->nu);
   }
   fprintf(fp0, "\n");
   fprintf(fp1, "\n");
/*
 * Now, crank out funcptr arrays
 */
   for (ia=0; ia < 3; ia ++)
   {
      for (ib=0; ib < 4; ib++)
      {
         fprintf(fp0, 
            "static ablk2cmat_t ATL_@(UP)AMM_BLK2C_a%c_b%c[ATL_@(UP)AMM_NCASES] =\n{\n",
                 ac[ia], bc[ib]);
         SpewForthC2BDecl(pre, mmb, fp0, "ablk2cmat", ac[ia], bc[ib]);
         fprintf(fp1, 
            "static cmat2ablk_t ATL_@(UP)AMM_C2BLK_a%c_b%c[ATL_@(UP)AMM_NCASES] =\n{\n",
                 ac[ia], bc[ib]);
         SpewForthC2BDecl(pre, mmb, fp1, "cmat2ablk", ac[ia], bc[ib]);
      }
   }
   fprintf(fp0, "\n#endif  /* end include file guard */\n");
   fclose(fp0);
   fprintf(fp1, "\n#endif  /* end include file guard */\n");
   fclose(fp1);
}

void SpewForthCpProto(char pre, FILE *fp, char alp, int u, int kmaj)
{
   const int G = (pre == 'c' || pre == 'z') ? 2 : 1;
   const char *cst[2] = {"", "C"};
   int g;

   for (g=0; g < G; g++)
   {
@ROUT emit_amm
      if (kmaj > 1)
         fprintf(fp, "void ATL_%ccm2am_a%c_%dx%d%s\n", 
                 pre, alp, kmaj, u, cst[g]);
      else
         fprintf(fp, "void ATL_%ccm2am_a%c_%d%s\n", pre, alp, u, cst[g]);
@ROUT emit_uamm
      if (kmaj > 1)
         fprintf(fp, "void ATL_%cu%dcm2am_a%c_%dx%d%s\n", 
                 pre, UID, alp, kmaj, u, cst[g]);
      else
         fprintf(fp, "void ATL_%cu%dcm2am_a%c_%d%s\n",pre, UID, alp, u, cst[g]);
@ROUT emit_amm emit_uamm
      if (pre == 'z' || pre == 'c')
         fprintf(fp,
    "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*,TYPE*);\n");
      else
         fprintf(fp,
         "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*);\n");
@ROUT emit_amm
      if (kmaj > 1)
         fprintf(fp, "void ATL_%crm2am_a%c_%dx%d%s\n", 
                 pre, alp, kmaj, u, cst[g]);
      else
         fprintf(fp, "void ATL_%crm2am_a%c_%d%s\n", pre, alp, u, cst[g]);
@ROUT emit_uamm
      if (kmaj > 1)
         fprintf(fp, "void ATL_%cu%drm2am_a%c_%dx%d%s\n", 
                 pre, UID, alp, kmaj, u, cst[g]);
      else
         fprintf(fp, "void ATL_%cu%drm2am_a%c_%d%s\n",pre, UID, alp, u, cst[g]);
@ROUT emit_amm emit_uamm
      if (pre == 'z' || pre == 'c')
         fprintf(fp,
     "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*,TYPE*);\n");
      else
         fprintf(fp,
         "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*);\n");
   }
}

void SpewForthCpConjDecl(char pre, ATL_mmnode_t *mmb, FILE *fp, 
                         char *arr, char *rt, char alp, int u)
{
   ATL_mmnode_t *mp;
   int j;

   fprintf(fp, "static cm2am_t %s_a%c[%d] =\n{\n", arr, alp, 
           ATL_CountNumberOfMMNodes(mmb));
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      const int kmaj = mp->kmaj;
@ROUT emit_amm
      if (kmaj > 1)
         fprintf(fp, "   ATL_%c%s_a%c_%dx%dC", pre, rt, alp, kmaj, 
                 u?mp->mu:mp->nu);
      else
         fprintf(fp, "   ATL_%c%s_a%c_%dC", pre, rt, alp, u?mp->mu:mp->nu);
@ROUT emit_uamm
      if (kmaj > 1)
         fprintf(fp, "   ATL_%cu%d%s_a%c_%dx%dC", pre, UID, rt, alp, kmaj, 
                 u?mp->mu:mp->nu);
      else
         fprintf(fp, "   ATL_%cu%d%s_a%c_%dC", pre, UID, rt, alp, 
                 u?mp->mu:mp->nu);
@ROUT emit_amm emit_uamm
      if (mp->next)
         fprintf(fp, ",");
      else
         fprintf(fp, " ");
      fprintf(fp, "  /* index %d */\n", j);
   }
   fprintf(fp, "};\n\n");
}

void SpewForthCpDecl(char pre, ATL_mmnode_t *mmb, FILE *fp, 
                     char *arr, char *rt, char alp, int u)
{
   ATL_mmnode_t *mp;
   int j;

   fprintf(fp, "static cm2am_t %s_a%c[%d] =\n{\n", arr, alp, 
           ATL_CountNumberOfMMNodes(mmb));
   for (j=0,mp=mmb; mp; j++,mp = mp->next)
   {
      const int kmaj = mp->kmaj;
@ROUT emit_amm
      if (kmaj > 1)
         fprintf(fp, "   ATL_%c%s_a%c_%dx%d", pre, rt, alp, kmaj, 
                 u?mp->mu:mp->nu);
      else
         fprintf(fp, "   ATL_%c%s_a%c_%d", pre, rt, alp, u?mp->mu:mp->nu);
@ROUT emit_uamm
      if (kmaj > 1)
         fprintf(fp, "   ATL_%cu%d%s_a%c_%dx%d", pre, UID, rt, alp, kmaj, 
                 u?mp->mu:mp->nu);
      else
         fprintf(fp, "   ATL_%cu%d%s_a%c_%d", pre, UID, rt, alp, 
                 u?mp->mu:mp->nu);
@ROUT emit_amm emit_uamm
      if (mp->next)
         fprintf(fp, ",");
      else
         fprintf(fp, " ");
      fprintf(fp, "  /* index %d */\n", j);
   }
   fprintf(fp, "};\n\n");
}

@ROUT emit_amm
   @define len @23@
@ROUT emit_uamm
   @define len @24+UIL@
@ROUT emit_amm emit_uamm
void GenCMAJ2AMAJ(char pre, ATL_mmnode_t *mmb, char *outd, char *suff)
/*
 * 3. atlas_<pre>amm_cm2am_a[1,X,n]: 
 *    defines: ATL_AMM_NCASES
 *    prototypes all rm2am & cm2am routines
 *    1 indexible array giving which to use for each block factor
 */
{
   char ac[3] = {'1', 'n', 'X'};
   int ia, j;
   char *fnam, *sp, *np;
   ATL_mmnode_t *mp;

   if (!suff)
      suff = "";
   ia = strlen(outd) + strlen(suff) + @(len);
   fnam = malloc(ia*sizeof(char));
   assert(fnam);
@ROUT emit_amm
   sprintf(fnam, "%s/atlas_%camm%s_cm2am_a1.h", outd, pre, suff);
@ROUT emit_uamm
   sprintf(fnam, "%s/atlas_%cu%damm%s_cm2am_a1.h", outd, pre, UID, suff);
@ROUT emit_amm emit_uamm
   np = fnam+ia-23+12;
   assert(*np == 'c' && np[1] == 'm');
   sp = fnam+ia-4;
   assert(*sp == '1');

   for (ia=0; ia < 3; ia++)
   {
      char *rt[2] = {"cm2am", "rm2am"};
      FILE *fp;
      int kmaj = mmb->kmaj;

      if (kmaj == 1)
         kmaj = 0;
      *sp = ac[ia];
      fp = fopen(fnam, "w");
      assert(fp);
      sp[1] = '\0';
      PrintBegBlock(pre, mmb, np, fp);
      sp[1] = '.';
      fprintf(fp, "/*\n * mat2blk prototypes\n */\n");
      SpewForthCpProto(pre, fp, ac[ia], mmb->mu, kmaj);
      if (mmb->nu != mmb->mu || kmaj > 1)
         SpewForthCpProto(pre, fp, ac[ia], mmb->nu, kmaj);
      for (mp=mmb->next; mp; mp = mp->next)
      {
         ATL_mmnode_t *p;
         int mu = mp->mu, nu = mp->nu, kmaj=mp->kmaj;
         for (p=mmb; p != mp; p = p->next)
            if (mu == p->mu && p->kmaj == kmaj)
               break;
         if (p == mp) /* haven't seen before */
            SpewForthCpProto(pre, fp, ac[ia], mu, kmaj);
         for (p=mmb; p != mp; p = p->next)
            if ((p->nu == nu && p->kmaj == kmaj) || 
                (p->kmaj == kmaj && p->mu == nu))
               break;
         if (p == mp) /* haven't seen before */
            SpewForthCpProto(pre, fp, ac[ia], nu, kmaj);
      }
      fprintf(fp, "\n");
      SpewForthCpDecl(pre, mmb, fp, "ATL_@(UP)AMM_A2BLK", "cm2am", ac[ia], 1);
      SpewForthCpDecl(pre, mmb, fp, "ATL_@(UP)AMM_AT2BLK", "rm2am", ac[ia], 1);
      SpewForthCpDecl(pre, mmb, fp, "ATL_@(UP)AMM_B2BLK", "cm2am", ac[ia], 0);
      SpewForthCpDecl(pre, mmb, fp, "ATL_@(UP)AMM_BT2BLK", "rm2am", ac[ia], 0);
      if (pre == 'c' || pre == 'z')
      {
         SpewForthCpConjDecl(pre, mmb, fp, "ATL_@(UP)AMM_AC2BLK", 
                             "cm2am", ac[ia], 1);
         SpewForthCpConjDecl(pre, mmb, fp, "ATL_@(UP)AMM_AH2BLK", 
                             "rm2am", ac[ia], 1);
         SpewForthCpConjDecl(pre, mmb, fp, "ATL_@(UP)AMM_BC2BLK", 
                             "cm2am", ac[ia], 0);
         SpewForthCpConjDecl(pre, mmb, fp, "ATL_@(UP)AMM_BH2BLK", 
                             "rm2am", ac[ia], 0);
      }
      fprintf(fp, "\n#endif  /* end include file guard */\n");
      fclose(fp);
   }
   free(fnam);
}

int KernelIsExactSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same including KB, 0 otherwise
 */
{
/*
 * Kernels aren't the same if one is being compiled with specific KB,
 * and the other has runtime
 */
   if (FLAG_IS_SET(p0->flag, MMF_KRUNTIME) != 
       FLAG_IS_SET(p1->flag, MMF_KRUNTIME))
      return(0);
   if (!FLAG_IS_SET(p0->flag, MMF_KRUNTIME) && (p0->kbB != p1->kbB))
      return(0);
/*
 * Kernels aren't same if one is K-veclen-major and one is not
 */
   if (p0->kmaj != p1->kmaj)
      return(0);
/*
 * Two generated kernels are the same if mu,nu,kmaj,ku,VLEN,flag are the same.
 * NOTE: if we make generator handle muladd, etc, MUST UPDATE HERE!!!
 */
   if (p0->ID == 0 && p1->ID == 0)
      return(p0->mu == p1->mu && p0->nu == p1->nu && p0->kmaj == p1->kmaj &&
             p0->ku == p1->ku && p0->vlen == p1->vlen && p0->flag == p1->flag);
/*
 * If both are user kernels, then they may be repeats.  For user kernels,
 * they are the same if both ID and flag match, else they are not.
 */
   else if (p0->ID > 0 && p1->ID > 0)
      return(p0->ID == p1->ID && p0->flag == p1->flag);
   return(0);  /* Can't be the same if above criteria fails */
}

int ExactKernelInList(ATL_mmnode_t *mmb, ATL_mmnode_t *p)
/*
 * RETURNS: 1 if p is duplicated in mmb, else 0
 */
{
   ATL_mmnode_t *mp;
   if (!p || !mmb)
      return(0);
   for (mp=mmb; mp; mp = mp->next)
      if (KernelIsExactSame(mp, p))
         return(1);
    return(0);
}

void SpewForthKernProto(FILE *fp, char pre, ATL_mmnode_t *p, char bc)
{
@ROUT emit_amm
   fprintf(fp, "void ATL_%cAMMM_%d_%d_%d_%dx%dx%d_b%c\n", pre, p->ID, 
           FLAG_IS_SET(p->flag, MMF_KRUNTIME)?0:p->kbB, p->kmaj,
           p->mu, p->nu, p->ku,bc);
@ROUT emit_uamm
   fprintf(fp, "void ATL_%cu%dAMMM_%d_%d_%d_%dx%dx%d_b%c\n", pre, UID, p->ID, 
           FLAG_IS_SET(p->flag, MMF_KRUNTIME)?0:p->kbB, p->kmaj,
           p->mu, p->nu, p->ku,bc);
@ROUT emit_amm emit_uamm
   fprintf(fp, 
      "   (ATL_CSZT,ATL_CSZT,ATL_CSZT,const TYPE*,const TYPE*,TYPE*,\n");
   fprintf(fp, 
      "    const TYPE*,const TYPE*,const TYPE*);\n");
}

void SpewForthKernProtos(FILE *fp, char pre, ATL_mmnode_t *mmb, int nbet)
{
   ATL_mmnode_t *mp;
   for (mp=mmb; mp; mp = mp->next)
   {
      if (!ExactKernelInList(mp->next, mp))
      {
         char bc[3] = {'0', '1', 'n'};  /* 0 must come first */
         int ib;
         for (ib=0; ib < nbet; ib++)
            SpewForthKernProto(fp, pre, mp, bc[ib]);
      }
   }
}

void SpewForthKernArray(FILE *fp, char pre, ATL_mmnode_t *mmb, 
                        char *vnam, char cbet)
{
   ATL_mmnode_t *mp;
   int n;

   for (n=0,mp=mmb; mp; n++, mp = mp->next);
   fprintf(fp, "static ammkern_t ATL_@(UP)AMM_%s[%d] =\n", vnam, n);
   fprintf(fp, "{\n");
   for (mp=mmb; mp; mp = mp->next)
   {
@ROUT emit_amm
      fprintf(fp, "   ATL_%cAMMM_%d_%d_%d_%dx%dx%d_b%c", pre, mp->ID, 
              FLAG_IS_SET(mp->flag, MMF_KRUNTIME)?0:mp->kbB, mp->kmaj,
              mp->mu, mp->nu, mp->ku, cbet);
@ROUT emit_uamm
      fprintf(fp, "   ATL_%cu%dAMMM_%d_%d_%d_%dx%dx%d_b%c", pre, UID, mp->ID, 
              FLAG_IS_SET(mp->flag, MMF_KRUNTIME)?0:mp->kbB, mp->kmaj,
              mp->mu, mp->nu, mp->ku, cbet);
@ROUT emit_amm emit_uamm
      if (mp->next)
         fprintf(fp, ",\n");
   }
   fprintf(fp, "\n};\n\n");
}

/*
 * RETURNS: possibly updated list of all unique mu/nu comboes
 */
typedef struct mnur mnur_t;
struct mnur {int mu; int nu; int kmaj; mnur_t *next;};
mnur_t *GetUniqueMNUnrolls(ATL_mmnode_t *mmb, mnur_t *urb)
{
   ATL_mmnode_t *mp;
   mnur_t *up;
/*
 * For each node in mmb, add to urb if mu/nu combo not already there
 * kmaj only affects A/B copy, and this is for C put, so ignore kmaj
 */
   for (mp = mmb; mp; mp = mp->next)
   {
      for (up=urb; up; up = up->next)
         if (mp->mu == up->mu && mp->nu == up->nu)
            break;
      if (!up)
      {
         up = malloc(sizeof(mnur_t));
         assert(up);
         up->mu = mp->mu;
         up->nu = mp->nu;
         up->kmaj = 0;
         up->next = urb;
         urb = up;
      }
   }
   return(urb);
}

/*
 * RETURNS: list of just unique MUs from mnb not already in mub
 */
mnur_t *GetUniqueMUnrolls(ATL_mmnode_t *mnb, mnur_t *mub)
{
   mnur_t *mup;
   ATL_mmnode_t *mnp;
   if (!mnb)
      return(mub);
   for (mnp=mnb; mnp; mnp = mnp->next)
   {
      const int kmaj = mnp->kmaj;
      for (mup=mub; mup; mup = mup->next)
         if (mup->mu == mnp->mu && mup->kmaj == kmaj)
            break;
      if (!mup)  /* a new mu */
      {
         mup = malloc(sizeof(mnur_t));
         assert(mup);
         mup->nu = mup->mu = mnp->mu;
         mup->next = mub;
         mup->kmaj = kmaj;
         mub = mup;
      }
   }
   return(mub);
}
/*
 * RETURNS: list of just unique NUs from mnb not already in mub
 */
mnur_t *GetUniqueNUnrolls(ATL_mmnode_t *mnb, mnur_t *mub)
{
   mnur_t *mup;
   ATL_mmnode_t *mnp;
   if (!mnb)
      return(mub);
   for (mnp=mnb; mnp; mnp = mnp->next)
   {
      const int kmaj = mnp->kmaj;
      for (mup=mub; mup; mup = mup->next)
         if (mup->mu == mnp->nu && kmaj == mup->kmaj)
            break;
      if (!mup)  /* a new nu */
      {
         mup = malloc(sizeof(mnur_t));
         assert(mup);
         mup->nu = mup->mu = mnp->nu;
         mup->next = mub;
         mup->kmaj = kmaj;
         mub = mup;
      }
   }
   return(mub);
}

void KillUnrollList(mnur_t *b)
{
   mnur_t *p;
   while (b)
   {
      p = b->next;
      free(b);
      b = p;
   }
}

int KernelIsSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same except for blocking, 0 otherwise
 */
{
/*
 * Kernels aren't the same if one is being compiled with specific KB,
 * and the other has runtime
 */
   if (FLAG_IS_SET(p0->flag, MMF_KRUNTIME) != 
       FLAG_IS_SET(p1->flag, MMF_KRUNTIME))
      return(0);
/*
 * Two generated kernels are the same if mu,nu,ku,VLEN,flag are the same.
 * NOTE: if we make generator handle muladd, etc, MUST UPDATE HERE!!!
 */
   if (p0->ID == 0 && p1->ID == 0)
      return(p0->mu == p1->mu && p0->nu == p1->nu && p0->ku == p1->ku &&
             p0->vlen == p1->vlen && p0->flag == p1->flag);
/*
 * If both are user kernels, then they may be repeats.  For user kernels,
 * they are the same if both ID and flag match, else they are not.
 */
   else if (p0->ID > 0 && p1->ID > 0)
      return(p0->ID == p1->ID && p0->flag == p1->flag);
   return(0);  /* Can't be the same if above criteria fails */
}

@beginskip
/*
 * This routine spits out the timing estimate for doing a muXnuXku portion
 * of the computation.  It is a wild estimate, in that assumes you are
 * using mbBxnbBxkbB blocking used during timings, but it's better than nothing.
 * Note we have a MFLOP measure, and mf = 2*M*N*K / (1e6*time)
 * so time = 2*M*N*K / (1e6*mf), which is time for full GEMM, so
 * time / M*N*K is time for 1 K iteration, or t1 = 2 / (1.e6*mf), which we
 * then multiply by mu*nu*ku to get t2 = 2*mu*nu*ku /1.e6*mf, which is the
 * time to do one unrolled iteration of the ku loop (the building block of
 * all usage of this kernel).  For k-major storage, total time can be
 * estimated at:
 *   T = CEIL(M/mu)*CEIL(N/nu)*CEIL(K/ku)*t3
 * For M-major storage it would instead be:
 *   T = CEIL(M/mu) * CEIL(N/nu) * (FLOOR(K/ku)*t3 + K%ku*t3_K1)
 * where t3_K1 is the t3 mentioned above for the KU=1 K-cleanup kernel.
 */
void SpewTimeEst
(
   ATL_mmnode_t *mmb,  /* baseptr  of AMMM kernel queue */
   char *arrnam,       /* name of array to create */
   FILE *fpout,        /* open file stream to print array to */
   int imf             /* which mflop elt to use for timing */
)
{
}
@endskip

void GenRankKH
(
   char pre, 
   ATL_mmnode_t *sqb,  /* baseptr  of square-case AMMM kernels */
   ATL_mmnode_t *rkb,  /* rank-K kernels, one for each supported K */
   char *outd
)
{
   FILE *fp;
   mnur_t *putb, *cpyb, *up;
   ATL_mmnode_t *mp;
   int m, n, k;
   int ia, ib;
   char PRE = pre;
   char ac[3] =  {'1', 'n', 'X'};
   char bc[4] = {'1', 'n', '0', 'X'};
   if (pre == 'c')
      pre = 's';
   else  if (pre == 'z')
      pre = 'd';

   assert(sqb && rkb);
   fp = StandHStart(PRE, rkb, outd, "rankK");
   fprintf(fp, "\n");

   for (mp=sqb; mp->next; mp = mp->next);
   fprintf(fp, "#define ATL_MAXM_RKK %d\n", mp->mbB);
   fprintf(fp, "#define ATL_MAXN_RKK %d\n", mp->nbB);
   fprintf(fp, "#define ATL_MAXK_RKK %d\n\n", mp->kbB);
/*
 * Prototype needed copy routines
 */
   putb = GetUniqueMNUnrolls(rkb, NULL);
   fprintf(fp, "/*\n * cblk2mat put function prototypes\n */\n");
   for (up=putb; up; up = up->next)
   {
      for (ib=0; ib < 4; ib++)
      {
         fprintf(fp, "void ATL_%cablk2cmat_%dx%d_a1_b%c\n", 
                 PRE, up->mu, up->nu, bc[ib]);
         if (PRE == 'c' || PRE == 'z')
            fprintf(fp, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const TYPE*,const SCALAR,TYPE *,ATL_CSZT);\n");
         else
            fprintf(fp, "   (ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,const SCALAR,TYPE *,ATL_CSZT);\n");
      }
   }
   KillUnrollList(putb);
   fprintf(fp, 
      "/*\n * Column-major to access-major copy function prototypes\n */\n");
   cpyb = GetUniqueMUnrolls(rkb, NULL);
   cpyb = GetUniqueNUnrolls(rkb, cpyb);
   for (up=cpyb; up; up = up->next)
   {
      for (ia=0; ia < 3; ia++)
         SpewForthCpProto(PRE, fp, ac[ia], up->mu, up->kmaj);
   }
   KillUnrollList(cpyb);
/*
 * Prototype the rank-K functions
 */
   fprintf(fp, "/*\n * rank-K AMMM kernel prototypes\n */\n");
   for (mp=rkb; mp; mp = mp->next)
   {
/*
 *    For runtime kernels, only prototype 1st time they are seen in list
 */
      if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
      {
         ATL_mmnode_t *p;
         if (mp->ID > 0)
         {
            for (p=rkb; p != mp; p = p->next)
               if (p->ID == mp->ID)
                  break;
         }
         else
         {
            for (p=rkb; p != mp; p = p->next)
               if (KernelIsSame(mp, p))
                  break;
         }
         if (mp == p)
         {
            SpewForthKernProto(fp, pre, mp, '0');
            SpewForthKernProto(fp, pre, mp, '1');
            SpewForthKernProto(fp, pre, mp, 'n');
         }
      }
/*
 *    compile-time-K kernels get prototyped for each invocation
 */
      else
      {
         SpewForthKernProto(fp, pre, mp, '0');
         SpewForthKernProto(fp, pre, mp, '1');
         SpewForthKernProto(fp, pre, mp, 'n');
      }
   }
/*
 * Now, crank out funcptr arrays
 */
   for (ib=0; ib < 4; ib++)
   {
      fprintf(fp,
         "\nstatic ablk2cmat_t ATL_RKK_BLK2C_a1_b%c[%d] =\n{\n",
              bc[ib], ATL_CountNumberOfMMNodes(rkb));
      SpewForthC2BDecl(PRE, rkb, fp, "ablk2cmat", '1', bc[ib]);
   }
   for (ia=0; ia < 3; ia++)
   {
      fprintf(fp, "\n");
      SpewForthCpDecl(PRE, rkb, fp, "ATL_RKK_A2BLK", "cm2am", ac[ia], 1);
      SpewForthCpDecl(PRE, rkb, fp, "ATL_RKK_AT2BLK", "rm2am", ac[ia], 1);
      SpewForthCpDecl(PRE, rkb, fp, "ATL_RKK_B2BLK", "cm2am", ac[ia], 0);
      SpewForthCpDecl(PRE, rkb, fp, "ATL_RKK_BT2BLK", "rm2am", ac[ia], 0);
      if (PRE == 'z' || PRE == 'c')
      {
         SpewForthCpConjDecl(PRE, rkb, fp, "ATL_RKK_AC2BLK", "cm2am",ac[ia],1);
         SpewForthCpConjDecl(PRE, rkb, fp, "ATL_RKK_AH2BLK", "rm2am",ac[ia],1);
         SpewForthCpConjDecl(PRE, rkb, fp, "ATL_RKK_BC2BLK", "cm2am",ac[ia],0);
         SpewForthCpConjDecl(PRE, rkb, fp, "ATL_RKK_BH2BLK", "rm2am",ac[ia],0);
      }
   }
   SpewForthKernArray(fp, pre, rkb, "KERN_RKK", '0');
   SpewForthKernArray(fp, pre, rkb, "KERN_RKK_b1", '1');
   SpewForthKernArray(fp, pre, rkb, "KERN_RKK_bn", 'n');
   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenKernH(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *ukb, 
              ATL_mmnode_t *kcb, char *outd)
/*
 * 5. atlas_<pre>amm_kerns.h
 *    defines: ATL_AMM_NCASES
 *    prototypes all kernels, including K-cleanup
 *    1 indexible array gives kernel to use for each case as func ptr
 *    1 indexible array gives K-clean kernel
 */
{
   FILE *fp;
/*
 * Dump out standard header start and kernel prototypes
 */
   fp = StandHStart(pre, mmb, outd, "kern");
   fprintf(fp, "\n");
   SpewForthKernProtos(fp, pre, mmb, 3);
   if (ukb)
      SpewForthKernProtos(fp, pre, ukb, 3);
   fprintf(fp, "\n");
/*
 * Dump out kernel ptr arrays
 */
   SpewForthKernArray(fp, pre, mmb, "KERN_b0", '0');
   SpewForthKernArray(fp, pre, mmb, "KERN_b1", '1');
   SpewForthKernArray(fp, pre, mmb, "KERN_bn", 'n');
   if (kcb)
   {
      SpewForthKernArray(fp, pre, kcb, "KERN_K1", '0');
      SpewForthKernArray(fp, pre, kcb, "KERN_K1_b1", '1');
      SpewForthKernArray(fp, pre, kcb, "KERN_K1_bn", 'n');
   }

   fprintf(fp, "\n#endif  /* end include file guard */\n");
   fclose(fp);
}

void GenCmplxHeaders(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *rkb, char *outd)
{
   GenCMAJ2AMAJ(pre, mmb, outd, NULL);
   GenC2BLK(pre, mmb, outd, NULL);
   if (rkb)
   {
      GenCMAJ2AMAJ(pre, rkb, outd, "rkk");
      GenC2BLK(pre, rkb, outd, "_rkk");
      GenRankKH(pre, mmb, rkb, outd);
   }
}

void GenHeaderFiles(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *ukb, 
                    ATL_mmnode_t *kcb, ATL_mmnode_t *rkb, ATL_mmnode_t *urb,
                    char *outd)
/*
 * Header files required to build full gemm (no timing):
 *X1. atlas_<pre>amm_blk.h : 
 *X   defines: ATL_AMM_NCASES, ATL_AMM_MAX[M,N,K]B
 *X   3 arrays indexed by case give blocking
 *X2  atlas_<pre>amm_flag.h
 *X   defines: ATL_AMM_NCASES
 *X   1 indexible array giving KRUNTIME for now
 *X3. atlas_<pre>amm_cm2am_a[1,X,n]: 
 *X   defines: ATL_AMM_NCASES
 *X   prototypes all rm2am & cm2am routines
 *X   1 indexible array giving which to use for each block factor
 *X4. atlas_<pre>amm_ablk2cmat.h
 *X   defines: ATL_AMM_NCASES
 *X   prototypes all ablk2cmat routines
 *X   1 indexible array for each alpha,beta combination
 *X   -> 3*4 = 12 indexible arrays total
 *X5. atlas_<pre>amm_kerns.h
 *X   defines: ATL_AMM_NCASES
 *X   prototypes all kernels, including K-cleanup
 *X   1 indexible array gives kernel to use for each case as func ptr
 *X   1 indexible array gives K-clean kernel
 *X6. atlas_<pre>amm_cmat2ablk.h (I don't need, Rakib does)
 *X   defines: ATL_AMM_NCASES 
 *X   prototypes all cmat2ablk routines
 *X   1 indexible array for each alpha,beta combination
 *X   -> 3*4 = 12 indexible arrays total
 */
{
   if (rkb)
      GenAmmSum(pre, mmb, rkb, outd);
   GenBlockingFile(pre, mmb, outd, "blk");
   GenFlagH(pre, mmb, outd, "flag");
   GenCMAJ2AMAJ(pre, mmb, outd, NULL);
   GenC2BLK(pre, mmb, outd, NULL);
   GenKernH(pre, mmb, ukb, kcb, outd);
   GenCmplxHeaders(pre=='s'?'c':'z', mmb, rkb, outd);
   if (rkb)
   {
      GenBlockingFile(pre, rkb, outd, "rkkblk");
      GenFlagH(pre, rkb, outd, "rkkflag");
      GenCMAJ2AMAJ(pre, rkb, outd, "rkk");
      GenC2BLK(pre, rkb, outd, "_rkk");
      GenRankKH(pre, mmb, rkb, outd);
   }
}

/*
 * Splits rkb into two lists: (1) Routines with runtime K (RUNB),
 * (2) Routines with fixed-KB (returned)
 * NOTE: original list rkb is unchanged
 */
ATL_mmnode_t *SplitRankK(ATL_mmnode_t *rkb, ATL_mmnode_t **RUNB)
{
   ATL_mmnode_t *runb=NULL, *fixb=NULL, *p, *np;
   for (p=rkb; p; p = p->next)
   {
      np = CloneMMNode(p);
      if (FLAG_IS_SET(np->flag, MMF_KRUNTIME))
      {
         np->next = runb;
         runb = np;
      }
      else
      {
         np->next = fixb;
         fixb = np;
      }
   }
   *RUNB = runb;
   return(fixb);
}

@ROUT emit_amm
   @define lib @ATLAS@
@ROUT emit_uamm
   @define lib @UAMM@
@ROUT emit_amm emit_uamm
void GenMakefile(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *ukb, 
                 ATL_mmnode_t *rkb, ATL_mmnode_t *urb, char *outd)
{
   ATL_mmnode_t *mmp, *p, *fixb, *runb;
   mnur_t *mnurb=NULL, *allub, *up;
   FILE *fp;
   char *comp, *cflags;
   char *ln;
   int i;
   char pres[2];
   char be[3] = {'1', 'n', '0'};
   char *bes[3] = {"1", "N1", "0"};
   char al[3] = {'1', 'n', 'X'};
   char dcomp[8] = {'$', '(', 'D', 'M', 'C', ')', '\0'};
   char dflags[12] = {'$', '(', 'D', 'M', 'C', 'F', 'L', 'A', 'G', 'S', 
                     ')', '\0'};
   char *styps[2] = {"-DDREAL", "-DDCPLX"};
   char *styp = (pre == 'd') ? "-DDREAL" : "-DSREAL";

   pres[0] = pre;
   if (pre == 's')
   {
      styps[0] = "-DSREAL";
      styps[1] = "-DSCPLX";
      pres[1] = 'c';
   }
   else
      pres[1] = 'z';

   ln = malloc((strlen(outd)+11)*sizeof(char));
   assert(ln);
   sprintf(ln, "%s/%cMake_amm", outd, pre);
   fp = fopen(ln, "w");
   assert(fp);
   free(ln);
   fprintf(fp, "include ../Make.inc\n");
   fprintf(fp, "CDEFS2=$(CDEFS)\n\n");
/*
 * Build list of all unique MU/NU combos for copy routines
 */
   mnurb = GetUniqueMNUnrolls(mmb, NULL);
   mnurb = GetUniqueMNUnrolls(urb, mnurb);
   allub = GetUniqueMUnrolls(mmb, NULL);
   allub = GetUniqueMUnrolls(urb, allub);
   allub = GetUniqueNUnrolls(mmb, allub);
   allub = GetUniqueNUnrolls(urb, allub);
/*
 * Spew out all filenames that must be compiled
 */
   fprintf(fp, "objs =");
/*
 * Routines to copy from MU/NU-major to column major output array
 */
   for (up=mnurb; up; up = up->next)
   {
      int j;
      const int mu=up->mu, nu=up->nu;
      for (j=0; j < 3; j++)
      {
         int k;
         char *rtn[2] = {"ablk2cmat", "cmat2ablk"};
         for (k=0; k < 2; k++)
         {
            int h;
            for (h=0; h < 2; h++)
            {
               char pre = pres[h];
@ROUT emit_amm
               fprintf(fp, " \\\n       ATL_%c%s_%dx%d_a%c_b1.o",
                       pre, rtn[k], mu, nu, al[j]);
               fprintf(fp, " ATL_%c%s_%dx%d_a%c_bX.o",
                       pre, rtn[k], mu, nu, al[j]);
               fprintf(fp, " \\\n       ATL_%c@(up)%s_%dx%d_a%c_b0.o",
                       pre, rtn[k], mu, nu, al[j]);
               fprintf(fp, " ATL_%c%s_%dx%d_a%c_bn.o",
                       pre, rtn[k], mu, nu, al[j]);
@ROUT emit_uamm
               fprintf(fp, " \\\n       ATL_%cu%d%s_%dx%d_a%c_b1.o",
                       pre, UID, rtn[k], mu, nu, al[j]);
               fprintf(fp, " ATL_%cu%d%s_%dx%d_a%c_bX.o",
                       pre, UID, rtn[k], mu, nu, al[j]);
               fprintf(fp, " \\\n       ATL_%cu%d%s_%dx%d_a%c_b0.o",
                       pre, UID, rtn[k], mu, nu, al[j]);
               fprintf(fp, " ATL_%cu%d%s_%dx%d_a%c_bn.o",
                       pre, UID, rtn[k], mu, nu, al[j]);
@ROUT emit_amm emit_uamm
            }
         }
      }
   }
/*
 * Routines to copy back and forth from A and B
 */
   for (up=allub; up; up = up->next)
   {
      int h;
      for (h=0; h < 2; h++)
      {
         char pre=pres[h];
         int j;
         const int u = up->mu;
         for (j=0; j < 3; j++)
         {
            if (up->kmaj > 1)
               fprintf(fp, 
@ROUT emit_amm
 " \\\n       ATL_%crm2am_a%c_%dx%d.o ATL_%ccm2am_a%c_%dx%d.o",
                       pre, al[j], up->kmaj, u, pre, al[j], up->kmaj, u);
            else
               fprintf(fp, " \\\n       ATL_%crm2am_a%c_%d.o ATL_%ccm2am_a%c_%d.o",
                       pre, al[j], u, pre, al[j], u);
            if (pre == 'c' || pre == 'z')
            {
               if (up->kmaj > 1)
                  fprintf(fp, 
 " \\\n       ATL_%crm2am_a%c_%dx%dC.o ATL_%ccm2am_a%c_%dx%dC.o",
                          pre, al[j], up->kmaj, u, pre, al[j], up->kmaj, u);
               else
                  fprintf(fp, " \\\n       ATL_%crm2am_a%c_%dC.o ATL_%ccm2am_a%c_%dC.o",
                          pre, al[j], u, pre, al[j], u);
@ROUT emit_uamm
 " \\\n       ATL_%cu%drm2am_a%c_%dx%d.o ATL_%cu%dcm2am_a%c_%dx%d.o",
              pre, UID, al[j], up->kmaj, u, pre, UID, al[j], up->kmaj, u);
            else
               fprintf(fp, " \\\n       ATL_%cu%drm2am_a%c_%d.o ATL_%cu%dcm2am_a%c_%d.o",
                       pre, UID, al[j], u, pre, UID, al[j], u);
            if (pre == 'c' || pre == 'z')
            {
               if (up->kmaj > 1)
                  fprintf(fp, 
 " \\\n       ATL_%cu%drm2am_a%c_%dx%dC.o ATL_%cu%dcm2am_a%c_%dx%dC.o",
                  pre, UID, al[j], up->kmaj, u, pre, UID, al[j], up->kmaj, u);
               else
                  fprintf(fp, " \\\n       ATL_%cu%drm2am_a%c_%dC.o ATL_%cu%dcm2am_a%c_%dC.o",
                          pre, UID, al[j], u, pre, UID, al[j], u);
@ROUT emit_amm emit_uamm
            }
         }
      }
   }
/*
 * AMM kernel routines
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      int kb = mmp->kbB;
/*
 *    Kernels that take runtime K are only compiled once, so don't repeat them
 *    for every KB.  Only generate a statement if this is the first one.
 */
      if (FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
      {
         const int id = mmp->ID;
         for (p=mmb; p != mmp; p = p->next)
            if (p->ID == id && FLAG_IS_SET(p->flag, MMF_KRUNTIME))
               break;
         if (p != mmp)
            continue;
         kb = 0;
      }
/* 
 *    ATL_<pre>@(UP)AMMM_<ID>_<kb>_<kmaj>_<mu>x<nu>x<ku>_b<X>
 */
      for (i=0; i < 3; i++)
@ROUT emit_amm
         fprintf(fp, " \\\n       ATL_%cAMMM_%d_%d_%d_%dx%dx%d_b%c.o", 
                 pre, mmp->ID, kb, mmp->kmaj, mmp->mu, mmp->nu, mmp->ku, be[i]);
@ROUT emit_uamm
         fprintf(fp, " \\\n       ATL_%cu%dAMMM_%d_%d_%d_%dx%dx%d_b%c.o", 
                 pre, UID, mmp->ID, kb, mmp->kmaj, mmp->mu, mmp->nu, mmp->ku, 
                 be[i]);
@ROUT emit_amm emit_uamm
   }
/*
 * AMM K-cleanup kernel routines are all unique, so no checking for repeats
 *    ATL_<pre>@(UP)AMMM_<ID>_<kb>_<kmaj>_<mu>x<nu>x<ku>_b0
 */
   for (mmp=ukb; mmp; mmp = mmp->next)
      for (i=0; i < 3; i++)
@ROUT emit_amm
         fprintf(fp, " \\\n       ATL_%cAMMM_%d_0_%d_%dx%dx%d_b%c.o", pre, 
                 mmp->ID, mmp->kmaj, mmp->mu, mmp->nu, mmp->ku, be[i]);
@ROUT emit_uamm
         fprintf(fp, " \\\n       ATL_%cu%dAMMM_%d_0_%d_%dx%dx%d_b%c.o", pre, 
                 UID, mmp->ID, mmp->kmaj, mmp->mu, mmp->nu, mmp->ku, be[i]);
@ROUT emit_amm
/*
 * rank-K AMM routines where KB is runtime variable
 */
   fixb = SplitRankK(rkb, &runb);
   KillAllMMNodes(runb);
   KillAllMMNodes(SplitRankK(urb, &runb));
   for (mmp=runb; mmp; mmp = mmp->next)
      for (i=0; i < 3; i++)
         fprintf(fp, " \\\n       ATL_%cAMMM_%d_0_%d_%dx%dx%d_b%c.o", pre, 
                 mmp->ID, mmp->kmaj, mmp->mu, mmp->nu, mmp->ku, be[i]);
/*
 * rank-K AMM routines where KB is compile-time, need obj for each unique kbB
 */
   for (mmp=fixb; mmp; mmp = mmp->next)
   {
      if (!ExactKernelInList(mmb, mmp) && !ExactKernelInList(ukb, mmp))
      {
         for (i=0; i < 3; i++)
            fprintf(fp, " \\\n       ATL_%cAMMM_%d_%d_%d_%dx%dx%d_b%c.o", 
                    pre, mmp->ID, mmp->kbB, mmp->kmaj, mmp->mu, mmp->nu, 
                    mmp->ku, be[i]);
      }
   }
@ROUT emit_amm emit_uamm
/*
 * library make targets
 */
   fprintf(fp, "\n\nlib : %clib.grd\nall : %clib.grd\n%clib : %clib.grd\n", 
           pre, pre, pre, pre);
   fprintf(fp, "%clib.grd : $(objs)\n", pre);
   fprintf(fp, "\t$(ARCHIVER) $(ARFLAGS) $(@(lib)lib) $(objs)\n");
   fprintf(fp, "\t $(RANLIB) $(@(lib)lib)\n");
   fprintf(fp, "\t touch %clib.grd\n", pre);
   fprintf(fp, "clean : %cclean\n", pre);
   fprintf(fp, "%cclean:\n\t- rm -f $(objs)\n", pre);
   fprintf(fp, "killall : %ckillall\n", pre);
   fprintf(fp, "%ckillall : %cclean\n", pre, pre);
   fprintf(fp, "\t- $(ARCHIVER) d $(@(lib)lib) $(objs)\n");
   fprintf(fp, "\t $(RANLIB) $(@(lib)lib)\n");
   fprintf(fp, "\t- rm -f ATL_%c*.[S,c]\n", pre);

/*
 * Print out the individual rules for each needed copy function
 */
   dcomp[2] = dflags[2] = toupper(pre);
   dflags[3] = dcomp[3] = 'K';
   fprintf(fp, "\ntsth.o : tsth.c\n");
   fprintf(fp, "\t%s %s $(CDEFS) %s -c tsth.c\n\n", dcomp, dflags, styp);
   fprintf(fp, "#\n# Data copy rules\n#\n");
/*
 * Print out 2-D ablk2Cmat and cmat2ablk targets
 */
   for (up=mnurb; up; up = up->next)
   {
      const int mu=up->mu, nu = up->nu;
      char cbe[4] = {'0', '1', 'n', 'X'};
      int ibe[4] =  {0,    1,  -1,  2};
      int i, j;
      for (i=0; i < 4; i++)
      {
         int h;
         for (h=0; h < 2; h++)
         {
            char pre=pres[h];
            char *styp=styps[h];
            for (j=0; j < 3; j++)
            {
               int k;
               char *rtn[2] = {"ablk2cmat", "cmat2ablk"};
               for (k=0; k < 2; k++)
               {
                  char rn[64];
@ROUT emit_amm
                  sprintf(rn, "ATL_%c%s_%dx%d_a%c_b%c",
                          pre, rtn[k], mu, nu, al[j], cbe[i]);
                  fprintf(fp, "%s.o : %s.c\n", rn, rn);
                  fprintf(fp, "\t%s %s $(CDEFS) %s -c %s.c\n", 
                          dcomp, dflags, styp, rn);
@ROUT emit_uamm
                  sprintf(rn, "ATL_%cu%d%s_%dx%d_a%c_b%c",
                          pre, UID, rtn[k], mu, nu, al[j], cbe[i]);
                  fprintf(fp, "%s.o : %s.c\n", rn, rn);
                  fprintf(fp, "\t%s %s $(CDEFS) %s -c -DATL_%c%s=%s \\\n", 
                          dcomp, dflags, styp, rn[4], rn+6+UIL, rn);
                  fprintf(fp, "          -c %s.c\n", rn);
@ROUT emit_amm emit_uamm
               }
            }
         }
      }
   }
   KillUnrollList(mnurb);
/*
 * Print out 1-D copy-in routine rules
 */
   for (up=allub; up; up = up->next)
   {
      const int u = up->mu, kmaj=up->kmaj;
      int j;
      for (j=0; j < 3; j++)
      {
         int h;
         for (h=0; h < 2; h++)
         {
            char pre=pres[h];
            char *styp=styps[h];
            char *cst[2] = {"", "C"};
            char *cdef[2] = {"", "-DConj_=1 "};
            int g;
            const int G = (pre == 'c' || pre == 'z') ? 2:1;
            for (g=0; g < G; g++)
            {
               int kk;
@ROUT emit_amm
               char rout[32];
               if (kmaj > 1)
                  sprintf(rout, "ATL_%crm2am_a%c_%dx%d", pre, al[j], kmaj, u);
               else
                  sprintf(rout, "ATL_%crm2am_a%c_%d", pre, al[j], u);
@ROUT emit_uamm
               char rout[32], rt0[32];
               if (kmaj > 1)
               {
                  sprintf(rout, "ATL_%cu%drm2am_a%c_%dx%d", 
                          pre, UID, al[j], kmaj, u);
                  sprintf(rt0, "ATL_%crm2am_a%c_%dx%d", pre, al[j], kmaj, u);
               }
               else
               {
                  sprintf(rout, "ATL_%cu%drm2am_a%c_%d", pre, UID, al[j], u);
                  sprintf(rt0, "ATL_%crm2am_a%c_%d", pre, al[j], u);
               }
@ROUT emit_amm emit_uamm
               for (kk=0; kk < 2; kk++)
               {
                  if (kk == 1)
@ROUT emit_amm  `                  rout[5] = 'c';`
@ROUT emit_uamm `                  rt0[5] = rout[6+UIL] = 'c';`
                  fprintf(fp, "%s%s.o : %s.c\n", rout, cst[g], rout);
@ROUT emit_amm
                  fprintf(fp, "\t%s %s $(CDEFS) %s%s -o %s%s.o -c %s.c\n", 
                          dcomp, dflags, cdef[g], styp, rout, cst[g], rout);
@ROUT emit_uamm
               fprintf(fp, 
                       "\t%s %s $(CDEFS) %s%s -D%s%s=%s%s -o %s%s.o -c %s.c\n", 
                       dcomp, dflags, cdef[g], styp, rt0, cst[g], rout, cst[g],
                       rout, cst[g], rout);
@ROUT emit_amm emit_uamm
               }
            }
         }
      }
   }
   KillUnrollList(allub);
/*
 * Print out the individual rules for each kernel compile
 */
   dflags[3] = dcomp[3] = 'M';
   fprintf(fp, "#\n#  AMM kernel rules\n#\n");
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
/*
 *    Kernels that take runtime K are only compiled once, so print rules on
 *    only the first encounter of that ID
 */
      if (FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
      {
         const int id = mmp->ID;
         for (p=mmb; p != mmp; p = p->next)
            if (p->ID == id && FLAG_IS_SET(p->flag, MMF_KRUNTIME))
               break;
         if (p != mmp)
            continue;
      }
      if (mmp->comp)
      {
         comp = (mmp->comp[0] == 'g' && mmp->comp[1] == 'c' && 
                 mmp->comp[2] == 'c' && 
                 (mmp->comp[3] == '\0' || mmp->comp[3] == ' ')) 
              ? "$(GOODGCC)" : mmp->comp;
         cflags = mmp->cflags;
      }
      else
      {
         comp = dcomp;
         cflags = dflags;
      }
/* 
 *    ATL_<pre>@(UP)AMMM_<ID>_<kb>_<kmaj>_<mu>x<nu>x<ku>_b<X>, 
 *    kerns in all 3 beta cases
 */
      for (i=0; i < 3; i++)
      {
         const int kb=FLAG_IS_SET(mmp->flag, MMF_KRUNTIME)?0:mmp->kbB;
         const int kmaj = mmp->kmaj;
@ROUT emit_amm
         fprintf(fp, "ATL_%cAMMM_%d_%d_%d_%dx%dx%d_b%c.o : %s\n", pre, 
                 mmp->ID,kb, kmaj, mmp->mu, mmp->nu, mmp->ku, be[i], mmp->rout);
@ROUT emit_uamm
         fprintf(fp, "ATL_%cu%dAMMM_%d_%d_%d_%dx%dx%d_b%c.o : %s\n", pre, 
                 UID, mmp->ID, kb, kmaj, mmp->mu, mmp->nu, mmp->ku, 
                 be[i], mmp->rout);
@ROUT emit_amm emit_uamm
         fprintf(fp, "\t%s $(CDEFS2) %s -DBETA%s=1", comp, styp, bes[i]);
         if (!FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
            fprintf(fp, " -DMB=%d -DNB=%d, -DKB=%d", 
                    mmp->mbB, mmp->nbB, mmp->kbB);
@ROUT emit_amm
         fprintf(fp, " -DATL_USERMM=ATL_%cAMMM_%d_%d_%d_%dx%dx%d_b%c", pre,
                 mmp->ID, kb, kmaj, mmp->mu, mmp->nu, mmp->ku, be[i]);
         fprintf(fp, " %s -o ATL_%cAMMM_%d_%d_%d_%dx%dx%d_b%c.o -c %s\n", 
                 cflags, pre, mmp->ID, kb, kmaj, mmp->mu, mmp->nu, mmp->ku, 
                 be[i], mmp->rout);
@ROUT emit_uamm
         fprintf(fp, " -DATL_USERMM=ATL_%cu%dAMMM_%d_%d_%d_%dx%dx%d_b%c", pre,
                 UID, mmp->ID, kb, kmaj, mmp->mu, mmp->nu, mmp->ku, be[i]);
         fprintf(fp, " %s -o ATL_%cu%dAMMM_%d_%d_%d_%dx%dx%d_b%c.o -c %s\n", 
                 cflags, pre, UID, mmp->ID, kb, kmaj, mmp->mu, mmp->nu, 
                 mmp->ku, be[i], mmp->rout);
@ROUT emit_amm emit_uamm
      }
   }
/*
 * K-cleanup needs only the kernel compile rule
 */
   fprintf(fp, "#\n#  K-cleanup rules\n#\n");
   for (mmp=ukb; mmp; mmp = mmp->next)
   {
      const int kmaj = mmp->kmaj;
      if (mmp->comp)
      {
         comp = (mmp->comp[0] == 'g' && mmp->comp[1] == 'c' && 
                 mmp->comp[2] == 'c' && 
                 (mmp->comp[3] == '\0' || mmp->comp[3] == ' ')) 
              ? "$(GOODGCC)" : mmp->comp;
         cflags = mmp->cflags;
      }
      else
      {
         comp = dcomp;
         cflags = dflags;
      }
      for (i=0; i < 3; i++)
      {
@ROUT emit_amm
         fprintf(fp, "ATL_%cAMMM_%d_0_%d_%dx%dx%d_b%c.o : %s\n", pre, 
                 mmp->ID, kmaj, mmp->mu, mmp->nu, mmp->ku, be[i], mmp->rout);
         fprintf(fp, "\t%s $(CDEFS2) %s -DBETA%s=1", comp, styp, bes[i]);
         fprintf(fp, " -DATL_USERMM=ATL_%cAMMM_%d_0_%d_%dx%dx%d_b%c", pre,
                 mmp->ID, kmaj, mmp->mu, mmp->nu, mmp->ku, be[i]);
         fprintf(fp, " %s -o ATL_%cAMMM_%d_0_%d_%dx%dx%d_b%c.o -c %s\n", 
                 cflags, pre, mmp->ID, kmaj, mmp->mu, mmp->nu, mmp->ku, 
                 be[i], mmp->rout);
@ROUT emit_uamm
         fprintf(fp, "ATL_%cu%dAMMM_%d_0_%d_%dx%dx%d_b%c.o : %s\n", pre, UID,
                 mmp->ID, kmaj, mmp->mu, mmp->nu, mmp->ku, be[i], mmp->rout);
         fprintf(fp, "\t%s $(CDEFS2) %s -DBETA%s=1", comp, styp, bes[i]);
         fprintf(fp, " -DATL_USERMM=ATL_%cu%dAMMM_%d_0_%d_%dx%dx%d_b%c", pre,
                 UID, mmp->ID, kmaj, mmp->mu, mmp->nu, mmp->ku, be[i]);
         fprintf(fp, " %s -o ATL_%cu%dAMMM_%d_0_%d_%dx%dx%d_b%c.o -c %s\n", 
                 cflags, pre, UID, mmp->ID, kmaj, mmp->mu, mmp->nu, mmp->ku, 
                 be[i], mmp->rout);
@ROUT emit_amm emit_uamm
      }
   }
@ROUT emit_amm
/*
 * runtime-KB rank-K needs only one kernel compile rule
 */
   if (runb)
      fprintf(fp, "#\n#  rank-K kernels with run-time K\n#\n");
   for (mmp=runb; mmp; mmp = mmp->next)
   {
      const int kmaj = mmp->kmaj;
      if (mmp->comp)
      {
         comp = (mmp->comp[0] == 'g' && mmp->comp[1] == 'c' && 
                 mmp->comp[2] == 'c' && 
                 (mmp->comp[3] == '\0' || mmp->comp[3] == ' ')) 
              ? "$(GOODGCC)" : mmp->comp;
         cflags = mmp->cflags;
      }
      else
      {
         comp = dcomp;
         cflags = dflags;
      }
      for (i=0; i < 3; i++)
      {
         fprintf(fp, "ATL_%cAMMM_%d_0_%d_%dx%dx%d_b%c.o : %s\n", pre, mmp->ID, 
                 kmaj, mmp->mu, mmp->nu, mmp->ku, be[i], mmp->rout);
         fprintf(fp, "\t%s $(CDEFS2) %s -DBETA%s=1", comp, styp, bes[i]);
         fprintf(fp, " -DATL_USERMM=ATL_%cAMMM_%d_0_%d_%dx%dx%d_b%c", pre, 
                 mmp->ID, kmaj, mmp->mu, mmp->nu, mmp->ku, be[i]);
         fprintf(fp, " %s -o ATL_%cAMMM_%d_0_%d_%dx%dx%d_b%c.o -c %s\n", 
                 cflags, pre, mmp->ID, kmaj, mmp->mu, mmp->nu, mmp->ku, 
                 be[i], mmp->rout);
      }
   }
/*
 * Compile-time rank-K must be recompiled for each kbB
 */
   if (fixb)
      fprintf(fp, "#\n#  rank-K kernels with compile-time KB\n#\n");
   for (mmp=fixb; mmp; mmp = mmp->next)
   {
      const int kmaj = mmp->kmaj;
      if (ExactKernelInList(ukb, mmp))
         continue;
      if (ExactKernelInList(mmb, mmp))
         continue;
      if (mmp->comp)
      {
         comp = (mmp->comp[0] == 'g' && mmp->comp[1] == 'c' && 
                 mmp->comp[2] == 'c' && 
                 (mmp->comp[3] == '\0' || mmp->comp[3] == ' ')) 
              ? "$(GOODGCC)" : mmp->comp;
         cflags = mmp->cflags;
      }
      else
      {
         comp = dcomp;
         cflags = dflags;
      }
      for (i=0; i < 3; i++)
      {
         fprintf(fp, "ATL_%cAMMM_%d_%d_%d_%dx%dx%d_b%c.o : %s\n", pre, mmp->ID, 
                 mmp->kbB, kmaj, mmp->mu, mmp->nu, mmp->ku, be[i], mmp->rout);
         fprintf(fp, "\t%s $(CDEFS2) %s -DBETA%s=1", comp, styp, bes[i]);
         fprintf(fp, " -DKB=%d -DATL_USERMM=ATL_%cAMMM_%d_%d_%d_%dx%dx%d_b%c", 
                 mmp->kbB, pre, mmp->ID, mmp->kbB, kmaj, mmp->mu, mmp->nu, 
                 mmp->ku, be[i]);
         fprintf(fp, " %s -o ATL_%cAMMM_%d_%d_%d_%dx%dx%d_b%c.o -c %s\n", 
                 cflags, pre, mmp->ID, mmp->kbB, kmaj, mmp->mu, mmp->nu, 
                 mmp->ku, be[i], mmp->rout);
      }
   }
   KillAllMMNodes(fixb);
   KillAllMMNodes(runb);
@ROUT emit_amm emit_uamm
   fclose(fp);
}

void GenKerns(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *ukb, ATL_mmnode_t *urb,
              char *outd)
/*
 * Creates/copies all required matmul kernels into outd using specified names
 */
{
   ATL_mmnode_t *mmp, *p;
   mnur_t *mnurb=NULL, *allub, *up;
   char *ln=NULL;
   int lnlen=0, dlen;
   char al[3] = {'1', 'n', 'X'};
   int ial[3] = {1,   -1,   2};
   char pres[2];
   pres[0] = pre;
   pres[1] = (pre == 's') ? 'c' : 'z';
/*
 * Build list of all unique MU/NU combos for copy routines
 */
   mnurb = GetUniqueMNUnrolls(mmb, NULL);
   mnurb = GetUniqueMNUnrolls(urb, mnurb);
   allub = GetUniqueMUnrolls(mmb, NULL);
   allub = GetUniqueMUnrolls(urb, allub);
   allub = GetUniqueNUnrolls(mmb, allub);
   allub = GetUniqueNUnrolls(urb, allub);
   dlen = strlen(outd);
/*
 * Extract every unique block-copy routine
 */
   for (up=mnurb; up; up = up->next)
   {
      const int mu=up->mu, nu=up->nu;
      char cbe[4] = {'0', '1', 'n', 'X'};
      int ibe[4] =  {0,    1,  -1,  2};
      int i, j;
      j = 64+8 + strlen(outd);
      j = (j > 128) ? j : 128;
      if (lnlen < j)
      {
         free(ln);
         lnlen = j;
         ln = malloc(j*sizeof(char));
         assert(ln);
      }
      for (i=0; i < 4; i++)
      {
         for (j=0; j < 3; j++)
         {
            char rn[64];
            int ierr;
            int k;
            for (k=0; k < 2; k++)
            {
               int h;
               for (h=0; h < 2; h++)
               {
                  char pre = pres[h];
                  if (!k)
                     sprintf(rn, "ATL_%cablk2cmat_%dx%d_a%c_b%c.c",
                             pre, mu, nu, al[j], cbe[i]);
                  else
                     sprintf(rn, "ATL_%ccmat2ablk_%dx%d_a%c_b%c.c",
                             pre, mu, nu, al[j], cbe[i]);
                  sprintf(ln, 
                     "make %s pre=%c mu=%d nu=%d al=%c be=%c alpha=%d beta=%d", 
                          rn, pre, mu, nu, al[j], cbe[i], ial[j], ibe[i]);
                  ierr = system(ln);
                  if (ierr)
                  {
                     fprintf(stderr, "FAILED CMND='%s'\n", ln);
                     exit(ierr);
                  }
@ROUT emit_uamm
                  sprintf(ln, "mv %s %s/ATL_%cu%d%s", rn, outd, pre, UID, rn+5);
@ROUT emit_amm
                  sprintf(ln, "mv %s %s/.", rn, outd);
@ROUT emit_amm emit_uamm
                  ierr = system(ln);
                  if (ierr)
                  {
                     fprintf(stderr, "FAILED CMND='%s'\n", ln);
                     exit(ierr);
                  }
               }
            }
         }
      }
   }
   KillUnrollList(mnurb);

/*
 * Routines to copy back and forth from A and B
 */
   for (up=allub; up; up = up->next)
   {
      const int u = up->mu, kmaj=up->kmaj;
      int j;
      j = 16 * 40 + (strlen(outd)<<1);
      j = (j > 90) ? j : 90;
      if (lnlen < j)
      {
         free(ln);
         lnlen = j;
         ln = malloc(j*sizeof(char));
         assert(ln);
      }
      for (j=0; j < 3; j++)
      {
         int h;
         for (h=0; h < 2; h++)
         {
            int ierr;
            char pre = pres[h];
            sprintf(ln, "make ATL_%crm2am_a%c_%d.c ATL_%ccm2am_a%c_%d.c pre=%c UR=%d alpha=%d al=%c kmaj=%d",
                    pre, al[j], u, pre, al[j], u, pre, u, ial[j], al[j], kmaj);
            ierr = system(ln);
            if (ierr)
            {
               fprintf(stderr, "FAILED CMND='%s'\n", ln);
               exit(ierr);
            }
            if (kmaj > 1)
            {
               sprintf(ln, 
@ROUT emit_amm
                  "mv ATL_%crm2am_a%c_%d.c %s/ATL_%crm2am_a%c_%dx%d.c",
                       pre, al[j], u, outd, pre, al[j], kmaj, u);
@ROUT emit_uamm
                  "mv ATL_%crm2am_a%c_%d.c %s/ATL_%cu%drm2am_a%c_%dx%d.c",
                       pre, al[j], u, outd, pre, UID, al[j], kmaj, u);
@ROUT emit_amm emit_uamm
               ierr = system(ln);
               if (ierr)
               {
                  fprintf(stderr, "FAILED CMND='%s'\n", ln);
                  exit(ierr);
               }
               sprintf(ln, 
@ROUT emit_amm
                    "mv ATL_%ccm2am_a%c_%d.c %s/ATL_%ccm2am_a%c_%dx%d.c",
                       pre, al[j], u, outd, pre, al[j], kmaj, u);
@ROUT emit_uamm
                    "mv ATL_%ccm2am_a%c_%d.c %s/ATL_%cu%dcm2am_a%c_%dx%d.c",
                       pre, al[j], u, outd, pre, UID, al[j], kmaj, u);
@ROUT emit_amm emit_uamm
            }
            else
            {
               sprintf(ln, 
@ROUT emit_amm
                       "mv ATL_%crm2am_a%c_%d.c %s/ATL_%crm2am_a%c_%d.c",
                       pre, al[j], u, outd, pre, al[j], u);
@ROUT emit_uamm
                       "mv ATL_%crm2am_a%c_%d.c %s/ATL_%cu%drm2am_a%c_%d.c",
                       pre, al[j], u, outd, pre, UID, al[j], u);
@ROUT emit_amm emit_uamm
               ierr = system(ln);
               if (ierr)
               {
                  fprintf(stderr, "FAILED CMND='%s'\n", ln);
                  exit(ierr);
               }
               sprintf(ln, 
@ROUT emit_amm
                       "mv ATL_%ccm2am_a%c_%d.c %s/ATL_%ccm2am_a%c_%d.c",
                       pre, al[j], u, outd, pre, al[j], u);
@ROUT emit_uamm
                       "mv ATL_%ccm2am_a%c_%d.c %s/ATL_%cu%dcm2am_a%c_%d.c",
                       pre, al[j], u, outd, pre, UID, al[j], u);
@ROUT emit_amm emit_uamm
            }
            ierr = system(ln);
            if (ierr)
            {
               fprintf(stderr, "FAILED CMND='%s'\n", ln);
               exit(ierr);
            }
         }
      }
   }
   KillUnrollList(allub);
/*
 * Copy/generate every unique file, but only once
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      const int id=mmp->ID;
/*
 *    For generated files, just overwrite dups with same file, won't hurt
 */
      if (id == 0)
      {
         assert(mmp->genstr);
         assert(!system(mmp->genstr));
      }
      else  /* user-supplied files copied from AMMCASES directory */
      {
/*
 *       If this is the first time we've seen this ID, it must be copied
 */
         for (p=mmb; p != mmp && p->ID != id; p = p->next);
         if (p == mmp)
         {
            int i, ierr;
            i = strlen(mmp->rout) + dlen + 16;
            if (i > lnlen)
            {
               if (ln)
                  free(ln);
               ln = malloc(i*sizeof(char));
               assert(ln);
               lnlen = i;
            }
            sprintf(ln, "cp AMMCASES/%s %s/.", mmp->rout, outd);
            ierr = system(ln);
            if (ierr)
            {
               fprintf(stderr, "FAILED CMND='%s'\n", ln);
               exit(ierr);
            }
         }
      }
   }
/*
 * Copy/generate k-cleanup which is known to be unique
 */
   for (mmp=ukb; mmp; mmp = mmp->next)
   {
      const int id=mmp->ID;
/*
 *    For generated files, just generate it using genstr
 */
      if (id == 0)
      {
         assert(mmp->genstr);
         assert(!system(mmp->genstr));
      }
      else  /* user-supplied files copied from AMMCASES directory */
      {
         int i, ierr;
         i = strlen(mmp->rout) + dlen + 16;
         if (i > lnlen)
         {
            if (ln)
               free(ln);
            ln = malloc(i*sizeof(char));
            assert(ln);
            lnlen = i;
         }
         sprintf(ln, "cp AMMCASES/%s %s/.", mmp->rout, outd);
         ierr = system(ln);
         if (ierr)
         {
            fprintf(stderr, "FAILED CMND='%s'\n", ln);
            exit(ierr);
         }
      }
   }
@ROUT emit_amm
/*
 * Copy/generate rank-K kerns which are known to be unique
 */
   for (mmp=urb; mmp; mmp = mmp->next)
   {
      const int id=mmp->ID;
/*
 *    For generated files, just generate it using genstr
 */
      if (id == 0)
      {
         assert(mmp->genstr);
         assert(!system(mmp->genstr));
      }
      else  /* user-supplied files copied from AMMCASES directory */
      {
         int i, ierr;
         i = strlen(mmp->rout) + dlen + 16;
         if (i > lnlen)
         {
            if (ln)
               free(ln);
            ln = malloc(i*sizeof(char));
            assert(ln);
            lnlen = i;
         }
         sprintf(ln, "cp AMMCASES/%s %s/.", mmp->rout, outd);
         ierr = system(ln);
         if (ierr)
         {
            fprintf(stderr, "FAILED CMND='%s'\n", ln);
            exit(ierr);
         }
      }
   }
@ROUT emit_amm emit_uamm
   if (ln)
      free(ln);
}
void GenAllFiles(char pre, ATL_mmnode_t *mmb, ATL_mmnode_t *ukb, 
                 ATL_mmnode_t *kcb, ATL_mmnode_t *rkb, ATL_mmnode_t *urb,
                 char *outd)
{
   GenHeaderFiles(pre, mmb, ukb, kcb, rkb, urb, outd);
   GenMakefile(pre, mmb, ukb, rkb, urb, outd);
   GenKerns(pre, mmb, ukb, urb, outd);
}


int KernelInList(ATL_mmnode_t *mmb, ATL_mmnode_t *p)
/*
 * RETURNS: 1 if p is duplicated in mmb, else 0
 */
{
   ATL_mmnode_t *mp;
   if (!p || !mmb)
      return(0);
   for (mp=mmb; mp; mp = mp->next)
      if (KernelIsSame(mp, p))
         return(1);
    return(0);
}

ATL_mmnode_t *StripNonUniqueKs(ATL_mmnode_t *ukb, ATL_mmnode_t *mmb) 
/*
 * Deletes any ukb node that also appears in mmb,
 * RETURNS: possibly shortened ukb
 */
{
   ATL_mmnode_t *mp, *prev;
/*
 * Delete any repetitive nodes starting unique queue
 */
   while(ukb && KernelInList(mmb, ukb))
      ukb = KillMMNode(ukb);
   if (!ukb)
      return(ukb);
/*
 * Now, delete any internal non-unique K-cleanup
 */
   prev = ukb;
   mp = ukb->next;
   while (mp)
   {
      if (KernelInList(mmb, mp))
         mp = prev->next = KillMMNode(mp);
      else
      {
         prev = mp;
         mp = mp->next;
      }
   }
   return(ukb);
}
ATL_mmnode_t *StripExactMatchKs(ATL_mmnode_t *ukb, ATL_mmnode_t *mmb) 
/*
 * Deletes any ukb node that also appears in mmb with same K-value,
 * RETURNS: possibly shortened ukb
 */
{
   ATL_mmnode_t *mp, *prev;
/*
 * Delete any repetitive nodes starting unique queue
 */
   while(ukb && ExactKernelInList(mmb, ukb))
      ukb = KillMMNode(ukb);
   if (!ukb)
      return(ukb);
/*
 * Now, delete any internal non-unique K-cleanup
 */
   prev = ukb;
   mp = ukb->next;
   while (mp)
   {
      if (ExactKernelInList(mmb, mp))
         mp = prev->next = KillMMNode(mp);
      else
      {
         prev = mp;
         mp = mp->next;
      }
   }
   return(ukb);
}
/*
 * RETURNS: mmb, with all repeated kernels removed
 */
ATL_mmnode_t *RemoveNonUniqueKernels(ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mp;
   if (!mmb || !mmb->next)
      return(mmb);
   for (mp=mmb; mp; mp = mp->next)
   {
      ATL_mmnode_t *p=mp->next, *prev=mp;
      while (p)
      {
@skip    if (KernelIsSame(mp, p) && (FLAG_IS_SET(p->flag, MMF_KRUNTIME) ||
@skip        p->kbB == mp->kbB))
         if (KernelIsSame(mp, p))
            prev->next = p = KillMMNode(p);
         else
         {
            prev = p;
            p = p->next;
         }
      }
   }
   return(mmb);
}

int main(int nargs, char **args)
{
   char pre='d';
   int verb=1;
   int *nbs;
   char *outd, *ukin, *kcin, *rkin;
   ATL_mmnode_t *mmb, *mmp, *ukb=NULL, *kcb=NULL, *rkb=NULL, *urb=NULL;

   mmb = GetFlags(nargs, args, &pre, &outd, &ukin, &kcin, &rkin);
   assert(mmb);
   if (pre == 'c')
      pre = 's';
   else if (pre == 'z')
      pre = 'd';
@beginskip
   if (pre == 'c' || pre == 'z')
   {
      if (rkin)
         rkb = ReadMMFile(rkin);
      GenCmplxHeaders(pre, mmb, rkb, outd);
      KillAllMMNodes(mmb);
      if (rkin)
         KillAllMMNodes(rkb);
      exit(0);
   }
@endskip
   if (ukin)
   {
      ukb = ReadMMFile(ukin);
      free(ukin);
/*
 *    Now, strip off any ukb node that also appears in mmb, in order to
 *    make sure we don't repeat prototypes, generation, etc
 */
      ukb = StripNonUniqueKs(ukb, mmb);
   }
   if (kcin)
   {
      kcb = ReadMMFile(kcin);
      free(kcin);
   }
   if (rkin)
   {
      rkb = ReadMMFile(rkin);
      urb = CloneMMQueue(rkb);
      urb = RemoveNonUniqueKernels(urb);
      urb = StripExactMatchKs(urb, kcb);
      urb = StripExactMatchKs(urb, mmb);
      free(rkin);
   }
   FillInGenStrings(pre, mmb, outd);
   FillInGenStrings(pre, ukb, outd);
   FillInGenStrings(pre, kcb, outd);
   FillInGenStrings(pre, rkb, outd);
   FillInGenStrings(pre, urb, outd);
   GenAllFiles(pre, mmb, ukb, kcb, rkb, urb, outd);
   KillAllMMNodes(mmb);
   KillAllMMNodes(ukb);
   KillAllMMNodes(kcb);
   KillAllMMNodes(rkb);
   exit(0);
}
@ROUT ammsearch uammsearch
@extract -b @(topd)/cw.inc lang=C -def cwdate 2012 -def cwdate 2013
#include "atlas_misc.h"
#include "atlas_gnuvec.h"
#define ATL_JKMDEF 1
#include "atlas_mmtesttime.h"

#define NVECS 4
static enum VECTYPE {VTAVXZ=0, VTAVX=1, VTSSE=2, VTGV=3, VTSC=4} VECi=VTSC;
static int VLEN[5] = {8, 4, 2, 2, 1};  /* assume double, fix later if nec */
static char *VECs[5] = {"avxz", "avx", "sse", "gvec", "scalar"};
static int TSIZE=8;
#define KRUNMUL 1.02   /* KRUNTIME speedup increase over K-compile time */

@extract -b @(basd)/atlas.base rout=Mylcm

double TimeMMKernel_KB
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   ATL_mmnode_t *mmp,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >=0: size of cache flush, else ignored */
)
/*
 * If kernel has property KRUNTIME, try timing it with compile- and run-time K,
 * and if compile-time is more than 2% faster, turn off KRUNTIME
 */
{
   double mf;
   if (mmp->kbmax && kb > mmp->kbmax)
      return(0.0);
   if (mmp->kbmin && kb < mmp->kbmin)
      return(0.0);
   mf = TimeMMKernel(verb, FORCETIME, mmp, pre, mb, nb, kb, 0, 0, 0, 
                     beta, mflop, cflush);
   if (FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
   {
      double mfC;
      mmp->flag &= ~(1<<MMF_KRUNTIME);
      mfC = TimeMMKernel(verb, FORCETIME, mmp, pre, mb, nb, kb, kb, kb, mb, 
                         beta, mflop, cflush);
      if (mfC <= 1.02*mf)
         mmp->flag |= (1<<MMF_KRUNTIME);
      else
      {
         if (verb)
            printf("      Forcing K compile-time, mfC=%.2f, mfR=%.2f\n", 
                   mfC, mf);
         mf = mfC;
      }
   }
   return(mf);
}
ATL_mmnode_t *BestForThisNB
(
   int verb, 
   char pre, 
   ATL_mmnode_t *mmb, 
   int nb, 
   int pnb,  /* previous nb */
   int nnb,  /* next nb */
   int FORCE
)
/*
 * Times all kernels in mmb
 * RETURNS: ptr to best performing kernel, empty gen node if no user case wrks
 */
{
   ATL_mmnode_t *mmp, *mmB=NULL;
   double mf, mf0, mfB=0.0;

   printf("SCOPING FOR BEST PERFORMING KERNEL FOR NB=%d\n", nb);
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      int kb;
/*
 *    Choose kb, if forced only kb will do, so skip if kernel can't do it
 */
      if (FORCE || nb <= 16)
         kb = nb;
/*
 *    If this kernel can't do the exact block factor, allow leeway
 */
      else
      {
         int u;
         u = Mylcm(mmp->mu, mmp->nu);
         u = Mylcm(u, mmp->ku);
         kb = (nb/u)*u;
         if (kb != nb)
         {
            int kbB;
            kbB = ((nb+u-1)/u)*u;
            if (!kb || kbB-nb < nb-kb && kbB <= 4)
               kb = kbB;
         }
      }
      if ((mmp->kbmin && kb < mmp->kbmin) ||
          (mmp->kbmax && kb > mmp->kbmax) ||
          ((kb/mmp->mu)*mmp->mu != kb) || ((kb/mmp->nu)*mmp->nu != kb) ||
          ((kb/mmp->ku)*mmp->ku != kb) || (kb == pnb) || (kb == nnb))
      {
         
         printf("   %d. %s: SKIPPED, bad NB\n", mmp->ID, mmp->rout);
         continue;
      }
      mf0 = TimeMMKernel(verb, 0, mmp, pre, kb, kb, kb, kb, kb, kb, 1, 0, -1);
/*
 *    Give bonus to K-runtime variable over K-compile time; K-runtime kernels
 *    can be used for some K-cleanup, and they can be used for any required KB
 *    as well as being typically much smaller instruction load, so they are
 *    strongly prefered
 */
      mf = FLAG_IS_SET(mmp->flag, MMF_KRUNTIME) ? mf0*KRUNMUL : mf0;
      if (mf > mfB)
      {
         mfB = mf;
         mmB = mmp;
         mmB->mbB = mmB->nbB = mmB->kbB = kb;
      }
      printf("   %d. %s: kb=%d, MFLOP=%.2f\n", mmp->ID, mmp->rout, kb, mf0);
   }
   if (!mmB)
   {
      printf("NO KERNEL POSSIBLE FOR NB=%d\n", nb);
      mmB = GetMMNode();
      mmB->mbB = mmB->nbB = mmB->kbB = nb;
   }
   else
   {
      int i, kb = mmB->kbB;
      i = MMKernelFailsTest(pre, kb, kb, kb, 0, mmB);
      if (!i)
         i = MMKernelFailsTest(pre, kb, kb, kb, 1, mmB);
      if (!i)
         i = MMKernelFailsTest(pre, kb, kb, kb, -1, mmB);
      if (i)
      {
         printf("BEST KERNEL FAILS TESTER FOR NB=%d\n", kb);
         exit(i);
      }
      if (FLAG_IS_SET(mmB->flag, MMF_KRUNTIME))
         mfB /= KRUNMUL;
      printf("BEST KERNEL FOUND FOR NB=%d: ID#%d '%s' %.2f MFLOPS\n\n", 
             nb, mmB->ID, mmB->rout, mfB);
      mmB = CloneMMNode(mmB);
      mmB->mflop[0] = mfB;
      mmB->next = NULL;
   }
   return(mmB);
}

int DeleteBadBigNBs(ATL_mmnode_t *mmb, int *nbs)
{
   ATL_mmnode_t *best=NULL, *mmp;
   double mfB=0.0;
   int n=0;
/*
 * Find the best-performing kernel
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      double mf;
      mf = mmp->mflop[0];
      if (mf > mfB)
      {
         mfB = mf;
         best = mmp;
      }
   }
/*
 * Delete all NBs larger than best
 */
   while (best->next)
   {
      best->next = KillMMNode(best->next);
      n++;
   }
   if (n)
   {
      int N = *nbs;
      N = (N >= 0) ? N : -N;
      printf("Deleted %d large, slow kernels starting at NB=%d\n", 
             n, nbs[N-n+1]);
   }
   return(n);
}

ATL_mmnode_t *FindBestForEachNB(int verb, char pre, ATL_mmnode_t *mmb, int *nbs)
{
   int i, n, FORCE;
   ATL_mmnode_t *best, *bp;
/*
 * If # of nbs is negative, then each nb is required and that exact size
 * will be used, or no NB of that size if no kernel works.  The normal behavior
 * is the exact size of forced for all nb <= 16, and inexact for larger
 */
   n = nbs[0];
   if (n < 0)  /* negative # of nbs says force exact NB or nothing */
   {
      n = -n;
      FORCE = 1;
   }
   bp = best = BestForThisNB(verb, pre, mmb, nbs[1], 0, (n == 1)?nbs[1]:0,
                             FORCE);
   for (i=2; i <= n; i++)
   {
      int pnb = nbs[i-1], nnb = (i < n) ? nbs[i+1]:0;
      bp->next = BestForThisNB(verb, pre, mmb, nbs[i], pnb, nnb, FORCE);
      bp = bp->next;
   }
   if (!FORCE)
      i = DeleteBadBigNBs(best, nbs);
   return(best);
}

@ROUT ammsearch
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr, 
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
@skip    fprintf(stderr, "   -o <outfile>: output file (res/<pre>uAMMRES.sum)\n");
   fprintf(stderr, "   -n # nb1 ... nb# : NBs to try for\n");
   fprintf(stderr, "   -N # nb1 ... nb# : force exact NBs in search\n");
   fprintf(stderr, "   -r <nreg> : set max # of registers to try\n");
   fprintf(stderr, "   -b <nb>   : set initial block factor to try\n");
   fprintf(stderr, "   -v <verb> : set verbosity (1)\n");
   exit(ierr ? ierr : -1);
}

int *GetFlags(int nargs, char **args, char *PRE, 
              int *verb, int *NREG, int *NB, int *CS)
{
   int i, j=0, n, k;
   char pre='d';
   int *nbs=NULL;
   *NREG = *NB = 0;
   *verb = 1;
   *CS = 0;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      
      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
@beginskip
      case 'o':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *FNOUT = DupString(args[i]);
        break;
@endskip
      case 'n':
         j = 1;
      case 'N':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         n = atoi(args[i]);
         nbs = malloc((n+1)*sizeof(int));
         assert(nbs);
         nbs[0] = (j) ? n : -n;
         for (k=1; k <= n; k++)
         {
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
            nbs[k] = atoi(args[i]);
         }
         break;
      case 'r':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *NREG = atoi(args[i]);
         break;
      case 'v':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *verb = atoi(args[i]);
         break;
      case 'b':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *NB = atoi(args[i]);
         break;
   fprintf(stderr, "   -b <nb>   : set initial block factor to try\n");
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *PRE = pre;
   if (pre == 's')
   {
      VLEN[VTAVXZ] = 16;
      VLEN[VTAVX] = 8;
      VLEN[VTSSE] = 4;
      VLEN[VTGV] = 4;
      TSIZE = 4;
   }
   #ifdef ATL_AVXZ
      if (*NREG == 0)
         *NREG = ATL_NVREG;
      VECi = VTAVXZ;
      VECi = VTSC;  /* turn off due to errors */
   #elif defined(ATL_AVX)
      if (*NREG == 0)
         *NREG = ATL_NVREG;
      VECi = VTAVX;
   #elif defined(ATL_SSE1)
      if (*NREG == 0)
         *NREG = ATL_NVREG;
      if (pre == 's')
         VECi = VTSSE;
      #ifdef ATL_SSE2
      else
         VECi = VTSSE;
      #endif
   #elif (defined(ATL_AltiVec) && !defined(ATL_VSX)) || \
         (defined(ATL_NEON) && defined(ATL_NONIEEE) && ATL_NONIEEE != 0) || \
         (defined(ATL_3DNow) && defined(ATL_NONIEEE) && ATL_NONIEEE != 0)
      if (*NREG == 0)
         *NREG = ATL_NVREG;
      if (pre == 's')
         VECi = VTGV;
   #elif defined(ATL_VSX)
      if (*NREG == 0)
         *NREG = ATL_NVREG;
      VECi = VTGV;
   #endif
      if (*NREG == 0)
      #ifdef ATL_GAS_x8664
         *NREG = 16;
      #elif defined(ATL_GAS_x8632)
         *NREG = 8;
      #elif defined(ATL_ARCH_IA64Itan) || defined(ATL_ARCH_IA64Itan)
         *NREG = 128;
      #else
         *NREG = 32;
      #endif
   if (!nbs)
   {
      nbs = malloc(9*sizeof(int));
      assert(nbs);
      nbs[0] = 8;
      nbs[1] = 4; nbs[2] = 6; nbs[3] = 8; nbs[4] = 10;
      nbs[5] = 12; nbs[6] = 14; nbs[7] = 16; nbs[8] = 18;
@beginskip
      nbs[0] = 19; nbs[1] = 4; nbs[2] = 6; nbs[3] = 8; 
      nbs[4] = 12; nbs[5] = 16; nbs[6] = 18; nbs[7] = 24;
      nbs[8] = 32; nbs[9] = 36; nbs[10] = 48; nbs[11] = 56; 
      nbs[12] = 60; nbs[13] = 72; nbs[14] = 80; nbs[15] = 120; 
      nbs[16] = 144; nbs[17] = 180; nbs[18] = 240; nbs[19] = 480;
@endskip
   }
   if (*CS == 0)
      *CS = GetL1CacheElts(pre);
   return(nbs);
}
@ROUT ammsearch uammsearch

char *GenString(char pre, int lat, int nb, int mu, int nu, int ku, 
                int kmaj, char *rt)
{
   char *frm=
      "make gen_amm_%s lat=%d mu=%d nu=%d ku=%d kb=%d vlen=%d rt=%s kmaj=%d"; 
   char *ln;
   int l;
   l = strlen(frm) + strlen(VECs[VECi]) + strlen(rt) + 8;
   ln = malloc(l*sizeof(char));
   assert(ln);
   if (kmaj > 1)
      sprintf(ln, frm, "scalar", lat, mu, nu, ku, nb, 1, rt, kmaj);
   else if (VECi != VTGV)
      sprintf(ln, frm, VECs[VECi], lat, mu*VLEN[VECi], nu, ku, nb, 
              VLEN[VECi], rt, 0);
   else
   {
      int sz = (pre == 's') ? 4 : 8;
      sprintf(ln, frm, VECs[VECi], lat, mu, nu, ku, nb, VLEN[VECi]*sz, rt, 0);
   }
   return(ln);
}

void FillInGenStrings(char pre, ATL_mmnode_t *mmb)
{
   ATL_mmnode_t *mp;
   for (mp=mmb; mp; mp = mp->next)
   {
      if (mp->ID == 0 && !mp->genstr)
      {
         const int vlen=mp->vlen, mu = (vlen) ? mp->mu/vlen : mp->mu, vl0=VECi;
         if (!vlen || vlen == 1)
            VECi = VTSC;
         else if (vlen != VLEN[VECi])
         {
            if (pre == 's' || pre == 'c')
            {
               if (vlen == 16)
                  VECi = VTAVXZ;
               else if (vlen == 8)
                  VECi = VTAVX;
               else if (vlen == 4 && VECi == VTAVX)
                  VECi = VTSSE;
               else if (vlen == 4)
                  VECi = VTGV;
               else 
                  VECi = VTSC;
            }
            else
            {
               if (vlen == 8)
                  VECi = VTAVXZ;
               else if (vlen == 4)
                  VECi = VTAVX;
               else if (vlen == 2 && VECi == VTAVX)
                  VECi = VTSSE;
               else if (vlen == 2)
                  VECi = VTGV;
               else 
                  VECi = VTSC;
            }
         }
         mp->genstr = GenString(pre, mp->lat, mp->kbB, mu, mp->nu, mp->ku, 
                                mp->kmaj, mp->rout);
         VECi = vl0;
      }
   }
}

ATL_mmnode_t *GetNewGenNode(char pre, int nb, int lat, int mu, int nu, int ku,
                            int kmaj)
{
   ATL_mmnode_t *np;
   char *ln;
   if (kmaj < 2)
      kmaj = 0;
   np = GetMMNode();
   np->rout = malloc(sizeof(char)*27);
   assert(np->rout);
   sprintf(np->rout, "ATL_%cgamm%d_%dx%d_nb%d.c", pre, kmaj, mu, nu, nb);
   np->vlen = VLEN[VECi];
   np->nbB = np->mbB = np->kbB = nb;
   if (kmaj)
      np->mu = mu;
   else
      np->mu = mu*VLEN[VECi];
   np->nu = nu;
   np->ku = ku;
   np->muladd = VECi;  /* stores what vector ISA to use */
   np->lat = lat;
   np->kmaj = kmaj;
   np->genstr = GenString(pre, lat, nb, mu, nu, ku, kmaj, np->rout);
   return(np);
}

void FindDefMUNU(int verb, char pre, int nreg, int lat, int nb, int ku,
                 int *MU, int *NU)
{
   ATL_mmnode_t *mmp;
   double mf, mfB=0.0;
   int n, i, j, kb, muB=1, nuB=1;

   mmp = ReadMMFileWithPath(pre, "res", "gAMMMUNU.sum");
   if (mmp)
   {
      FillInGenStrings(pre, mmp);
      nb = mmp->kbB;
      if (mmp->mflop[0] < 0.0)
         mmp->mflop[0] = TimeMMKernel(verb, 1, mmp, pre, nb, nb, nb, 
                                      nb, nb, nb, 1, 0, -1);
      printf("READ IN BEST GENNED MU=%d, NU=%d, MFLOP=%.2f\n\n", 
             mmp->mu, mmp->nu, mmp->mflop[0]);
/*
 *    See if there is a mismatch between vector settings
 */
      if (mmp->vlen != VLEN[VECi])
      {
         printf("\n\n!!! WARNING: TURNING OFF VECTORIZATION DUE TO MISMATCHED VLEN IN 'res/%cAMMMUNU.sum!!!!\n\n", pre);
         VECi = VTSC;
      }
      *MU = mmp->mu / VLEN[VECi];
      assert(*MU);
      *NU = mmp->nu;
      KillMMNode(mmp);
      return;
   }
   mmp = GetMMNode();
   mmp->ku = ku;
   mmp->muladd = (lat != 0);
   mmp->lat = lat;
   mmp->rout = DupString("amm_munu.c");
   mmp->mbB = mmp->nbB = mmp->kbB = nb;
   mmp->vlen = VLEN[VECi];
/*
 * Try all near-square register blocking cases
 */
   printf("Finding best MUxNU case for nb=%d\n", nb);
   for (n=4; n < nreg; n++)
   {
      int mbu, nbu, mu, nu;
      for (j=1; j*j < n; j++);
      i = n / j;
      if (nb%i || nb%j)
         continue;
      mu = mmp->mu = i * VLEN[VECi];
      nu = mmp->nu = j;
      if (mmp->genstr)
        free(mmp->genstr);
      mbu = (nb >= mu) ? (nb/mu)*mu : mu;
      nbu = (nb >= nu) ? (nb/nu)*nu : nu;
      mmp->genstr = GenString(pre, lat, nb, i, j, ku, mmp->kmaj, mmp->rout);
      mf = TimeMMKernel(verb, 1, mmp, pre, mbu, nbu, nb, nb, nb, nb, 1, 0, -1);
      printf("   MU=%2d, NU=%2d, MFLOP=%.2f\n", i, j, mf);
      if (mf > mfB)
      {
         muB = i;
         nuB = j;
         mfB = mf;
      }
   }
/*
 * For x86, try 1-D cases since older machines are 2-operand assemblies
 */
   #if defined(ATL_GAS_x8664) || defined(ATL_GAS_x8632) 
   if (VECi != VTAVX && VECi != VTAVXZ)  /* AVX is 3-operand */
   {
      printf("BEST NEAR-SQUARE CASE IS MU=%d, NU=%d, MFLOP=%.2f\n\n", 
             muB, nuB, mfB);
      printf("Finding best 1-D outer loop unrolling for nb=%d\n", nb);
      for (n=2; n < nreg; n++)
      {
         int mbu, nbu, mu, nu;
         i = 1; j = n;
         if (nb % n)
            continue;
         mu = mmp->mu = i*VLEN[VECi];
         nu = mmp->nu = j;
         if (mmp->genstr)
           free(mmp->genstr);
         mmp->genstr = GenString(pre, lat, nb, i, j, ku, mmp->kmaj, mmp->rout);
         mbu = (nb >= mu) ? (nb/mu)*mu : mu;
         nbu = (nb >= nu) ? (nb/nu)*nu : nu;
         mf = TimeMMKernel(verb, 1, mmp, pre, mbu, nbu, nb, nb, nb, nb, 
                           1, 0, -1);
         printf("   MU=%2d, NU=%2d, MFLOP=%.2f\n", i, j, mf);
         if (mf > mfB)
         {
            muB = i;
            nuB = j;
            mfB = mf;
         }
         i = n; j = 1;
         mu = mmp->mu = i * VLEN[VECi];
         nu = mmp->nu = j;
         mbu = (nb >= mu) ? (nb/mu)*mu : mu;
         nbu = (nb >= nu) ? (nb/nu)*nu : nu;
         if (mmp->genstr)
           free(mmp->genstr);
         mmp->genstr = GenString(pre, lat, nb, i, j, ku, mmp->kmaj, mmp->rout);
         mf = TimeMMKernel(verb, 1, mmp, pre, mbu, nbu, nb, nb, nb, nb, 
                           1, 0, -1);
         printf("   MU=%2d, NU=%2d, MFLOP=%.2f\n", i, j, mf);
         if (mf > mfB)
         {
            muB = i;
            nuB = j;
            mfB = mf;
         }
      }
   }
   #endif
   mmp->mu = muB * VLEN[VECi];
   mmp->nu = nuB;
   mmp->mflop[0] = mfB;
   WriteMMFileWithPath(pre, "res", "gAMMMUNU.sum", mmp);
   KillMMNode(mmp);
   printf("BEST CASE IS MU=%d, NU=%d, MFLOP=%.2f\n\n", 
          muB, nuB, mfB);
   *MU = muB;
   *NU = nuB;
}

void GetMUNUbyNB(int nb, int nreg, int *MU, int *NU)
{
   int mu=(*MU), nu=(*NU), vmu=mu*VLEN[VECi];

   assert(mu && nu && !(nb%VLEN[VECi]));
   if (!(nb%vmu) && !(nb%nu))
      return;
   if (nu == 1) /* handle MUx1 by decreasing by VLEN */
   {
      int u = vmu, vlen = VLEN[VECi];
      while (u+u+1 <= nreg && nb%u)
         u += vlen;
      if (u+u+1 > nreg)
         u -= vlen;
      while (nb%u)
         u -= vlen;
      assert(u);
      *MU = u / vlen;
      return;
   }
   if (mu == 1 || nu == 1) /* handle 1-D cases by just inc/dec U */
   {
      int u = (mu == 1) ? nu : mu;
      while (u+u+1 <= nreg && nb%u)
         u++;
      if (u+u+1 > nreg)
         u--;
      while (nb%u)
         u--;
      if (mu == 1)
         *NU = u;
      else
         *MU = u;
      return;
   }
   if (nb%vmu)  /* mu can't handle NB */
   {
      int i;
/* 
 *    try increasing mu until we run out of registers
 */
      for (i=mu+1; i*nu+i+nu <= nreg; i++)
         if (!(nb%(i*VLEN[VECi])))
            break;
/*
 *    Try decreasing mu until it divides
 */
      if (nb%(i*VLEN[VECi]) || i*nu+i+nu > nreg)
      {
         for (mu--; mu; mu--)
            if (!(nb%(mu*VLEN[VECi])))
               break;
      }
      else
         mu = i;
   }
   if (nb%nu)  /* nu can't handle NB */
   {
      int i;
/* 
 *    try increasing nu until we run out of registers
 */
      for (i=nu+1; i*mu+i+mu <= nreg; i++)
         if (!(nb%i))
            break;
/*
 *    Try decreasing nu until it divides
 */
      if (nb%i || i*mu+i+mu > nreg)
      {
         for (nu--; nu; nu--)
            if (!(nb%nu))
               break;
      }
      else
         nu = i;
   }
   *MU = mu;
   *NU = nu;
}

int FindNBInArray(int nb, int *nbs)
/*
 * RETURNS: location+1, or 0 if not found
 */
{
   int i, n = (nbs[0] > 0) ? nbs[0] : -nbs[0];
   for (i=1; i <= n; i++)
       if (nbs[i] == nb)
          return(i);
   return(0);
}
ATL_mmnode_t *CreateGenCasesFromNBs
(
   ATL_mmnode_t *mmb,   /* best user-contributed kernels */
   char pre,            /* precision: s/d */
   int *nbs,            /* list of desired NBs */
   int nreg,            /* upper bound on register use */
   int MU, int NU,      /* default M/N unrolling */
   int KU               /* -1 for fully unrolled, else unrolling factor */
)
/*
 * Generate a list of generated kernels, with the union of nb's in nbs
 * and mmb, and return the generated nodes for timing.
 * HERE HERE HERE: this code is crap, needs to merge both lists, not user
 * list twice.
 */
{
   ATL_mmnode_t *mp, *umb=NULL, *ap;
   int i, n = (nbs[0] > 0) ? nbs[0] : -nbs[0], ne=0, *enbs;

/*
 * Create new queue with an entry for all NBs; both lists (mmb & nbs) are
 * sorted in increasing size
 */
   if (!n && !mmb)
      return(NULL);
   n++;
   ap = mmb;  /* add ptr */
   i = 1;     /* ptr to normal block under consideration */
   do
   {
      int nb, mu=MU, nu=NU, ku;
      ATL_mmnode_t *p=NULL;
      if (ap && i < n)  /* must choose amongst blocks */
      {
         nb = ap->kbB;
         nb = Mmin(nb, nbs[i]);
         if (nb == ap->kbB)
            ap = ap->next;
         if (nb == nbs[i])
            i++;
      }
      else if (ap)
      {
         nb = ap->kbB;
         ap = ap->next;
      }
      else
         nb = nbs[i++];
      ku = (KU == -1) ? nb : KU;
   
/*
 *    If NB is not a multiple of VLEN, drop down to shorter ops
 */
      if (nb%VLEN[VECi])
      {
         int vl=VECi;
/*
 *       For AVX, see if dropping to SSE will fix problem
 */
         if (VECi == VTAVX && !(nb%VLEN[VTSSE]))  /* AVX can drop to SSE */
         {
            VECi = VTSSE;
            GetMUNUbyNB(nb, nreg, &mu, &nu);
            p = GetNewGenNode(pre, nb, 0, mu, nu, ku, 0);
         }
         if (!p)
         {
            VECi = VTSC;
            GetMUNUbyNB(nb, nreg, &mu, &nu);
            p = GetNewGenNode(pre, nb, 0, mu, nu, ku, 0);
         }
         VECi = vl;
      }
      else
      {
         GetMUNUbyNB(nb, nreg, &mu, &nu);
         p = GetNewGenNode(pre, nb, 0, mu, nu, ku, 0);
      }
      if (umb)
      {
         mp->next = p;
         mp = p;
      }
      else
         umb = mp = p;
   }
   while (i < n || ap);
   return(umb);
}
void SetGenVec(int verb, char pre)
/*
 * This routine uses a simple timing to be sure if vectorization helps or not
 */
{
   ATL_mmnode_t *mp;
/*
 * If vector operations are being used, make sure they work; compiler and
 * flag changes can mess them up, and in this case we'll fall back to
 * scalar generation.  Try to see if we can successfully test simplist
 * possible vector kernel, and fall back to scalar kernel if we can't
 */
   if (VLEN[VECi] < 2)
      return;
   mp = GetNewGenNode(pre, 32, 0, 1, 1, 1, 0);
   if (MMKernelFailsTest(pre, 32, 32, 32, 1, mp))
   {
      printf("ERROR: VEC='%s' FAILED, genstr='%s'!\n",VECs[VECi],mp->genstr);
      KillMMNode(mp);
/*
 *    For AVX, try falling back to SSE
 */
      if (VECi == VTAVX)
      {
         VECi = VTSSE;
         KillMMNode(mp);
         mp = GetNewGenNode(pre, 32, 0, 1, 1, 1, 0);
         if (MMKernelFailsTest(pre, 32, 32, 32, 1, mp))
            VECi = VTSC;
      }
      else
         VECi = VTSC;
   }
   KillMMNode(mp);
/*
 * For AVX, switch to SSE if AVX doesn't offer a performance advantage
 * (as on AMD Dozer), since SSE smaller code size and requires less cleanup 
 */
   if (VECi == VTAVX)
   {
      double mfA, mfS, mf;
      char *sp; 
      int vl;
      mp = GetNewGenNode(pre, 128, 0, 1, 4, 1, 0);
      mfA = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                         1, 0, -1);
      KillMMNode(mp);
      mp = GetNewGenNode(pre, 128, 0, 2, 2, 1, 0);
      mf = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                        1, 0, -1);
      KillMMNode(mp);
      if (mf > mfA)
         mfA = mf;
      vl = VECi;
      VECi = VTSSE;
      mp = GetNewGenNode(pre, 128, 0, 1, 4, 1, 0);
      mfS = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                         1, 0, -1);
      KillMMNode(mp);
      mp = GetNewGenNode(pre, 128, 0, 2, 2, 1, 0);
      mf = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                        1, 0, -1);
      if (mf > mfA)
         mfA = mf;
      KillMMNode(mp);
      if (mfA < 1.03*mfS)
         printf("USING SSE INSTEAD OF AVX, AVX=%.2f, SSE=%.2f\n", mfA, mfS);
      else
      {
         printf("AVX GOOD, AVX=%.2f, SSE=%.2f\n", mfA, mfS);
         VECi = vl;
      }
   }
/*
 * For any system, don't use vector instructions if they aren't faster than
 * scalar. 
 */
   if (VLEN[VECi] > 1)
   {
      double mfV, mfS;
      char *sp; 
      int vl;
      mp = GetNewGenNode(pre, 128, 0, 1, 4, 1, 0);
      mfV = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                         1, 0, -1);
      KillMMNode(mp);
      vl = VECi;
      VECi = VTSC;
      mp = GetNewGenNode(pre, 128, 0, 1, 4, 1, 0);
      mfS = TimeMMKernel(verb, 1, mp, pre, 128, 128, 128, 128, 128, 128,
                         1, 0, -1);
      KillMMNode(mp);
      if (mfV < 1.05*mfS)
         printf("USING SCALAR INSTEAD OF VECTOR, VEC=%.2f, SCALAR=%.2f\n", 
                mfV, mfS);
      else
      {
         printf("VEC GOOD, VEC=%.2f, SCALAR=%.2f\n", mfV, mfS);
         VECi = vl;
      }
   }
   printf("GENERATING WITH VEC='%s', VLEN=%d\n\n", VECs[VECi], VLEN[VECi]);
}

ATL_mmnode_t *FindBestGenCases(int verb, char pre, int nreg, 
                               int *nbs, ATL_mmnode_t *ummb)
{
   ATL_mmnode_t *mp, *gmmU, *gmmb;
   int MU, NU;

   gmmb = ReadMMFileWithPath(pre, "res", "gAMMRES.sum");
   if (gmmb)
   {
      printf("Reading in generated cases for all NBs:\n");
      FillInGenStrings(pre, gmmb);
      for (mp=gmmb; mp; mp = mp->next)
      {
         const int mu = (mp->vlen) ? mp->mu / mp->vlen : mp->mu;
         int kb = mp->kbB, mb = Mmax(mp->mu,kb), nb=Mmax(mp->nu,kb);
         if (mp->mflop[0] < 0.0)
            mp->mflop[0] = TimeMMKernel(verb, 1, mp, pre, mb, nb, kb,
                                         kb, kb, mb, 1, 0, -1);
         printf("  NB=%d, MU=%d, NU=%d, vlen=%d, MFLOP=%.2f\n", 
                nb, mu, mp->nu, mp->vlen, mp->mflop[0]);
      }
      WriteMMFileWithPath(pre, "res", "gAMMRES.sum", gmmb);
      printf("Done.\n\n");
      return(gmmb);
   }
   SetGenVec(verb, pre);
/*
 * Find the best mu/nu for NB=120; we don't care if we overflow cache for
 * this timing, and 120 = LCM(2,3,4,5,6,8,12).  Use ku=1 so that large
 * problems don't have large K-driven advantage.
 */
   FindDefMUNU(verb, pre, nreg, 0, 120, 1, &MU, &NU);
   gmmb = CreateGenCasesFromNBs(ummb, pre, nbs, nreg, MU, NU, 1);
   if (verb > 1)
   {
      printf("\n");
      PrintMMNodes(stdout, gmmb);
      printf("\n");
   }
   printf("Finding generated cases for all NBs:\n");
   for (mp=gmmb; mp; mp = mp->next)
   {
      int mu;
      mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mp->mbB, mp->nbB, mp->kbB, 
                                  mp->kbB, mp->kbB, mp->kbB, 1, 0, -1);
      mu = (mp->vlen) ? mp->mu / mp->vlen : mp->mu;
      printf("   NB=%d, mu=%d, nu=%d, vlen=%d, MFLOPS=%.2f\n", 
             mp->kbB, mu, mp->nu, mp->vlen, mp->mflop[0]);
   }
   printf("Done.\n\n");
   WriteMMFileWithPath(pre, "res", "gAMMRES.sum", gmmb);
   return(gmmb);
}


ATL_mmnode_t *GetWorkingUserCases(int verb, char pre)
{
   ATL_mmnode_t *mmb, *mmp;
   mmb = ReadMMFileWithPath(pre, "res", "WORKING.sum");
   if (mmb)
      return(mmb);
   mmb = ReadMMFileWithPath(pre, "AMMCASES", "amcases.idx");
   if (!mmb)
      return(mmb);
/*
 * Eliminate those kernels that can't work for any block size
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      if (FLAG_IS_SET(mmp->flag, MMF_KUISKB))
         mmp->mbB = mmp->nbB = mmp->kbB = mmp->ku;
      else
      {
         int m = Mylcm(mmp->mu, mmp->nu);
         m = ((60+m-1)/m)*m;
         mmp->mbB = mmp->nbB = mmp->kbB = m;
         if (mmp->kbmin)
            mmp->kbB = Mmax(mmp->kbB, mmp->kbmin);
         if (mmp->kbmax)
            mmp->kbB = Mmin(mmp->kbB, mmp->kbmax);
      }
   }
   mmb = DelBadMMKernels(pre, verb, mmb);
   WriteMMFileWithPath(pre, "res", "WORKING.sum", mmb);
   return(mmb);
}

ATL_mmnode_t *FindBestUserCases(int verb, char pre, int *nbs, ATL_mmnode_t *mmb)
/*
 * NOTE: frees mmb after search!!
 * RETURNS: list of the best user case for each supplied NB; if no user case
 *          works, special "generated" node is returned for later filling out.
 */
{
   ATL_mmnode_t *mmp, *mp;
   mp = ReadMMFileWithPath(pre, "res", "uAMMRES.sum");
/*
 * If final output file exists, then we need to rerun timings at worst
 */
   if (mp)
   {
      KillAllMMNodes(mmb);
      for (mmp=mp; mmp; mmp = mmp->next)
      {
         if (mmp->ID > 0 && mmp->mflop[0] < 0.0)
            mmp->mflop[0] = TimeMMKernel(verb, 0, mmp, pre, mmp->mbB, mmp->nbB,
                                         mmp->kbB, mmp->kbB, mmp->kbB, mmp->kbB,
                                         1, 0, -1);
         if (mmp->ID > 0)
            printf("USER KERNEL AT NB=%d gets MFLOP=%.2f\n",
                   mmp->kbB, mmp->mflop[0]);
         else
            printf("NO USER KERNEL FOR NB=%d\n", mmp->kbB);
      }
      printf("\n");
      return(mp);
   }
   mmp = FindBestForEachNB(verb, pre, mmb, nbs);
   KillAllMMNodes(mmb);
   WriteMMFileWithPath(pre, "res", "uAMMRES.sum", mmp);
   return(mmp);
}

ATL_mmnode_t *MergeCases
(
   int imf,
   ATL_mmnode_t *bs0, /* queue of cases */
   ATL_mmnode_t *bs1  /* queue of cases */
)
/*
 * Merges two queues of matmul kern cases.  Cases are not winnowed, but
 * duplicates are not allowed, so if two entries have the same kbB, then
 * we take the one with best mflop[imf].  If imf < 0, then we do indeed
 * allow duplicates of kbB.
 * NOTE: does not change bs0 or bs1.
 * ASSUMES: both bs0 & bs1 are in kb-increasing order.
 * RETURNS: base ptr to merged queue
 */
{
   ATL_mmnode_t *mb=NULL, *mp;
   while (bs0 || bs1)
   {
      ATL_mmnode_t *p;
      if (bs0 && bs1)
      {
         if (bs0->kbB < bs1->kbB)
         {
            p = CloneMMNode(bs0);
            bs0 = bs0->next;
         }
         else if (bs0->kbB > bs1->kbB)
         {
            p = CloneMMNode(bs1);
            bs1 = bs1->next;
         }
         else /* they are equal, must take best performer, or both */
         {
/*
 *          If we are taking both, special case can't use general completion
 */
            if (imf < 0)
            {
               p = CloneMMNode(bs0);
               bs0 = bs0->next;
               p->next = CloneMMNode(bs1);
               bs1 = bs1->next;
               if (mb)
                  mp->next = p;
               else
                  mb = p;
               mp = p->next;
               continue;
            }
/*
 *          Taking only the best performer, but moving both base ptrs
 */
            else
            {
/*
 *             If they are equal, take the KRUN=1 case if it exists, else
 *             take the most flexible one or one requiring the least cleanup
 */
               if (bs0->mflop[imf] == bs1->mflop[imf])
               {
                  if (FLAG_IS_SET(bs0->flag, MMF_KRUNTIME))
                     p = bs0;
                  else if (FLAG_IS_SET(bs1->flag, MMF_KRUNTIME))
                     p = bs1;
                  else if (bs0->ku < bs1->ku)
                     p = bs0;
                  else if (bs1->ku < bs0->ku)
                     p = bs1;
                  else
                  {
                     const int u0=Mmax(bs0->mu, bs0->nu), 
                               u1=Mmax(bs1->mu, bs1->nu);
                     p = (u0 <= u1) ? bs0 : bs1;
                  }
               }
               else
                  p = (bs0->mflop[imf] > bs1->mflop[imf]) ? bs0 : bs1;
               p = CloneMMNode(p);
               bs0 = bs0->next;
               bs1 = bs1->next;
            }
         }
      }
      else if (bs0)
      {
         p = CloneMMNode(bs0);
         bs0 = bs0->next;
      }
      else /* if (bs1) */
      {
         p = CloneMMNode(bs1);
         bs1 = bs1->next;
      }
      if (mb)
      {
         mp->next = p;
         mp = p;
      }
      else
        mp = mb = p;
   }
   return(mb);
}

#define HUGE_NB 180
ATL_mmnode_t *WinnowHugeNB
(
   int imf,
   ATL_mmnode_t *mb  /* queue of cases */
)
/*
 * Removes any NB >= HUGE_NB that aren't at least 2% faster than smaller cases
 */
{
   ATL_mmnode_t *mp, *p, *prev=mb;
   double mfB;

   if (!mb || !mb->next)
      return(mb);
   mp = mb->next;
/*
 * Find best-performing kernel below HUGE_NB
 */
   mfB = mp->mflop[imf];
   for (mp=mb->next; mp; mp = mp->next)
   {
      if (mp->mbB < HUGE_NB && mp->nbB < HUGE_NB && mp->kbB < HUGE_NB)
         mfB = Mmax(mfB, mp->mflop[imf]);
      else
         break;
      prev = mp;
   }
/*
 * If no kernels above threshold, return original queue
 */
   if (!mp)
      return(mb);
/* 
 * mp points to first NB above threshold, but there is no point in deleting
 * small NB if we leave large NB, so delete only from the end of queue
 */
  do
  {
     for (p=mp; p->next; p = p->next);
     if (p->mflop[imf] <= 1.02*mfB)
        mp = RemoveMMNodeFromQ(mp, p);
     else  /* stop removing stuff */
        break;
  }
  while (mp);
  prev->next = mp;
  return(mb);
}

ATL_mmnode_t *WinnowCases
(
   int imf,
   ATL_mmnode_t *mb  /* queue of cases */
)
/*
 * Removes any case that runs slower than a smaller case
 * RETURNS: mb with queue bad kernels deleted
 * NOTE: mb can never change, since by def nothing smaller than 1st case
 */
{
   ATL_mmnode_t *prev = mb, *mp;

   if (!mb)
      return(NULL);
   mb = WinnowHugeNB(imf, mb);
   mp = mb->next;
   while (mp)
   {
      if (mp->mflop[imf] <= prev->mflop[imf])  /* kill slow KB */
         mp = prev->next = KillMMNode(mp);
      else
      {
         prev = mp;
         mp = mp->next;
      }
   }
   return(mb);
}

ATL_mmnode_t *MergeAndWinnowCases
(
   int verb, 
   char pre, 
   ATL_mmnode_t *umb, /* queue of user cases */
   ATL_mmnode_t *gmb  /* genned cases, always include NBs of umb */
)
/*
 * Merges user and gmp cases, while getting rid of cases that get worse
 * performance than their smaller blocks; FREES umb and gmb
 * RETURNS: new merged and winnowed queue
 */
{
   ATL_mmnode_t *mmb=NULL, *mmp, *gmp, *ump=umb;
   for (gmp=gmb; gmp; gmp = gmp->next)
   {
      ATL_mmnode_t *p;
      if (ump)
      {
         if (ump->kbB == gmp->kbB)
         {
            if (gmp->mflop[0] >= ump->mflop[0])
               p = CloneMMNode(gmp);
            else
               p = CloneMMNode(ump);
            ump = ump->next;
         }
         else
            p = CloneMMNode(gmp);
      }
      else
         p = CloneMMNode(gmp);
      p->next = NULL;
      if (mmb)
      {
/*
 *       If larger NB isn't faster than smaller one, kill it for nb >= 16
 */
         if (p->kbB >= 16 && mmp->mflop[0] > p->mflop[0])
            KillMMNode(p);
         else
         {
            mmp->next = p;
            mmp = p;
         }
      }
      else
         mmp = mmb = p;
   }
   KillAllMMNodes(umb);
   KillAllMMNodes(gmb);
   mmb = WinnowHugeNB(0, mmb);
   return(mmb);
}

int FailKCleanTests(char pre, int nb, ATL_mmnode_t *kp)
/*
 *  This routine tests if a kernel is suitable for use in K-cleanup by
 *  doing testing with ku=1, kb=0, and tries all K values between 1 and nb
 *  RETURNS: 0 if kernel passes all tests, else non-zero
 */
{
   int i, beg, end, inc;

   if (!FLAG_IS_SET(kp->flag, MMF_KRUNTIME) || 
       (kp->ku != 1 && kp->ku != kp->kmaj))
      return(-1);
   printf("TESTING ID=%d, rout='%s', nb=%d, mu=%d, nu=%d for K-cleanup:\n",
          kp->ID, kp->rout, nb, kp->mu, kp->nu);

   if (kp->kmaj > 1)
   {
      inc = beg = kp->kmaj;
      end = ((nb+inc-1)/inc)*inc;
   }
   else
   {
      beg = inc = 1;
      end = nb;
   }
   for (i=beg; i <= end; i += inc)
   {
      int ierr;
      ierr = MMKernelFailsTest(pre, nb, nb, i, 0, kp);
      if (ierr)
      {
         printf("  K=%d: FAILED!\n", i);
         return(ierr);
      }
      else
         printf("  K=%d: PASSED!\n", i);
   }
   printf("PASSED ALL K-tests!\n\n");
   return(0);
}
@ROUT ammsearch  `@define kpr @AMM@`
@ROUT uammsearch `@define kpr @UMM@`
ATL_mmnode_t *GetUniqueKClean(int verb, char pre, ATL_mmnode_t *mmb)
/*
 * OUTPUT: <pre>@(kpr)KCLEAN.sum: all unique kerns to be compiled
 */
{
   ATL_mmnode_t *mp, *gmmb, *ummb, *ub, *np, **dlmm;
   int nn=0, nd=0, n=0;  /* #needed & done, total, copy of done */
   int *dl, *nl;         /* done and needed lists */
   int i;
@ROUT ammsearch
   gmmb = ReadMMFileWithPath(pre, "res", "@(kpr)KCLEAN.sum");
   if (gmmb)
   {
      printf("READING IN UNIQUE K-CLEANUP:\n");
      FillInGenStrings(pre, gmmb);
      for (mp=gmmb; mp; mp = mp->next)
      {
         int mb = (mp->nbB > mp->mu) ? (mp->nbB/mp->mu)*mp->mu : mp->mu;
         int nb = (mp->nbB > mp->nu) ? (mp->nbB/mp->nu)*mp->nu : mp->nu;
         int kb = (nb > 8) ? (nb>>2) : nb, KB = kb;
         int ku = mp->ku;
         if (mp->kmaj > 1)
            KB = ((kb+ku-1)/ku)*ku;
         if (mp->mflop[0] < 0.0)
         {
            mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mb, nb, KB, 0, 0, nb,
                                        0, 0, -1);
            mp->mflop[0] *= (double)kb / (double)KB;
         }
         printf("   nb=%d,  kb=%d, mu=%d, nu=%d, MFLOP=%.2f\n", 
                nb, kb, mp->mu, mp->nu, mp->mflop[0]);
      }
      printf("Done.\n");
      return(gmmb);
   }
@ROUT ammsearch uammsearch
/*
 * Find out how many total kernels, and how many already have their own
 * cleanup (nd, number done).  This nd may be bigger than it should, because
 * we can't guarantee they are unique
 */
   for (mp=mmb; mp; mp = mp->next, n++)
      if ((mp->ku == 1 || (mp->kmaj == mp->ku)) && 
          FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
        nd++;
   dl = malloc(8*n*sizeof(int));
   assert(dl);
   if (nd)
   {
      dlmm = malloc(nd*sizeof(ATL_mmnode_t*));
      assert(dlmm);
   }
   else
      dlmm = NULL;

   nl = dl + (n<<2);
   nd = 0;
/*
 * First, go back through kernels, and add kernels that can serve as K-cleaners
 * to the done list
 */
   for (mp=mmb; mp; mp = mp->next, n++)
   {
      if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME) && 
          (mp->ku == 1 || mp->kmaj == mp->ku))
      {
         const int nd4 = (nd<<2), mu=mp->mu, nu=mp->nu, kmaj=mp->kmaj;
/*
 *       See if trip is already in done list if so, no new entry, just update kb
 *       and cleanup kernel entry
 */
         for (i=0; i < nd4; i += 4)
            if (mu == dl[i] && nu == dl[i+1] && kmaj == dl[i+2])
               break;
         if (i < nd4)
         {                      /* (larger NB always later) */
            dl[i+3] = mp->kbB;  /* take largest kbB that matches mu/nu */
            dlmm[i>>2] = mp;
            continue;           
         }
         else
         {
            dl[nd4] = mu;
            dl[nd4+1] = nu;
            dl[nd4+2] = kmaj;
            dl[nd4+3] = mp->kbB;
            dlmm[nd++] = mp;
         }
      }
   }
/*
 * Delete any kernels from dl that fail to actually work for K cleaning
 */
   for (i=0; i < nd; i++)
   {
      if (FailKCleanTests(pre, dlmm[i]->kbB, dlmm[i]))
      {
         const int i4=(i<<2), nc=nd-i-1;
         if (nc > 0)
         {
            memcpy(dl+i4, dl+i4+4, (nc<<2)*sizeof(int));
            memcpy(dlmm[i], dlmm[i+1], nc*sizeof(ATL_mmnode_t*));
         }
         nd--;
      }
   }

/*
 * Find all unique (mu,nu,kmaj) combos that still need to to be cleaned; 
 * there will be nn (# needed) of these, and we'll save (mu,nu,MAXNB) in
 * needed list (nl).
 * We use MAXNB for testing (large NB tests mosts cases of K).
 * Combos that are handled by the done list (dl) aren't added to needed list.
 */
   for (mp=mmb; mp; mp = mp->next, n++)
   {
      int mu=mp->mu, nu=mp->nu, kmaj=mp->kmaj, nn4=(nn<<2), nd4=(nd<<2);
/*
 *    See if pair is already in done list or needed list, if so, no change
 */
      for (i=0; i < nd4; i += 4)
         if (mu == dl[i] && nu == dl[i+1] && kmaj == dl[i+2])
            break;
      if (i < nd4)    /* if it was found in the done list */
         continue;    /* this combo is already handled */
/*
 *    If we reach here, combo is not handled, must add to needed list 
 */
      for (i=0; i < nn4; i += 4)
         if (mu == nl[i] && nu == nl[i+1] && kmaj == nl[i+2])
            break;
      if (i < nn4)            /* If already in needed list */
      {
         nl[i+3] = mp->kbB;   /* just update kb so we get largest for testing */
         continue;
      }
/*
 *    If we haven't seen this pair before, add to needed list
 */
      else
      {
         nl[nn4] = mu;
         nl[nn4+1] = nu;
         nl[nn4+2] = kmaj;
         nl[nn4+3] = mp->kbB;
         nn++;
      }
   }
/*
 * Now, create a queue of generated kernels for each needed pair, and time
 * it's maxNB performance.
 */
   gmmb = NULL;
   printf("Timing Generated K-cleanup:\n");
   for (i=0; i < nn; i++)
   {
      ATL_mmnode_t *p;
      const int i4 = (i<<2), mu=nl[i4], nu=nl[i4+1], kmaj=nl[i4+2];
      int nb = Mmax(nl[i4+3],nu), mb = (nb > mu) ? (nb/mu)*mu : mu;
      const int kb = (nb > 8) ? (nb>>2) : nb;
      int vl=VECi, vmu, KK;
      double mf;
/*
 *    HERE HERE: Improve KMAJ when generator is extended!
 */
      if (kmaj > 1)
      {
        vmu = mu;
        VECi = VTSC;
      }
      else
      {
         if (mu % VLEN[VECi])
         {
            if (VECi == VTAVX && !(mu%VLEN[VTSSE]))
               VECi = VTSSE;
            else
               VECi = VTSC;
         }
         vmu = mu / VLEN[VECi];
      }
/* HERE HERE */
      p = GetNewGenNode(pre, nb, 0, vmu, nu, 1, kmaj);
      p->mbB = mb;
      p->nbB = nb;
      p->kbB = kb;
      p->flag |= (1<<MMF_KRUNTIME);
      VECi = vl;
      #if 0  /* by default don't waste time testing generated code */
         assert(!FailKCleanTests(pre, nb, p));
      #endif
      KK = (kmaj < 2) ? kb : ((kb+kmaj-1)/kmaj)*kmaj;
      p->mflop[0] = TimeMMKernel(verb, 0, p, pre, mb, nb, kb, 0, 0, nb, 
                                 0, 0, -1);
      if (KK != kb)
         p->mflop[0] *= (double)kb / (double)KK;
      printf("   nb=%d, kb=%d,  mu=%d, nu=%d, MFLOP=%.2f\n", 
             nb, kb, mu, nu, p->mflop[0]);
      if (gmmb)
      {
         mp->next = p;
         mp = p;
      }
      else
         gmmb = mp = p;
   }
   printf("Done.\n");
/*
 * Now, add the done-list items to generated list
 */
   for (i=0; i < nd; i++)
   {
      const int i4=4*i, mu=dl[i4], nu=dl[i4+1], kmaj=dl[i4+2], nb=dl[i4+3];
      ATL_mmnode_t *prev=NULL;
/*
 *    Get a copy of done-list kern that can be added to genlist
 */
      np = CloneMMNode(dlmm[i]);
      np->next = gmmb;
      gmmb = np;
   }
   if (dlmm)
      free(dlmm);
/*
 * Now, search index file for suitable user-submitted kernels to compete
 * with existing solutions
 */
   ub = ReadMMFileWithPath(pre, "AMMCASES", "amcases.idx");
   ummb = NULL;  /* no suitable user cases to begin */
/*
 * Look through user-list for any routine with ku=1 and K-Runtime
 */
   for (mp=ub; mp; mp = mp->next)
   {
      if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME) && 
          (mp->ku == 1 || mp->kmaj == mp->ku))
      {
/*
 *       It matched our gross criteria, see if it is a required mu/nu
 */
         for (i=0; i < nn; i++)
         {
            const int i4=(i<<2), mu=nl[i4], nu=nl[i4+1], kmaj=nl[i4+2], 
                      nb=nl[i4+3];
            if (mp->mu == mu && mp->nu == nu && mp->kmaj == kmaj)
            {
               if (!FailKCleanTests(pre, nb, mp))
               {
                  ATL_mmnode_t *p;
                  p = CloneMMNode(mp);
                  p->next = NULL;
                  p->nbB = ((nb+nu-1)/nu)*nu;
                  p->mbB = ((nb+mu-1)/mu)*mu;
                  p->kbB = nb;
                  if (ummb)
                  {
                     np->next = p;
                     np = p;
                  }
                  else
                     np = ummb = p;
                  break;
               }
            }
         }
      }
   }
   KillAllMMNodes(ub);
/*
 * If we have both user and genned code, must compare timing to select best
 */
   if (ummb)
   {
/*
 *    Now, loop over user cases and time them for comparison with genned
 */
      printf("Timing User K-cleanup:\n");
      for (mp=ummb; mp; mp = mp->next)
      {
         const int nb = mp->nbB, kb = (nb > 8) ? (nb>>2) : nb;
         const int KK = (mp->kmaj < 2) ? kb:((kb+mp->kmaj-1)/mp->kmaj)*mp->kmaj;
         mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mp->mbB, nb, KK, 0, 0, 
                                     KK, 0, 0, -1);
         if (KK != kb)
            mp->mflop[0] *= (double)kb / (double)KK;
         printf("   ID=%d, nb=%d, kb=%d, mu=%d, nu=%d, MFLOP=%.2f\n", 
                mp->ID, nb, kb, mp->mu, mp->nu, mp->mflop[0]);
      }
      printf("Done timing, merging lists:\n");
/*
 *    Merge generated (gmmb) and user (ummb) kerns by selecting best performing.
 *    gmmb is a superset of ummb, so what we will do is look through gmmb
 *    for matching (mu,nu,dup), time them, and if ummb is faster, replace
 *    that entry in gmmb with ummb.
 */
      while (ummb)
      {
         ATL_mmnode_t *prev=NULL;
         int mu=ummb->mu, nu=ummb->nu, kmaj = ummb->kmaj;
         for (mp=gmmb; mp && (mp->mu != mu || mp->nu != nu || mp->kmaj != kmaj);
              mp = mp->next)
            prev = mp;
         assert(mp);  /* logic error if we haven't found it */
/*
 *       If user case gets better performance, replace genned case in queue
 */
         if (ummb->mflop[0] > gmmb->mflop[0])
         {
            printf("   Replacing genned case (%.2f) with user ID %d (%.2f)\n",
                   gmmb->mflop[0], ummb->ID, ummb->mflop[0]);
            if (prev)
            {
               prev->next = ummb;
               ummb = ummb->next;
               prev->next->next = KillMMNode(mp);
            }
            else /* replace gmmb, mp pts at gmmb */
            {
               ATL_mmnode_t *up=ummb;
               ummb = ummb->next;
               up->next = KillMMNode(gmmb);
               gmmb = up;
            }
         }
         else /* user case loser, just delete it */
         {
            printf("   Preferring genned case (%.2f) over user ID %d (%.2f)\n",
                   gmmb->mflop[0], ummb->ID, ummb->mflop[0]);
            ummb = KillMMNode(ummb);
         }
      }
      printf("DONE.\n\n");
   }
   else
      printf("NO VALID USER-SUBMITTED K-CLEANUP KERNELS\n\n");
   free(dl);
   WriteMMFileWithPath(pre, "res", "@(kpr)KCLEAN.sum", gmmb);
   return(gmmb);
}

ATL_mmnode_t *FindMUNU(ATL_mmnode_t *mb, int mu, int nu)
{
   ATL_mmnode_t *mp;
   for (mp=mb; mp; mp = mp->next)
      if (mp->mu == mu && mp->nu == nu)
         return(mp);
   return(NULL);
}

ATL_mmnode_t *KCleanByNB
(
   int verb, 
   char pre, 
   ATL_mmnode_t *mmb, /* final kernels giving final supported NBs */
   ATL_mmnode_t *mkb  /* All necessary routs ku=1 to clean all kerns in mmb */
)
/*
 * Replicates mkb so that it includes all NBs in mmb, times K-clean,
 * **FREES** mkb, and returns by-NB list
 *
 * OUTPUT:
 *   <pre>@(kpr)KCLEANBYNB.sum: non-unique K-clean for each NB in mmb
 *      mflop[1] contains estimated time for 1 K-it using K=MAX(kb/4,4)
 */
{
   ATL_mmnode_t *nkb=NULL, *mp, *np;
   int kb;
   double mf;

@ROUT ammsearch
   nkb = ReadMMFileWithPath(pre, "res", "@(kpr)KCLEANBYNB.sum");
   if (nkb)
   {
      KillAllMMNodes(mkb);
      printf("READING IN BY-NB K-CLEANUP:\n");
      FillInGenStrings(pre, nkb);
      for (mp=nkb; mp; mp = mp->next)
      {
         int mb=mp->mbB, nb=mp->nbB;
         kb = mp->kbB >> 2;
         kb = (kb >= 4) ? kb : 4;
         if (mp->mflop[0] < 0.0)
         {
            mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mb, nb, kb, 0, 0, mb,
                                        0, 0, -1);
            mf = (2.0*nb)*nb;  /* flop count of gemm/kits (kb) */
            mp->mflop[1] = mf / mp->mflop[0]; /* time in microsecs for 1 k-it */
         }
         printf("   nb=%d, kb=%d, mu=%d, nu=%d, mf=%.2f (%e Usec/Kit)\n", 
                nb, kb, mp->mu, mp->nu, mp->mflop[0], mf);
      }
      printf("Done.\n");
      WriteMMFileWithPath(pre, "res", "@(kpr)KCLEANBYNB.sum", nkb);
      return(nkb);
   }
@ROUT ammsearch uammsearch
   printf("TIMING K-CLEAN FOR ALL SUPPORTED NBs:\n");
   for (mp=mmb; mp; mp = mp->next)
   {
      ATL_mmnode_t *p;
      int mb = mp->mbB, nb = mp->nbB, kb;

      kb = mp->kbB >> 2;
      kb = (kb >= 4) ? kb : 4;
      if (mp->kmaj > 1)
         kb = ((kb+mp->kmaj-1)/mp->kmaj)*mp->kmaj;

      p = FindMUNU(mkb, mp->mu, mp->nu);
/*
 *    If no user cleanup exists, generate one
 */
      if (!p)
      {
         if (mp->kmaj > 1)
            p = GetNewGenNode(pre, 0, 0, mp->mu, mp->nu, mp->kmaj, mp->kmaj);
         else
            p = GetNewGenNode(pre, 0, 0, mp->mu, mp->nu, 1, 0);
      }
      else
      {
         p = CloneMMNode(p);
         p->next = NULL;
      }
      p->nbB = nb; p->mbB = mb;  p->kbB = kb;
      p->mflop[0] = TimeMMKernel(verb, 0, p, pre, mb, nb, kb, 0, 0, kb, 
                                 0, 0, -1);
      mf = mb*nb;
      p->mflop[1] = mf / p->mflop[0];   /* time in microseconds for 1 k it */
      printf("   mb=%d, nb=%d, kb=%d, mu=%d, nu=%d, mf=%.2f (%e Usec/Kit)\n", 
             mb, nb, kb, p->mu, p->nu, p->mflop[0], mf);
      if (nkb)
      {
         np->next = p;
         np = p;
      }
      else
         nkb = np = p;
   }
   printf("DONE.\n\n");
   KillAllMMNodes(mkb);
   WriteMMFileWithPath(pre, "res", "@(kpr)KCLEANBYNB.sum", nkb);
   return(nkb);
}

void TimeKClean(int verb, char pre, ATL_mmnode_t *mp)
/*
 *   mp is the ku=1, KRUNTIME K-cleanup kernel for a support NB.
 *   This routine creates an output file for supported the NB, where we
 *   document the performance for all NB different KB values.  These
 *   timings can therefore precisely document how expensive K-cleanup
 *   will be for each NB.  
 *   OUTPUT:
 *   <pre>@(kpr)KCLEAN_<nb>.TIM: timing of K-clean for nb=<nb>; there are
 *   i=nb-1 timings, mflop[0] contains time to do NB-i K its.  Will use
 *   these times to get completely accurate estimate of total time for
 *   large problems (use estimated time in CLBYNB for small probs).
 */
{
   ATL_mmnode_t *mmb, *p, *np;
   char fn[32];
   int mb = mp->mbB, nb = mp->nbB, i;

   sprintf(fn, "@(kpr)KCLEAN_%d.TIM", mp->nbB);
   mmb = ReadMMFileWithPath(pre, "res", fn);
   if (mmb)
   {
      printf("READING IN K-CLEANUP TIMINGS FOR NB=%d:\n", nb);
      FillInGenStrings(pre, mmb);
      for (p=mmb; p; p = p->next)
      {
         int kb = p->kbB;
         assert(nb == p->nbB && mb == p->mbB);
         if (p->mflop < 0)
            p->mflop[0] = TimeMMKernel(verb, 0, p, pre, mb, nb, kb, 0, 0, kb, 
                                       0, 0, -1);
         printf("   MB=%d, NB=%d, KB=%d, mu=%d, nu=%d, MFLOP=%.2f\n", 
                mb, nb, kb, p->mu, p->nu, p->mflop[0]);
      }
      printf("Done.\n\n");
      WriteMMFileWithPath(pre, "res", fn, mmb);
      KillAllMMNodes(mmb);
      return;
   }
   
   printf("TIMING K-CLEANUP FOR MB=%d, NB=%d:\n", mb, nb);
   for (i=1; i <= nb; i++)  /* create queue of ascending KB */
   {
      p = CloneMMNode(mp);
      p->next = NULL;
      p->kbB = i;
      p->mflop[0] = TimeMMKernel(verb, 0, p, pre, mb, nb, i, 0, 0, i, 0, 0, -1);
      printf("   MB=%d, NB=%d, KB=%d, mu=%d, nu=%d, MFLOP=%.2f\n", mb, nb, i, 
             p->mu, p->nu, p->mflop[0]);
      if (mmb)
      {
         np->next = p;
         np = p;
      }
      else
         mmb = np = p;
   }
   WriteMMFileWithPath(pre, "res", fn, mmb);
   KillAllMMNodes(mmb);
   printf("Done.\n");
}

void ComputeKClean(int verb, char pre, ATL_mmnode_t *mmb)
/*
 * This kernel generates K-cleanup for all routines present in mmb.
 * To do this, it finds all unique (mu,nu,kmaj) triplets, and then finds the
 * best (ku=1 || kmaj>1), K-runtime kernel for that pair (timing both user
 * and generated).
 * OUTPUT: <pre>@(kpr)KCLEAN.sum: all unique kerns to be compiled
 *   <pre>@(kpr)KCLEANBYNB.sum: non-unique K-clean for each NB in mmb
 *      mflop[1] contains estimated time for 1 K-it using K=MAX(kb/4,4)
 *   <pre>@(kpr)KCLEAN_<nb>.TIM: timing of K-clean for nb=<nb>; there are
 *   i=nb-1 timings, mflop[0] contains time to do NB-i K its.  Will use
 *   these times to get completely accurate estimate of total time for
 *   large problems (use estimated time in CLBYNB for small probs).
 * 
 * NOTE: we will gen/time K-cleanup kernels only in BETA=0 case, and peel
 *    the first K-block rather than the last.  This will minimize the C cost,
 *    which is more appreciable for short-K.
 */
{
   ATL_mmnode_t *mkb, *mp;
   mkb = GetUniqueKClean(verb, pre, mmb);
   mkb = KCleanByNB(verb, pre, mmb, mkb);
/*
 * For now, skip the timing until we have things working and know better 
 * what timings we'll need
 */
   #if 0
/*
 * Now, create NB detailed K-cleanup files
 */
   for (mp=mkb; mp; mp = mp->next)
      TimeKClean(verb, pre, mp);
   printf("\n");
   #endif
   KillAllMMNodes(mkb);
}

void FindBestKU1
(
   int verb, 
   char pre,   
   int K       /* K dim, should be small, probably like 23 or 17 */
)
/* 
 * Find the best possible kernel for use in low-rank update;  We only consider
 * kernels with runtime-K that handle all possible K (ku=1).  We will try
 * all legal blocking factors between 16 & 480 for this kernel, and choose
 * the one that performs best.  This kernel always used for any K not covered
 * by optimized kernels given in eAMMRES kbBs.  When we match a kbB, we
 * compare the perf of this kernel at its optimal nbB/mbB wt that of the
 * specialized kernel, and choose the best.
 *
 * OUTPUT: This routine outputs two files:
 * (1) AMMRANKK: best ku=1 kern wt best MB/NB, K=K
 * (2) AMMRANKKT: timing of this kern wt M=mbB, N=nbB, all K between 1 & maxNB
 */
{
}

double CacheRatio_all3(size_t CS, size_t mb, size_t nb, size_t kb, 
                       size_t mu, size_t nu)
{ /* RETURNS: ratio of utilized cache to keep all 3 mm ops in CS */
   double dret = 1.0*kb*(mb+nb)+mb*nb;
   return(dret/CS);
}

double CacheRatio_one(size_t CS, size_t mb, size_t nb, size_t kb, 
                      size_t mu, size_t nu)
{ /* RETURNS: ratio of util cache for B + working set of A/C */
   double dret = kb*nb + 2.0*(mu*kb + mu*nu);
   return(dret/CS);
}

double CacheRatio_ws(size_t CS, size_t mb, size_t nb, size_t kb, 
                     size_t mu, size_t nu)
{ /* RETURNS: ratio of working set of all matmul ops to CS */
   double dret = 2.0*(mu*nu + nu*kb) + mu*kb;
   return(dret/CS);
}

typedef void (*BudgetFunc_t)(double, size_t, size_t, size_t, size_t, 
                             size_t*, size_t*, size_t*);

#define MAXNB 512
void GetBlkFromBudget_all3(double thresh, size_t CS, 
                           size_t mu, size_t nu, size_t ku,
                           size_t *MB, size_t *NB, size_t *KB)
{
   size_t mb=mu, nb=nu, kb=ku;
   int MGROW, NGROW, KGROW;
   do
   {
      size_t mn=mb+mu, nn=nb+nu, kn=kb+ku;
      MGROW = mn < MAXNB && (CacheRatio_all3(CS, mn, nb, kb, mu, nu) <= thresh);
      NGROW = nn < MAXNB && (CacheRatio_all3(CS, mb, nn, kb, mu, nu) <= thresh);
      KGROW = kn < MAXNB && (CacheRatio_all3(CS, mb, nb, kn, mu, nu) <= thresh);
      if (KGROW && ((!MGROW && !NGROW) || (kn <= nn && kn <= mn)))
         kb = kn;
      else if (MGROW && (!NGROW || mb < nb))
         mb = mn;
      else if (NGROW)
         nb = nn;
   }
   while (MGROW | NGROW | KGROW);
   *MB = mb;
   *NB = nb;
   *KB = kb;
}

void GetBlkFromBudget_one(double thresh, size_t CS, 
                           size_t mu, size_t nu, size_t ku,
                           size_t *MB, size_t *NB, size_t *KB)
{
   size_t mb=mu, nb=nu, kb=ku;
   int NGROW, KGROW;
   do
   {
      size_t nn=nb+nu, mn=(nn/mu)*mu, mn1 = ((nn+mu-1)/mu)*mu, kn=kb+ku;
      if (mn1 - nn <= nn - mn || !mn)
         mn = mn1;
      NGROW = nn < MAXNB && (CacheRatio_one(CS, mn, nn, kb, mu, nu) <= thresh);
      KGROW = kn < MAXNB && (CacheRatio_one(CS, mb, nb, kn, mu, nu) <= thresh);
      if (NGROW && ((nn < kn && mn < kn) || !KGROW))
      {
         nb = nn;
         mb = mn;
      }
      else if (KGROW)
         kb = kn;
   }
   while (NGROW | KGROW);
   *MB = mb;
   *NB = nb;
   *KB = kb;
}

void GetBlkFromBudget_ws(double thresh, size_t CS, 
                          size_t mu, size_t nu, size_t ku,
                          size_t *MB, size_t *NB, size_t *KB)
{
   size_t mb=mu, nb=nu, kb=ku;
   int KGROW;
   do
   {
      size_t kn=kb+ku, mn=(kn > mu)?(kn/mu)*mu:mu, nn=(kn>nu)?(kn/nu)*nu:nu;
      KGROW = kn < MAXNB && (CacheRatio_ws(CS, mn, nn, kn, mu, nu) <= thresh);
      if (KGROW)
      {
         mb = mn;
         nb = mn;
         kb = kn;
      }
   }
   while (KGROW);
   *MB = mb;
   *NB = nb;
   *KB = kb;
}

ATL_mmnode_t *FindBestCacheBudgetCase
(
   int verb,
   char pre, 
   BudgetFunc_t GetBlocking,     /* func ptr to budget function */
   double thresh,                /* max ratio of cache to fill */
   size_t CS,                    /* size of cache we are optimizing for */
   int imf,                      /* entry in mflop[] to use */
   ATL_mmnode_t *mmb             /* list of cases to try */
)
/*
 * RETURNS: clone of best-peforming kernel in mmb for kb=kb, mb & nb 
 *          near-square and within budget
 */
{
   ATL_mmnode_t *mmB=NULL, *mp, *p;
   double mf, mfB=0.0;

   printf("Finding best case for cache budget case=%d, CS=%.0f elts\n",
          imf, CS*thresh);
   for (mp=mmb; mp; mp = mp->next)
   {
      size_t mb, nb, kb;
      GetBlocking(thresh, CS, mp->mu, mp->nu, mp->ku, &mb, &nb, &kb);
      p = CloneMMNode(mp);  /* can't use mp, since may switch KRUNTIME */
      mf = TimeMMKernel_KB(verb, 0, p, pre, mb, nb, kb, 1, 0, -1);
      printf("   ID=%d, mb=%d, nb=%d, kb=%d, RTK=%d, MFLOP=%.2f\n", p->ID,
             (int)mb, (int)nb, (int)kb, FLAG_IS_SET(p->flag, MMF_KRUNTIME), mf);
      if (mf > mfB)
      {
         if (mmB)
            KillMMNode(mmB);
         p->mbB = mb;
         p->nbB = nb;
         p->kbB = kb;
         mmB = p;
         mfB = mmB->mflop[imf] = mf;
      }
      else
         KillMMNode(p);
   }
   printf("BEST CASE %s: mb=%d, nb=%d, kb=%d, RTK=%d, MFLOP=%.2f\n\n",
          mmB->rout ? mmB->rout : "GENNED",
          mmB->mbB, mmB->nbB, mmB->kbB, FLAG_IS_SET(mmB->flag, MMF_KRUNTIME), 
          mmB->mflop[imf]);
   mmB->next = NULL;
   return(mmB);
}

ATL_mmnode_t *FindBestCacheBudgetCases
(
   int verb,
   char pre, 
   size_t CS,                    /* size of cache we are optimizing for */
   ATL_mmnode_t *mmb             /* list of cases to try */
)
/*
 * This case attempts to find the best kernel for 3 cases of interest:
 * (1) All 3 matrices fit in CS -- this case is designed for when we wish
 *     to reuse at least one of the matrices *across* mmkern calls.  It is
 *     particularly good for complex arithmetic, or when CS is large enough
 *     that A&B are reused so much internally to a mmkern call that it makes
 *     sense to retain C in cache for the next mmkern call in K-loop.
 * (2) All of B fits in CS, and so does the working set of A&C.  This one
 *     reuses all internal ops from L1, but won't allow any full op reuse
 *     across multiple GEMM calls.  Usually best for small-to-medium cache
 *     sizes.
 * (3) All of working set of A/B/C fit in cache.  This case provides maximal
 *     NB, where only the mu*KB panel of A is reused from the L1 internally
 *     to the algorthm.  It is essentially an L2-blocked algorithm internally,
 *     but can be useful on those archs where the best sustained bandwidth
 *     comes from one L1 load (A) and 1 L2 load (B).
 */
{
   ATL_mmnode_t *mm3, *mm1, *mmw;
   mm3 = FindBestCacheBudgetCase(verb, pre, GetBlkFromBudget_all3, 1.0, 
                                 CS, 1, mmb);
   mm1 = FindBestCacheBudgetCase(verb, pre, GetBlkFromBudget_one, 1.0, 
                                 CS, 2, mmb);
   mmw = FindBestCacheBudgetCase(verb, pre, GetBlkFromBudget_ws, .90, 
                                 CS, 3, mmb);
   mm3->next = mm1;
   mm1->next = mmw;
   mmw->next = NULL;

   printf("3CASES: ID=%d/%d/%d, mb=%d/%d/%d, nb=%d/%d/%d, kb=%d/%d/%d\n",
          mm3->ID, mm1->ID, mmw->ID, mm3->mbB, mm1->mbB, mmw->mbB, 
          mm3->nbB, mm1->nbB, mmw->nbB, mm3->kbB, mm1->kbB, mmw->kbB);
   printf("        RTK=%d/%d/%d, MFLOP=%.2f/%2f/%2f\n\n",
          FLAG_IS_SET(mm3->flag, MMF_KRUNTIME),
          FLAG_IS_SET(mm1->flag, MMF_KRUNTIME),
          FLAG_IS_SET(mmw->flag, MMF_KRUNTIME),
          mm3->mflop[1], mm1->mflop[2], mmw->mflop[3]);

   return(mm3);
}

int KernelIsSame(ATL_mmnode_t *p0, ATL_mmnode_t *p1)
/*
 * RETURNS: 1 if kernels are the same except for blocking, 0 otherwise
 */
{
/*
 * Two generated kernels are the same if mu,nu,ku,VLEN,flag are the same.
 * NOTE: if we make generator handle muladd, etc, MUST UPDATE HERE!!!
 */
   if (p0->ID == 0 && p1->ID == 0)
      return(p0->mu == p1->mu && p0->nu == p1->nu && p0->ku == p1->ku &&
             p0->vlen == p1->vlen && p0->flag == p1->flag &&
             p0->kmaj == p1->kmaj);
/*
 * If both are user kernels, then they may be repeats.  For user kernels,
 * they are the same if both ID and flag match, else they are not.
 */
   else if (p0->ID > 0 && p1->ID > 0)
      return(p0->ID == p1->ID && p0->flag == p1->flag);
   return(0);  /* Can't be the same if above criteria fails */
}

int KernelIsUnique(ATL_mmnode_t *mmb, ATL_mmnode_t *mmp)
/*
 * Determines if mmp is the first mention of a unique kernel in mmb, or not.
 * For user cases (ID > 0), (ID,flag) together make a unique kernel.
 * For user generated cases, if they match on : mu,nu,ku,VLEN,flag
 *
 * RETURNS: 0 if mmp appears in mmb before mmp, else 1
 */
{
   ATL_mmnode_t *mp;
   if (mmp == mmb)
      return(1);
   for (mp=mmb; mp && mp != mmp; mp = mp->next)
      if (KernelIsSame(mmp, mp))
         return(0);
   return(1);  /* didn't find it, must be first time in list */
}

ATL_mmnode_t *TimeKBRegion
(
   int verb,
   char pre, 
   ATL_mmnode_t *mmk,            /* kernel to time throughout region */
   int kbmin,                    /* start of region */
   int kbend,                    /* largest kb in region */
   int kincD                     /* default stride between kernel timings */
)
/*
 * Returns list of timings of kernel mmk using near-square cases with KB
 * varying between kbmin - kbend.  All cases that are legal and incremented
 * by kinc are tried, as are all perfectly square cases
 */
{
   ATL_mmnode_t *mmb=NULL, *mp, *mpB=NULL;
   const int ku = mmk->ku, mu=mmk->mu, nu=mmk->nu;
   int kstart, kinc, kend, k, ksq, ksqinc;
   double mf, mfB=0.0;
/*
 * Get starting and ending point that is legal for this kernel.
 */
   kstart = Mmax(mmk->kbmin, kbmin);
   kstart = ((kstart+ku-1)/ku)*ku;
   kend = ((kbend+ku-1)/ku)*ku;
   if (mmk->kbmax)
      kend = Mmin(kend, mmk->kbmax);
   k = kstart;
/*
 * square inc always lcm(mu,nu,ku).  Normal increment is always at least
 * as big as the default stride, but must be a multiple of the kernel's ku
 */
   ksqinc = Mylcm(mu, nu);
   ksqinc = Mylcm(ksqinc, ku);
   for (kinc=ku; kinc < kincD; kinc += ku);
   if (kstart <= kend)
   {
      int kb = k;
      printf("TIMING %s mu=%d, mu=%d, For KB=[%d,%d]:\n", 
             mmk->rout ? mmk->rout : "Genkern", mu, nu, kstart, kend);
      ksq = ((kstart+ksqinc-1)/ksqinc)*ksqinc;
      do
      {
         ATL_mmnode_t *p;
         const int mb=((kb+mu-1)/mu)*mu, nb=((kb+nu-1)/nu)*nu;

         p = CloneMMNode(mmk);
         p->mbB = mb; p->nbB = nb; p->kbB = kb;
         mf = TimeMMKernel_KB(verb, 0, p, pre, mb, nb, kb, 1, 0, -1);
         printf("   mb=%d, nb=%d, kb=%d, KRUN=%d, MFLOP=%.2f\n",
                mb, nb, kb, FLAG_IS_SET(p->flag, MMF_KRUNTIME), mf);
         p->mflop[0] = mf;
         if (mf > mfB)
         {
            mfB = mf;
            mpB = p;
         }
         if (mmb)
         {
            mp->next = p;
            mp = p;
         }
         else
            mmb = mp = p;
         if (kb == ksq)
            ksq += ksqinc;
         if (kb == k)
            k += kinc;
         kb = Mmin(k,ksq);
      }
      while(kb <= kend);
      printf("DONE, best case %s mb=%d, nb=%d, kb=%d, MFLOP=%.2f\n\n", 
             mmk->rout ? mmk->rout : "Genkern",
             mpB->mbB, mpB->nbB, mpB->kbB, mfB);
   }
   else
   {
      printf("KERNEL %s mu=%d, mu=%d, has no legal cases in KB=[%d,%d]!\n\n", 
             mmk->rout ? mmk->rout : "Genkern", mu, nu, kstart, kend);
   }
   return(mmb);
}

ATL_mmnode_t *TimeAllKBRegions
(
   int verb,
   char pre, 
   ATL_mmnode_t *mmk,            /* kernel to time throughout regions */
   int kb1,                      /* rough kb ending region 1 */
   int kb2,                      /* rough kb ending region 2 */
   int kb3                       /* maxKB to ever try */
)
/*
 * Times mmk for KBs in the three regions, returns list
 */
{
   const int ku = mmk->ku;
   ATL_mmnode_t *mmb, *mp;

   mmb = TimeKBRegion(verb, pre, mmk, 24, kb3, 4);
   return(mmb);
}

ATL_mmnode_t *FindCacheBudgetCasesByKB
(
   int verb,
   char pre, 
   size_t CS,                    /* size of cache we are optimizing for */
   ATL_mmnode_t *mmb             /* list of cases to try */
)
/* 
 * This routine is responsible for:
 * (1) Find the best performing kernels out of mmb for our 3 cache budget
 *     cases
 * (2) Free mmb
 * (3) For each unique kernel, find perf of kernel for all supported KBs 
 *     in the budgetary regions
 * (4) Merge these lists, and winnow underperforming cases
 * (5) RETURN: queue of all supported KBs
 */
{
   ATL_mmnode_t *mm3b, *mp;
/*
 * See if we just need to rerun cases
 */
   mm3b = ReadMMFileWithPath(pre, "res", "bAMMRES.sum");
   if (mm3b)
   {
      int i=0;
      printf("READING IN LARGE KERNEL CASES FROM res/<pre>bAMMRES:\n");
      FillInGenStrings(pre, mm3b);
      for (mp=mm3b; mp; mp = mp->next)
      {
         if (mp->mflop[0] <= 0.0)
            mp->mflop[0] = TimeMMKernel(verb, 0, mp, pre, mp->mbB, mp->nbB, 
                                        mp->kbB, 0, 0, 0, 1, 0, -1);
         printf("   ID=%d, %s: MB=%d, NB=%d, KB=%d, KRUN=%d, MFLOP=%.2f\n",
                mp->ID, mp->rout ? mp->rout : "Gennedkern",
                mp->mbB, mp->nbB, mp->kbB, FLAG_IS_SET(mp->flag, MMF_KRUNTIME),
                mp->mflop[0]);
         i++;
      }
      printf("DONE %d CASES.\n\n", i);
      return(mm3b);
   }
/*
 * Find best performing kernels for each of our 3 cache budgets
 */
   mm3b = FindBestCacheBudgetCases(verb, pre, CS, mmb);
   KillAllMMNodes(mmb);
/*
 * Get list of performance of all-3 in-cache kernel in all 3 cache regions
 */
   mmb = TimeAllKBRegions(verb, pre, mm3b, mm3b->kbB, mm3b->next->kbB,
                          mm3b->next->next->kbB);
   for (mp=mm3b->next; mp; mp = mp->next)
   {
      if (KernelIsUnique(mm3b, mp))
      {
         ATL_mmnode_t *p, *p2;
         p = TimeAllKBRegions(verb, pre, mp, mm3b->kbB, mm3b->next->kbB,
                              mm3b->next->next->kbB);
         p2 = MergeCases(0, mmb, p);
         KillAllMMNodes(p);
         KillAllMMNodes(mmb);
         mmb = p2;
      }
   }
   KillAllMMNodes(mm3b);
/*
 * Now, get rid of any blocking factor that is slower than the preceeding one
 */
   mmb = WinnowCases(0, mmb);
   WriteMMFileWithPath(pre, "res", "bAMMRES.sum", mmb);
   return(mmb);
}

ATL_mmnode_t *DecentGenCase(int verb, char pre, int nreg)
{
/*
 * Find out what vectorization, if any, to use in generating kernels
 */
   int mu, nu;
   SetGenVec(verb, pre);
/* 
 * 120 = LCM(2,3,4,5,6,8), and large enough to stress mu/nu
 */
   FindDefMUNU(verb, pre, nreg, 0, 120, 1, &mu, &nu);
   return(ReadMMFileWithPath(pre, "res", "gAMMMUNU.sum"));
@skip   return(GetNewGenNode(pre, 0, 0, mu, nu, 1, 0));
}

/*
 * This routine finds kernels to use in low-rank-K update. For 3 <= K <= 15,
 * it tries all kernels and chooses the best performing; In this search
 * we consider only compile-time K kernels, since runtime kernels will be
 * selected by general (K>15) search.
 * (K=1 and K=2 are handled by GER and GER2).
 * We consider only user-generated kernels; for any problem sizes that are
 * not supported, we will use the normal K or K-clean routines.  This list
 * is just to allow for hand-tuning small-K special cases.
 * This routine produces output file <pre>AMMLOWK.sum
 */
ATL_mmnode_t *GetLowRankKKernels
(
   int verb,            /* verbosity */
   char pre,            /* s,d */
   int NB,              /* default mb/nb to time with */
   ATL_mmnode_t *inb    /* all working ukerns */
)
{
   int k, ik;
   ATL_mmnode_t *rkKb=NULL, *mp;
/*
 * Get rid of all K-runtime kernels from consideration
 */
   while (inb && FLAG_IS_SET(inb->flag, MMF_KRUNTIME))
      inb = KillMMNode(inb);
   if (inb)
   {
      ATL_mmnode_t *prev=inb;
      mp = inb->next;
      while (mp)
      {
         if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
         {
            mp = KillMMNode(mp);
            prev->next = mp;
         }
         else
         {
            prev = mp;
            mp = mp->next;
         }
      }
   }
   else
      return(NULL);
   for (ik=0; ik < 2; ik++)
   {
      int kbeg, kend, kinc;
      if (!ik)
      {
         kbeg = 96;
         kend = 16;
         kinc = 16;
      }
      else
      {
         kbeg = 15;
         kend = 3;
         kinc = 1;
      }
      for (k=kbeg; k >= kend; k -= kinc)
      {
         printf("FINDING BEST USER-PROVIDED KERNEL FOR K=%d:\n", k);
         ATL_mmnode_t *best=NULL;
         for (mp=inb; mp; mp = mp->next)
         {
            const int mu = mp->mu, nu = mp->nu, ku = mp->ku;
            const int mb = (NB/mu)*mu, nb = (NB/nu)*nu;
            const int KK = (mp->kmaj < 2) ? k : ((k+ku-1)/ku)*ku;
            double mf;
   
            assert(mb && nb);
            if (FLAG_IS_SET(mp->flag, MMF_KRUNTIME) || KK%ku)
            {
               printf("   skipping %d. %s, KRUN=%d, ku=%d\n", mp->ID, mp->rout,
                      FLAG_IS_SET(mp->flag, MMF_KRUNTIME), ku);
               continue;
            }
            if ((mp->kbmin && k < mp->kbmin) || (mp->kbmax && KK > mp->kbmax))
            {
               printf("   skipping %d. %s, kbmin,max=%d,%d, K=%d\n", 
                      mp->ID, mp->rout, mp->kbmin, mp->kbmax, KK);
               continue;
            }
            mf = TimeMMKernel(verb, 0, mp, pre, mb, nb, KK, 0, 0, 0, 0, 0, -1);
            if (KK != k)
               mf = (mf*k) / (double)KK;
            printf("   %d. %s: mb=%d, nb=%d, MFLOP=%.2f\n", mp->ID, mp->rout,
                   mb, nb, mf);
            if (!best)
            {
               best = mp;
               mp->mflop[0] = mf;
               mp->mbB = mb;
               mp->nbB = nb;
               mp->kbB = k;
            }
            else if (best->mflop[0] < mf)
            {
               best = mp;
               mp->mflop[0] = mf;
               mp->mbB = mb;
               mp->nbB = nb;
               mp->kbB = k;
            }
         }
         if (best)
         {
            best = CloneMMNode(best);
            best->next = rkKb;
            rkKb = best;
            printf("BEST FIXED-%d KERNEL: %d. %s MFLOP=%.2f\n\n", 
                   k, best->ID, best->rout, best->mflop[0]);
         }
         else
            printf("NO SPECIAL CASE for K=%d\n\n", k);
      }
   }
   KillAllMMNodes(inb);
   return(rkKb);
}

/*
 * Finds list of best run-time kernel, ranked by KU.  Higher KUs are not
 * retained unless they beat any lower-KU kernel that divides that KU evenly
 */
ATL_mmnode_t *GetRuntimeKKernels
(
   int verb,            /* verbosity */
   char pre,            /* s,d */
   int NB,              /* default mb/nb to time with */
   ATL_mmnode_t *inb    /* all working ukerns */
)
{
   ATL_mmnode_t *mp;
   int KU;
/*
 * Get rid of all non-K-runtime kernels from consideration
 */
   while (inb && !FLAG_IS_SET(inb->flag, MMF_KRUNTIME))
      inb = KillMMNode(inb);
   if (inb)
   {
      ATL_mmnode_t *prev=inb;
      mp = inb->next;
      while (mp)
      {
         if (!FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
         {
            mp = KillMMNode(mp);
            prev->next = mp;
         }
         else
         {
            prev = mp;
            mp = mp->next;
         }
      }
   }
   else
      return(NULL);
   KU = inb->ku;
   for (mp=inb->next; mp; mp = mp->next)
      KU = Mylcm(KU, mp->ku);
   if (KU > 32)
      KU = 32;
   else
      KU = ((16+KU-1)/KU)*KU;
   printf("TRYING ALL RUNTIMEK KERNS WITH NB=%d, KB=%d:\n", NB, KU);
   for (mp=inb; mp; mp = mp->next)
   {
      int mu=mp->mu, nu=mp->nu, ku=mp->ku;
      int mb = (NB/mu)*mu, nb = (NB/nu)*nu, kb = (KU/ku)*ku;
      double mf;
      assert(mb && nb && kb);
      mf = TimeMMKernel(verb, 0, mp, pre, mb, nb, kb, 0, 0, 0, 0, 0, -1);
      printf("   %d. %s: mb=%d, nb=%d, MFLOP=%.2f\n", mp->ID, mp->rout,
             mb, nb, mf);
      mp->mflop[0] = mf;
      mp->mbB = mb;
      mp->nbB = nb;
      mp->kbB = kb;
   }
   printf("\n");
   inb = ATL_SortMMNodesByMflop(0, inb);
   if (inb->ku == 1)
   {
      KillAllMMNodes(inb->next);
      inb->next = NULL;
   }   
   else
   {
      ATL_mmnode_t *p;
/*
 *    Go thru sorted list, and kill all slower nodes that don't add new K
 */
      for (p=inb; p; p = p->next)
      {
         ATL_mmnode_t *prev=p;
         mp = p->next;
         while (mp)
         {
            if (mp->ku % p->ku == 0)
            {
               mp = KillMMNode(mp);
               prev->next = mp;
            }
            else
            {
               prev = mp;
               mp = mp->next;
            }
         }
      }
   }
   if (!inb)
      printf("NO RETAINED RUNTIME KERNELS.\n\n");
   else
   {
      printf("RETAINED RUNTIME KERNELS:\n");
      for (mp=inb; mp; mp = mp->next)
         printf("   %d. %s: ku=%d, MFLOP=%.2f\n", mp->ID, mp->rout, mp->ku,
                mp->mflop[0]);
      printf("DONE.\n");
   }
   return(inb);
}
/*
 * RETURNS: 1 if mmc is slower than any kernel in mmb
 */
int IsSlowerThanList
(
   int verb,            /* verbosity */
   char pre,            /* s,d */
   int NB,              /* default mb/nb to time with */
   ATL_mmnode_t *mmc,  /* candidate mmkern */
   ATL_mmnode_t *mmb   /* kernels to time candidate against */
)
{
   ATL_mmnode_t *mp;
   double mfc, mf;
   int mu, nu, ku;
   int mb, nb, kb, KB;

   if (!mmb)
      return(0);
   kb = mmc->kbB;
   mu = mmc->mu;
   nu = mmc->nu;
   mb = (NB/mu)*mu;
   nb = (NB/nu)*nu;
   assert(mb && nb && kb);
   KB = (mmc->kmaj < 2) ? kb : ((kb+mmc->ku-1)/mmc->ku)*mmc->ku;
   mfc = TimeMMKernel(verb, 0, mmc, pre, mb, nb, KB, 0, 0, 0, 0, 0, -1);
   mfc = (kb*mfc)/(double)KB;
   mmc->mflop[1] = mfc;
   kb = mmc->kbB;
   for (mp=mmb; mp; mp = mp->next)
   {
      ku = mp->ku;
      if (mp->kbmin && kb < mp->kbmin)
         continue;
      if (mp->kbmax && kb > mp->kbmax)
         continue;
      if (kb%ku == 0 || mp->kmaj > 1)
      {
         int KK = (mp->kmaj > 1) ? ((kb+ku-1)/ku)*ku : kb;
         mu = mp->mu;
         nu = mp->nu;
         mb = (NB/mu)*mu;
         nb = (NB/nu)*nu;
         assert(mb && nb);
         mf = TimeMMKernel(verb, 0, mp, pre, mb, nb, KK, 0, 0, 0, 0, 0, -1);
         mp->mflop[1] = (kb*mfc)/(double)KK;
         if (mf > mfc)
         {
@skip            printf("      %d. %s (%.2f) outcompeted by %d. %s (%.2f)\n",
@skip                   mmc->ID, mmc->rout, mfc, mp->ID, mp->rout, mf);
            return(1);
         }
      }
   }
   return(0);
}

@ROUT ammsearch
ATL_mmnode_t *MergeRankKKernels
(
   int verb,            /* verbosity */
   char pre,            /* s,d */
   int NB,              /* default mb/nb to time with */
   int maxKB,           /* largest KB to produce */
   ATL_mmnode_t *fixb,  /* rank-K fixed-K kerenls */
   ATL_mmnode_t *runb,  /* rank-K, runtime-K kernels */
   ATL_mmnode_t *sqrb   /* optimized near-square kernels */
)
{
   ATL_mmnode_t *rkb, *rkp;
   int k;
   rkp = rkb = GetMMNode();
   printf("CHOOSING BEST KERNEL FOR EACH RANK-K:\n");
   for (k=3; k <= maxKB; k++)
   {
      ATL_mmnode_t *best=NULL, *p;
      double mfB=0.0, mf;
/*
 *    fixb & sqrb are in K-order, so we pop them off stack until we get to
 *    one big enough to solve the problem.  We also ignore all KRUNTIME kernels
 *    in sqrb, since they should appear in runb if they are competitive
 */
      while (fixb)
      {
         if (fixb->kbB < k || (fixb->kbmin && fixb->kbmin > k) ||
             (fixb->kbmax && fixb->kbmax < k))
            fixb = KillMMNode(fixb);
         else
            break;
      }
      while (sqrb)
      {
         if (sqrb->kbB < k || FLAG_IS_SET(sqrb->flag, MMF_KRUNTIME)
             || (sqrb->kbmin && sqrb->kbmin > k) || 
                (sqrb->kbmax && sqrb->kbmax < k))
            sqrb = KillMMNode(sqrb);
         else break;
      }
      if (fixb)
      {
         if (fixb->kbB == k)
         {
            int mu = fixb->mu, nu = fixb->nu, ku = fixb->ku;
            int mb = (NB/mu)*mu, nb = (NB/nu)*nu;
            int kb = (fixb->kmaj < 2) ? k : ((k+ku-1)/ku)*ku;
            best = fixb;
            fixb = fixb->next;
            mfB = TimeMMKernel(verb, 0, best, pre, mb, nb, kb, 0, 0, 0, 0,0,-1);
            mfB = (mfB*k)/(double)kb;
         }
      }
      if (sqrb)
      {
         if (sqrb->kbB == k)
         {
            int mu = sqrb->mu, nu = sqrb->nu, ku = sqrb->ku;
            int mb = (NB/mu)*mu, nb = (NB/nu)*nu;
            int kb = (sqrb->kmaj < 2) ? k : ((k+ku-1)/ku)*ku;
            mf = TimeMMKernel(verb, 0, sqrb, pre, mb, nb, kb, 0, 0, 0, 0, 0,-1);
            mf = (mf*k)/(double)kb;
            if (mf > mfB)
            {
               mfB = mf;
               if (best)
                  KillMMNode(best);
               best = sqrb;
               sqrb = sqrb->next;
            }
            else
               sqrb = KillMMNode(sqrb);
         }
      }
      for (p=runb; p; p = p->next)
         if ((k % p->ku == 0 || p->kmaj > 1) && 
             k > p->kbmax && (!p->kbmin || p->kbmin <= k))
            break;
      if (p)
      {
         int mu = p->mu, nu = p->nu, ku = p->ku;
         int mb = (NB/mu)*mu, nb = (NB/nu)*nu;
         int kb = (p->kmaj < 2) ? k : ((k+ku-1)/ku)*ku;
         if (p->kbmax && p->kbmax < kb)
            mf = -1.0;
         else
            mf = TimeMMKernel(verb, 0, p, pre, mb, nb, kb, 0, 0, 0, 0, 0, -1);
         mf = (mf*k)/(double)kb;
         if (mf > mfB)
         {
            mfB = mf;
            if (best)
               KillMMNode(best);
            best = CloneMMNode(p);
         }
      }
      assert(best);
      printf("   Best kernel K=%d: %d. %s (%.2f)\n",k,best->ID,best->rout,mfB);
      best->kbB = k;
      rkp->next = best;
      rkp = best;
   }
   if (sqrb)
      KillAllMMNodes(sqrb);
   if (fixb)
      KillAllMMNodes(fixb);
   rkp->next = NULL;
   printf("DONE.\n\n");
   return(KillMMNode(rkb));
}

ATL_mmnode_t *GetRankKKernels
(
   int verb,            /* verbosity */
   char pre,            /* s,d */
   int NB,              /* default mb/nb to time with */
   ATL_mmnode_t *gmm,   /* generated matmul kernel */
   ATL_mmnode_t *low,   /* all working ukerns */
   ATL_mmnode_t *mmb    /* cases already chosen for square GEMM */
)
{
   ATL_mmnode_t *run, *rkb;
   int maxKB=128;
   
   rkb = ReadMMFileWithPath(pre, "res", "ARANKK.sum");
   if (rkb)
   {
      ATL_mmnode_t *mp;
      printf("Reading in RANK-K cases:\n");
      FillInGenStrings(pre, rkb);
      for (mp=rkb; mp; mp = mp->next)
      {
         const int mu = (mp->vlen) ? mp->mu / mp->vlen : mp->mu;
         int kb = mp->kbB, mb = mp->mbB, nb=mp->nbB;
         if (mp->mflop[0] < 0.0)
            mp->mflop[0] = TimeMMKernel(verb, 1, mp, pre, mb, nb, kb,
                                         kb, kb, mb, 1, 0, -1);
         printf("  ID=%d, %s: (M,N,K)=(%d,%d,%d) mf=%.2f\n", mp->ID, 
                mp->rout ? mp->rout:"Gennedkern", mb, nb, kb, mp->mflop[0]);
      }
      WriteMMFileWithPath(pre, "res", "ARANKK.sum", rkb);
      return(rkb);
   }
   if (mmb)
   {
      maxKB = mmb->kbB;
      for (run=mmb; run; run = run->next)
         if (maxKB < run->kbB)
            maxKB = run->kbB;
   }
   run = CloneMMQueue(low);
   if (FLAG_IS_SET(gmm->flag, MMF_KRUNTIME))
   {
      if (gmm->ku != 1)
      {
         ATL_mmnode_t *p;
         int gmu = (gmm->kmaj > 1) ? gmm->mu : gmm->mu / VLEN[VECi];
         assert(gmu);
         p = GetNewGenNode(pre, NB, gmm->lat, gmu, gmm->nu, 1, 0);
         p->next = run;
         run = p;
      }
      gmm->next = run;
      run = gmm;
   }
   else
   {
      ATL_mmnode_t *p;
      int gmu = (gmm->kmaj > 1) ? gmm->mu : gmm->mu / VLEN[VECi];
      assert(gmu);
      p = GetNewGenNode(pre, NB, gmm->lat, gmu, gmm->nu, 1, 0);
      p->flag |= (1<<MMF_KRUNTIME);
      p->next = run;
      run = p;
      gmm->next = low;
      low = gmm;
   }
   low = GetLowRankKKernels(verb, pre, NB, low);
   run = GetRuntimeKKernels(verb, pre, NB, run);
/*
 * Delete any fixed kernels that are slower than the runtime-K kernels
 */
   printf("DELETING FIXED KERNELS OUTCOMPETED BY RUNTIME KERNELS:\n");
   while (low)
   {
      if (!IsSlowerThanList(verb, pre, NB, low, run));
         break;
      printf("   Deleting: %d. %s for K=%d\n", low->ID, low->rout, low->kbB);
      low = KillMMNode(low);
   }
   if (low)
   {
      ATL_mmnode_t *mp=low->next, *prev=low;
      while (mp)
      {
         if (IsSlowerThanList(verb, pre, NB, mp, run))
         {
            printf("   Deleting: %d. %s for K=%d\n", mp->ID, mp->rout, mp->kbB);
            mp = KillMMNode(mp);
            prev->next = mp;
         }
         else
         {
            prev = mp;
            mp = mp->next;
         }
      }
   }
   printf("DONE.\n\n");

   rkb = MergeRankKKernels(verb, pre, NB, maxKB, low, run, mmb);
   printf("RANK-K KERNELS:\n");
   PrintMMNodes(stdout, rkb);
   printf("\n");
   KillAllMMNodes(run);
   WriteMMFileWithPath(pre, "res", "ARANKK.sum", rkb);
   return(rkb);
}

/*
 * Complex types use the previously selected real kernels in order to
 * reduce library size (means we only have 2 precision GEMMS for 4
 * types/precisions).  The only thing that is different is we may
 * reduce max NB in order to keep complex ops in cache.
 * May want to write this as part of real tuning!
 */
int DoComplex(char pre, int verb)
{
   ATL_mmnode_t *mmb;
   char upr = (pre == 'z') ? 'd' : 's';
   exit(-1);
   mmb = ReadMMFileWithPath(pre, "res", "eAMMRES.sum");
   if (!mmb)
   {
      mmb = ReadMMFileWithPath(upr, "res", "eAMMRES.sum");
      assert(mmb);
      WriteMMFileWithPath(pre, "res", "eAMMRES.sum", mmb);
   }

}
int main(int nargs, char **args)
{
   char pre='d';
   int verb, nregs, nb, CS, gmu, gnu;
   int *nbs;
   char *fnout;
   ATL_mmnode_t *smmb, *mmb, *mmp, *mm3b, *gmm, *p, *rnkK, *grnkK=NULL;

   nbs = GetFlags(nargs, args, &pre, &verb, &nregs, &nb, &CS);
   if (pre == 'c' || pre == 'z')
      return(DoComplex(pre, verb));
   if (verb)
   {
      int i;
      const int n = nbs[0]+1;
      printf("NBs = %3d", nbs[1]);
      for (i=2; i < n; i++)
         printf(", %3d", nbs[i]);
      printf("\n");
   }
/*
 * Find which kernels can compile on this platform
 */
   mmb = GetWorkingUserCases(verb, pre);
   rnkK = CloneMMQueue(mmb);  /* clone the working kerns for rank-K search */
/*
 * For small cases (or user specified), try all kernels with all KB for
 * user generated.  Smmb now points to these KB values that are always
 * retained, and will simply be added to eventual list of large KB kernels
 * that we generate in the next step.
 */
   if (mmb)
   {
      mmp = CloneMMQueue(mmb);
      smmb = FindBestUserCases(verb, pre, nbs, mmp);
      mmp = FindBestGenCases(verb, pre, nregs, nbs, smmb);
      if (nbs[0] >= 0)
         smmb = MergeAndWinnowCases(verb, pre, smmb, mmp);
      else  /* forced nbs are all kept, so just merge */
         smmb = MergeCases(0, smmb, mmp);
   }
   else
     smmb = FindBestGenCases(verb, pre, nregs, nbs, NULL);
/*
 * If nbs aren't being forced, then try larger ranges using cache budgets
 */
   if (nbs[0] >= 0)
   {
/*
 *    Find decent generator case and find correct vectorization settings, add
 *    this case to default list to be searched.
 */
      gmm = DecentGenCase(verb, pre, nregs);
      grnkK = CloneMMNode(gmm);
      gmm->next = mmb;
      mmb = gmm;
/*
 *    Find the best user-supplied cases for the three common cache blking cases
 */
      mmb = FindCacheBudgetCasesByKB(verb, pre, CS, mmb);
/*
 *    Now add small-case kernels back in, and write it out
 */
      p = MergeCases(0, mmb, smmb);
      KillAllMMNodes(smmb);
      KillAllMMNodes(mmb);
      mmb = p;
   }
   else /* when we force nbs, we just blindly use the provided list */
      mmb = smmb;
   WriteMMFileWithPath(pre, "res", "eAMMRES.sum", mmb);
   ComputeKClean(verb, pre, mmb);
@skip   KillAllMMNodes(mmb);
   FindBestKU1(verb, pre, 17);  /* create kern for use in low-rank update */
   if (!grnkK)
      grnkK = DecentGenCase(verb, pre, nregs);
   mmb = GetRankKKernels(verb, pre, pre == 'd' ? 60:80, grnkK, rnkK, mmb);
   KillAllMMNodes(mmb);
   free(nbs);
   exit(0);
}
@ROUT uammsearch
#define CON_NOKVEC 0
#define CON_NOMVEC 1
#define CON_NOCOMPK 2
/*
 * RETURNS: N-length queue wt best-performing kernel for specified dims
 */
ATL_mmnode_t *FindBestKerns
(
   char pre, 
   int verb, 
   ATL_mmnode_t *mmb,  /* candidate user-supplied kerns */
   int N,              /* number of forced block factors */
   int *mbs, int *nbs, int *kbs, /* forced block factors */
   int C               /* constraints */
)
{
   ATL_mmnode_t *nmmb=NULL, *mp, *mpB, *mpG, *mpg;
   const int TRYKVEC=!(C & (1<<CON_NOKVEC));
   const int TRYMVEC=!(C & (1<<CON_NOMVEC));
   int i;
   double mfB, mf;
/*
 * Find basic register blocking for generated case
 */
   mpG = DecentGenCase(verb, pre, 32);
   if (mpG->vlen != VLEN[VECi])
      VECi = VTSC;
   assert (mpG->kmaj < 2);
/*
 * Loop over all required blocking factors
 */
   printf("SEARCHING %d USER BLOCKINGS:\n", N);
   for (i=N-1; i >= 0; i--)
   {
      int mb=mbs[i], nb=nbs[i], kb=kbs[i];
      int kuG, KK=kb, veci0=VECi;
      double mfK=0.0, mfM=0.0;
      int iveci = VECi, VL=VLEN[VECi];

      printf("\n   FINDING KERNEL FOR MB=%d, NB=%d, KB=%d:\n", mb, nb, kb);
/*
 *    Find best of M- or K-vectorized generated code for this problem size
 */
      mpg = mpB = NULL;
      if (TRYMVEC)
      {
         int muG=mpG->mu, nuG=mpG->nu, ut=muG*nuG; 
/*
 *       If mb not a multiple of vlen, reduce vlen until it is
 */
         if (mb%VLEN[VECi])
         {
            if (VECi == VTAVX && !(mb%VLEN[VTSSE]))
               VECi = VTSSE;
            else
               VECi = VTSC;
         }
/*
 *       Make register block a multiple of mandated block
 */
         muG = (muG / VL)*VLEN[VECi];
         ut = muG * nuG;
         while (muG > 1 && mb%muG)
            muG -= VLEN[VECi];
         if (muG < 1)
            muG = 1;
         while(muG*(nuG+1) <= ut)
            nuG++;
         while (nb%nuG)
            nuG--;
         kuG = 1;
         mpg = GetNewGenNode(pre, kb, 0, muG/VLEN[VECi], nuG, 1, 0);
         mfM = TimeMMKernel(verb, 0, mpg, pre, mb, nb, KK, KK, KK, KK, 1, 0,-1);
         printf("      Gen mu=%d, nu=%d, kmaj=%d, mf=%.2f\n", muG, nuG, 0, mfM);
      }
      VECi = iveci;
      if (TRYKVEC)
      {
         int muG, nuG=mpG->nu, ut;

         if (VLEN[VECi] > 1)
            muG = mpG->mu / VLEN[VECi];
         else
            muG = mpG->mu;
         ut = muG * nuG;
/*
 *       If kb not a multiple of vlen, reduce it until it is
 */
         if (kb%VLEN[VECi])
         {
            if (VECi == VTAVX && !(kb%VLEN[VTSSE]))
               VECi = VTSSE;
            else
               VECi = VTSC;
         }
         kuG = VLEN[VECi];
/*
 *       Make register block a multiple of mandated block
 */
         while (mb%muG)
            muG--;
         while(muG*(nuG+1) <= ut)
            nuG++;
         while (nb%nuG)
            nuG--;
         if (kuG > 1)
         {
            mpB =  GetNewGenNode(pre, kb, 0, muG, nuG, kuG, kuG);
            mfK = TimeMMKernel(verb, 0, mpB, pre, mb, nb, KK, KK, KK, KK,
                               1, 0,-1);
            printf("      Gen mu=%d, nu=%d, kmaj=%d, mf=%.2f\n", muG, nuG, kuG,
                   mfK);
         }
      }
      if (mfM >= mfK)  /* use M-vectorized gen kernel */
      {
         if (mpB)
            KillMMNode(mpB);
         mpB = mpg;
         mfB = mfM;
      }
      else
      {
         if (mpg)
            KillMMNode(mpg);
         mpg = mpB;
         mfB = mfK;
      }
      VECi = iveci;
      if (KK != kb)
         mfB *= (double)kb / (double)KK;
      mpg->mflop[0] = mfB;
/*
 *    Search through all user kernels, and take best performing
 */
      mpB = mpg;
      for (mp=mmb; mp; mp = mp->next)
      {
         const int mu=mp->mu, nu=mp->nu, ku=mp->ku, kmaj=mp->kmaj;
         const int KB = (kmaj < 2) ? kb : ((kb+ku-1)/ku)*ku;
         int SKIP=0;
         if (mb%mu || nb%nu || KB%ku)
            SKIP=1;
         else if (mp->kbmin && mp->kbmin > kb)
            SKIP=1;
         else if (mp->kbmax && mp->kbmax < kb)
            SKIP=1;
         if (SKIP)
         {
            printf("      %d-%s: SKIPPED\n", mp->ID, mp->rout);
            continue;
         }
         mf = TimeMMKernel(verb, 0, mp, pre, mb, nb, KB, KB, KB, KB, 1, 0, -1);
         if (KB != kb)
            mf *= (double)kb / (double)KB;
         printf("      %d-%s: %.2f\n", mp->ID, mp->rout, mf);
         if (mf > mfB)
         {
            mfB = mf;
            mpB = mp;
         }
      }
      printf("    [M,N,K]B=%d,%d,%d BEST: %d-%s %.2f\n", mb, nb, kb,
             mpB->ID, mpB->rout, mfB);
      if (mpB == mpg)
      {
         mpg->next = nmmb;
         nmmb = mpg;
      }
      else
      {
         KillMMNode(mpg);
         mp = CloneMMNode(mpB);
         mp->next = nmmb;
         nmmb = mp;
      }
      nmmb->mflop[0] = mfB;
      nmmb->mbB = mb;
      nmmb->nbB = nb;
      nmmb->kbB = kb;
      VECi = veci0;
   }
   KillAllMMNodes(mmb);
   KillMMNode(mpG);
@skip   PrintMMNodes(stderr, nmmb);
   WriteMMFileWithPath(pre, "res", "uAMMFRC.sum", nmmb);
   printf("DONE.\n");
   return(nmmb);
}

/*
 * This routine applies the contraints C to mmb, and returns winnowed queue
 * RETURNS: Q wt all kernels failing constraints stropped out
 */
ATL_mmnode_t *ApplyConstraints(ATL_mmnode_t *mmb, int C)
{
    if (C)
    {
       ATL_mmnode_t *mp = mmb, *next;
       while (mp)
       {
          next = mp->next;
          if ((C & (1<<CON_NOKVEC)) && mp->kmaj > 1)
             mmb = KillMMNodeFromQ(mmb, mp);
          else if ((C & (1<<CON_NOMVEC)) && mp->kmaj < 2)
             mmb = KillMMNodeFromQ(mmb, mp);
          else if ((C & (1<<CON_NOCOMPK)) && 
                   !FLAG_IS_SET(mp->flag, MMF_KRUNTIME))
             mmb = KillMMNodeFromQ(mmb, mp);
          mp = next;
       }
    }
    return(mmb);
}
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr, 
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -b # nb1 ... nb# : square NBs to force\n");
   fprintf(stderr, "   -B # mb1 nb1 kb1 ... mb# nb# kb#: dims to force\n");
   fprintf(stderr, "   -v <verb> : set verbosity (1)\n");
   fprintf(stderr, "   -C [kmc] : Constrain kernel choice:\n");
   fprintf(stderr, "      k : don't allow K-vectorized storage\n");
   fprintf(stderr, "      m : don't allow M-vectorized storage\n");
   fprintf(stderr, "      c : don't allow compile-time K kernels\n");
   exit(ierr ? ierr : -1);
}

int GetFlags(int nargs, char **args, char *PRE, int *VERB, int *C,
             int **MBS, int **NBS, int **KBS)
{
   int *mbs=NULL, *nbs=NULL, *kbs=NULL;
   int i, k, N=0;
   char *cs;

   *VERB = 1;
   *PRE = 'd';
   *C = 0;
   for (i=1; i < nargs; i++)
   {
      int n;
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'v':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *VERB = atoi(args[i]);
         break;
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *PRE = tolower(args[i][0]);
        assert(*PRE == 's' || *PRE == 'd' || *PRE == 'z' || *PRE == 'c');
        break;
      case 'C':  /* -C <constraint string */
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         cs = args[i];
         n = strlen(cs);
         for (k=0; k < n; k++)
         {
            switch(cs[k])
            {
            case 'm':
               *C |= 1<<CON_NOMVEC;
               break;
            case 'k':
               *C |= 1<<CON_NOKVEC;
               break;
            case 'c':
               *C |= 1<<CON_NOCOMPK;
               break;
            default:
               PrintUsage(args[0], -i, "UNKNOWN CONSTRAINT");
            }
         }
      case 'B':
         if (nbs)
         {
            free(mbs);
            free(nbs);
            free(kbs);
         }
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         N = atoi(args[i]);
         assert(N > 0);
         nbs = malloc(N*sizeof(int));
         assert(nbs);
         mbs = malloc(N*sizeof(int));
         assert(mbs);
         kbs = malloc(N*sizeof(int));
         assert(kbs);
         for (k=0; k < N; k++)
         {
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
           mbs[k] = atoi(args[i]);
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
           nbs[k] = atoi(args[i]);
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
           kbs[k] = atoi(args[i]);
         }
         break;
      case 'b':
         if (nbs)
         {
            free(mbs);
            free(nbs);
            free(kbs);
         }
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         N = atoi(args[i]);
         assert(N > 0);
         nbs = malloc(N*sizeof(int));
         assert(nbs);
         mbs = malloc(N*sizeof(int));
         assert(nbs);
         kbs = malloc(N*sizeof(int));
         assert(nbs);
         for (k=0; k < N; k++)
         {
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
            mbs[k] = kbs[k] = nbs[k] = atoi(args[i]);
         }
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (!nbs)
      PrintUsage(args[0], -1, "Dimensional flag (-b or -B) required!");
   *MBS = mbs;
   *NBS = nbs;
   *KBS = kbs;
   if (*PRE == 's')
   {
      VLEN[VTAVXZ] = 16;
      VLEN[VTAVX] = 8;
      VLEN[VTSSE] = 4;
      VLEN[VTGV] = 4;
      TSIZE = 4;
   }
   #ifdef ATL_AVXZ
      VECi = VTAVXZ;
   #elif defined(ATL_AVX)
      VECi = VTAVX;
   #elif defined(ATL_SSE1)
      if (*PRE == 's')
         VECi = VTSSE;
      #ifdef ATL_SSE2
      else
         VECi = VTSSE;
      #endif
   #elif (defined(ATL_AltiVec) && !defined(ATL_VSX)) || \
         (defined(ATL_NEON) && defined(ATL_NONIEEE) && ATL_NONIEEE != 0) || \
         (defined(ATL_3DNow) && defined(ATL_NONIEEE) && ATL_NONIEEE != 0)
      if (pre == 's')
         VECi = VTGV;
   #elif defined(ATL_VSX)
      VECi = VTGV;
   #endif
   return(N);
}

int main(int nargs, char **args)
{
   int *nbs, *mbs, *kbs, verb, N, C=0;
   char pre;
   ATL_mmnode_t *mmb, *mp, *mmB;
   double mfB;

   N = GetFlags(nargs, args, &pre, &verb, &C, &mbs, &nbs, &kbs);
/*
 * Get all working kernels
 */
   mmb = GetWorkingUserCases(verb, pre);
   mmb = ApplyConstraints(mmb, C);
   mmb = FindBestKerns(pre, verb, mmb, N, mbs, nbs, kbs, C);
   ComputeKClean(verb, pre, mmb);
   mmb = ATL_SortMMNodesByMflop(0, mmb);
   mmB = ReadMMFileWithPath(pre, "res", "eAMMRES.sum");
   mmB = ATL_SortMMNodesByMflop(0, mmB);
   printf("\n");
   if (mmb)
      printf("YOUR BEST CASE: %d-%s, BLK=%d,%d,%d  %.2f\n", 
             mmb->ID, mmb->rout, mmb->mbB, mmb->nbB, mmb->kbB, mmb->mflop[0]);
   if (mmB)
      printf("ATLAS BEST CASE: %d-%s, BLK=%d,%d,%d  %.2f\n", 
             mmB->ID, mmB->rout, mmB->mbB, mmB->nbB, mmB->kbB, mmB->mflop[0]);

   KillAllMMNodes(mmb);
   KillAllMMNodes(mmB);
   free(mbs);
   free(nbs);
   free(kbs);
   return(0);
}
@ROUT ATL_ammmABC
#include "atlas_misc.h"
/*
 * This routine loops over calls to the access-major matmul kernel given
 * in the arguments, using the NMK loop pattern, using the given blocking
 * parameters.  
 * alpha & beta are both applied by ablk2cmat.
 * It allocates an K*NB workspace for B, and an Mc*K workspace for A,
 * and a NB*NB workspace for C.
 */

typedef void (*mat2am_t)
   (ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT, TYPE*);
typedef void (*ablk2cmat_t)
   (ATL_CINT M, ATL_CINT N, const SCALAR al, const TYPE*A, 
    const SCALAR beta, TYPE*C, ATL_CINT ldc);
typedef void (*ammm_t)
   (ATL_CINT M, ATL_CINT N, ATL_CINT K, TYPE *A, TYPE *B, TYPE *C);
int Mjoin(PATL,ammmABC)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CINT M,
   ATL_CINT N,
   ATL_CINT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *B,
   ATL_CINT ldb,
   const SCALAR beta,
   const TYPE *C,
   ATL_CINT ldc,
   ATL_CINT MB,                 /* chosen M blocking for this problem */
   ATL_CINT NB,                 /* chosen N blocking for this problem */
   ATL_CINT KB,                 /* chosen K blocking for this problem */
   ATL_CINT mu,                 /* M unrolling used by kernels */
   ATL_CINT nu,                 /* N unrolling used by kernels */
   ATL_CINT ku,                 /* K unrolling used by non-cleanup kernels */
   ammm_t ammmk_b0,             /* amm beta=0 kernel to use */
   ammm_t ammmk_b1,             /* amm beta=1 kernel to use */
   ammm_t ammmk_ku1,            /* amm beta=1 for K-cleanup */
   mat2am_t A2am,               /* routine to translate A into access-major */
   mat2am_t B2am,               /* routine to translate B into access-major */
   ablk2cmat_t ablk2cmat,       /* put ammmk's C back to user's C */
)
{
   ATL_CINT Mf = (M/mu)*mu, mr = M-Mf, Nf = (N/nu)*nu, nr = N-Nf;
   ATL_CINT Kf = (K/ku)*ku, kr = K-Kf;
   ATL_CINT Mc = (mr) ? Mf + mr : Mf;  /* compute CEIL from FLOOR */
   ATL_CINT Nc = (nr) ? Nf + nr : Nf;
   ATL_CINT Kc = (kr) ? Kf + kr : Kf;
   ATL_CINT incBn = (TB == AtlasNoTrans) ldb*NB-Kf : NB-Kf*ldb;
   ATL_CINT incAm = (TA == AtlasNoTrans) ? MB - Kf*ldb : MB*ldb - Kf;
   ATL_INT i, j, k;
   void *vp;
   TYPE *pA, *pB, *c;
   int COPYA=1;

   if (K <= KB) 
      return(1);   /* don't handle rank-K update with this routine */
   vp = malloc(3*ATL_Cacchelen + sizeof(TYPE)*(Mc*K+K*NB+NB*NB));
   if (!vp)
      return(2);
   pB = ATL_AlignPtr(vp);
   pA = pB + K*NB;
   pA = ATL_AlignPtr(pA);
   c = pA + Mc*K;
   c = ATL_AlignPtr(c);

   for (j=0; j != Nc; j += NB)
   {
      ATL_CINT n = Mmin(NB, Nc-j), incb = n*nu*KB, n0 = Mmin(NB, N-j);
      int COPYB=1;
      TYPE *b = pB, *a = pA;

      for (i=0; i != Mc; i += MB)
      {
         ATL_CINT m = Mmin(MB, Mc-i), inca = m*mu*KB, m0 = Mmin(NB,M-j);

/* 
 *       Handle first block, known to always have a full KB, using _b0
 *       case to initialize workspace c
 */
         if (COPYA)
            A2am(m, KB, ATL_rone, A, lda, a);
         if (COPYB)
            B2am(KB, n, ATL_rone, B, ldb, b);
         ammmk_b0(m, n, KB, a, b, c);
         a += inca; b += incb;
/*
 *       Loop over all remaining blocks that can use ammmk_b1
 */
         for (k=KB; k < Kf; k += KB, a += inca, b += incb)
         {
            ATL_CINT kk = Mmin(KB, Kf-i);
/*
 *          If necessary, copy both A & B blocks to access-major format
 */
            if (COPYA)
            {
               A2am(m, kk, ATL_rone, A, lda, a);
               A += (TA == AtlasNoTrans) ? kk*lda : kk;
            }
            if (COPYB)
            {
               B2am(kk, n, ATL_rone, B, ldb, b);
               B += (TB == AtlasNoTrans) ? kk : kk*ldb;
            }
            ammmk_b1(m, n, kk, a, b, c);
         }
/*
 *       Handle K cleanup using the provided kernel
 */
         if (kr)
         {
            if (COPYA)
               A2am(m, kr, ATL_rone, A, lda, a);
            if (COPYB)
               B2am(kr, n, ATL_rone, B, ldb, b);
            ammmk_ku1(m, n, kr, a, b, c);
            a += kr*m;
         }
         A += incAm;
/*
 *       Write answer back out to user's C 
 */
         ablk2cmat(m0, n0, alpha, c, beta, C, ldc);
         C += m0;
         COPYB = 0;
         b = pB;
      }
      B += incBn;
      COPYA = 0;
   }
   free(vp);
   return(0);
}
@ROUT ATL_ammm_IP ATL_cammm_IP ATL_ammm_tN ATL_cammm_tN ATL_ammmMNK ATL_cammmMNK
   @define rt @Mjoin(PATL,ammm_IP)@
#include "atlas_misc.h"
#include "atlas_amm.h"
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_sum.h))
@ROUT ATL_ammm_IP ATL_cammm_IP
/*
 * This routine handles M <= MAXM && N <= MAXN && very long K, or
 * the inner-product GEMM form.  It appears in the GEMM-based SYRK, which
 * is important for Cholesky.  It is typically the worst-case for ATLAS,
 * since the copy of A and B are of the same order as the computation.
 * It is a minimal workspace routine.
 */
@ROUT ATL_ammm_rkK0
#include "atlas_misc.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_rankK.h))
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_rkkblk.h))
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_rkkflag.h))
@ROUT ATL_cammm_1b ATL_ammm_rkK ATL_cammm_rkK
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_lvl2.h"
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_sum.h))
@ROUT ATL_ammm_1b ATL_ammmKNM
#include "atlas_misc.h"
#include "atlas_amm.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_sum.h))
@ROUT ATL_ammm ATL_cammm
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_level1.h"
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_sum.h))
   @define rt @Mjoin(PATL,ammm)@
@ROUT ATL_cammm_rkK ATL_cammm_tN ATL_cammmMNK
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_sum.h))
#ifdef ATL_CAMM_MAXMB
   #define MY_MAXMB ATL_CAMM_MAXMB
   #define MY_MAXNB ATL_CAMM_MAXNB
#else
   #define MY_MAXMB ATL_MAXM_RKK
   #define MY_MAXNB ATL_MAXM_RKK
#endif
@ROUT ATL_ammm_rkK ATL_cammm_rkK ATL_ammm_tN ATL_cammm_tN ATL_ammmMNK @\
      ATL_ammmKNM ATL_cammmMNK

#ifdef __GNUC__
static inline int ATL_ComputeB   /* RETURNS: selected blocking */
#else
static int ATL_ComputeB           /* RETURNS: selected blocking */
#endif
(
   size_t N,   /* problem dimension */
   int nu,     /* unrolling by kernel on this dim */
   int nb,     /* IN: large-case blocking */
   size_t *NS, /* OUT: # of blks of size NB-nu to perform */
   size_t *NT  /* OUT: # of blks to perform */
)
{
   size_t ns, nt, nblks, NN;
/*
 * If the entire problem is less than or equal to the unrolling, choose a block
 * of the ceiling of the unrolling and only do one
 */
   NN=((N+nu-1)/nu)*nu;  /* ceiling of number of unrollings in N */
   if (NN <= nu)
   {
      *NS = 0;
      *NT = 1;
      return(NN);
   }
/*
 * If suggested block size is smaller or same as unrolling, then the blocking
 * size is the unrolling, and we don't have an NB-nu sized-blocks, since that
 * would be zero sized
 */
   if (nb <= nu)
   {
      *NS = 0;
      *NT = NN/nu;
      return(nu);
   }

   nb = (nb/nu)*nu;      /* floor of number of unrollings in a block*/
/*
 * If 1 block is within NU of covering the entire dim, just make the
 * block size the entire dim
 */
   if (nb+nu >= NN)
   {
      *NS = 0;
      *NT = 1;
      return(NN);
   }
/*
 * Otherwise, compute how many blocks we need  of each type
 */
   while(1)
   {
      nblks = (N+nb-1)/nb;
      ns = (nblks*nb - NN)/nu;
      if (ns < nblks)
         break;
      nb -= nu;
   }

   *NS = ns;
   *NT = nblks;
   return(nb);
}
@ROUT ATL_ammmKNM

static int ATL_ammm_rkK
(
   const size_t M,
   const size_t nmblks,
   const size_t nsmblks,
   const int MB,
   const int NMU,
   const int mu,
   const size_t N,
   const size_t nnblks,
   const size_t nsnblks,
   const int NB,
   const int NNU,
   const int nu,
   const int K,
   const int KK,
   const int ku,
   const TYPE *A,      /* pts to beginning of matrix */
   const size_t lda,
   const size_t incAm0,
   const size_t incAm,
   const TYPE *B,      /* pts to 1 past END of matrix */
   const size_t ldb,
   const size_t incBn0,
   const size_t incBn,
   TYPE *C,            /* pts to 1 past END of matrix */
   const size_t ldc,
   const SCALAR alpA, 
   const SCALAR alpB,
   const SCALAR beta,
   TYPE *pA,
   const size_t incAw0,
   const size_t incAw,
   TYPE *pB,
   TYPE *pC,
   const ammkern_t amm,
   const cm2am_t a2blk,
   const cm2am_t b2blk,
   const ablk2cmat_t blk2c
)
{
   size_t n, j;
   int mb, nb;
   TYPE *pA0=pA;

   n = N;
   for (n=N, j=0; j < nnblks; j++)
   {
      int nmu, mb, nnu, nb, nn;
      size_t i, m;
      TYPE *c;
      if (j < nsnblks)
      {
         nb = NB-nu;
         nnu = NNU-1;
         B -= incBn0;
      }
      else
      {
         nb = NB;
         nnu = NNU;
         B -= incBn;
      }
      nn = Mmin(n, nb);
      C -= nn*ldc;
      c=C;

      b2blk(K, nn, alpB, B, ldb, pB);

      mb = MB-mu;
      nmu = NMU-1;
      pA = pA0;
      for (m=M,i=0; i < nsmblks; i++, m -= mb, c += mb)
      {
         const int mm = Mmin(m, mb);
         TYPE *pAn = pA + incAw0;
         if (!j)
         {
            a2blk(K, mm, alpA, A, lda, pA);
            A += incAm0;
         }
         amm(nmu, nnu, KK, pA, pB, pC, pAn, pB, pC);
         blk2c(mm, nn, ATL_rone, pC, beta, c, ldc);
         pA = pAn;
      }

      for (mb=MB, nmu=NMU; i < nmblks; i++, m -= mb, c += mb)
      {
         const int mm = Mmin(m, mb);
         TYPE *pAn = pA + incAw;
         if (!j)
         {
            a2blk(K, mm, alpA, A, lda, pA);
            A += incAm;
         }
         amm(nmu, nnu, KK, pA, pB, pC, pAn, pB, pC);
         blk2c(mm, nn, ATL_rone, pC, beta, c, ldc);
         pA = pAn;
      }
      n -= nb;
   }
   return(0);
}

@ROUT ATL_ammmKNM
   @define rt @Mjoin(PATL,ammmKNM)@
/*
 * This routine called for very large matrices; requires workspace of
 * one panel and 2 blocks at most
 */
@ROUT ATL_ammmMNK ATL_cammmMNK
   @define rt @Mjoin(PATL,ammmMNK)@
/*
 * This routine called when N < M and K is large
 */
@ROUT ATL_ammm_rkK ATL_cammm_rkK
   @define rt @Mjoin(PATL,ammm_rkK)@
/*
 * This routine called when 2 < K <= MAXK
 */
@ROUT ATL_ammm_1b ATL_cammm_1b
   @define rt @Mjoin(PATL,ammm_1b)@
/* 
 * This routine called in degenerate case where all dims less than max block,
 * so we can do entire operation with one kernel call
 */
@ROUT ATL_ammm ATL_cammm
static int ATL_ammm
@ROUT ATL_ammm_tN ATL_cammm_tN
/* 
 * This routine handles N <= MAXN, K & M large (left-looking shape)
 */
int Mjoin(PATL,ammm_tN)
@ROUT ATL_ammm_1b  ATL_ammm_rkK ATL_cammm_1b ATL_ammmMNK ATL_cammmMNK @\
      ATL_cammm_rkK  ATL_ammm_IP ATL_cammm_IP ATL_ammmKNM
int @(rt)
@ROUT ATL_ammm ATL_ammm_1b  ATL_ammm_rkK ATL_cammm ATL_cammm_1b ATL_ammmMNK @\
      ATL_cammm_rkK  ATL_ammm_IP ATL_cammm_IP ATL_ammm_tN ATL_cammm_tN @\
      ATL_ammmKNM ATL_cammmMNK
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
@ROUT ATL_ammmMNK ATL_cammmMNK
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   size_t m, nsmblks, nmblks, nsnblks, nnblks, i, incAm0, incAm, incAw0;
   size_t nkb, incAk, incAk0, mulAm, incBk, incBk0, mulBn;
   int mu, nu, ku, MB, NB, KB, KB0, kb0, NMU, NNU, A_1TRIP;
   void *vp;
@ROUT ATL_ammmMNK
   TYPE *pC, *pB, *pB0, *pA, *pA0;
   ammkern_t ammK0, amm;
   const int B_BYCOLS = (TB == AtlasNoTrans);
   const int A_BYROWS = (TA == AtlasNoTrans);
   TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
@ROUT ATL_cammmMNK
   TYPE *rC, *iC, *iB, *pB0, *iA, *pA0;
   ammkern_t ammK0, ammK0_bn, ammK0_b1, amm_b1, amm_bn;
   const int B_BYCOLS = (TB == AtlasNoTrans || TB == AtlasConj);
   const int A_BYROWS = (TA == AtlasNoTrans || TA == AtlasConj);
   const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   const TYPE *alpA=ONE, *alpB=ONE, *alpC=ONE;
@ROUT ATL_ammmMNK ATL_cammmMNK
   amminfo_t mminfo;

   mu = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else 
      alpC = alpha;
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
@ROUT ATL_cammmMNK
   MB = ATL_ComputeB(M, mu, MY_MAXMB, &nsmblks, &nmblks);
   NMU = MB / mu;
   NB = ATL_ComputeB(N, nu, MY_MAXNB, &nsnblks, &nnblks);
@ROUT ATL_ammmMNK
   MB = ATL_ComputeB(M, mu, ATL_AMM_MAXMB, &nsmblks, &nmblks);
   NMU = MB / mu;
   NB = ATL_ComputeB(N, nu, ATL_AMM_MAXNB, &nsnblks, &nnblks);
@ROUT ATL_ammmMNK ATL_cammmMNK
   NNU = NB / nu;
   KB = mminfo.kb;
   nkb = K/KB;
/*
 * kb0: K remainder, KB0 is CEIL(kb0/ku)*ku for k-vector kerns, and
 * same as kb0 for M-vector kerns
 */
   KB0 = kb0 = K - nkb*KB;
   if (!kb0)
   {
      KB0 = kb0 = KB;
      nkb--;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            ammK0 = mminfo.amm_b0;
         else
            ammK0 = (mminfo.kb==KB0) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
   {
      ammK0 = (kb0 == KB) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && kb0 == (kb0/ku)*ku &&
          kb0 > mminfo.kbmin)
         ammK0 = mminfo.amm_b0;
   }
@ROUT ATL_ammmMNK
   amm = mminfo.amm_b1;
@ROUT ATL_cammmMNK
   if (ammK0 == mminfo.amm_b0)
   {
      amm_b1 = ammK0_b1 = mminfo.amm_b1;
      amm_bn = ammK0_bn = mminfo.amm_bn;
   }
   else
   {
      ammK0_b1 = mminfo.amm_k1_b1;
      ammK0_bn = mminfo.amm_k1_bn;
      amm_b1 = mminfo.amm_b1;
      amm_bn = mminfo.amm_bn;
   }
@ROUT ATL_ammmMNK ATL_cammmMNK
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;
   i = nkb*KB+KB0;
/*
 * Determine worspace requirements and allocate
 */
   {
      size_t tsz;
      const size_t szA=MB*i;
      const size_t szB=i*(nsnblks*(NB-nu)+(nnblks-nsnblks)*NB);
      const int szC = MB*NB;

      tsz = ATL_MulBySize(szA + szB + szC + mu*nu*ku) + 3*ATL_Cachelen;
      if (tsz > ATL_MaxMalloc)
         return(2);
      vp = malloc(tsz);
      if (!vp)
         return(1);
@ROUT ATL_ammmMNK
      pC = ATL_AlignPtr(vp);
      pA = pC + szC;
      pA0 = pA = ATL_AlignPtr(pA);
      pB = pA + szA;
      pB0 = pB = ATL_AlignPtr(pB);
@ROUT ATL_cammmMNK
      iC = ATL_AlignPtr(vp);
      rC = iC + szC;
      iA = rC + szC;
      pA0 = iA = ATL_AlignPtr(iA);
      iB = iA + szA + szA;
      pB0 = iB = ATL_AlignPtr(iB);
@ROUT ATL_ammmMNK ATL_cammmMNK
   }
   if (A_BYROWS)
   {
      incAk = KB*(lda SHIFT);
      incAk0 = kb0*(lda SHIFT);
      mulAm = 1 SHIFT;
   }
   else
   {
      incAk = KB SHIFT;
      incAk0 = kb0 SHIFT;
      mulAm = lda SHIFT;
   }
   if (B_BYCOLS)
   {
      incBk = KB SHIFT;
      incBk0 = kb0 SHIFT;
      mulBn = ldb SHIFT;
   }
   else
   {
      incBk = (KB SHIFT)*ldb;
      incBk0 = kb0*(ldb SHIFT);
      mulBn = 1 SHIFT;
   }

   for (m=M, i=0; i < nmblks; i++)
   {
      size_t j, n;
      int mb, mm, nmu, incAw, incAw0;
      TYPE *c=C;
      if (i < nsmblks)
      {
         mb = MB-mu;
         nmu = NMU-1;
      }
      else
      {
         mb = MB;
         nmu = NMU;
      }
      mm = Mmin(m, mb);  /* number of A/C rows left */
      m -= mm;
      incAw = mb*KB;
      incAw0 = mb*KB0;
      for (n=N, j=0; j < nnblks; j++)
      {
         size_t k;
@ROUT ATL_ammmMNK
         int nb, nn, nnu, incBw;
         const TYPE *b=B, *a=A; 
         TYPE *pAn, *pBn;
@ROUT ATL_cammmMNK
         int nb, nn, nnu, incBw, incBw0;
         const TYPE *b=B, *a=A; 
         TYPE *pAn, *pBn, *rA, *rB;
@ROUT ATL_ammmMNK ATL_cammmMNK

         if (j < nsnblks)
         {
            nb = NB-nu;
            nnu = NNU-1;
         }
         else
         {
            nb = NB;
            nnu = NNU;
         }
         incBw = KB*nb;
         nn = Mmin(n, nb);  /* number of B/C cols left */
         n -= nn;
@ROUT ATL_ammmMNK
         if (!j)
         {
            a2blk(kb0, mm, alpA, a, lda, pA);
            a += incAk0;
         }
         if (!i)
         {
             b2blk(kb0, nn, alpB, b, ldb, pB);
             b += incBk0;
         }
         pAn = pA + incAw0;
         pAn = (nkb) ? pAn : pA0;
         pBn = pB + KB0*nb;
         ammK0(nmu, nnu, KB0, pA, pB, pC, pAn, pBn, pC);
         pA = pAn;
         pB = pBn;
         for (k=0; k < nkb; k++)
         {
            if (!j)
            {
               a2blk(KB, mm, alpA, a, lda, pA);
               a += incAk;
            }
            if (!i)
            {
                b2blk(KB, nn, alpB, b, ldb, pB);
                b += incBk;
            }
            pAn = pA + incAw;
            pAn = (k != nkb-1) ? pAn : pA0;
            pBn = pB + incBw;
            pBn = (k != nkb-1 || j != nnblks-1) ? pBn : pB0;
            amm(nmu, nnu, KB, pA, pB, pC, pAn, pBn, pC);
            pA = pAn;
            pB = pBn;
         }
         blk2c(mm, nn, alpC, pC, beta, c, ldc);
         c += nn*(ldc SHIFT);
         B += nn*mulBn;
      }
      pB = pB0;
      A += mm*mulAm;
      C += mm;
   }
@ROUT ATL_cammmMNK
         incBw0 = KB0*nb;

         rA = iA + incAw0;
         pAn = rA + incAw0;
         pAn = (nkb) ? pAn : pA0;
         rB = iB + incBw0;
         pBn = rB + incBw0;
         if (!j)
         {
            a2blk(kb0, mm, alpA, a, lda, rA, iA);
            a += incAk0;
         }
         if (!i)
         {
             b2blk(kb0, nn, alpB, b, ldb, rB, iB);
             b += incBk0;
         }
         ammK0(nmu, nnu, KB0, iA, iB, rC, rA, iB, iC);
         ammK0(nmu, nnu, KB0, rA, iB, iC, rA, rB, rC);
         ammK0_bn(nmu, nnu, KB0, rA, rB, rC, iA, rB, iC);
         ammK0_b1(nmu, nnu, KB0, iA, rB, iC, pAn, pBn, rC);
         iA = pAn;
         iB = pBn;
         for (k=0; k < nkb; k++)
         {
            rA = iA + incAw;
            rB = iB + incBw;
            if (!j)
            {
               a2blk(KB, mm, alpA, a, lda, rA, iA);
               a += incAk;
            }
            if (!i)
            {
                b2blk(KB, nn, alpB, b, ldb, rB, iB);
                b += incBk;
            }
            pAn = rA + incAw;
            pAn = (k != nkb-1) ? pAn : pA0;
            pBn = rB + incBw;
            pBn = (k != nkb-1 || j != nnblks-1) ? pBn : pB0;
            amm_bn(nmu, nnu, KB, iA, iB, rC, rA, iB, iC);
            amm_b1(nmu, nnu, KB, rA, iB, iC, rA, rB, rC);
            amm_bn(nmu, nnu, KB, rA, rB, rC, iA, rB, iC);
            amm_b1(nmu, nnu, KB, iA, rB, iC, pAn, pBn, rC);
            iA = pAn;
            iB = pBn;
         }
         blk2c(mm, nn, alpC, rC, iC, beta, c, ldc);
         c += nn*(ldc SHIFT);
         B += nn*mulBn;
      }
      iB = pB0;
      A += mm*mulAm;
      C += mm SHIFT;
   }
@ROUT ATL_ammmMNK ATL_cammmMNK

   free(vp);
   return(0);
}
@ROUT ATL_ammmKNM
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   size_t n, nsmblks, nmblks, nsnblks, nnblks, j, incAm0, incAm, incAw0, incAw;
   size_t KK, incAk, incBk, incBn0, incBn, k;
   int mu, nu, ku, MB, NB, KB, mb, nb, NMU, NNU, A_1TRIP, nkb, kb0, KB0;
   void *vp;
   TYPE *pC, *pB, *pA, *pA0;
   ammkern_t ammK0, amm;
   const int B_BYCOLS = (TB == AtlasNoTrans);
   const int A_BYROWS = (TA == AtlasNoTrans);
   TYPE alpA=ATL_rone, alpB=ATL_rone;
   amminfo_t mminfo;

@skip   ATL_assert(N > ATL_AMM_MAXNB & M > ATL_AMM_MAXMB & K > ATL_AMM_MAXKB);
   mu = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else
      alpB = alpha;
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   MB = ATL_ComputeB(M, mu, ATL_AMM_MAXMB, &nsmblks, &nmblks);
   NMU = MB / mu;
   NB = ATL_ComputeB(N, nu, ATL_AMM_MAXMB, &nsnblks, &nnblks);
   NNU = NB / nu;
   A_1TRIP = (nnblks < 2);
   KB = mminfo.kb;
   nkb = K/KB;
/*
 * kb0: K remainder, KB0 is CEIL(kb0/ku)*ku for k-vector kerns, and
 * same as kb0 for M-vector kerns
 */
   KB0 = kb0 = K - nkb*KB;
   if (!kb0)
   {
      KB0 = kb0 = KB;
      nkb--;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            ammK0 = mminfo.amm_b0;
         else
            ammK0 = (mminfo.kb==KB0) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
   {
      ammK0 = (kb0 == KB) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && kb0 == (kb0/ku)*ku &&
          kb0 > mminfo.kbmin)
         ammK0 = mminfo.amm_b0;
   }
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;
   KK = nkb*KB + KB0;
/*
 * Do memory allocation, setup pointers
 */
   {
      size_t tsz, szA;
      const int szB = NB*KB, szC = MB*NB;

      if (A_1TRIP)
         szA = KB*MB;
      else
         szA = (nsmblks*(MB-mu)+(nmblks-nsmblks)*MB)*KB;
      tsz = ATL_MulBySize(szA + szB + szC + mu*nu*ku) + 3*ATL_Cachelen;
      if (tsz > ATL_MaxMalloc)
         return(2);
      vp = malloc(tsz);
      if (!vp)
         return(1);
      pC = ATL_AlignPtr(vp);
      pB = pC + szC;
      pB = ATL_AlignPtr(pB);
      pA = pB + szB;
      pA = ATL_AlignPtr(pA);
   }

   if (A_BYROWS)
   {
      incAm0 = (MB-mu);
      incAm = MB;
      incAk = KB*lda;
   }
   else
   {
      incAm0 = (MB-mu)*lda;
      incAm = MB*lda;
      incAk = KB;
   }
   if (B_BYCOLS)
   {
      incBn0 = (NB-nu)*ldb;
      incBn = NB*ldb;
   }
   else
   {
      incBn0 = (NB-nu);
      incBn = NB;
   }
   if (A_1TRIP)
      incAw0 = incAw = 0;
   else
   {
      incAw0 = (MB-mu)*KB0;
      incAw = MB*KB0;
   }

   C += N*ldc;
   j = (nnblks-nsnblks)*NB + nsnblks*(NB-nu);
   if (B_BYCOLS)
   {
      B += j*ldb;
      incBk = KB;
   }
   else
   {
      B += j;
      incBk = KB*ldb;
   }
/*
 * Handle remainder/full block using the actual beta; all remaining K blks
 * will be of size KB after this
 */
   ATL_ammm_rkK(M, nmblks, nsmblks, MB, NMU, mu, N, nnblks, nsnblks, NB,
                NNU, nu, kb0, KB0, ku, A, lda, incAm0, incAm, B, ldb, 
                incBn0, incBn, C, ldc, alpA, alpB, beta, pA, incAw0, incAw, 
                pB, pC, ammK0, a2blk, b2blk, blk2c);
   B += (B_BYCOLS) ? kb0 : kb0*ldb;
   A += (A_BYROWS) ? kb0*lda : kb0;
/* 
 * If A workspace is entire panel, must now base increment on full KB
 */
   if (!A_1TRIP && KB0 != KB)
   {
      incAw0 = (MB-mu)*KB;
      incAw = MB*KB;
   }
/*
 * Loop over all remaining blocks using beta=1 and full KB
 * ALSO: need to change blk2c if it is bn!
 */
   amm = mminfo.amm_b0;
   for (k=0; k < nkb; k++, B += incBk, A += incAk)
      ATL_ammm_rkK(M, nmblks, nsmblks, MB, NMU, mu, N, nnblks, nsnblks, NB,
                   NNU, nu, KB, KB, ku, A, lda, incAm0, incAm, B, ldb, 
                   incBn0, incBn, C, ldc, alpA, alpB, ATL_rone, 
                   pA, incAw0, incAw, pB, pC, amm, a2blk, b2blk, blk2c);
   free(vp);
   return(0);
}
@ROUT ATL_ammm_rkK
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   size_t n, nsmblks, nmblks, nsnblks, nnblks, j, incAm0, incAm, incAw0, incAw;
   int mu, nu, ku, MB, NB, mb, nb, NMU, NNU, A_1TRIP;
   void *vp;
   TYPE *pC, *pB, *pA, *pA0;
   ammkern_t amm;
   const int B_BYCOLS = (TB == AtlasNoTrans);
   const int A_BYROWS = (TA == AtlasNoTrans);
   TYPE alpA=ATL_rone, alpB=ATL_rone;
   #if ATL_MAXKMAJ_RKK > 1
      int KK=K;
   #else
      #define KK K
   #endif
   amminfo_t mminfo;

   mu = Mjoin(PATL,GetRankKInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else
      alpB = alpha;
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   MB = ATL_ComputeB(M, mu, ATL_MAXM_RKK, &nsmblks, &nmblks);
   NMU = MB / mu;
   NB = ATL_ComputeB(N, nu, ATL_MAXN_RKK, &nsnblks, &nnblks);
   NNU = NB / nu;
   A_1TRIP = (nnblks < 2);
   #if ATL_MAXKMAJ_RKK > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
         KK = ((K+ku-1)/ku)*ku;
   #endif

   {
      size_t tsz, szA;
      int szB = KK*NB, szC = MB*NB;

      if (A_1TRIP)
         szA = MB*KK;
      else
         szA = (nsmblks*(MB-mu)+(nmblks-nsmblks)*MB)*KK;
      tsz = ATL_MulBySize(szA + szB + szC + mu*nu*ku) + 3*ATL_Cachelen;
      if (tsz > ATL_MaxMalloc)
         return(2);
      vp = malloc(tsz);
      if (!vp)
         return(1);
      pC = ATL_AlignPtr(vp);
      pB = pC + szC;
      pB = ATL_AlignPtr(pB);
      pA = pB + szB;
      pA0 = pA = ATL_AlignPtr(pA);
   }
   amm = mminfo.amm_b0;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;

   if (A_BYROWS)
   {
      incAm0 = (MB-mu);
      incAm = MB;
   }
   else
   {
      incAm0 = (MB-mu)*lda;
      incAm = MB*lda;
   }
   if (A_1TRIP)
      incAw0 = incAw = 0;
   else
   {
      incAw0 = (MB-mu)*KK;
      incAw = MB*KK;
   }

   C += N*ldc;
   B += (B_BYCOLS) ? N*ldb : N;
   n = N;
   for (n=N, j=0; j < nnblks; j++)
   {
      int nmu, mb, nnu, nb, nn;
      size_t incBn, i, m;
      TYPE *c;
      if (j < nsnblks)
      {
         nb = NB-nu;
         nnu = NNU-1;
      }
      else
      {
         nb = NB;
         nnu = NNU;
      }
      nn = Mmin(n, nb);
      B -= (B_BYCOLS) ? nn*ldb : nn;
      C -= nn*ldc;
      c=C;

      b2blk(K, nn, alpB, B, ldb, pB);

      mb = MB-mu;
      nmu = NMU-1;
      pA = pA0;
      for (m=M,i=0; i < nsmblks; i++, m -= mb, c += mb)
      {
         const int mm = Mmin(m, mb);
         TYPE *pAn = pA + incAw0;
         if (!j)
         {
            a2blk(K, mm, alpA, A, lda, pA);
            A += incAm0;
         }
         amm(nmu, nnu, KK, pA, pB, pC, pAn, pB, pC);
         blk2c(mm, nn, ATL_rone, pC, beta, c, ldc);
         pA = pAn;
      }

      for (mb=MB, nmu=NMU; i < nmblks; i++, m -= mb, c += mb)
      {
         const int mm = Mmin(m, mb);
         TYPE *pAn = pA + incAw;
         if (!j)
         {
            a2blk(K, mm, alpA, A, lda, pA);
            A += incAm;
         }
         amm(nmu, nnu, KK, pA, pB, pC, pAn, pB, pC);
         blk2c(mm, nn, ATL_rone, pC, beta, c, ldc);
         pA = pAn;
      }

      n -= nb;
   }
   free(vp);
   return(0);
}
@ROUT ATL_cammm_rkK
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   size_t n, nsmblks, nmblks, nsnblks, nnblks, j, incAm0, incAm, incAw0, incAw;
   int mu, nu, ku, MB, NB, mb, nb, NMU, NNU, A_1TRIP;
   void *vp;
   TYPE *rC, *iC, *rB, *iB, *pA0;
   ammkern_t amm_b0, amm_b1, amm_bn;
   const size_t lda2=lda+lda, ldb2=ldb+ldb, ldc2=ldc+ldc;
   const int B_BYCOLS = (TB == AtlasNoTrans || TB == AtlasConj);
   const int A_BYROWS = (TA == AtlasNoTrans || TA == AtlasConj);
   const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   const TYPE *alpA=ONE, *alpB=ONE;
   #if ATL_MAXKMAJ_RKK > 1
      int KK=K;
   #else
      #define KK K
   #endif
   amminfo_t mminfo;

   mu = Mjoin(PATL,GetRankKInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else
      alpB = alpha;
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   MB = ATL_ComputeB(M, mu, MY_MAXMB, &nsmblks, &nmblks);
   NMU = MB / mu;
   NB = ATL_ComputeB(N, nu, MY_MAXNB, &nsnblks, &nnblks);
   NNU = NB / nu;
   A_1TRIP = (nnblks < 2);
   #if ATL_MAXKMAJ_RKK > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
         KK = ((K+ku-1)/ku)*ku;
   #endif

   {
      size_t szA, tsz;
      int szB = KK*NB, szC = MB*NB;
      if (A_1TRIP)
         szA = MB*KK;
      else
         szA = ((nmblks-nsmblks)*MB+nsmblks*(MB-mu))*KK;
      tsz = ATL_MulBySize(szA + szB + szC + mu*nu*ku) + 3*ATL_Cachelen;
      if (tsz > ATL_MaxMalloc)
         return(2);
      vp = malloc(tsz);
      if (!vp)
         return(1);
      iC = ATL_AlignPtr(vp);
      rC = iC + szC;
      iB = rC + szC;
      iB = ATL_AlignPtr(iB);
      rB = iB + szB;
      pA0 = rB + szB;
      pA0 = ATL_AlignPtr(pA0);
   }
   amm_b0 = mminfo.amm_b0;
   amm_b1 = mminfo.amm_b1;
   amm_bn = mminfo.amm_bn;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;

   if (A_BYROWS)
   {
      incAm0 = (MB-mu)SHIFT;
      incAm = MB SHIFT;
   }
   else
   {
      incAm0 = (MB-mu)*lda2;
      incAm = MB*lda2;
   }
   incAw0 = (MB-mu)*KK;
   incAw = MB*KK;

   C += N*ldc2;
   B += (B_BYCOLS) ? N*ldb2 : N+N;
   n = N;
   for (n=N, j=0; j < nnblks; j++)
   {
      int nmu, mb, nnu, nb, nn;
      size_t incBn, i, m;
      TYPE *iA=pA0;
      TYPE *c;
      if (j < nsnblks)
      {
         nb = NB-nu;
         nnu = NNU-1;
      }
      else
      {
         nb = NB;
         nnu = NNU;
      }
      nn = Mmin(n, nb);
      B -= (B_BYCOLS) ? nn*ldb2 : nn+nn;
      C -= nn*ldc2;
      c=C;

      b2blk(K, nn, alpB, B, ldb, rB, iB);

      mb = MB-mu;
      nmu = NMU-1;
      for (m=M,i=0; i < nsmblks; i++, m -= mb, c += mb+mb)
      {
         const int mm = Mmin(m, mb);
         TYPE *rA = iA + incAw0, *pAn = (A_1TRIP) ? iA : rA + incAw0;

         if (!j)
         {
            a2blk(K, mm, alpA, A, lda, rA, iA);
            A += incAm0;
         }
         amm_b0(nmu, nnu, KK, iA, iB, rC, iA, rB, iC);
         amm_b0(nmu, nnu, KK, iA, rB, iC, rA, rB, rC);
         amm_bn(nmu, nnu, KK, rA, rB, rC, rA, iB, iC);
         amm_b1(nmu, nnu, KK, rA, iB, iC, pAn, rB, rC);
         blk2c(mm, nn, ONE, rC, iC, beta, c, ldc);
         iA = pAn;
      }

      for (mb=MB, nmu=NMU; i < nmblks; i++, m -= mb, c += mb+mb)
      {
         const int mm = Mmin(m, mb);
         TYPE *rA = iA + incAw, *pAn = (A_1TRIP) ? iA : rA + incAw;
         if (!j)
         {
            a2blk(K, mm, alpA, A, lda, rA, iA);
            A += incAm;
         }
         amm_b0(nmu, nnu, KK, iA, iB, rC, iA, rB, iC);
         amm_b0(nmu, nnu, KK, iA, rB, iC, rA, rB, rC);
         amm_bn(nmu, nnu, KK, rA, rB, rC, rA, iB, iC);
         amm_b1(nmu, nnu, KK, rA, iB, iC, pAn, rB, rC);
         blk2c(mm, nn, ONE, rC, iC, beta, c, ldc);
         iA = pAn;
      }

      n -= nb;
   }
   free(vp);
   return(0);
}
@ROUT ATL_ammm_rkK ATL_cammm_rkK
static void *FixVector(enum ATLAS_TRANS TX, ATL_CSZT N, const SCALAR alpha,
                       const TYPE *X, ATL_CSZT incX)
{
   void *vx;
   TYPE *x;
   vx = malloc(ATL_MulBySize(N)+ATL_Cachelen);
   ATL_assert(vx);
   x = ATL_AlignPtr(vx);
@ROUT ATL_ammm_rkK
   if (SCALAR_IS_ONE(alpha))
      Mjoin(PATL,copy)(N, X, incX, x, 1);
   else
      Mjoin(PATL,cpsc)(N, alpha, X, incX, x, 1);
@ROUT ATL_cammm_rkK
   if (SCALAR_IS_ONE(alpha))
   {
      if (TX == AtlasTrans || TX == AtlasNoTrans)
         Mjoin(PATL,copy)(N, X, incX, x, 1);
      else
         Mjoin(PATL,copyConj)(N, X, incX, x, 1);
   }
   else
   {
      if (TX == AtlasTrans || TX == AtlasNoTrans)
         Mjoin(PATL,cpsc)(N, alpha, X, incX, x, 1);
      else
         Mjoin(PATL,moveConj)(N, alpha, X, incX, x, 1);
   }
@ROUT ATL_ammm_rkK ATL_cammm_rkK
   return(vx);
}

/*
 * This entry makes rkK safe for L3kernel aliased calls.  It handles
 * only the aliasing required by the L3kernels, namely square blocks
 * less than ATLAS's largest blocking factor for the square dimensions,
 * with one of A/B aliased with C, and aliased by having
 * either A == C or B == C (i.e., not a partial overlap).  When A==C, 
 * M=K < ATL_MAXK_RKK; when B==C, N=K < ATL_MAXK_RKK.
 */
@ROUT ATL_ammm_rkK 
   @define one @ATL_rone@
@ROUT ATL_cammm_rkK
   @define one @ONE@
@ROUT ATL_ammm_rkK ATL_cammm_rkK
int Mjoin(PATL,ammm_aliased_rkK)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alp,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
@skip   TYPE *a = (TYPE*)A, *b = (TYPE*)B;
@skip   size_t lda=ldA, ldb=ldB;
@ROUT ATL_cammm_rkK `   const TYPE ONE[2] = {ATL_rone, ATL_rzero};`
   void *vp=NULL;

   if (K == 0 || SCALAR_IS_ZERO(alp))
   {
      if (SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gezero)(M, N, C, ldc);
      else if (!SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gescal)(M, N, beta, C, ldc);
      return(0);
   }
   if (K == 1)
   {
@ROUT ATL_ammm_rkK  `      TYPE alpha = alp;`
@ROUT ATL_cammm_rkK `      const SCALAR alpha = alp;`
      void *xp=NULL, *yp=NULL;
      TYPE *a = (TYPE*)A, *b = (TYPE*)B;
      size_t ldA=lda, ldB=ldb;

@ROUT ATL_cammm_rkK `      TYPE ONE[2] = {ATL_rone, ATL_rzero};`

      if (A == C)
      {
         xp = FixVector(TA, M, alpha, A, 
                        (TA == AtlasTrans || TA == AtlasConjTrans) ? lda:1);
         a = ATL_AlignPtr(xp);
         alpha = @(one);
         if (TA == AtlasConjTrans || TA == AtlasTrans)
         {
            TA = AtlasTrans;
            ldA = 1;
         }
         else if (TA == AtlasConj)
            TA = AtlasNoTrans;
      }
      if (B == C)
      {
         yp = FixVector(TB, N, alpha, B, 
                        (TB == AtlasTrans || TB == AtlasConjTrans) ? 1:ldb);
         b = ATL_AlignPtr(yp);
         alpha = @(one);
         if (TB == AtlasConjTrans)
            TB = AtlasTrans;
         else if (TB == AtlasConj || TB == AtlasNoTrans)
         {
            TA = AtlasNoTrans;
            ldB = 1;
         }
      }
      ATL_assert(!Mjoin(PATL,ammm)(TA, TB, M, N, K, alpha, a, ldA, b, ldB, 
                                   beta, C, ldc));
      if (xp)
         free(xp);
      if (yp)
         free(yp);
      return(0);
   }

   if (K == 2)
   {
@ROUT ATL_ammm_rkK  `      TYPE alpha = alp;`
@ROUT ATL_cammm_rkK `      const SCALAR alpha = alp;`
@ROUT ATL_cammm_rkK `      TYPE ONE[2] = {ATL_rone, ATL_rzero};`
/*
 *    If BETA != 1, ammm_rk2 will copy all inputs and thus aliasing safe
 */
      if (!SCALAR_IS_ONE(beta))
         Mjoin(PATL,ammm_rk2)(TA, TB, M, N, alpha, A, lda, B, ldb, beta, 
                              C, ldc);
/*
 *    For beta = 1, copy aliased input array(s) and then call GER2
 */
      else
      {
         void *wp=NULL, *xp=NULL, *yp=NULL, *zp=NULL;
         TYPE *w, *x, *y, *z;
         ATL_SZT incX, incY;
@ROUT ATL_ammm_rkK
         if (A == C)
         {
            ATL_CSZT incx = (TA == AtlasTrans) ? lda:1;
@ROUT ATL_cammm_rkK
         if (A == C || TA == AtlasConjTrans || TA == AtlasConj)
         {
            ATL_CSZT incx = (TA == AtlasTrans || TA == AtlasConjTrans) ? lda:1;
@ROUT ATL_ammm_rkK ATL_cammm_rkK
            wp = FixVector(TA, M, alpha, A, incx);
            xp = FixVector(TA, M, alpha, A+((incx==1 ? lda:1)SHIFT), incx);
            alpha = @(one);
            w = ATL_AlignPtr(wp);
            incX = 1;
         }
         else  /* don't need to copy A */
         {
            w = (TYPE*)A;
            if (TA == AtlasNoTrans)
            {
               x = (TYPE*)(A + (lda SHIFT));
               incX = 1;
            }
            else /* if (TA == AtlasTrans) */
            {
               x = (TYPE*)(A + (1 SHIFT));
               incX = lda;
            }
         }
         if (B == C)
         {
            ATL_CSZT incy = (TB == AtlasTrans || TB == AtlasConjTrans) ? 1:ldb;
            yp = FixVector(TB, N, alpha, A, incy);
            zp = FixVector(TB, N, alpha, A+(((incy==1)?ldb:1)SHIFT), incy);
            y = ATL_AlignPtr(yp);
            z = ATL_AlignPtr(zp);
@ROUT ATL_cammm_rkK
            if (TB == AtlasConj)
               TB = AtlasNoTrans;
            else if (TB == AtlasConjTrans)
               TB = AtlasTrans;
@ROUT ATL_ammm_rkK ATL_cammm_rkK
            incY = 1;
            alpha = @(one);
         
         }
         else  /* no need to copy B */
         {
            y = (TYPE*)B;
@ROUT ATL_cammm_rkK `            if (TB == AtlasNoTrans || TB == AtlasConj)`
@ROUT ATL_ammm_rkK `            if (TB == AtlasNoTrans)`
            {
               incY = ldb;
               z = (TYPE*)(B + (1 SHIFT));
            }
            else
            {
               incY = 1;
               z = (TYPE*)(B + (ldb SHIFT));
            }
         }
@ROUT ATL_ammm_rkK
         Mjoin(PATL,ger2)(M, N, alpha, w, incX, y, incY, @(one), 
                          x, incX, z, incY, C, ldc);
@ROUT ATL_cammm_rkK
         if (TB == AtlasNoTrans || TB == AtlasTrans)
            Mjoin(PATL,ger2u)(M, N, alpha, w, incX, y, incY, @(one), 
                              x, incX, z, incY, C, ldc);
         else
            Mjoin(PATL,ger2c)(M, N, alpha, w, incX, y, incY, @(one), 
                              x, incX, z, incY, C, ldc);
@ROUT ATL_ammm_rkK ATL_cammm_rkK
         if (wp)
            free(wp);
         if (xp)
            free(xp);
         if (yp)
            free(yp);
         if (zp)
            free(zp);
         return(0);
      }
      return(0);
   }
/*
 * For K > 3, ATL_ammm_rkK is safe for these precise aliasing conditions
 */
   ATL_assert(!Mjoin(PATL,ammm_rkK)(TA, TB, M, N, K, alp, A, lda, B, ldb, 
                                    beta, C, ldc));
   return(0);
@beginskip
   if (K < 3)
   {
      lda = (TA == AtlasNoTrans || TA == AtlasConj) ? M:K;
      ldb = (TB == AtlasNoTrans || TB == AtlasConj) ? K:N;
      a = malloc(ATL_MulBySize((M+N)*K));
      ATL_assert(a);
      b = a + ((M*K)SHIFT);
      if (lda == M)
         Mjoin(PATL,gecopy)(M, K, A, ldA, a, lda);
      else
         Mjoin(PATL,gecopy)(K, M, A, ldA, a, lda);
      if (ldb == K)
         Mjoin(PATL,gecopy)(K, N, B, ldB, b, ldb);
      else
         Mjoin(PATL,gecopy)(N, K, B, ldB, b, ldb);
   }
   ATL_assert(!Mjoin(PATL,ammm)(TA, TB, M, N, K, alpha, a, lda, b, ldb, 
              beta, C, ldc));
   if (a != A)
      free(a);
@endskip
}
@ROUT ATL_ammm_tN
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   ammkern_t ammK0, amm;
   amminfo_t mminfo;
   TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
   TYPE *pA, *pB0, *pB, *pC;
   int mu, nu, ku, nnu, NN, MB, NMU, KB, KB0, kb0, incBw, incBw0;
   size_t incAk0, incAk, mulAm, incBk0, incBk, nkb, k, nmblks, nsmblks, i, m;
   void *vp;

   ATL_assert(N <= ATL_AMM_MAXNB);
   mu = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else
      alpC = alpha;

   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   MB = ATL_ComputeB(M, mu, ATL_AMM_MAXMB, &nsmblks, &nmblks);
   NMU = MB / mu;
   nnu = (N+nu-1)/nu;
   KB = mminfo.kb;
   NN = nnu * nu;
   nkb = K/KB;
/*
 * kb0: K remainder, KB0 is CEIL(kb0/ku)*ku for k-vector kerns, and
 * same as kb0 for M-vector kerns
 */
   KB0 = kb0 = K - nkb*KB;
   if (!kb0)
   {
      KB0 = kb0 = KB;
      nkb--;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            ammK0 = mminfo.amm_b0;
         else
            ammK0 = (mminfo.kb==KB0) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
   {
      ammK0 = (kb0 == KB) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && kb0 == (kb0/ku)*ku &&
          kb0 > mminfo.kbmin)
         ammK0 = mminfo.amm_b0;
   }
   amm = mminfo.amm_b1;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;

/*
 * Do memory allocation, setup pointers
 */
   {
      const int szA = MB*KB, szC=MB*NN; 
      size_t szB = (nkb*KB+KB0)*NN;
      const size_t tsz = ATL_MulBySize(szA+szB+szC+mu*nu*ku) + 3*ATL_Cachelen;
      if (tsz > ATL_MaxMalloc)
         return(2);
      vp = malloc(tsz);
      if (!vp)
         return(1);
      pA = ATL_AlignPtr(vp);
      pB = pA + szA;
      pB0 = pB = ATL_AlignPtr(pB);
      pC = pB + szB;
      pC = ATL_AlignPtr(pC);
   }
   if (TA == AtlasNoTrans)
   {
      incAk = lda*KB;
      incAk0 = lda*kb0;
      mulAm = 1;
   }
   else
   {
      incAk = KB;
      incAk0 = kb0;
      mulAm = lda;
   }
   if (TB == AtlasNoTrans)
   {
      incBk = KB;
      incBk0 = kb0;
   }
   else
   {
      incBk = KB*ldb;
      incBk0 = kb0*ldb;
   }
   if (nkb)
   {
      incBw0 = KB0*NN;
      if (nkb > 1)
         incBw = KB*NN;
      else incBw = 0;
   }
   else 
      incBw = incBw0 = 0;
   for (m=M,i=0; i < nmblks; i++)
   {
      const TYPE *An;
      TYPE *pBn;
      int mb, nmu, mm;

      if (i < nsmblks)
      {
         mb = MB-mu;
         nmu = NMU-1;
      }
      else
      {
         mb = MB;
         nmu = NMU;
      }
      mm = Mmin(m, mb);
      m -= mm;
      An = A + mm*mulAm;
/*
 *    Do first (possibly partial) K-block
 */
      a2blk(kb0, mm, alpA, A, lda, pA);
      A += incAk0;
      if (!i)
      {
         b2blk(kb0, N, alpB, B, ldb, pB);
         B += incBk0;
      }
      pBn = pB + incBw0;
      ammK0(nmu, nnu, KB0, pA, pB, pC, pA, pBn, pC);
      pB = pBn;
/*
 *    Loop over all full-sized blocks
 */
      for (k=0; k < nkb; k++)
      {
         a2blk(KB, mm, alpA, A, lda, pA);
         A += incAk;
         if (!i)
         {
            b2blk(KB, N, alpB, B, ldb, pB);
            B += incBk;
         }
         pBn = (k < nkb-1) ? pB+incBw : pB0;
         amm(nmu, nnu, KB, pA, pB, pC, pA, pBn, pC);
         pB = pBn;
      }
      blk2c(mm, N, alpC, pC, beta, C, ldc);
      C += mm;
      A = An;
   }

   free(vp);
   return(0);
}
@ROUT ATL_cammm_tN
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   ammkern_t ammK0_b0, ammK0_b1, ammK0_bn, amm_b1, amm_bn;
   amminfo_t mminfo;
   const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   const TYPE *alpA=ONE, *alpB=ONE, *alpC=ONE;
   TYPE *rA, *iA, *pB0, *rC, *iC;
   int mu, nu, ku, nnu, NN, MB, NMU, KB, KB0, kb0, incBw, incBw0;
   size_t incAk0, incAk, mulAm, incBk0, incBk, nkb, k, nmblks, nsmblks, i, m;
   void *vp;

   ATL_assert(N <= ATL_AMM_MAXNB);
   mu = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else
      alpC = alpha;

   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   MB = ATL_ComputeB(M, mu, MY_MAXMB, &nsmblks, &nmblks);
   NMU = MB / mu;
   nnu = (N+nu-1)/nu;
   KB = mminfo.kb;
   NN = nnu * nu;
   nkb = K/KB;
/*
 * kb0: K remainder, KB0 is CEIL(kb0/ku)*ku for k-vector kerns, and
 * same as kb0 for M-vector kerns
 */
   KB0 = kb0 = K - nkb*KB;
   if (!kb0)
   {
      KB0 = kb0 = KB;
      nkb--;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            ammK0_b0 = mminfo.amm_b0;
         else
            ammK0_b0 = (mminfo.kb==KB0) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
   {
      ammK0_b0 = (kb0 == KB) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && (kb0/ku)*ku == kb0 &&
          kb0 > mminfo.kbmin)
         ammK0_b0 = mminfo.amm_b0;
   }
   amm_b1 = mminfo.amm_b1;
   amm_bn = mminfo.amm_bn;
   if (ammK0_b0 == mminfo.amm_b0)
   {
      ammK0_b1 = mminfo.amm_b1;
      ammK0_bn = mminfo.amm_bn;
   }
   else
   {
      ammK0_b1 = mminfo.amm_k1_b1;
      ammK0_bn = mminfo.amm_k1_bn;
   }
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;

/*
 * Do memory allocation, setup pointers
 */
   {
      const int szA = MB*KB, szC=MB*NN; 
      size_t szB = (nkb*KB+KB0)*NN;
      const size_t tsz = ATL_MulBySize(szA+szB+szC+mu*nu*ku) + 3*ATL_Cachelen;
      if (tsz > ATL_MaxMalloc)
         return(2);
      vp = malloc(tsz);
      if (!vp)
         return(1);
      iA = ATL_AlignPtr(vp);
      rA = iA + szA;
      iC = rA + szA;
      iC = ATL_AlignPtr(iC);
      rC = iC + szC;
      pB0 = rC + szC;
      pB0 = ATL_AlignPtr(pB0);
   }
   if (TA == AtlasNoTrans)
   {
      incAk = (lda*KB)SHIFT;
      incAk0 = (lda*kb0)SHIFT;
      mulAm = 2;
   }
   else
   {
      incAk = KB SHIFT;
      incAk0 = kb0 SHIFT;
      mulAm = lda SHIFT;
   }
   if (TB == AtlasNoTrans)
   {
      incBk = KB SHIFT;
      incBk0 = kb0 SHIFT;
   }
   else
   {
      incBk = (KB*ldb)SHIFT;
      incBk0 = (kb0*ldb)SHIFT;
   }
   incBw0 = KB0*NN;
   incBw = KB*NN;
   for (m=M,i=0; i < nmblks; i++)
   {
      const TYPE *An;
      TYPE *iB=pB0, *rB=pB0+incBw0, *pBn=rB+incBw0;
      int mb, nmu, mm;

      if (i < nsmblks)
      {
         mb = MB-mu;
         nmu = NMU-1;
      }
      else
      {
         mb = MB;
         nmu = NMU;
      }
      mm = Mmin(m, mb);
      m -= mm;
      An = A + mm*mulAm;
/*
 *    Do first (possibly partial) K-block
 */
      a2blk(kb0, mm, alpA, A, lda, rA, iA);
      A += incAk0;
      if (!i)
      {
         b2blk(kb0, N, alpB, B, ldb, rB, iB);
         B += incBk0;
      }
      rB = iB + incBw0;
      pBn = rB + incBw0;
      ammK0_b0(nmu, nnu, KB0, iA, iB, rC, rA, iB, iC);
      ammK0_b0(nmu, nnu, KB0, rA, iB, iC, rA, rB, rC);
      ammK0_bn(nmu, nnu, KB0, rA, rB, rC, iA, rB, iC);
      ammK0_b1(nmu, nnu, KB0, iA, rB, iC, rA, pBn, iC);
      iB = pBn;
/*
 *    Loop over all full-sized blocks
 */
      for (k=0; k < nkb; k++)
      {
         a2blk(KB, mm, alpA, A, lda, rA, iA);
         A += incAk;
         rB = iB + incBw;
         if (!i)
         {
            b2blk(KB, N, alpB, B, ldb, rB, iB);
            B += incBk;
         }
         pBn = (k < nkb-1) ? rB+incBw : pB0;
         amm_bn(nmu, nnu, KB, iA, iB, rC, rA, iB, iC);
         amm_b1(nmu, nnu, KB, rA, iB, iC, rA, rB, rC);
         amm_bn(nmu, nnu, KB, rA, rB, rC, iA, rB, iC);
         amm_b1(nmu, nnu, KB, iA, rB, iC, rA, pBn, iC);
         iB = pBn;
      }
      blk2c(mm, N, alpC, rC, iC, beta, C, ldc);
      C += mm+mm;
      A = An;
   }

   free(vp);
   return(0);
}
@ROUT ATL_cammm_IP
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   ammkern_t ammK0_b0, ammK0_b1, ammK0_bn, amm_b1, amm_bn;
   amminfo_t mminfo;
   const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   const TYPE *alpA=ONE, *alpB=ONE, *alpC=ONE;
   TYPE *rA, *iA, *rB, *iB, *rC, *iC;
   int mu, nu, ku, nmu, nnu, MM, NN, KB, KB0, kb0;
   size_t incA, incB, nkb, k;
   void *vp;

   mu = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else
      alpC = alpha;

   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   nmu = (M+mu-1)/mu;
   nnu = (N+nu-1)/nu;
   KB = mminfo.kb;
   MM = nmu * mu;
   NN = nnu * nu;
   nkb = K/KB;
/*
 * kb0: K remainder, KB0 is CEIL(kb0/ku)*ku for k-vector kerns, and
 * same as kb0 for M-vector kerns
 */
   KB0 = kb0 = K - nkb*KB;
   if (!kb0)
   {
      KB0 = kb0 = KB;
      nkb--;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            ammK0_b0 = mminfo.amm_b0;
         else
            ammK0_b0 = (mminfo.kb==KB0) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
   {
      ammK0_b0 = (kb0 == KB) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && (kb0/ku)*ku == kb0 && 
          kb0 > mminfo.kbmin)
         ammK0_b0 = mminfo.amm_b0;
   }
   amm_b1 = mminfo.amm_b1;
   amm_bn = mminfo.amm_bn;
   if (ammK0_b0 == mminfo.amm_b0)
   {
      ammK0_b1 = amm_b1;
      ammK0_bn = amm_bn;
   }
   else
   {
      ammK0_b1 = mminfo.amm_k1_b1;
      ammK0_bn = mminfo.amm_k1_bn;
   }
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;

/*
 * Do memory allocation, setup pointers
 */
   {
      const int szA=MM*KB, szB=KB*NN, szC=MM*NN;
      vp = malloc(ATL_MulBySize(szA + szB + szC + mu*nu*ku) + 3*ATL_Cachelen);
      ATL_assert(vp);
      iA = ATL_AlignPtr(vp);
      rA = iA + szA;
      iB = rA + szA;
      iB = ATL_AlignPtr(iB);
      rB = iB + szB;
      iC = rB + szB;
      iC = ATL_AlignPtr(iC);
      rC = iC + szC;
   }
   incA = ((TA == AtlasNoTrans) ? lda*KB : KB)SHIFT;
   incB = ((TB == AtlasNoTrans) ? KB : KB*ldb)SHIFT;
/*
 * Do first (possibly partial) K-block
 */
   a2blk(kb0, M, alpA, A, lda, rA, iA);
   b2blk(kb0, N, alpB, B, ldb, rB, iB);
   ammK0_b0(nmu, nnu, KB0, iA, iB, rC, rA, iB, iC);
   ammK0_b0(nmu, nnu, KB0, rA, iB, iC, rA, rB, rC);
   ammK0_bn(nmu, nnu, KB0, rA, rB, rC, iA, rB, iC);
   ammK0_b1(nmu, nnu, KB0, iA, rB, iC, iA, iB, rC);
   A += ((TA == AtlasNoTrans) ? lda*kb0 : kb0)SHIFT;
   B += ((TB == AtlasNoTrans) ? kb0 : kb0*ldb)SHIFT;
/*
 * Loop over all full-sized blocks
 */
   for (k=0; k < nkb; k++)
   {
      a2blk(KB, M, alpA, A, lda, rA, iA);
      b2blk(KB, N, alpB, B, ldb, rB, iB);
      ammK0_bn(nmu, nnu, KB, iA, iB, rC, rA, iB, iC);
      ammK0_b1(nmu, nnu, KB, rA, iB, iC, rA, rB, rC);
      ammK0_bn(nmu, nnu, KB, rA, rB, rC, iA, rB, iC);
      ammK0_b1(nmu, nnu, KB, iA, rB, iC, iA, iB, rC);
      A += incA;
      B += incB;
   }
   blk2c(M, N, alpC, rC, iC, beta, C, ldc);

   free(vp);
   return(0);
}
@ROUT ATL_ammm_IP
{
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   ammkern_t ammK0, amm;
   amminfo_t mminfo;
   TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
   TYPE *pA, *pB, *pC;
   int mu, nu, ku, nmu, nnu, MM, NN, KB, KB0, kb0;
   size_t incA, incB, nkb, k;
   void *vp;

   mu = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!mu)
      alpA = alpha;
   else if (mu == 1)
      alpB = alpha;
   else
      alpC = alpha;

   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   nmu = (M+mu-1)/mu;
   nnu = (N+nu-1)/nu;
   KB = mminfo.kb;
   MM = nmu * mu;
   NN = nnu * nu;
   nkb = K/KB;
/*
 * kb0: K remainder, KB0 is CEIL(kb0/ku)*ku for k-vector kerns, and
 * same as kb0 for M-vector kerns
 */
   KB0 = kb0 = K - nkb*KB;
   if (!kb0)
   {
      KB0 = kb0 = KB;
      nkb--;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KB0 = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            ammK0 = mminfo.amm_b0;
         else
            ammK0 = (mminfo.kb==KB0) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
   {
      ammK0 = (kb0 == KB) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      if (ATL_AMMFLG_KRUNTIME(mminfo.flag) && kb0 == (kb0/ku)*ku && 
          kb0 > mminfo.kbmin)
         ammK0 = mminfo.amm_b0;
   }
   amm = mminfo.amm_b1;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;

/*
 * Do memory allocation, setup pointers
 */
   {
      const int szA=MM*KB, szB=KB*NN, szC=MM*NN;
      vp = malloc(ATL_MulBySize(szA + szB + szC + mu*nu*ku) + 3*ATL_Cachelen);
      ATL_assert(vp);
      pA = ATL_AlignPtr(vp);
      pB = pA + szA;
      pB = ATL_AlignPtr(pB);
      pC = pB + szB;
      pC = ATL_AlignPtr(pC);
   }
   incA = (TA == AtlasNoTrans) ? lda*KB : KB;
   incB = (TB == AtlasNoTrans) ? KB : KB*ldb;
/*
 * Do first (possibly partial) K-block
 */
   a2blk(kb0, M, alpA, A, lda, pA);
   b2blk(kb0, N, alpB, B, ldb, pB);
   ammK0(nmu, nnu, KB0, pA, pB, pC, pA, pB, pC);
   A += (TA == AtlasNoTrans) ? lda*kb0 : kb0;
   B += (TB == AtlasNoTrans) ? kb0 : kb0*ldb;
/*
 * Loop over all full-sized blocks
 */
   for (k=0; k < nkb; k++)
   {
      a2blk(KB, M, alpA, A, lda, pA);
      b2blk(KB, N, alpB, B, ldb, pB);
      amm(nmu, nnu, KB, pA, pB, pC, pA, pB, pC);
      A += incA;
      B += incB;
   }
   blk2c(M, N, alpC, pC, beta, C, ldc);

   free(vp);
   return(0);
}
@ROUT ATL_ammm_1b
{
   int i;
   int nmu, nnu, nku, bM, bN, bK, szB;
   #if ATL_AMM_MAXKMAJ > 1
      int KK;
   #else
      #define KK K
   #endif
   int mu, nu, ku, appAl;
   void *vp;
   TYPE *pA, *pB, *pC, *p;
   TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
   ammkern_t amm;
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   amminfo_t mminfo;
   appAl = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!appAl)
      alpA = alpha;
   else if (appAl == 1)
      alpB = alpha;
   else
      alpC = alpha;
/*
 * These kernels all take runtime M/N, and do well with near-square, so
 * blindly use this kernel with nM = CEIL(M/mu)*mu, nN = CEIL(N/nu)*nu
 */
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   nmu = (M+mu-1)/mu;
   nnu = (N+nu-1)/nu;
   nku = (K+ku-1)/ku;
   bM = nmu * mu;
   bN = nnu * nu;
   bK = nku * ku;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;
   #if ATL_AMM_MAXKMAJ > 1
      KK = K;
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KK = bK;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            amm = mminfo.amm_b0;
         else 
            amm = (mminfo.kb==KK) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
         amm = (bK == K) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
/*
 * Force rank-K code to handle this case if we would have to use K-cleanup
 * code with unknown performance
 */
   if (amm != mminfo.amm_b0 && K > 2 && K <= ATL_MAXK_RKK)
      return(-1);
   szB = KK*bN;
   vp = malloc((bM*bN + bM*KK + szB + mu*nu*ku)*sizeof(TYPE) + 3*ATL_Cachelen);
   if (!vp)
      return(1);
   pB = ATL_AlignPtr(vp);
   pA = pB + szB;
   pA = ATL_AlignPtr(pA);
   pC = pA + bM*KK;
   pC = ATL_AlignPtr(pC);
/*
 * Copy A & B into workspace, and pad K its if necessary
 */
   a2blk(K, M, alpA, A, lda, pA);
   b2blk(K, N, alpB, B, ldb, pB);
   amm(nmu, nnu, KK, pA, pB, pC, pA, pB, pC);
   blk2c(M, N, alpC, pC, beta, C, ldc);

   free(vp);
   return(0);
}
@ROUT ATL_cammm_1b
{
   int i;
   int nmu, nnu, nku, bM, bN, bK;
   int szA, szB, szC;
   #if ATL_AMM_MAXKMAJ > 1
      int KK;
   #else
      #define KK K
   #endif
   int mu, nu, ku, appAl;
   void *vp;
   TYPE *rA, *iA, *rB, *iB, *rC, *iC, *p, *w;
   const TYPE one[2] = {ATL_rone, ATL_rzero};
   const TYPE *alpA=one, *alpB=one, *alpC=one;
   ammkern_t amm;
   ablk2cmat_t blk2c;
   cm2am_t a2blk, b2blk;
   amminfo_t mminfo;
   appAl = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!appAl)
      alpA = alpha;
   else if (appAl == 1)
      alpB = alpha;
   else
      alpC = alpha;
/*
 * These kernels all take runtime M/N, and do well with near-square, so
 * blindly use this kernel with nM = CEIL(M/mu)*mu, nN = CEIL(N/nu)*nu
 */
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   nmu = (M+mu-1)/mu;
   nnu = (N+nu-1)/nu;
   nku = (K+ku-1)/ku;
   bM = nmu * mu;
   bN = nnu * nu;
   bK = nku * ku;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
   blk2c = mminfo.Cblk2cm;
   #if ATL_AMM_MAXKMAJ > 1
      KK = K;
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KK = bK;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            amm = mminfo.amm_b0;
         else 
            amm = (mminfo.kb==KK) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
   #endif
         amm = (bK == K) ? mminfo.amm_b0 : mminfo.amm_k1_b0;
/*
 * Force rank-K code to handle this case if we would have to use K-cleanup
 * code with unknown performance
 */
   if (amm != mminfo.amm_b0 && K > 2 && K <= ATL_MAXK_RKK)
      return(-1);
   szB = KK*bN;
   szA = bM*KK;
   szC = bM*bN;
   vp = malloc((szC+mu*nu*ku + szA + szB)*2*ATL_sizeof + 3*ATL_Cachelen);
   ATL_assert(vp);
   iB = ATL_AlignPtr(vp);
   rB = iB + szB;
   rB = ATL_AlignPtr(rB);
   iA = rB + szB;
   iA = ATL_AlignPtr(iA);
   rA = iA + szA;
   iC = rA + szA;
   rC = iC + szC;
   w = rC + szC;
/*
 * Copy A & B into workspace, and pad K its if necessary
 */
   a2blk(K, M, alpA, A, lda, rA, iA);
   b2blk(K, N, alpB, B, ldb, rB, iB);
   amm(nmu, nnu, KK, iA, iB, rC, rA, iB, iC);
   amm(nmu, nnu, KK, rA, iB, iC, rA, rB, rC);
   if (amm == mminfo.amm_b0)
   {
      mminfo.amm_bn(nmu, nnu, KK, rA, rB, rC, iA, rB, iC);
      mminfo.amm_b1(nmu, nnu, KK, iA, rB, iC, iA, rB, iC);
   }
   else
   {
      mminfo.amm_k1_bn(nmu, nnu, KK, rA, rB, rC, iA, rB, iC);
      mminfo.amm_k1_b1(nmu, nnu, KK, iA, rB, iC, iA, rB, iC);
   }
   blk2c(M, N, alpC, rC, iC, beta, C, ldc);

   free(vp);
   return(0);
}
@ROUT ATL_ammm
{
/*
 * Just do a scale and return
 */
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      if (SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gezero)(M, N, C, ldc);
      else if (!SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gescal)(M, N, beta, C, ldc);
      return(0);
   }
/*
 * Scope for degenerate cases that should call Level-2 BLAS; these
 * routines assert they work, since their workspace is O(N) and so are
 * not allowed to fail.
 */
   if (K == 1)  /* really a GER */
   {
      if (!SCALAR_IS_ONE(beta))
      {
         int i;
         ATL_CSZT incA = ((TA == AtlasNoTrans) ? 1 : lda);
         ATL_CSZT incB = ((TB == AtlasNoTrans) ? ldb : 1);
         for (i=0; i < N; i++, B += incB, C += ldc)
            Mjoin(PATL,axpby)(M, alpha * *B,  A, incA, beta, C, 1);
      }
      else
         Mjoin(PATL,ger)(M, N, alpha, A, (TA == AtlasNoTrans) ? 1 : lda,
                         B, (TB == AtlasNoTrans) ? ldb : 1, C, ldc);
      return(0);
   }
   if (K == 2)
      return(Mjoin(PATL,ammm_rk2)(TA, TB, M, N, alpha, A, lda, B, ldb,
                                  beta, C, ldc));
   if (N == 1)  /* Really GEMV with A as matrix, A & C as vectors */
   {
      if (TA == AtlasNoTrans)
         Mjoin(PATL,gemv)(AtlasNoTrans, M, K, alpha, A, lda, B,
                          (TB == AtlasNoTrans) ? 1:ldb, beta, C, 1);
      else
         Mjoin(PATL,gemv)(AtlasTrans, K, M, alpha, A, lda, B,
                          (TB == AtlasNoTrans) ? 1:ldb, beta, C, 1);
      return(0);
   }
   if (M == 1)  /* Really GEMV with B as matrix, A & C as vectors */
   {
      if (TB == AtlasNoTrans)
         Mjoin(PATL,gemv)(AtlasTrans, K, N, alpha, B, ldb, A,
                          (TA == AtlasNoTrans) ? lda:1, beta, C, ldc);
      else
         Mjoin(PATL,gemv)(AtlasNoTrans, N, K, alpha, B, ldb, A,
                          (TA == AtlasNoTrans) ? lda:1, beta, C, ldc);
      return(0);
   }
/*
 * 1-block special case code can return w/o doing op if it thinks
 * rank-K would be faster
 */
   if (M <= ATL_AMM_MAXMB && N <= ATL_AMM_MAXNB && K <= ATL_AMM_MAXKB)
      if (!Mjoin(PATL,ammm_1b)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                               beta, C, ldc))
         return(0);
/*
 * Rank-K can fail to allocate space, so return success/failure
 */
   if (K > 2 && K <= ATL_MAXK_RKK)
      return(Mjoin(PATL,ammm_rkK)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                  beta, C, ldc));
/*
 * Handle case that is really an inner product shape (M<=MB, N<=NB, large K)
 * This case not allowed to fail since it requires only 3*NB^2 workspace.
 */
   if (M <= ATL_AMM_MAXMB && N <= ATL_AMM_MAXNB)
      return(Mjoin(PATL,ammm_IP)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                 beta, C, ldc));
/*
 * If B/C have only one column panel, call special low-workspace (3NB^3)
 * code for additional performance.  This shape occurs in left-looking LU.
 */
   if (N <= ATL_AMM_MAXNB)
      return(Mjoin(PATL,ammm_tN)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                 beta, C, ldc));
/*
 * Next two loop orderings are general case, so use whichever uses least
 * workspace
 */
   if (M >= N)
      return(Mjoin(PATL,ammmMNK)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                 beta, C, ldc));
/*
 * This guy tries to allocate (M+NB)*K + NB^2 worskpace, so recursion
 * may be needed to keep it within allotted memory.
 */
   return(Mjoin(PATL,ammmNMK)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                              beta, C, ldc));
}
@ROUT ATL_cammm
{
/*
 * Just do a scale and return
 */
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      if (SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gezero)(M, N, C, ldc);
      else if (!SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gescal)(M, N, beta, C, ldc);
      return(0);
   }
/*
 * Scope for degenerate cases that should call Level-2 BLAS; these
 * routines assert they work, since their workspace is O(N) and so they
 * are not allowed to fail.
 */
   if (K == 1)  /* really a GER */
   {
      if (!SCALAR_IS_ONE(beta))  /* can't use GER for beta != 1 */
      {
         int i;
         const register TYPE ral=alpha[0], ial=alpha[1];
         const size_t ldc2 = ldc+ldc;
         ATL_CSZT incB = ((TB == AtlasNoTrans) ? ldb : 1)SHIFT;
         const register TYPE 
            cjm = (TB==AtlasConj || TB==AtlasConjTrans) ? ATL_rnone:ATL_rone;
         TYPE *X=(TYPE*)A;
         void *vp=NULL;
/*
 *       Copy A if it's a row or if it must be conjugated
 */
         if (TA == AtlasTrans || TA == AtlasConjTrans || TA == AtlasConj)
         {
            vp = malloc(ATL_MulBySize(M)+ATL_Cachelen);
            ATL_assert(vp);
            X = ATL_AlignPtr(vp);
            if (TA == AtlasTrans)
               Mjoin(PATL,copy)(M, A, lda, X, 1);
            else if (TA == AtlasConjTrans)
               Mjoin(PATL,copyConj)(M, A, lda, X, 1);
            else
               Mjoin(PATL,copyConj)(M, A, 1, X, 1);
         }
         for (i=0; i < N; i++, B += incB, C += ldc2)
         {
            TYPE scal[2];
            register TYPE rb=(*B), ib=cjm*B[1];
            scal[0] = rb*ral - ib*ial;
            scal[1] = rb*ial + ib*ral;
            Mjoin(PATL,axpby)(M, scal,  X, 1, beta, C, 1);
         }
         if (vp) 
            free(vp);
      }
      else  /* BETA=1, can use GERU/GERC */
      {
         if (TA == AtlasConjTrans || TA == AtlasConj)  /* must copyConj A */
         {
            void *vp;
            TYPE *X;
            const TYPE ONE[2] = {ATL_rone, ATL_rzero};
            vp = malloc(ATL_MulBySize(M)+ATL_Cachelen);
            ATL_assert(vp);
            X = ATL_AlignPtr(vp);
            Mjoin(PATL,moveConj)(M, alpha, A, (TA == AtlasConj) ? 1:lda, X, 1);
            if (TB == AtlasConjTrans || TB == AtlasConj)  /* use gerc */
               Mjoin(PATL,gerc)(M, N, ONE, X, 1, B, 
                                (TB == AtlasConj) ? ldb : 1, C, ldc);
            else
               Mjoin(PATL,geru)(M, N, ONE, X, 1, B, 
                                (TB == AtlasNoTrans) ? ldb : 1, C, ldc);
            free(vp);
         }
         else if (TB == AtlasConjTrans || TB == AtlasConj)  /* use gerc */
            Mjoin(PATL,gerc)(M, N, alpha, A, (TA == AtlasNoTrans) ? 1 : lda, 
                             B, (TB == AtlasConj) ? ldb : 1, C, ldc);
         else /* use geru */
            Mjoin(PATL,geru)(M, N, alpha, A, (TA == AtlasNoTrans) ? 1 : lda, 
                            B, (TB == AtlasNoTrans) ? ldb : 1, C, ldc);
      }
      return(0);
   }
   if (K == 2)
      return(Mjoin(PATL,ammm_rk2)(TA, TB, M, N, alpha, A, lda, B, ldb,
                                  beta, C, ldc));
   if (N == 1)  /* GEMV wt A as matrix, B&C vecs */
   {                     
      TYPE *X = (TYPE*)B;
      void *vp = NULL;
      int incX = 1;
/*
 *    Copy B if it we need to conjugate it
 */
      if (TB == AtlasConj || TB == AtlasConjTrans)
      {
         vp = malloc(ATL_MulBySize(K)+ATL_Cachelen);
         ATL_assert(vp);
         X = ATL_AlignPtr(vp);
         Mjoin(PATL,copyConj)(K, B, (TB == AtlasConj) ? 1:ldb, X, 1);
      }
      else
         incX = (TB == AtlasNoTrans) ? 1:ldb;
      if (TA == AtlasNoTrans || TA == AtlasConj)
         Mjoin(PATL,gemv)(TA, M, K, alpha, A, lda, X, incX, beta, C, 1);
      else /* if (TA == AtlasTrans || TA == AtlasConjTrans) */
         Mjoin(PATL,gemv)(TA, K, M, alpha, A, lda, X, incX, beta, C, 1);
      if (vp)
         free(vp);
      return(0);
   }
   if (M == 1)  /* Really GEMV with B as matrix, A & C as vectors */
   {
      TYPE *X = (TYPE*)A;
      void *vp = NULL;
      int incX = 1;
/*
 *    Copy A if it we need to conjugate it
 */
      if (TA == AtlasConj || TA == AtlasConjTrans)
      {
         vp = malloc(ATL_MulBySize(K)+ATL_Cachelen);
         ATL_assert(vp);
         X = ATL_AlignPtr(vp);
         Mjoin(PATL,copyConj)(K, A, (TA == AtlasConj) ? lda:1, X, 1);
      }
      else
         incX = (TA == AtlasNoTrans) ? lda:1;
      if (TB == AtlasNoTrans)
         Mjoin(PATL,gemv)(AtlasTrans, K, N, alpha, B, ldb, X, incX,
                          beta, C, ldc);
      else if (TB == AtlasConj)
         Mjoin(PATL,gemv)(AtlasConjTrans, K, N, alpha, B, ldb, X, incX,
                          beta, C, ldc);
      else if (TB == AtlasTrans)
         Mjoin(PATL,gemv)(AtlasNoTrans, N, K, alpha, B, ldb, X, incX,
                          beta, C, ldc);
      else if (TB == AtlasConjTrans)
         Mjoin(PATL,gemv)(AtlasConj, N, K, alpha, B, ldb, X, incX,
                          beta, C, ldc);
      if (vp)
         free(vp);
      return(0);
   }
/*
 * 1-block special case code can return w/o doing op if it thinks
 * rank-K would be faster
 */
   if (M <= ATL_AMM_MAXMB && N <= ATL_AMM_MAXNB && K <= ATL_AMM_MAXKB)
   {
      if (!Mjoin(PATL,ammm_1b)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                               beta, C, ldc))
         return(0);
   }
/*
 * Rank-K could fail to allocate M*KB+KB*N+MB*KB workspace
 */
   if (K > 2 && K <= ATL_MAXK_RKK)
      return(Mjoin(PATL,ammm_rkK)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                  beta, C, ldc));
/*
 * If B/C have only one column panel, call special low-workspace (3NB^3)
 * code for additional performance.  This shape occurs in left-looking algs.
 */
   if (N <= ATL_AMM_MAXNB)
      return(Mjoin(PATL,ammm_tN)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                 beta, C, ldc));
/*
 * Handle case that is really an inner product shape (M<=MB, N<=NB, large K)
 */
   if (M <= ATL_AMM_MAXMB && N <= ATL_AMM_MAXNB)
      return(Mjoin(PATL,ammm_IP)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                 beta, C, ldc));
/*
 * Next two loop orderings are general case, so use whichever uses least
 * workspace
 */
   if (M > N)
      return(Mjoin(PATL,ammmMNK)(TA, TB, M, N, K, alpha, A, lda, B, ldb,
                                 beta, C, ldc));
/*
 * This guy tries to allocate (M+NB)*K + NB^2 worskpace, so recursion
 * may be needed to keep it within allotted memory.
 */
   return(Mjoin(PATL,ammmNMK)(TA, TB, M, N, K, alpha, A, lda, B, ldb, 
                              beta, C, ldc));
}
@ROUT ATL_ammm ATL_cammm
/*
 * Recur to get K below this value; this puts a ceiling on workspace and
 * usually improves performance (in huge problems, reduces TLB pressure)
 */
#define ATL_MAX_RK 3000


/*
 * This routine uses recursion to cut the dimensions of the matrices until
 * workspace requirements are low enough that a call to ATL_ammm succeeds
 */
int Mjoin(PATL,ammm)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
/*
 * Cases where all we must do is possibly scale and return
 */
   if (SCALAR_IS_ZERO(alpha))
   {
      if (SCALAR_IS_ZERO(beta))
         Mjoin(PATL,gezero)(M, N, C, ldc);
      else if (!SCALAR_IS_ONE(beta))
         Mjoin(PATL,gescal)(M, N, beta, C, ldc);
      return(0);
   }
/*
 * Our stopping criteria is if ATL_ammm signals success
 */
   if (K <= ATL_MAX_RK)
      if (!ATL_ammm(TA, TB, M, N, K, alpha, A, lda, B, ldb, beta, C, ldc))
         return(0);
/*
 * =========================================================================
 * Otherwise, problem too large, so we'll recursively divide its largest dim
 * =========================================================================
 */
/*
 * if K is tied for largest, cut it, since it reduces size of A & B
 * NOTE: C always uses only NB^2 workspace, so only A/B matters.
 */
   if (K > ATL_MAX_RK || (K >= N && K >= M))
   {
      const size_t kL=(K>>4)<<3, kR=K-kL;
@ROUT ATL_cammm `   const TYPE ONE[2] = {ATL_rone, ATL_rzero};`

      Mjoin(PATL,ammm)(TA, TB, M, N, kL, alpha, A, lda, B, ldb, beta, C, ldc);
      if (TA == AtlasNoTrans || TA == AtlasConj)
         A += (lda*kL)SHIFT;
      else
         A += kL SHIFT;
      if (TB == AtlasNoTrans)
         B += kL SHIFT;
      else
         B += (ldb*kL) SHIFT;
      Mjoin(PATL,ammm)(TA, TB, M, N, kR, alpha, A, lda, B, ldb, 
@ROUT ATL_ammm `                       ATL_rone, C, ldc);`
@ROUT ATL_cammm `                       ONE, C, ldc);`
   }
   else if (N >= M)  /* cutting N */
   {
      const size_t nL = (N>>1), nR = N-nL;
      Mjoin(PATL,ammm)(TA, TB, M, nL, K, alpha, A, lda, B, ldb, beta, C, ldc);
      if (TB == AtlasNoTrans || TB == AtlasConj)
         B += (ldb*nL)SHIFT;
      else 
         B += nL SHIFT;
      C += (ldc*nL)SHIFT;
      Mjoin(PATL,ammm)(TA, TB, M, nR, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   else  /* cutting M */
   {
      const size_t mL = (M>>1), mR = M-mL;
      Mjoin(PATL,ammm)(TA, TB, mL, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
      if (TA == AtlasNoTrans || TA == AtlasConj)
         A += mL SHIFT;
      else
         A += (mL*lda)SHIFT;
      C += mL SHIFT;
      Mjoin(PATL,ammm)(TA, TB, mR, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   return(0);
}

@ROUT ATL_ammm_rk2
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_level1.h"
/*
 * This is special-case code that handles rank-2 update by calling GER2
 */
int Mjoin(PATL,ammm_rk2)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   #ifdef DREAL
      const int MB=512, NB=32;
   #else /* SREAL */
      const int MB=512, NB=64;
   #endif
   void *vp;
   TYPE *x, *y, *w, *z;
   size_t j;
   ATL_CSZT incC = NB*ldc;

/*
 * If beta is one, can handle by one call to ger2
 */
   if (SCALAR_IS_ONE(beta))
   {
      if (TA == AtlasNoTrans)
      {
         if (TB == AtlasNoTrans)
            Mjoin(PATL,ger2)(M, N, alpha, A, 1, B, ldb, alpha, A+lda, 1,
                             B+1, ldb, C, ldc);
         else
            Mjoin(PATL,ger2)(M, N, alpha, A, 1, B, 1, alpha, A+lda, 1,
                             B+ldb, 1, C, ldc);
      }
      else if (TB == AtlasNoTrans)
         Mjoin(PATL,ger2)(M, N, alpha, A, lda, B, ldb, alpha, A+1, lda,
                          B+1, ldb, C, ldc);
      else
         Mjoin(PATL,ger2)(M, N, alpha, A, lda, B, 1, alpha, A+1, lda,
                          B+ldb, 1, C, ldc);
      return(0);
   }
/*
 * Later on, do smart think like copy only MB/NB at a time, and don't copy
 * at all if vectors are contiguous, but right now, always do copy up-front
 * so loop does not have to worry about TA/TB; this is a O(N) cost in N^2 alg
 */
   vp = malloc(2*ATL_MulBySize(M+N)+4*ATL_Cachelen);
   if (!vp)
      return(1);
   x = ATL_AlignPtr(vp);
   y = x + M;
   y = ATL_AlignPtr(y);
   w = y + N;
   w = ATL_AlignPtr(w);
   z = w + M;
   z = ATL_AlignPtr(z);
   if (TA == AtlasNoTrans)
   {
      Mjoin(PATL,copy)(M, A, 1, x, 1);
      Mjoin(PATL,copy)(M, A+lda, 1, w, 1);
   }
   else
   {
      Mjoin(PATL,copy)(M, A, lda, x, 1);
      Mjoin(PATL,copy)(M, A+1, lda, w, 1);
   }
   if (SCALAR_IS_ONE(alpha))
   {
      if (TB == AtlasNoTrans)
      {
         Mjoin(PATL,copy)(N, B, ldb, y, 1);
         Mjoin(PATL,copy)(N, B+1, ldb, z, 1);
      }
      else
      {
         Mjoin(PATL,copy)(N, B, 1, y, 1);
         Mjoin(PATL,copy)(N, B+ldb, 1, z, 1);
      }
   }
   else
   {
      if (TB == AtlasNoTrans)
      {
         Mjoin(PATL,cpsc)(N, alpha, B, ldb, y, 1);
         Mjoin(PATL,cpsc)(N, alpha, B+1, ldb, z, 1);
      }
      else
      {
         Mjoin(PATL,cpsc)(N, alpha, B, 1, y, 1);
         Mjoin(PATL,cpsc)(N, alpha, B+ldb, 1, z, 1);
      }
   }
   for (j=0; j < N; j += NB, C += incC)
   {
      size_t i, nb = N-j;
      nb = (nb >= NB) ? NB : nb;
      for (i=0; i < M; i += MB)
      {
         size_t mb = M-i;
         mb = (mb >= MB) ? MB : mb;
         Mjoin(PATL,gescal)(mb, nb, beta, C+i, ldc);
         Mjoin(PATL,ger2)(mb, nb, ATL_rone, x+i, 1, y+j, 1, ATL_rone, 
                          w+i, 1, z+j, 1, C+i, ldc);
      }
   }
   free(vp);
   return(0);
}
@ROUT ATL_cammm_rk2
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_level1.h"
/*
 * This is special-case code that handles rank-2 update by calling GER2
 */
int Mjoin(PATL,ammm_rk2)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   #ifdef DCPLX
      const int MB=512, NB=16;
   #else /* SCPLX */
      const int MB=512, NB=32;
   #endif
   void *vp;
   TYPE *x, *y, *w, *z;
   size_t j;
   const TYPE ONE[2] = {ATL_rone, ATL_rzero};
   ATL_CSZT lda2=lda+lda, ldb2=ldb+ldb, ldc2=ldc+ldc, incC = NB*ldc2;

/*
 * If beta is one, can handle by one call to ger2
 */
   if (SCALAR_IS_ONE(beta) && 0)
   {
      if (TA == AtlasNoTrans)
      {
         if (TB == AtlasNoTrans)
            Mjoin(PATL,ger2u)(M, N, alpha, A, 1, B, ldb, alpha, A+lda2, 1,
                              B+2, ldb, C, ldc);
         else if (TB == AtlasConj)
            Mjoin(PATL,ger2c)(M, N, alpha, A, 1, B, ldb, alpha, A+lda2, 1,
                              B+2, ldb, C, ldc);
         else if (TB == AtlasTrans)
            Mjoin(PATL,ger2u)(M, N, alpha, A, 1, B, 1, alpha, A+lda2, 1,
                              B+ldb2, 1, C, ldc);
         else /* if (TB == AtlasConjTrans) */
            Mjoin(PATL,ger2c)(M, N, alpha, A, 1, B, 1, alpha, A+lda2, 1,
                              B+ldb2, 1, C, ldc);
      }
      else if (TA == AtlasTrans)
      {
         if (TB == AtlasNoTrans)
            Mjoin(PATL,ger2u)(M, N, alpha, A, lda, B, ldb, alpha, A+2, lda,
                              B+2, ldb, C, ldc);
         else if (TB == AtlasConj)
            Mjoin(PATL,ger2c)(M, N, alpha, A, lda, B, ldb, alpha, A+2, lda,
                              B+2, ldb, C, ldc);
         else if (TB == AtlasTrans)
            Mjoin(PATL,ger2u)(M, N, alpha, A, lda, B, 1, alpha, A+2, lda,
                              B+ldb2, 1, C, ldc);
         else if (TB == AtlasConjTrans)
            Mjoin(PATL,ger2c)(M, N, alpha, A, lda, B, 1, alpha, A+2, lda,
                              B+ldb2, 1, C, ldc);
      }
/*
 *    If A must be conjugated, copy it
 */
      else  /* TA == AtlasConj || TA == AtlasConjTrans */
      {
         vp = malloc((ATL_MulBySize(M)+ATL_Cachelen)<<1);
         if (!vp)
           return(2);
         x = ATL_AlignPtr(vp);
         w = x + M + M;
         w = ATL_AlignPtr(w);
         if (SCALAR_IS_ONE(alpha))
         {
            if (TA == AtlasConj)
            {
               Mjoin(PATL,copyConj)(M, A, 1, x, 1);
               Mjoin(PATL,copyConj)(M, A+lda2, 1, w, 1);
            }
            else /* if (TA == AtlasConjTrans) */
            {
               Mjoin(PATL,copyConj)(M, A, lda, x, 1);
               Mjoin(PATL,copyConj)(M, A+2, lda, w, 1);
            }
         }
         else
         {
            if (TA == AtlasConj)
            {
               Mjoin(PATL,moveConj)(M, alpha, A, 1, x, 1);
               Mjoin(PATL,moveConj)(M, alpha, A+lda2, 1, w, 1);
            }
            else /* if (TA == AtlasConjTrans) */
            {
               Mjoin(PATL,moveConj)(M, alpha, A, lda, x, 1);
               Mjoin(PATL,moveConj)(M, alpha, A+2, lda, w, 1);
            }
         }
         if (TB == AtlasNoTrans)
            Mjoin(PATL,ger2u)(M, N, ONE, x, 1, B, ldb, ONE, w, 1,
                              B+2, ldb, C, ldc);
         else if (TB == AtlasConj)
            Mjoin(PATL,ger2c)(M, N, ONE, x, 1, B, ldb, ONE, w, 1,
                              B+2, ldb, C, ldc);
         else if (TB == AtlasTrans)
            Mjoin(PATL,ger2u)(M, N, ONE, x, 1, B, 1, ONE, w, 1,
                              B+ldb2, 1, C, ldc);
         else /* if (TB == AtlasConjTrans) */
            Mjoin(PATL,ger2c)(M, N, ONE, x, 1, B, 1, ONE, w, 1,
                              B+ldb2, 1, C, ldc);
         free(vp);
      }
      return(0);
   }
/*
 * Later on, do smart think like copy only MB/NB at a time, and don't copy
 * at all if vectors are contiguous, but right now, always do copy up-front
 * so loop does not have to worry about TA/TB; this is a O(N) cost in N^2 alg
 */
   vp = malloc(2*ATL_MulBySize(M+N)+4*ATL_Cachelen);
   if (!vp)
      return(1);
   x = ATL_AlignPtr(vp);
   y = x + M + M;
   y = ATL_AlignPtr(y);
   w = y + N + N;
   w = ATL_AlignPtr(w);
   z = w + M + M;
   z = ATL_AlignPtr(z);
   if (TA == AtlasNoTrans)
   {
      Mjoin(PATL,copy)(M, A, 1, x, 1);
      Mjoin(PATL,copy)(M, A+lda2, 1, w, 1);
   }
   else if (TA == AtlasConj)
   {
      Mjoin(PATL,copyConj)(M, A, 1, x, 1);
      Mjoin(PATL,copyConj)(M, A+lda2, 1, w, 1);
   }
   else if (TA == AtlasTrans)
   {
      Mjoin(PATL,copy)(M, A, lda, x, 1);
      Mjoin(PATL,copy)(M, A+2, lda, w, 1);
   }
   else if (TA == AtlasConjTrans)
   {
      Mjoin(PATL,copyConj)(M, A, lda, x, 1);
      Mjoin(PATL,copyConj)(M, A+2, lda, w, 1);
   }
   if (SCALAR_IS_ONE(alpha))
   {
      if (TB == AtlasNoTrans)
      {
         Mjoin(PATL,copy)(N, B, ldb, y, 1);
         Mjoin(PATL,copy)(N, B+2, ldb, z, 1);
      }
      else if (TB == AtlasConj)
      {
         Mjoin(PATL,copyConj)(N, B, ldb, y, 1);
         Mjoin(PATL,copyConj)(N, B+2, ldb, z, 1);
      }
      else if (TB == AtlasTrans)
      {
         Mjoin(PATL,copy)(N, B, 1, y, 1);
         Mjoin(PATL,copy)(N, B+ldb2, 1, z, 1);
      }
      else if (TB == AtlasConjTrans)
      {
         Mjoin(PATL,copyConj)(N, B, 1, y, 1);
         Mjoin(PATL,copyConj)(N, B+ldb2, 1, z, 1);
      }
   }
   else  /* alpha non-one; must apply */
   {
      if (TB == AtlasNoTrans)
      {
         Mjoin(PATL,cpsc)(N, alpha, B, ldb, y, 1);
         Mjoin(PATL,cpsc)(N, alpha, B+2, ldb, z, 1);
      }
      else if (TB == AtlasConj)
      {
         Mjoin(PATL,moveConj)(N, alpha, B, ldb, y, 1);
         Mjoin(PATL,moveConj)(N, alpha, B+2, ldb, z, 1);
      }
      else if (TB == AtlasTrans)
      {
         Mjoin(PATL,cpsc)(N, alpha, B, 1, y, 1);
         Mjoin(PATL,cpsc)(N, alpha, B+ldb2, 1, z, 1);
      }
      else /* if (TB == AtlasConjTrans) */
      {
         Mjoin(PATL,moveConj)(N, alpha, B, 1, y, 1);
         Mjoin(PATL,moveConj)(N, alpha, B+ldb2, 1, z, 1);
      }
   }
   for (j=0; j < N; j += NB, C += incC)
   {
      size_t i, nb = N-j;
      nb = (nb >= NB) ? NB : nb;
      for (i=0; i < M; i += MB)
      {
         size_t mb = M-i;
         mb = (mb >= MB) ? MB : mb;
         Mjoin(PATL,gescal)(mb, nb, beta, C+i+i, ldc);
         Mjoin(PATL,ger2u)(mb, nb, ONE, x+i+i, 1, y+j+j, 1, ONE,
                           w+i+i, 1, z+j+j, 1, C+i+i, ldc);
      }
   }
   free(vp);
   return(0);
}
@ROUT ATL_ammmNMK
#include "atlas_misc.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_sum.h))

int Mjoin(PATL,ammmNMK)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   amminfo_t mminfo;
   ATL_INT mb, NB, kb, mu, nu, ku, KRUN;
   #if ATL_AMM_MAXKMAJ > 1
      size_t kb0U, KK;
   #else
      #define kb0U kb0
      #define KK K
   #endif
   size_t nmblks, nnblks, nkblks, mbF, nbF, kb0, nmu, nmuF, MBF, NBF;
   size_t incwA, incAk, incBk, incAk0, incBk0, incAm, incBn, incCn;
   size_t i, j, k, szA, szB, szC, nnu0, nnuF;
   const TYPE *B0 = B;
   TYPE alpA=ATL_rone, alpB=ATL_rone, alpC=ATL_rone;
   TYPE *wA, *wB, *wC, *wA0, *wB0;
   void *vp;
   cm2am_t a2blk, b2blk;
   ablk2cmat_t blk2c;
   ammkern_t amm_b1, amm_b0;
   int appAl;

   appAl = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!appAl)
      alpA = alpha;
   else if (appAl == 1)
      alpB = alpha;
   else
      alpC = alpha;
   mb = mminfo.mb;
   NB = mminfo.nb;
   kb = mminfo.kb;
   KRUN = ATL_AMMFLG_KRUNTIME(mminfo.flag);
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   incwA = mb*kb; 
   nmu = mb / mu;
   amm_b1 = mminfo.amm_b1;
   blk2c = mminfo.Cblk2cm;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
/*
 * Handle N differently than other dims: since it is outer loop, don't want
 * to peel, so just vary nb inside the main loop.  nnblks therefore includes
 * final block, unlike for M or K.
 */
   if (N >= NB+nu+nu)
   {
      nnblks = N/NB;
      nbF = N - nnblks * NB;
      if (nbF < nu+nu)
         nbF += NB;
      else
         nnblks++;
   }
   else
   {
      nnblks = 1;
      nbF = N;
   }
   nnu0 = NB / nu;
   nnuF = (nbF+nu-1)/nu;
   NBF = nnuF * nu;
/*
 * For M, we must peel the final block to handle any cleanup (can't peel 1st
 * block or we mess up alignment!), so this block is not included in the
 * block count
 */
   if (M >= mb+mu+mu)  /* more than just last block */
   {
      nmblks = M/mb;
      mbF = M - nmblks * mb;
      if (mbF < mu+mu)  /* steal block from main iteration, not enough here! */
      {
         nmblks--;
         mbF += mb;
      }
   }
   else /* put everything in final block */
   {
      mbF = M;
      nmblks = 0;
   }
   nmuF = (mbF+mu-1) / mu;
   MBF = nmuF * mu;
/*
 * For K, we peel the first iteration to set BETA=0, so the nkblks does not
 * include the peeled block
 */
   if (K >= kb)
   {
      nkblks = K/kb;
      kb0 = K - nkblks * kb;
      if (!kb0)
      {
         kb0 = kb;
         nkblks--;
      }
      else
      {
         if (kb0 < 4)
         {
            kb0 += kb;
            nkblks--;
         }
      }
   }
   else /* K < nb */
   {
      kb0 = K;
      nkblks = 0;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KK = ((K+ku-1)/ku)*ku;
         kb0U = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            amm_b0 = mminfo.amm_b0;
         else
            amm_b0 = (mminfo.kb == kb0U) ?  mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
      {
         KK = K;
         kb0U = kb0;
         amm_b0 = (kb0 == mminfo.kb || 
                   (KRUN && kb0 >= mminfo.kbmin && (kb0/ku)*ku == kb0)) ?  
                  mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
   #else
      amm_b0 = (kb0 == mminfo.kb || 
                (KRUN && kb0 >= mminfo.kbmin && (kb0/ku)*ku == kb0)) ?  
               mminfo.amm_b0 : mminfo.amm_k1_b0;
   #endif
   szA = (nmblks*mb+MBF)*KK; /* wrkspc for all of A wt M rounded up to MU*/
   j = Mmax(NB, NBF);
   i = Mmax(MBF, mb);
   szC = i*j;
   szB = KK*j;                     /* workspace for panel of B */

   k = ATL_MulBySize(szA+szB+szC+mu*nu*ku) + 3*ATL_Cachelen;
   if (k > ATL_MaxMalloc)
      return(2);
   vp = malloc(k);
   if (!vp)
      return(1);
   wB0 = wB = ATL_AlignPtr(vp);
   wA = wB + szB;
   wA0 = wA = ATL_AlignPtr(wA);
   wC = wA + szA;
   wC = ATL_AlignPtr(wC);

   if (TA == AtlasNoTrans)
   {
      incAm = mb;
      incAk0 = kb0*lda;
      incAk = kb*lda;
   }
   else
   {
      incAm = mb*lda;
      incAk0 = kb0;
      incAk = kb;
   }
   if (TB == AtlasNoTrans)
   {
      incBk0 = kb0;
      incBk = kb;
      incBn = NB*ldb;
   }
   else
   {
      incBk0 = kb0*ldb;
      incBk = kb*ldb;
      incBn = NB;
   }
   incCn = ldc*NB;

   for (j=0; j < nnblks; j++)
   {
      size_t nb, nbsz, incwB, incwB0, nnu;
      const TYPE *Bn = B+incBn;
      TYPE *Cn = C + incCn;
      if (j != nnblks-1)
      {
         nbsz = nb = NB;
         nnu = nnu0;
      }
      else
      {
         nb = nbF;
         nbsz = NBF;
         nnu = nnuF;
      }
      incwB = nbsz*kb;
      incwB0 = nbsz*kb0U;
/*
 *    Do all M-blocks except final one, which may be of differing size & partial
 */
      for (i=0; i < nmblks; i++)
      {
         TYPE *wAn, *wBn;
         const TYPE *An = A+incAm;
/*
 *       Peel first K it to handle K-cleanup and set BETA=0
 */
         if (!j)
            a2blk(kb0, mb, alpA, A, lda, wA);
         if (!i)
            b2blk(kb0, nb, alpB, B, ldb, wB);
         wAn = wA+mb*kb0U;
         wBn = (nkblks) ? wB+incwB0 : wB;
         amm_b0(nmu, nnu, kb0U, wA, wB, wC, nkblks?wAn:wA, wBn, wC);
         wA = wAn;
         wB = wBn;
         A += incAk0;
         B += incBk0;
/*
 *       If first K-block not the only K-block
 */
         if (nkblks)
         {
            for (k=nkblks-1; k; k--)
            {
               wAn = wA+incwA;
               wBn = wB+incwB;
               if (!j)
                  a2blk(kb, mb, alpA, A, lda, wA);
               if (!i)
                  b2blk(kb, nb, alpB, B, ldb, wB);
               amm_b1(nmu, nnu, kb, wA, wB, wC, wAn, wBn, wC);
               wA = wAn;
               wB = wBn;
               A += incAk;
               B += incBk;
            }
/*
 *          Last K-block peeled to change prefetch pattern
 */
            wAn = wA+incwA;
            if (!j)
               a2blk(kb, mb, alpA, A, lda, wA);
            if (!i)
               b2blk(kb, nb, alpB, B, ldb, wB);
            amm_b1(nmu, nnu, kb, wA, wB, wC, wAn, wB0, wC);
            wA = wAn;
            wB = wB0;
         }
         blk2c(mb, nb, alpC, wC, beta, C, ldc);
         A = An;
         B = B0;
         C += mb;
      }
/*
 *    Do the final peeled M-block, which is of non-constant size mbF
 */
      {
         TYPE *wAn, *wBn;
/*
 *       Peel first K it to handle K-cleanup and set BETA=0
 */
         if (!j)
            a2blk(kb0, mbF, alpA, A, lda, wA);
         if (!i)
            b2blk(kb0, nb, alpB, B, ldb, wB);
         wAn = wA+MBF*kb0U;
         wBn = (nkblks) ? wB+incwB0 : wB;
         amm_b0(nmuF, nnu, kb0U, wA, wB, wC, nkblks?wAn:wA, wBn, wC);
         wA = wAn;
         wB = wBn;
         A += incAk0;
         B += incBk0;
/*
 *       If first K-block not the only K-block
 */
         if (nkblks)
         {
            for (k=nkblks-1; k; k--)
            {
               wAn = wA+MBF*kb;
               wBn = wB+incwB;
               if (!j)
                  a2blk(kb, mbF, alpA, A, lda, wA);
               if (!i)
                  b2blk(kb, nb, alpB, B, ldb, wB);
               amm_b1(nmuF, nnu, kb, wA, wB, wC, wAn, wBn, wC);
               wA += MBF*kb;
               wB = wBn;
               A += incAk;
               B += incBk;
            }
/*
 *          Last K-block peeled to change prefetch pattern
 */
            if (!j)
               a2blk(kb, mbF, alpA, A, lda, wA);
            if (!i)
               b2blk(kb, nb, alpB, B, ldb, wB);
            amm_b1(nmuF, nnu, kb, wA, wB, wC, wA0, wB0, wC);
            wA = wA0;
            wB = wB0;
         }
         blk2c(mbF, nb, alpC, wC, beta, C, ldc);
      }  /* end M-peel */
      wA = wA0;
      B = B0 = Bn;
      C = Cn;
   }
   free(vp);
   return(0);
}
@ROUT ATL_cammmNMK
#include "atlas_misc.h"
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_sum.h))

int Mjoin(PATL,ammmNMK)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   amminfo_t mminfo;
   ATL_INT mb, NB, kb, mu, nu, ku, KRUN;
   #if ATL_AMM_MAXKMAJ > 1
      size_t kb0U, KK;
   #else
      #define kb0U kb0
      #define KK K
   #endif
   size_t nmblks, nnblks, nkblks, mbF, nbF, kb0, nmu, nmuF, MBF, NBF;
   size_t incwA, incAk, incBk, incAk0, incBk0, incAm, incBn, incCn;
   size_t i, j, k, szA, szB, szC, nnu0, nnuF;
   const TYPE *B0 = B;
   const TYPE one[2] = {ATL_rone, ATL_rzero};
   const TYPE *alpA=one, *alpB=one, *alpC=one;
   TYPE *wA, *wB, *wC, *rC, *wA0, *wB0;
   void *vp;
   cm2am_t a2blk, b2blk;
   ablk2cmat_t blk2c;
   ammkern_t amm_b1, amm_b0, amm_bn, amm_b1K, amm_bnK;
   int appAl;

   appAl = Mjoin(PATL,GetAmmmInfo)(&mminfo, TA, TB, M, N, K, alpha, beta);
   if (!appAl)
      alpA = alpha;
   else if (appAl == 1)
      alpB = alpha;
   else
      alpC = alpha;
   mb = mminfo.mb;
   NB = mminfo.nb;
   kb = mminfo.kb;
   KRUN = ATL_AMMFLG_KRUNTIME(mminfo.flag);
   mu = mminfo.mu;
   nu = mminfo.nu;
   ku = mminfo.ku;
   incwA = mb*kb; 
   nmu = mb / mu;
   amm_b1 = mminfo.amm_b1;
   amm_bn = mminfo.amm_bn;
   blk2c = mminfo.Cblk2cm;
   a2blk = mminfo.a2blk;
   b2blk = mminfo.b2blk;
/*
 * Handle N differently than other dims: since it is outer loop, don't want
 * to peel, so just vary nb inside the main loop.  nnblks therefore includes
 * final block, unlike for M or K.
 */
   if (N >= NB+nu+nu)
   {
      nnblks = N/NB;
      nbF = N - nnblks * NB;
      if (nbF < nu+nu)
         nbF += NB;
      else
         nnblks++;
   }
   else
   {
      nnblks = 1;
      nbF = N;
   }
   nnu0 = NB / nu;
   nnuF = (nbF+nu-1)/nu;
   NBF = nnuF * nu;
/*
 * For M, we must peel the final block to handle any cleanup (can't peel 1st
 * block or we mess up alignment!), so this block is not included in the
 * block count
 */
   if (M >= mb+mu+mu)  /* more than just last block */
   {
      nmblks = M/mb;
      mbF = M - nmblks * mb;
      if (mbF < mu+mu)  /* steal block from main iteration, not enough here! */
      {
         nmblks--;
         mbF += mb;
      }
   }
   else /* put everything in final block */
   {
      mbF = M;
      nmblks = 0;
   }
   nmuF = (mbF+mu-1) / mu;
   MBF = nmuF * mu;
/*
 * For K, we peel the first iteration to set BETA=0, so the nkblks does not
 * include the peeled block
 */
   if (K >= kb)
   {
      nkblks = K/kb;
      kb0 = K - nkblks * kb;
      if (!kb0)
      {
         kb0 = kb;
         nkblks--;
      }
      else
      {
         if (kb0 < 4)
         {
            kb0 += kb;
            nkblks--;
         }
      }
   }
   else /* K < nb */
   {
      kb0 = K;
      nkblks = 0;
   }
   #if ATL_AMM_MAXKMAJ > 1
      if (ATL_AMMFLG_KMAJOR(mminfo.flag))
      {
         KK = ((K+ku-1)/ku)*ku;
         kb0U = ((kb0+ku-1)/ku)*ku;
         if (ATL_AMMFLG_KRUNTIME(mminfo.flag))
            amm_b0 = mminfo.amm_b0;
         else
            amm_b0 = (mminfo.kb == kb0U) ?  mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
      else
      {
         KK = K;
         kb0U = kb0;
         amm_b0 = (kb0 == mminfo.kb || 
                   (KRUN && kb0 >= mminfo.kbmin && (kb0/ku)*ku == kb0)) ?  
                  mminfo.amm_b0 : mminfo.amm_k1_b0;
      }
   #else
      amm_b0 = (kb0 == mminfo.kb || 
                (KRUN && kb0 >= mminfo.kbmin && (kb0/ku)*ku == kb0)) ?  
               mminfo.amm_b0 : mminfo.amm_k1_b0;
   #endif
   if (amm_b0 == mminfo.amm_b0)
   {
      amm_b1K = amm_b1;
      amm_bnK = amm_bn;
   }
   else
   {
      amm_b1K = mminfo.amm_k1_b1;
      amm_bnK = mminfo.amm_k1_bn;
   }
   szA = (nmblks*mb+MBF)*KK; /* wrkspc for all of A wt M rounded up to MU*/
   j = Mmax(NB, NBF);
   i = Mmax(MBF, mb);
   szC = i*j;
   szB = KK*j;                     /* workspace for panel of B */

   k = ATL_MulBySize(szA+szB+szC+mu*nu*ku) + 3*ATL_Cachelen;
   if (k > ATL_MaxMalloc)
      return(2);
   vp = malloc(k);
   if (!vp)
      return(1);
   wB0 = wB = ATL_AlignPtr(vp);
   wA = wB + szB + szB;
   wA0 = wA = ATL_AlignPtr(wA);
   wC = wA + szA + szA;
   wC = ATL_AlignPtr(wC);
   rC = wC + szC;

   if (TA == AtlasNoTrans)
   {
      incAm = mb SHIFT;
      incAk0 = kb0*lda SHIFT;
      incAk = kb*lda SHIFT;
   }
   else
   {
      incAm = mb*lda SHIFT;
      incAk0 = kb0 SHIFT;
      incAk = kb SHIFT;
   }
   if (TB == AtlasNoTrans)
   {
      incBk0 = kb0 SHIFT;
      incBk = kb SHIFT;
      incBn = NB*ldb SHIFT;
   }
   else
   {
      incBk0 = kb0*ldb SHIFT;
      incBk = kb*ldb SHIFT;
      incBn = NB SHIFT;
   }
   incCn = ldc*NB SHIFT;

   for (j=0; j < nnblks; j++)
   {
      size_t nb, nbsz, incwB, incwB0, nnu;
      const TYPE *Bn = B+incBn;
      TYPE *Cn = C + incCn;
      if (j != nnblks-1)
      {
         nbsz = nb = NB;
         nnu = nnu0;
      }
      else
      {
         nb = nbF;
         nbsz = NBF;
         nnu = nnuF;
      }
      incwB = nbsz*kb;
      incwB0 = nbsz*kb0U;
/*
 *    Do all M-blocks except final one, which may be of differing size & partial
 */
      for (i=0; i < nmblks; i++)
      {
         TYPE *wAn, *wBn;
         const TYPE *An = A+incAm;
/*
 *       Peel first K it to handle K-cleanup and set BETA=0
 */
         wAn = wA+mb*kb0U;
         wBn = wB+incwB0;
         if (!j)
            a2blk(kb0, mb, alpA, A, lda, wAn, wA);
         if (!i)
            b2blk(kb0, nb, alpB, B, ldb, wBn, wB);
         amm_b0(nmu, nnu, kb0U, wA, wB, rC, wAn, wB, wC);
         amm_b0(nmu, nnu, kb0U, wAn, wB, wC, wAn, wBn, rC);
         amm_bnK(nmu, nnu, kb0U, wAn, wBn, rC, wA, wBn, wC);
         wB = wBn+incwB0;
         wAn += mb*kb0U;
         amm_b1K(nmu, nnu, kb0U, wA, wBn, wC, wAn, wB, rC);
         wA = wAn;
         A += incAk0;
         B += incBk0;
/*
 *       If first K-block not the only K-block
 */
         if (nkblks)
         {
            for (k=nkblks-1; k; k--)
            {
               wAn = wA+incwA;
               wBn = wB+incwB;
               if (!j)
                  a2blk(kb, mb, alpA, A, lda, wAn, wA);
               if (!i)
                  b2blk(kb, nb, alpB, B, ldb, wBn, wB);
               amm_bn(nmu, nnu, kb, wA, wB, rC, wAn, wB, wC);
               amm_b1(nmu, nnu, kb, wAn, wB, wC, wAn, wBn, rC);
               amm_bn(nmu, nnu, kb, wAn, wBn, rC, wAn, wB, wC);
               wAn += incwA;
               wB = wBn + incwB;
               amm_b1(nmu, nnu, kb, wA, wBn, wC, wAn, wB, rC);
               wA = wAn;
               A += incAk;
               B += incBk;
            }
/*
 *          Last K-block peeled to change prefetch pattern
 */
            wAn = wA+incwA;
            wBn = wB+incwB;
            if (!j)
               a2blk(kb, mb, alpA, A, lda, wAn, wA);
            if (!i)
               b2blk(kb, nb, alpB, B, ldb, wBn, wB);
            amm_bn(nmu, nnu, kb, wA, wB, rC, wAn, wB, wC);
            amm_b1(nmu, nnu, kb, wAn, wB, wC, wAn, wBn, rC);
            amm_bn(nmu, nnu, kb, wAn, wBn, rC, wAn, wB, wC);
            wAn += incwA;
            amm_b1(nmu, nnu, kb, wA, wBn, wC, wAn, wB0, rC);
            wA = wAn;
            wB = wB0;
         }
         blk2c(mb, nb, alpC, rC, wC, beta, C, ldc);
         A = An;
         B = B0;
         wB = wB0;
         C += mb+mb;
      }
/*
 *    Do the final peeled M-block, which is of non-constant size mbF
 */
      {
         TYPE *wAn, *wBn;
/*
 *       Peel first K it to handle K-cleanup and set BETA=0
 */
         wAn = wA+MBF*kb0U;
         wBn = wB+incwB0;
         if (!j)
            a2blk(kb0, mbF, alpA, A, lda, wAn, wA);
         if (!i)
            b2blk(kb0, nb, alpB, B, ldb, wBn, wB);
         amm_b0(nmuF, nnu, kb0U, wA, wB, rC, wAn, wB, wC);
         amm_b0(nmuF, nnu, kb0U, wAn, wB, wC, wAn, wBn, rC);
         amm_bnK(nmuF, nnu, kb0U, wAn, wBn, rC, wAn, wB, wC);
         wAn += MBF*kb0U;
         wB = wBn + incwB0;
         amm_b1K(nmuF, nnu, kb0U, wA, wBn, wC, nkblks?wAn:wA, wB, rC);
         wA = wAn;
         A += incAk0;
         B += incBk0;
/*
 *       If first K-block not the only K-block
 */
         if (nkblks)
         {
            for (k=nkblks-1; k; k--)
            {
               wAn = wA+MBF*kb;
               wBn = wB+incwB;
               if (!j)
                  a2blk(kb, mbF, alpA, A, lda, wAn, wA);
               if (!i)
                  b2blk(kb, nb, alpB, B, ldb, wBn, wB);
               amm_bn(nmuF, nnu, kb, wA, wB, rC, wAn, wB, wC);
               amm_b1(nmuF, nnu, kb, wAn, wB, wC, wAn, wBn, rC);
               amm_bn(nmuF, nnu, kb, wAn, wBn, rC, wAn, wB, wC);
               wAn += MBF*kb;
               wB = wBn + incwB;
               amm_b1(nmuF, nnu, kb, wA, wBn, wC, wAn, wB, rC);
               wA = wAn;
               A += incAk;
               B += incBk;
            }
/*
 *          Last K-block peeled to change prefetch pattern
 */
            wAn = wA+MBF*kb;
            wBn = wB+incwB;
            if (!j)
               a2blk(kb, mbF, alpA, A, lda, wAn, wA);
            if (!i)
               b2blk(kb, nb, alpB, B, ldb, wBn, wB);
            amm_bn(nmuF, nnu, kb, wA, wB, rC, wAn, wB, wC);
            amm_b1(nmuF, nnu, kb, wAn, wB, wC, wAn, wBn, rC);
            amm_bn(nmuF, nnu, kb, wAn, wBn, rC, wAn, wB, wC);
            amm_b1(nmuF, nnu, kb, wA, wBn, wC, wA0, wB0, rC);
            wA = wA0;
            wB = wB0;
         }
         blk2c(mbF, nb, alpC, rC, wC, beta, C, ldc);
      }  /* end M-peel */
      wA = wA0;
      wB = wB0;
      B = B0 = Bn;
      C = Cn;
   }
   free(vp);
   return(0);
}
@ROUT peaktim
#include "atlas_misc.h"
#include <assert.h>

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -n <spclen>: workspace to pass\n");
   fprintf(stderr, "   -I <its> : iterations to pass\n");
   fprintf(stderr, "   -# <ntimes> : set # of times to time kernel\n");
   exit(ierr ? ierr : -1);
}
size_t GetFlags(int nargs, char **args, size_t *N, int *NREP)
{
   size_t nits = 10000;
   int i;

   *N = 128;
   *NREP = 3;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'I':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         nits = atoll(args[i]);
         break;
      case 'n':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *N = atoll(args[i]);
         break;
      case '#':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *NREP = atoi(args[i]);
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   return(nits);
}

double ATL_walltime(void);
void RunKern(size_t nits, void *vp);

int main (int nargs, char **args)
{
   size_t n, nits, i, ifl;
   double t0, mf, mfB;
   void *vp;
   char *cp;
   size_t *lp;
   int nrep;

   nits = GetFlags(nargs, args, &n, &nrep);
   vp = malloc(n+32);
   cp = ATL_AlignPtr(vp);
   lp = (size_t*)cp;
   for (i=0; i < n; i++)
      cp[i] = 0;

   mfB=0;
   for (i=0; i < nrep; i++)
   {
      t0 = ATL_walltime();
      RunKern(nits, (void*)cp);
      t0 = ATL_walltime() - t0;
      ifl = lp[0];
      mf = (((double)ifl)*nits) / (t0 * 1.0e6);
      if (mf > mfB)
         mfB = mf;
      printf("MFLOPS=%.2f\n", mf);
   }
   printf("\nBEST = %.2f\n\n", mfB);

   free(vp);
   return(0);
}
@ROUT cm2amtst
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "atlas_misc.h"

void cm2am_tst
(
   ATL_CSZT K,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *pA,            /* OUTPUT: access-major block holding real(A) */
   int nu
)
{
   ATL_CINT nfblks = (N/nu), NNU=nfblks*nu, nr = N-NNU;
   for (j=0; j < NNU; j += nu)
   {
      for (k=0; k < k++)
      {
         for (i=0; i < nu; i++)
            *pA++ = A[(j+i)*lda+k]
      }
   }
   for (; j < N; j++)
   {
      for (k=0; k < k++)
      {
         for (i=0; i < nr; i++)
            *pA++ = A[(j+i)*lda+k]
         for (; i < nu; i++)
            *pA++ = ATL_rzero;
      }
   }
}

void InitEntryArray(int M, int N, TYPE *A, int lda)
{
   int i, j;
   for (j=0; j < N; j++)
   {
      for (i=0; i < lda; i++)
         A[i] = lda*j+i;
   }
   
}

main(int nargs, char **args)
{
   int M=12, N=10, lda=14, align=16, maxalign=32, mu=5, k, ierr=0;
   TYPE *A, *pA0, *pA1;
   TYPE alpha = 1.0;
   A = malloc(((2*M+lda)*N + 2*maxalign);
   assert(A);
   pA0 = A + lda*N;
   pA1 = pA0 + M*N;
   assert(maxalign > align);
   pA1 = (TYPE*)((((size_t)pA1)+maxalign-1)/maxalign)*maxalign;
   if (align)
      pA1 = (TYPE*)((size_t)pA1 + align);
   cm2am_tst(N, M, alpha, A, lda, pA0, mu);
   ATL_UCM2AM(N, M, alpha, A, lda, pA1);
   for (k=0; k < M*N; k++)
   {
      if (pA0[i] != pA1[i])
      {
         int i, j, jmu;
         jmu = k / (M*mu);
         j = k - (jmu*M*mu);
         i = j / mu;
         j = j % mu;
         if (pA0[i] != alpha*A[j*lda+i])
         {
            printf(
               "TEST COPY OR INDEX CALC WRONG: pA0[%d] != A[%d,%d] (%g, %g)\n"
                   k, i, j, pA0[i] != A[j*lda+i]);
            return(k+1);
         }
         printf("pA[%d] ([%d,%d] of matrix): expected=%g (%g), got=%g\n",
                i, i, j, pA0[i], A[j*lda+i], pA1[i]);
         ierr++;
      }
   }
   if (!ierr)
      printf("PASSED.\n");
   else
      printf("FAILED: %d\n", ierr);
   return(ierr);
}

@ROUT ATL_GetAmmAlg.c
#include "atlas_amm.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_blk.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_ablk2cmat.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_a1.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_an.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_aX.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_flag.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_kern.h))

void GetAmmNMKDetails
(
/*
 * Input parameters describing problem; for now, don't use A/B/C, but might
 * be important to find aliasing later!
 */
   const enum ATLAS_TRANS TA,
   const enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   const TYPE *C,
   ATL_CSZT ldc
/*
 * Output params
 */
   ATL_SZT *mb, ATL_SZT *nb, ATL_SZT *kb,
   int *mu, int *nu, int *ku,
   ammkern_t *amm_b0, ammkern_t *amm_b1, ammkern_t *amm_bn, 
   cm2am_t *a2blk, *b2blk, ablk2cmat_t *blk2c
)
{

   if (SCALAR_IS_ONE(alpha))
   {
      if (SCALAR_IS_ONE(beta))
         *blk2c = ATL_AMM_BLK2C_a1_b1[IK];
      else if (SCALAR_IS_NONE(beta))
         *blk2c = ATL_AMM_BLK2C_a1_bn[IK];
      else if (SCALAR_IS_ZERO(beta))
         *blk2c = ATL_AMM_BLK2C_a1_b0[IK];
      else
         *blk2c = ATL_AMM_BLK2C_a1_bX[IK];
   }
   else if (alpha == ATL_rnone)
   {
      if (SCALAR_IS_ONE(beta))
         *blk2c = ATL_AMM_BLK2C_an_b1[IK];
      else if (SCALAR_IS_NONE(beta))
         *blk2c = ATL_AMM_BLK2C_an_bn[IK];
      else if (SCALAR_IS_ZERO(beta))
         *blk2c = ATL_AMM_BLK2C_an_b0[IK];
      else
         *blk2c = ATL_AMM_BLK2C_an_bX[IK];
   }
   else
   {
      if (beta == ATL_rone)
         *blk2c = ATL_AMM_BLK2C_aX_b1[IK];
      else if (beta == ATL_rnone)
         *blk2c = ATL_AMM_BLK2C_aX_bn[IK];
      else if (beta == ATL_rzero)
         *blk2c = ATL_AMM_BLK2C_aX_b0[IK];
      else
         *blk2c = ATL_AMM_BLK2C_aX_bX[IK];
   }
}
enum ATL_AMMALG ATL_GetAmmAlg
(
   const enum ATLAS_TRANS TA,
   const enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   const TYPE *C,
   ATL_CSZT ldc
{
   enum ATL_AMMALG ret=ATL_NMK;

   if (M <= ATL_AMM_MAXMB && N <= ATL_AMM_MAXNB && K <= ATL_AMM_MAXKB)
      ret = ATL_amm1b;
   else if (K <= ATL_RKK_MAXKB)  /* must create this! */
      ret = ATL_ammrkK;
   return(ret);
}
@ROUT genMM
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
enum VECEXT {VEC_None=0, VEC_VSX, VEC_AV, VEC_AVXMAC, VEC_AVXFMA4, VEC_AVX, 
             VEC_SSE3, VEC_SSE2, VEC_SSE1}
typedef enum VECEXT vec_t;
enum STRG {bcastB=0, kmaj};
typedef enum STRG strg_t;

char *typ = "double", *vtyp, *bcast, *mul, *add, *sub, *vld, *vst;
int VLEN, CL;
strg_t STRG=bcastB;

int GetVeclen(char pre, vec_t vec)
{
   int vlen;
   switch(vec)
   {
   case VEC_AVXMAC:
   case VEC_AVXFMA4:
   case VEC_AVX:
      vlen = 8;
      break;
   case VEC_VSX:
   case VEC_AV:
   case VEC_SSE3:
   case VEC_SSE2:
   case VEC_SSE1:
      vlen = 4;
      break;
   default:
      vlen = 1;
   }
   if (pre == 'd' && vlen > 1)
      vlen >>= 1;
}
void SetVecInfo(char pre, vec_t vec)
{
   VLEN = GetVeclen(pre, vec);
   if (pre == 'd')
   {
      switch(vec)
      {
      case VEC_AVXMAC:
      case VEC_AVXFMA4:
      case VEC_AVX:
         vtyp = "__m256d";
         bcast = "_mm256_broadcast_sd";
         mul = "_mm256_mul_pd";
         add = "_mm256_add_pd";
         sub = "_mm256_sub_pd";
         vld = "_mm256_load_pd";
         vst = "_mm256_store_pd";
         vlen = 4;
         break;
      case VEC_VSX:
      case VEC_AV:
      case VEC_SSE3:
      case VEC_SSE2:
      case VEC_SSE1:
         vlen = 4;
         break;
      default:
         vlen = 1;
      }
   }
   else
   {
   }
}
void PrintDecl(FILE *fp)
{
   fprintf(fp, "void ATL_USERMM(ATL_CSZT nmus, ATL_CSZT nnus, ATL_CSZT K,\n");
   fprintf(fp, "                const %s *pA, const %s *pB, %s *pC,\n",
           typ, typ, typ);
   fprintf(fp, "                const %s *pAn, const %s *pBn, const %s *pCn)\n",
           typ, typ, typ);
}
void DoKloop(FILE *fp, char pre, vec_t vec, int kmaj, int kb, 
             int mu, int nu, int ku)
{
   if (kmaj)
   {
      assert(kmaj == VLEN)
      assert(ku%kmaj == 0);
   }
   if (kb)
   {
      assert(kb%ku == 0);
      if (kb > ku)
         fprintf(fp, "      for (k=%d; k < %d; k += %d\n", ku, kb, ku);
   }
   else
      fprintf(fp, "      for (k=%d; k < K; k += %d\n", ku, ku);
   fprintf(fp,    "      {\n");
   fprintf(fp,    "      } /* end of K-loop */ \n");
}
void genMM(FILE *fp, char pre, vec_t vec, int kmaj, int kb, 
           int mu, int nu, int ku)
{
   int i, j;
   int incb = (kmaj) ? kmaj : 1;
   int ia=0, ib=0;
   char *Bld = (kmaj) ? "vld" : "bcast";

   if (kb && ku+ku >= kb)
      ku = kb;
   else
      ku = 0;

   fprintf(fp, "#include <atlas_simd.h>\n\n");
   PrintDecl(fp);
   fprintf(fp, "/*\n");
   fprintf(fp, 
" * Access-major matmul with: pre=%c, KMAJ=%d, kb=%d, mu=%d, nu=%d\n",
           pre, kmaj, kb, mu, nu);
   fprintf(fp, " */\n");
   fprintf(fp, "{\n");
   fprintf(fp, "   size_t i, j, k, incPF\n");
   if (kb)
      fprintf(fp, "   #define incA %d\n", mu*kb);
   else
      fprintf(fp, "   const size_t incA = K*%d\n", mu);
   fprintf(fp, "   const %s *pB0=pB;\n", typ);
   fprintf(fp, "   register ATL_VTYP rA0");
   for (j=1; j < nu; j++)
      fprintf(fp, ", rA%d", j);
   fprintf(fp, ";\n");
   fprintf(fp, "   register ATL_VTYP rB0");
   for (j=1; j < mu; j++)
      fprintf(fp, ", rB%d", j);
   fprintf(fp, ";\n");
   fprintf(fp, "   register ATL_VTYP rC0_0");
   for (j=0; j < nu; j++)
      for (i=0; i < mu; i++)
         if (i | j)
            fprintf(fp, ", rC%d_%d", i, j);
   fprintf(fp, ";\n");
   fprintf(fp, "\n");
   fprintf(fp, "   for (i=0; i < nmus; i++, pA += incA)\n   {\n");
   fprintf(fp, "      const %s *a=pA;\n");
   fprintf(fp, "      for (j=0; j < nnus; j++)\n      {\n");
/*
 * Rewrite to peel X its in order to schedule loads & prefetches, then
 * start loop; will have specialized routines for each case
 */
   fprintf(fp, "/*\n *         K=0 it peeled to zero rCx_x\n */\n");
   for (j=0; j < nu; j++)
      fprintf(fp, "         ATL_v%s(rB%d, pB+%d);\n", Bld, j, j*incb);
   if (!ku)
      fprintf(fp, "         pB += %d;\n", nu*incb);
   else 
      ib += nu*incb;
   for (i=0; i < mu; i++)
      fprintf(fp, "         ATL_vld(rA%d, a+%d);\n", i, i*VLEN);
   if (!ku)
      fprintf(fp, "         pA += %d;\n", VLEN*mu);
   else 
      ia += VLEN*mu;

   for (j=0; j < nu; j++)
   {
      for (i=0; i < mu; i++)
      {
         fprintf(fp, "         ATL_vmul(rC%d_%d, rA%d, rB%d);\n",
                 i, j, i, j);
         if (j==nu-1)
            fprintf(fp, "         ATL_vld(rA%d, a+%d);\n", i, ia+i*VLEN);
      }
      if (j != nu-1)
         fprintf(fp, "         ATL_v%s(rB%d, pB+%d);\n", Bld, j, ib+j*incb);
   }
   if (kb && ku+ku > kb) /* fully unrolled K loop */
   {
      fprintf(fp, "         ATL_v%s(rB0, pB+%d);\n", Bld, nu*incb);
      for (k=VLEN; k < kb; k += VLEN)
      {
         fprintf(fp, "/*\n *         K=%d iteration\n */\n");
      }
   }
   else
   {
      if (kmaj)
      {
         if (kb)
            fprintf(fp, "         for (k=%d; k < %d; k += %d)\n         {\n",
                    VLEN, kb, VLEN);
         else
            fprintf(fp, "         for (k=%d; k < K; k += %d)\n         {\n",
                    VLEN, VLEN);
      }
      else
      {
         fprintf(fp, "         for (k=1; k < K; k++)\n         {\n");
      }
      fprintf(fp, "         }  /* end K-loop */\n");
   }
   fprintf(fp, "         a += %d;\n", mu*VLEN);
   fprintf(fp, "         pB += %d;\n", nu*incb);

   fprintf(fp, "      } /* end j-loop */\n");
   fprintf(fp, "      pB = pB0;\n");
   fprintf(fp, "   } /* end i-loop */\n");

   
   fprintf(fp, "}\n");
   if (kb)
      fprintf(fp, "#undef incA\n");
}
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr, 
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -o <outfile>: path & file to generate\n");
   fprintf(stderr, "   -U[m,n,k]: set unrolling factor\n");
   fprintf(stderr, "   -V [sse1,sse2,sse3,avx,fma3,fma4,ppcav,vsx]\n");
   fprintf(stderr, "   -K # : non-zero number is fixed K loop\n");
   fprintf(stderr, "   -S [B,K]: storage bcastB/KU-major\n");
}

FILE *GetFlags(char *PRE, vec_t *VEC, int *KMAJ, int *KB, 
               int *MU, int *NU, int *KU)
{
   FILE *fpout=stdout;
   *PRE = 'd';
   *VEC = VEC_SSE3;
   *KMAJ = *KB = 0;
   *MU = *NU = 3;
   *KU = 1;
}
int main(int nargs, char **args)
{
   char pre='d';
   int mu, nu, ku, kb;
   FILE *fpout;
   vec_t vec;
   
   fpout = GetFlags(&pre, &vec, &kb, &kmaj, &mu, &nu, &ku);
   if (pre == 's')
      typ = "float";
   genMM(pre, vec, kmaj, kb, mu, nu, ku);
}
@ROUT ATL_GetRankKInfo
#include "atlas_misc.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_rankK.h))
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_rkkblk.h))
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_rkkflag.h))

int Mjoin(PATL,GetRankKInfo)
(
   amminfo_t *out,
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const SCALAR beta
)
{
   const int ik = K-3;
   int appAl;  /* 0:A, 1:B */
   ATL_assert(K > 2 && K <= ATL_MAXK_RKK);
@ROUT ATL_tGetSyammInfo
#include "atlas_misc.h"
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_blk.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_ablk2cmat.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_a1.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_an.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_aX.h))
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_flag.h))
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_kern.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_sum.h))

ablk2cmat_t Mjoin(PATL,tGetSyammInfo)
(
   amminfo_t *out,
   const int P,          /* scale you want to use */
   enum ATLAS_TRANS TA,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const SCALAR beta
)
{
   ablk2cmat_t dblk2cmat;
   #ifdef ATL_CAMM_MAXINDX
      int ik=ATL_CAMM_MAXINDX;
   #else
      int ik=ATL_AMM_98IDX;
   #endif
   int nb, k;
   if (K < ATL_AMM_MAXKB)  
   {
      for (ik=0; ik < ATL_AMM_NCASES && ATL_AMM_KBs[ik] < K; ik++);
   }
   ik=0;
   out->IDX = ik;
   out->mu = ATL_AMM_MUs[ik];
   out->nu = ATL_AMM_NUs[ik];
   out->ku = ATL_AMM_KUs[ik];
   nb = ATL_AMM_MBs[ik];
   nb = Mmax(nb, ATL_AMM_NBs[ik]);
   k = ATL_lcm(out->mu, out->nu);
   nb = (nb > k) ? (nb/k)*k : k;
   out->nb = out->mb = nb;
   out->kb = ATL_AMM_KBs[ik];
   out->kbmin = ATL_AMM_KBMINs[ik];
   out->flag = ATL_AMM_KFLAG[ik];
   out->amm_b0 = ATL_AMM_KERN_b0[ik];
   out->amm_b1 = ATL_AMM_KERN_b1[ik];
   out->amm_bn = ATL_AMM_KERN_bn[ik];
   out->amm_k1_b0 = ATL_AMM_KERN_K1[ik];
   out->amm_k1_b1 = ATL_AMM_KERN_K1_b1[ik];
   out->amm_k1_bn = ATL_AMM_KERN_K1_bn[ik];
   if (TA == AtlasNoTrans)
   {
      out->a2blk = ATL_AMM_AT2BLK_a1[ik];
      out->b2blk =  ATL_AMM_BT2BLK_a1[ik];
   }
   else
   {
      out->a2blk = ATL_AMM_A2BLK_a1[ik];
      out->b2blk =  ATL_AMM_B2BLK_a1[ik];
   }
   if (SCALAR_IS_ONE(alpha))
   {
      dblk2cmat = ATL_AMM_BLK2C_a1_b0[ik];
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_b1[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_bn[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_b0[ik];
      else
         out->Cblk2cm = ATL_AMM_BLK2C_a1_bX[ik];
   }
   else if (SCALAR_IS_NONE(alpha))
   {
      dblk2cmat = ATL_AMM_BLK2C_an_b0[ik];
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_an_b1[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_an_bn[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_an_b0[ik];
      else
         out->Cblk2cm = ATL_AMM_BLK2C_an_bX[ik];
   }
   else  /* alpha = X */
   {
      dblk2cmat = ATL_AMM_BLK2C_aX_b0[ik];
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_aX_b1[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_aX_bn[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_aX_b0[ik];
      else
         out->Cblk2cm = ATL_AMM_BLK2C_aX_bX[ik];
   }
   return(dblk2cmat);
}

@ROUT ATL_GetAmmmInfo
#include "atlas_misc.h"
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_blk.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_ablk2cmat.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_a1.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_an.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_aX.h))
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_flag.h))
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_kern.h))

int Mjoin(PATL,GetAmmmInfo)
(
   amminfo_t *out,
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const SCALAR beta
)
{
   #ifdef ATL_CAMM_MAXINDX
      int ik=ATL_CAMM_MAXINDX;
   #else
      int ik=ATL_AMM_NCASES-1; 
   #endif
   int appAl;  /* 0:A, 1:B, 2:C */
/*
 * For rank-K update, choose smallest KB that contains required K
 */
   if (K < ATL_AMM_MAXKB)  
   {
      for (ik=0; ik < ATL_AMM_NCASES && ATL_AMM_KBs[ik] < K; ik++);
   }
@ROUT ATL_GetAmmmInfo ATL_GetRankKInfo
   out->IDX = ik;
   out->mb = ATL_AMM_MBs[ik];
   out->nb = ATL_AMM_NBs[ik];
   out->kb = ATL_AMM_KBs[ik];
   #ifdef ATL_CAMM_MAXINDX
      if (ik == ATL_CAMM_MAXINDX)
      {
         out->mb = ATL_CAMM_MAXMB;
         out->nb = ATL_CAMM_MAXNB;
         out->kb = ATL_CAMM_MAXKB;
      }
   #endif
   out->kbmin = ATL_AMM_KBMINs[ik];
   out->mu = ATL_AMM_MUs[ik];
   out->nu = ATL_AMM_NUs[ik];
   out->ku = ATL_AMM_KUs[ik];
   out->flag = ATL_AMM_KFLAG[ik];
@ROUT ATL_GetAmmmInfo
   out->amm_b0 = ATL_AMM_KERN_b0[ik];
   out->amm_b1 = ATL_AMM_KERN_b1[ik];
   out->amm_bn = ATL_AMM_KERN_bn[ik];
   out->amm_k1_b0 = ATL_AMM_KERN_K1[ik];
   out->amm_k1_b1 = ATL_AMM_KERN_K1_b1[ik];
   out->amm_k1_bn = ATL_AMM_KERN_K1_bn[ik];
   @define pf @ATL_AMM_@
@ROUT ATL_GetRankKInfo
   out->amm_b0 = ATL_AMM_KERN_RKK[ik];
   out->amm_b1 = ATL_AMM_KERN_RKK_b1[ik];
   out->amm_bn = ATL_AMM_KERN_RKK_bn[ik];
   @define pf @ATL_RKK_@
@ROUT ATL_GetAmmmInfo ATL_GetRankKInfo
/*
 * Apply alpha to smallest matrix, and use alpha/beta to pick copy routines
 */
   if (SCALAR_IS_ONE(alpha))
   {
      appAl = 0;
      #ifdef TCPLX
         if (TA == AtlasNoTrans)
            out->a2blk = @(pf)AT2BLK_a1[ik];
         else if (TA == AtlasTrans)
            out->a2blk = @(pf)A2BLK_a1[ik];
         else if (TA == AtlasConjTrans)
            out->a2blk = @(pf)AC2BLK_a1[ik];
         else
            out->a2blk = @(pf)AH2BLK_a1[ik];
         if (TB == AtlasNoTrans)
             out->b2blk = @(pf)B2BLK_a1[ik];
         else if (TB == AtlasTrans)
             out->b2blk = @(pf)BT2BLK_a1[ik];
         else if (TB == AtlasConjTrans)
             out->b2blk = @(pf)BH2BLK_a1[ik];
         else
             out->b2blk = @(pf)BC2BLK_a1[ik];
      #else
         out->a2blk = (TA == AtlasNoTrans) ?
            @(pf)AT2BLK_a1[ik]:@(pf)A2BLK_a1[ik];
         out->b2blk = (TB == AtlasNoTrans) ?
            @(pf)B2BLK_a1[ik]:@(pf)BT2BLK_a1[ik];
      #endif
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = @(pf)BLK2C_a1_b1[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = @(pf)BLK2C_a1_b0[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = @(pf)BLK2C_a1_bn[ik];
      else
         out->Cblk2cm = @(pf)BLK2C_a1_bX[ik];
   }
   else  /* alpha is not one */
   {
@ROUT ATL_GetRankKInfo
      appAl = (M >= N) ? 1:0;
@ROUT ATL_GetAmmmInfo
      if (M >= N)                  /* A is larger than B, put alpha on C or B */
         appAl = (M >= K) ? 2 : 1;
      else                         /* B is larger than A, put alpha on C or A */
         appAl = (N >= K) ? 2 : 0;
      if (appAl == 2)  /* apply alpha to C */
      {
         #ifdef TCPLX
            if (TA == AtlasNoTrans)
               out->a2blk = @(pf)AT2BLK_a1[ik];
            else if (TA == AtlasTrans)
               out->a2blk = @(pf)A2BLK_a1[ik];
            else if (TA == AtlasConjTrans)
               out->a2blk = @(pf)AC2BLK_a1[ik];
            else
               out->a2blk = @(pf)AH2BLK_a1[ik];
            if (TB == AtlasNoTrans)
                out->b2blk = @(pf)B2BLK_a1[ik];
            else if (TB == AtlasTrans)
                out->b2blk = @(pf)BT2BLK_a1[ik];
            else if (TB == AtlasConjTrans)
                out->b2blk = @(pf)BH2BLK_a1[ik];
            else
                out->b2blk = @(pf)BC2BLK_a1[ik];
         #else
            out->a2blk = (TA == AtlasNoTrans) ?
                         @(pf)AT2BLK_a1[ik] : @(pf)A2BLK_a1[ik];
            out->b2blk = (TB == AtlasNoTrans) ?
                         @(pf)B2BLK_a1[ik] : @(pf)BT2BLK_a1[ik];
         #endif
         if (SCALAR_IS_ONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           @(pf)BLK2C_an_b1[ik] : @(pf)BLK2C_aX_b1[ik];
         else if (SCALAR_IS_ZERO(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           @(pf)BLK2C_an_b0[ik] : @(pf)BLK2C_aX_b0[ik];
         else if (SCALAR_IS_NONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           @(pf)BLK2C_an_bn[ik] : @(pf)BLK2C_aX_bn[ik];
         else
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           @(pf)BLK2C_an_bX[ik] : @(pf)BLK2C_aX_bX[ik];
      }
      else  /* not applying alpha to C */
      {
      @beginindent 1 3
@ROUT ATL_GetAmmmInfo ATL_GetRankKInfo
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = @(pf)BLK2C_a1_b1[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = @(pf)BLK2C_a1_b0[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = @(pf)BLK2C_a1_bn[ik];
      else
         out->Cblk2cm = @(pf)BLK2C_a1_bX[ik];
      if (!appAl)  /* apply to alpha to A */
      {
         #ifdef TCPLX
            if (TB == AtlasNoTrans)
                out->b2blk = @(pf)B2BLK_a1[ik];
            else if (TB == AtlasTrans)
                out->b2blk = @(pf)BT2BLK_a1[ik];
            else if (TB == AtlasConjTrans)
                out->b2blk = @(pf)BH2BLK_a1[ik];
            else
                out->b2blk = @(pf)BC2BLK_a1[ik];
            if (SCALAR_IS_NONE(alpha))
            {
               if (TA == AtlasNoTrans)
                  out->a2blk = @(pf)AT2BLK_an[ik];
               else if (TA == AtlasTrans)
                  out->a2blk = @(pf)A2BLK_an[ik];
               else if (TA == AtlasConjTrans)
                  out->a2blk = @(pf)AC2BLK_an[ik];
               else
                  out->a2blk = @(pf)AH2BLK_an[ik];
            }
            else
            {
               if (TA == AtlasNoTrans)
                  out->a2blk = @(pf)AT2BLK_aX[ik];
               else if (TA == AtlasTrans)
                  out->a2blk = @(pf)A2BLK_aX[ik];
               else if (TA == AtlasConjTrans)
                  out->a2blk = @(pf)AC2BLK_aX[ik];
               else
                  out->a2blk = @(pf)AH2BLK_aX[ik];
            }
         #else
            if (SCALAR_IS_NONE(alpha))
               out->a2blk = (TA == AtlasNoTrans) ?
                            @(pf)AT2BLK_an[ik] : @(pf)A2BLK_an[ik];
            else
               out->a2blk = (TA == AtlasNoTrans) ?
                            @(pf)AT2BLK_aX[ik] : @(pf)A2BLK_aX[ik];
            out->b2blk = (TB == AtlasNoTrans) ?
                         @(pf)B2BLK_a1[ik] : @(pf)BT2BLK_a1[ik];
         #endif
      }
      else /* apply alpha to B */
      {
         #ifdef TCPLX
            if (TA == AtlasNoTrans)
               out->a2blk = @(pf)AT2BLK_a1[ik];
            else if (TA == AtlasTrans)
               out->a2blk = @(pf)A2BLK_a1[ik];
            else if (TA == AtlasConjTrans)
               out->a2blk = @(pf)AC2BLK_a1[ik];
            else
               out->a2blk = @(pf)AH2BLK_a1[ik];
            if (SCALAR_IS_NONE(alpha))
            {
               if (TB == AtlasNoTrans)
                   out->b2blk = @(pf)B2BLK_an[ik];
               else if (TB == AtlasTrans)
                   out->b2blk = @(pf)BT2BLK_an[ik];
               else if (TB == AtlasConjTrans)
                   out->b2blk = @(pf)BH2BLK_an[ik];
               else
                   out->b2blk = @(pf)BC2BLK_an[ik];
            }
            else
            {
               if (TB == AtlasNoTrans)
                   out->b2blk = @(pf)B2BLK_aX[ik];
               else if (TB == AtlasTrans)
                   out->b2blk = @(pf)BT2BLK_aX[ik];
               else if (TB == AtlasConjTrans)
                   out->b2blk = @(pf)BH2BLK_aX[ik];
               else
                   out->b2blk = @(pf)BC2BLK_aX[ik];
            }
         #else
            out->a2blk = (TA == AtlasNoTrans) ?
                         @(pf)AT2BLK_a1[ik] : @(pf)A2BLK_a1[ik];
            if (SCALAR_IS_NONE(alpha))
               out->b2blk = (TB == AtlasNoTrans) ?
                            @(pf)B2BLK_an[ik] : @(pf)BT2BLK_an[ik];
            else
               out->b2blk = (TB == AtlasNoTrans) ?
                            @(pf)B2BLK_aX[ik] : @(pf)BT2BLK_aX[ik];
         #endif
      }
@ROUT ATL_GetAmmmInfo 
      @endindent
      }
@ROUT ATL_GetAmmmInfo  ATL_GetRankKInfo 
   }
   return(appAl);
}
@ROUT ATL_GetRankKInfo0000 
/*
 * This function provides an estimate on max number of threads to use to
 * perform a rank-K update.
 */
size_t GetRankKNthr(ATL_CSZT M, ATL_CSZT N, ATL_CSZT K)
{
   size_t nnblks=N/ATL_MAXN_RKK, nmblks=M/ATL_MAXM_RKK;
/*
 * For degenerate cases, require 32 blocks to pay for parallel overhead
 */
   if (N <= ATL_MAXN_RKK)
      return(nmblks>>5);
   if (M <= ATL_MAXM_RKK)
      return(nnblks>>5);
/*
 * In general case, rank-K is bus noisy, so ask that all threads have at least
 * 4 big blocks of C.  On some systems where memory scales poorly this will
 * vastly overestimate, and will underestimate on very good scaling, but
 * very good memory scaling should only occur for low number of cores, where
 * this won't hurt.
 */
   return((nnblks*nmblks)>>2);
}
@ROUT ATL_GetAmmmInfo00
/*
 * This function provides an estimate on max number of threads to use to
 * perform a access-major GEMM.
 */
size_t GetAmmmNthr(ATL_CSZT M, ATL_CSZT N, ATL_CSZT K)
{
   int GetRankNthr(ATL_CSZT M, ATL_CSZT N, ATL_CSZT K);
   size_t nnblks, nmblks, nkblks, p;

   nmblks = (M >= ATL_AMM_66MB) ? M/ATL_AMM_66MB : 1;
   nnblks = (N >= ATL_AMM_66NB) ? N/ATL_AMM_66NB : 1;
   nkblks = (K >= ATL_AMM_66KB) ? K/ATL_AMM_66KB : 1;
/*
 * Any shape with two degenerate dimensions causes a lot of bus traffic,
 * with very little computation to overcome threading overheads,
 * so demand at least 32 blocks before parallelizing
 */
   if ((nmblks==1 && nnblks==1) || (nmblks==1 && nkblks==1) || 
       (nnblks==1 && nkblks==1))
      return((nnblks*nmblks*nkblks)>>5)
/*
 * If it is a rank-K update, ask to have 4 big blocks of C
 */
   if (K <= ATL_MAXM_RKK)
   {
      nnblks=N/ATL_MAXN_RKK, nmblks=M/ATL_MAXM_RKK;
      return((nnblks*nmblks)>>2);
   }
   
/*
 * By default, give everyone 32 blocks to compute; for square problems,
 * the number of blocks is cubic, so this should not meaningfully restrict
 * parallelism.
 */
   return((nmblks*nnblks*nkblks)>>5);
}
@ROUT cnbtune
#include "atlas_misc.h"
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_blk.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_ablk2cmat.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_a1.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_an.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_aX.h))
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_flag.h))
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_kern.h))

static int IK=ATL_AMM_NCASES-1, MB=0, NB=0, KB=0;
#ifdef DCPLX
   static char MY_PRE='z', MY_PRE2='Z';
#elif defined(SCPLX)
   static char MY_PRE='c', MY_PRE2='C';
#elif defined(SREAL)
   static char MY_PRE='s', MY_PRE2='S';
#else
   static char MY_PRE='d', MY_PRE2='D';
#endif
/*
 * This routine overrides normal GetAmmmInfo, so we can tune kernel params
 */
int Mjoin(PATL,GetAmmmInfo)
(
   amminfo_t *out,
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const SCALAR beta
)
{
   int ik=IK, appAl;  /* 0:A, 1:B, 2:C */

   ATL_assert(ik >= 0 && ik < ATL_AMM_NCASES);
   while (K < ATL_AMM_KBs[ik] && ik)
      ik--;
   out->IDX = ik;
   out->mb = (MB) ? MB : ATL_AMM_MBs[ik];
   out->nb = (NB) ? NB : ATL_AMM_NBs[ik];
   out->kb = (KB) ? KB : ATL_AMM_KBs[ik];
   out->kbmin = ATL_AMM_KBMINs[ik];
   out->mu = ATL_AMM_MUs[ik];
   out->nu = ATL_AMM_NUs[ik];
   out->ku = ATL_AMM_KUs[ik];
   out->flag = ATL_AMM_KFLAG[ik];
   out->amm_b0 = ATL_AMM_KERN_b0[ik];
   out->amm_b1 = ATL_AMM_KERN_b1[ik];
   out->amm_bn = ATL_AMM_KERN_bn[ik];
   out->amm_k1_b0 = ATL_AMM_KERN_K1[ik];
   out->amm_k1_b1 = ATL_AMM_KERN_K1_b1[ik];
   out->amm_k1_bn = ATL_AMM_KERN_K1_bn[ik];
/*
 * Apply alpha to smallest matrix, and use alpha/beta to pick copy routines
 */
   if (SCALAR_IS_ONE(alpha))
   {
      appAl = 0;
      #ifdef TCPLX
         if (TA == AtlasNoTrans)
            out->a2blk = ATL_AMM_AT2BLK_a1[ik];
         else if (TA == AtlasTrans)
            out->a2blk = ATL_AMM_A2BLK_a1[ik];
         else if (TA == AtlasConjTrans)
            out->a2blk = ATL_AMM_AC2BLK_a1[ik];
         else
            out->a2blk = ATL_AMM_AH2BLK_a1[ik];
         if (TB == AtlasNoTrans)
             out->b2blk = ATL_AMM_B2BLK_a1[ik];
         else if (TB == AtlasTrans)
             out->b2blk = ATL_AMM_BT2BLK_a1[ik];
         else if (TB == AtlasConjTrans)
             out->b2blk = ATL_AMM_BH2BLK_a1[ik];
         else
             out->b2blk = ATL_AMM_BC2BLK_a1[ik];
      #else
         out->a2blk = (TA == AtlasNoTrans) ?
            ATL_AMM_AT2BLK_a1[ik]:ATL_AMM_A2BLK_a1[ik];
         out->b2blk = (TB == AtlasNoTrans) ?
            ATL_AMM_B2BLK_a1[ik]:ATL_AMM_BT2BLK_a1[ik];
      #endif
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_b1[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_b0[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_bn[ik];
      else
         out->Cblk2cm = ATL_AMM_BLK2C_a1_bX[ik];
   }
   else  /* alpha is not one */
   {
      if (M >= N)                  /* A is larger than B, put alpha on C or B */
         appAl = (M >= K) ? 2 : 1;
      else                         /* B is larger than A, put alpha on C or A */
         appAl = (N >= K) ? 2 : 0;
      if (appAl == 2)  /* apply alpha to C */
      {
         #ifdef TCPLX
            if (TA == AtlasNoTrans)
               out->a2blk = ATL_AMM_AT2BLK_a1[ik];
            else if (TA == AtlasTrans)
               out->a2blk = ATL_AMM_A2BLK_a1[ik];
            else if (TA == AtlasConjTrans)
               out->a2blk = ATL_AMM_AC2BLK_a1[ik];
            else
               out->a2blk = ATL_AMM_AH2BLK_a1[ik];
            if (TB == AtlasNoTrans)
                out->b2blk = ATL_AMM_B2BLK_a1[ik];
            else if (TB == AtlasTrans)
                out->b2blk = ATL_AMM_BT2BLK_a1[ik];
            else if (TB == AtlasConjTrans)
                out->b2blk = ATL_AMM_BH2BLK_a1[ik];
            else
                out->b2blk = ATL_AMM_BC2BLK_a1[ik];
         #else
            out->a2blk = (TA == AtlasNoTrans) ?
                         ATL_AMM_AT2BLK_a1[ik] : ATL_AMM_A2BLK_a1[ik];
            out->b2blk = (TB == AtlasNoTrans) ?
                         ATL_AMM_B2BLK_a1[ik] : ATL_AMM_BT2BLK_a1[ik];
         #endif
         if (SCALAR_IS_ONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_b1[ik] : ATL_AMM_BLK2C_aX_b1[ik];
         else if (SCALAR_IS_ZERO(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_b0[ik] : ATL_AMM_BLK2C_aX_b0[ik];
         else if (SCALAR_IS_NONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_bn[ik] : ATL_AMM_BLK2C_aX_bn[ik];
         else
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_bX[ik] : ATL_AMM_BLK2C_aX_bX[ik];
      }
      else  /* not applying alpha to C */
      {
         if (SCALAR_IS_ONE(beta))
            out->Cblk2cm = ATL_AMM_BLK2C_a1_b1[ik];
         else if (SCALAR_IS_ZERO(beta))
            out->Cblk2cm = ATL_AMM_BLK2C_a1_b0[ik];
         else if (SCALAR_IS_NONE(beta))
            out->Cblk2cm = ATL_AMM_BLK2C_a1_bn[ik];
         else
            out->Cblk2cm = ATL_AMM_BLK2C_a1_bX[ik];
         if (!appAl)  /* apply to alpha to A */
         {
            #ifdef TCPLX
               if (TB == AtlasNoTrans)
                   out->b2blk = ATL_AMM_B2BLK_a1[ik];
               else if (TB == AtlasTrans)
                   out->b2blk = ATL_AMM_BT2BLK_a1[ik];
               else if (TB == AtlasConjTrans)
                   out->b2blk = ATL_AMM_BH2BLK_a1[ik];
               else
                   out->b2blk = ATL_AMM_BC2BLK_a1[ik];
               if (SCALAR_IS_NONE(alpha))
               {
                  if (TA == AtlasNoTrans)
                     out->a2blk = ATL_AMM_AT2BLK_an[ik];
                  else if (TA == AtlasTrans)
                     out->a2blk = ATL_AMM_A2BLK_an[ik];
                  else if (TA == AtlasConjTrans)
                     out->a2blk = ATL_AMM_AC2BLK_an[ik];
                  else
                     out->a2blk = ATL_AMM_AH2BLK_an[ik];
               }
               else
               {
                  if (TA == AtlasNoTrans)
                     out->a2blk = ATL_AMM_AT2BLK_aX[ik];
                  else if (TA == AtlasTrans)
                     out->a2blk = ATL_AMM_A2BLK_aX[ik];
                  else if (TA == AtlasConjTrans)
                     out->a2blk = ATL_AMM_AC2BLK_aX[ik];
                  else
                     out->a2blk = ATL_AMM_AH2BLK_aX[ik];
               }
            #else
               if (SCALAR_IS_NONE(alpha))
                  out->a2blk = (TA == AtlasNoTrans) ?
                               ATL_AMM_AT2BLK_an[ik] : ATL_AMM_A2BLK_an[ik];
               else
                  out->a2blk = (TA == AtlasNoTrans) ?
                               ATL_AMM_AT2BLK_aX[ik] : ATL_AMM_A2BLK_aX[ik];
               out->b2blk = (TB == AtlasNoTrans) ?
                            ATL_AMM_B2BLK_a1[ik] : ATL_AMM_BT2BLK_a1[ik];
            #endif
         }
         else /* apply alpha to B */
         {
            #ifdef TCPLX
               if (TA == AtlasNoTrans)
                  out->a2blk = ATL_AMM_AT2BLK_a1[ik];
               else if (TA == AtlasTrans)
                  out->a2blk = ATL_AMM_A2BLK_a1[ik];
               else if (TA == AtlasConjTrans)
                  out->a2blk = ATL_AMM_AC2BLK_a1[ik];
               else
                  out->a2blk = ATL_AMM_AH2BLK_a1[ik];
               if (SCALAR_IS_NONE(alpha))
               {
                  if (TB == AtlasNoTrans)
                      out->b2blk = ATL_AMM_B2BLK_an[ik];
                  else if (TB == AtlasTrans)
                      out->b2blk = ATL_AMM_BT2BLK_an[ik];
                  else if (TB == AtlasConjTrans)
                      out->b2blk = ATL_AMM_BH2BLK_an[ik];
                  else
                      out->b2blk = ATL_AMM_BC2BLK_an[ik];
               }
               else
               {
                  if (TB == AtlasNoTrans)
                      out->b2blk = ATL_AMM_B2BLK_aX[ik];
                  else if (TB == AtlasTrans)
                      out->b2blk = ATL_AMM_BT2BLK_aX[ik];
                  else if (TB == AtlasConjTrans)
                      out->b2blk = ATL_AMM_BH2BLK_aX[ik];
                  else
                      out->b2blk = ATL_AMM_BC2BLK_aX[ik];
               }
            #else
               out->a2blk = (TA == AtlasNoTrans) ?
                            ATL_AMM_AT2BLK_a1[ik] : ATL_AMM_A2BLK_a1[ik];
               if (SCALAR_IS_NONE(alpha))
                  out->b2blk = (TB == AtlasNoTrans) ?
                               ATL_AMM_B2BLK_an[ik] : ATL_AMM_BT2BLK_an[ik];
               else
                  out->b2blk = (TB == AtlasNoTrans) ?
                               ATL_AMM_B2BLK_aX[ik] : ATL_AMM_BT2BLK_aX[ik];
            #endif
         }
      }
   }
   return(appAl);
}

double time00();
double Time2Mflops(int M, int N, int K, double t0)
{
   return((((2.0*M)*N)*K) / (1000000.0*t0));
}

int FindLowerBlock(int *M, int *N, int *K)
{
   int iret=1;
   if (ATL_AMM_KRUNTIME(ATL_AMM_KFLAG[IK]) && *K > *M && *K > *N &&
       *K-ATL_AMM_KUs[IK] >=  ATL_AMM_KBMINs[IK])
      *K -= ATL_AMM_KUs[IK];
   else if (*M >= *N && *M > ATL_AMM_MUs[IK])
      *M -= ATL_AMM_MUs[IK];
   else if (*N > ATL_AMM_NUs[IK])
      *N -= ATL_AMM_NUs[IK];
   else 
      iret = 0;
   return(iret);
}

double GetMflops(ATL_CINT M, ATL_CINT N, ATL_CINT K, TYPE *A, TYPE *B, TYPE *C)
{
   double t0;
   const TYPE ONE[2] = {ATL_rone, ATL_rzero};

   t0 = time00();
   Mjoin(PATL,ammm)(AtlasNoTrans, AtlasNoTrans, M, N, K, ONE, A, M, B, K,
                    ONE, C, M);
   t0 = time00() - t0;
   return(Time2Mflops(M, N, K, t0));
}

void TuneBlocking(int M, int N, int K, TYPE *A, TYPE *B, TYPE *C, 
              int *MB_, int *NB_, int *KB_)
{
   int mbB=ATL_AMM_MBs[IK], nbB=ATL_AMM_NBs[IK], kbB=ATL_AMM_KBs[IK];
   int mb=mbB, nb=nbB, kb=kbB, m, n, k;
   double t0, t1, mf0, mf, mfB;

   printf("\nTRYING REDUCED BLOCKING WITH INDEX=%d\n", IK);
   printf("        M       N       K  IDX   MB   NB   KB         MFLOPS\n");
   printf("   ======  ======  ======  ===  ===  ===  ===  =============\n");
   m = (M/mbB)*mbB;
   n = (N/nbB)*nbB;
   k = (K/kbB)*kbB;
   mf0 = mf = mfB = GetMflops(m, n, k, A, B, C);
   printf("  %7d %7d %7d %4d %4d %4d %4d %14.2f\n", 
          m, n, k, IK, mb, nb, kb, mf);
   while(FindLowerBlock(&mb, &nb, &kb))
   {
      MB = mb;
      NB = nb;
      KB = kb;
      m = (M/mb)*mb;
      n = (N/nb)*nb;
      k = (K/kb)*kb;
      mf = GetMflops(m, n, k, A, B, C);
      printf("  %7d %7d %7d %4d %4d %4d %4d %14.2f\n", 
             m, n, k, IK, mb, nb, kb, mf);
      if (mf > mfB)
      {
         mbB = mb;
         nbB = nb;
         kbB = kb;
         mfB = mf;
      }
      else if (mf*1.02 <= mfB)
         break;
   }
   printf("BEST BLOCKING: MB=%d, NB=%d, KB=%d speedup=%.3f\n", 
          mbB, nbB, kbB, (mfB/mf0));
   *MB_ = mbB;
   *NB_ = nbB;
   *KB_ = kbB;
}

int TuneIndx(int M, int N, int K, TYPE *A, TYPE *B, TYPE *C)
{
   double mfB=0.0, mf;
   int ik, iB=ATL_AMM_NCASES-1;

   printf("\n\nFINDING BEST INDEX:\n");
   printf("        M       N       K  IDX   MB   NB   KB         MFLOPS\n");
   printf("   ======  ======  ======  ===  ===  ===  ===  =============\n");
   for (ik=iB; ik >= 0; ik--)
   {
      const int mb=ATL_AMM_MBs[ik],nb=ATL_AMM_NBs[ik],kb=ATL_AMM_KBs[ik];
      const int m=(M/mb)*mb, n=(N/nb)*nb, k=(K/kb)*kb;
      IK = ik;
      mf = GetMflops(m, n, k, A, B, C);
      printf("  %7d %7d %7d %4d %4d %4d %4d %14.2f\n", 
             m, n, k, ik, mb, nb, kb, mf);
      if (mf > mfB)
      {
         iB = ik;
         mfB = mf;
      }
      else if (ATL_AMM_KBs[ik] < 16)
         break;
   }
   printf("\nBEST INDEX=%d (%.2f)\n", iB, mfB);
   return(iB);
}

void TuneCplxNB(FILE *fpout, int M, int N, int K, TYPE *A, TYPE *B, TYPE *C)
{
   int ik, mb, nb, kb;
   ik = TuneIndx(M, N, K, A, B, C);
   IK = ik;
   TuneBlocking(M, N, K, A, B, C, &mb, &nb, &kb);
   fprintf(fpout, "#ifndef ATL_%cAMM_SUM_H\n   #define ATLAS_%cAMM_SUM_H\n\n",
           MY_PRE2, MY_PRE2);
   fprintf(fpout, "   #define ATL_CAMM_MAXINDX %d\n", IK);
   fprintf(fpout, "   #define ATL_CAMM_MAXMB %d\n", mb);
   fprintf(fpout, "   #define ATL_CAMM_MAXNB %d\n", nb);
   fprintf(fpout, "   #define ATL_CAMM_MAXKB %d\n", kb);
   fprintf(fpout, "\n#endif\n");
   fclose(fpout);
}

FILE *GetFlags(int nargs, char **args, int *M, int *N, int *K)
{
   FILE *fp=NULL;
   *K = 1200;
   *M = *N = 2000;
   if (!fp)
   {
      char nam[32];
      sprintf(nam, "res/atlas_%samm_sum.h", Mstr(PRE));
      fp = fopen(nam, "w");
      ATL_assert(fp);
   }
   return(fp);
}


int main(int nargs, char **args)
{
   void *vp;
   TYPE *A, *B, *C;
   int M, N, K;
   size_t szA, szB, szC;
   FILE *fpout;

   fpout = GetFlags(nargs, args, &M, &N, &K);
   M = ((M+ATL_AMM_MAXMB-1)/ATL_AMM_MAXMB)*ATL_AMM_MAXMB;
   N = ((N+ATL_AMM_MAXNB-1)/ATL_AMM_MAXNB)*ATL_AMM_MAXNB;
   K = ((K+ATL_AMM_MAXKB-1)/ATL_AMM_MAXKB)*ATL_AMM_MAXKB;
   szA = M*K;
   szB = K*N;
   szC = M*N;
   vp = malloc(ATL_MulBySize(szA + szB + szC) + 3*ATL_Cachelen);
   ATL_assert(vp);
   A = ATL_AlignPtr(vp);
   B = A + szA+szA;
   B = ATL_AlignPtr(B);
   C = B + szB+szB;
   C = ATL_AlignPtr(C);
   Mjoin(PATL,zero)(szA, A, 1);
   Mjoin(PATL,zero)(szB, B, 1);
   Mjoin(PATL,zero)(szC, C, 1);
   TuneCplxNB(fpout, M, N, K, A, B, C);
   free(vp);
   return(0);
}
@ROUT ATL_GetSqMNAmmmInfo
#include "atlas_misc.h"
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_blk.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_ablk2cmat.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_a1.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_an.h))
#include Mstr(Mjoin(Mjoin(atlas_,PRE),amm_cm2am_aX.h))
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_flag.h))
#include Mstr(Mjoin(Mjoin(atlas_,UPR),amm_kern.h))

/*
 * Chooses good square M & N blocking; starts from size that gets 98% of
 * performance, since smaller produces less wasted flops for triangular and
 * symmetric operations, which are what usually demand square M/N blocking
 */
int Mjoin(PATL,GetSqMNAmmmInfo)
(
   amminfo_t *out,
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CSZT M,
   ATL_CSZT N,
   ATL_CSZT K,
   const SCALAR alpha,
   const SCALAR beta
)
{
   #ifdef ATL_CAMM_MAXINDX
      int mb, nb, u, ik=ATL_CAMM_MAXINDX;
   #else
      int ik=ATL_AMM_98IDX;
   #endif
   int appAl;  /* 0:A, 1:B, 2:C */
/*
 * For rank-K update, choose smallest KB that contains required K
 */
   if (K < ATL_AMM_MAXKB)
   {
      for (ik=0; ik < ATL_AMM_NCASES && ATL_AMM_KBs[ik] < K; ik++);
   }
   out->IDX = ik;
   u = ATL_98LCMMN;
   mb = ATL_AMM_MBs[ik];
   nb = ATL_AMM_NBs[ik];
   out->kb = ATL_AMM_KBs[ik];
   #ifdef ATL_CAMM_MAXINDX
      if (ik >= ATL_CAMM_MAXINDX)
      {
         ik = ATL_CAMM_MAXINDX
         u = ATL_CAMM_LCMMN;
         mb = ATL_CAMM_MAXMB;
         nb = ATL_CAMM_MAXMB;
         out->kb = ATL_CAMM_MAXKB;
      } 
   #endif
   if(mb != nb)
      nb = (mb > u) ? (mb/u)*u : u;
   out->mb = mb = out->nb = nb;
   out->kbmin = ATL_AMM_KBMINs[ik];
   out->mu = ATL_AMM_MUs[ik];
   out->nu = ATL_AMM_NUs[ik];
   out->ku = ATL_AMM_KUs[ik];
   out->flag = ATL_AMM_KFLAG[ik];
   out->amm_b0 = ATL_AMM_KERN_b0[ik];
   out->amm_b1 = ATL_AMM_KERN_b1[ik];
   out->amm_bn = ATL_AMM_KERN_bn[ik];
   out->amm_k1_b0 = ATL_AMM_KERN_K1[ik];
   out->amm_k1_b1 = ATL_AMM_KERN_K1_b1[ik];
   out->amm_k1_bn = ATL_AMM_KERN_K1_bn[ik];
/*
 * Apply alpha to smallest matrix, and use alpha/beta to pick copy routines
 */
   if (SCALAR_IS_ONE(alpha))
   {
      appAl = 0;
      #ifdef TCPLX
         if (TA == AtlasNoTrans)
            out->a2blk = ATL_AMM_AT2BLK_a1[ik];
         else if (TA == AtlasTrans)
            out->a2blk = ATL_AMM_A2BLK_a1[ik];
         else if (TA == AtlasConjTrans)
            out->a2blk = ATL_AMM_AC2BLK_a1[ik];
         else
            out->a2blk = ATL_AMM_AH2BLK_a1[ik];
         if (TB == AtlasNoTrans)
             out->b2blk = ATL_AMM_B2BLK_a1[ik];
         else if (TB == AtlasTrans)
             out->b2blk = ATL_AMM_BT2BLK_a1[ik];
         else if (TB == AtlasConjTrans)
             out->b2blk = ATL_AMM_BH2BLK_a1[ik];
         else
             out->b2blk = ATL_AMM_BC2BLK_a1[ik];
      #else
         out->a2blk = (TA == AtlasNoTrans) ?
            ATL_AMM_AT2BLK_a1[ik]:ATL_AMM_A2BLK_a1[ik];
         out->b2blk = (TB == AtlasNoTrans) ?
            ATL_AMM_B2BLK_a1[ik]:ATL_AMM_BT2BLK_a1[ik];
      #endif
      if (SCALAR_IS_ONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_b1[ik];
      else if (SCALAR_IS_ZERO(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_b0[ik];
      else if (SCALAR_IS_NONE(beta))
         out->Cblk2cm = ATL_AMM_BLK2C_a1_bn[ik];
      else
         out->Cblk2cm = ATL_AMM_BLK2C_a1_bX[ik];
   }
   else  /* alpha is not one */
   {
      if (M >= N)                  /* A is larger than B, put alpha on C or B */
         appAl = (M >= K) ? 2 : 1;
      else                         /* B is larger than A, put alpha on C or A */
         appAl = (N >= K) ? 2 : 0;
      if (appAl == 2)  /* apply alpha to C */
      {
         #ifdef TCPLX
            if (TA == AtlasNoTrans)
               out->a2blk = ATL_AMM_AT2BLK_a1[ik];
            else if (TA == AtlasTrans)
               out->a2blk = ATL_AMM_A2BLK_a1[ik];
            else if (TA == AtlasConjTrans)
               out->a2blk = ATL_AMM_AC2BLK_a1[ik];
            else
               out->a2blk = ATL_AMM_AH2BLK_a1[ik];
            if (TB == AtlasNoTrans)
                out->b2blk = ATL_AMM_B2BLK_a1[ik];
            else if (TB == AtlasTrans)
                out->b2blk = ATL_AMM_BT2BLK_a1[ik];
            else if (TB == AtlasConjTrans)
                out->b2blk = ATL_AMM_BH2BLK_a1[ik];
            else
                out->b2blk = ATL_AMM_BC2BLK_a1[ik];
         #else
            out->a2blk = (TA == AtlasNoTrans) ?
                         ATL_AMM_AT2BLK_a1[ik] : ATL_AMM_A2BLK_a1[ik];
            out->b2blk = (TB == AtlasNoTrans) ?
                         ATL_AMM_B2BLK_a1[ik] : ATL_AMM_BT2BLK_a1[ik];
         #endif
         if (SCALAR_IS_ONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_b1[ik] : ATL_AMM_BLK2C_aX_b1[ik];
         else if (SCALAR_IS_ZERO(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_b0[ik] : ATL_AMM_BLK2C_aX_b0[ik];
         else if (SCALAR_IS_NONE(beta))
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_bn[ik] : ATL_AMM_BLK2C_aX_bn[ik];
         else
            out->Cblk2cm = SCALAR_IS_NONE(alpha) ?
                           ATL_AMM_BLK2C_an_bX[ik] : ATL_AMM_BLK2C_aX_bX[ik];
      }
      else  /* not applying alpha to C */
      {
         if (SCALAR_IS_ONE(beta))
            out->Cblk2cm = ATL_AMM_BLK2C_a1_b1[ik];
         else if (SCALAR_IS_ZERO(beta))
            out->Cblk2cm = ATL_AMM_BLK2C_a1_b0[ik];
         else if (SCALAR_IS_NONE(beta))
            out->Cblk2cm = ATL_AMM_BLK2C_a1_bn[ik];
         else
            out->Cblk2cm = ATL_AMM_BLK2C_a1_bX[ik];
         if (!appAl)  /* apply to alpha to A */
         {
            #ifdef TCPLX
               if (TB == AtlasNoTrans)
                   out->b2blk = ATL_AMM_B2BLK_a1[ik];
               else if (TB == AtlasTrans)
                   out->b2blk = ATL_AMM_BT2BLK_a1[ik];
               else if (TB == AtlasConjTrans)
                   out->b2blk = ATL_AMM_BH2BLK_a1[ik];
               else
                   out->b2blk = ATL_AMM_BC2BLK_a1[ik];
               if (SCALAR_IS_NONE(alpha))
               {
                  if (TA == AtlasNoTrans)
                     out->a2blk = ATL_AMM_AT2BLK_an[ik];
                  else if (TA == AtlasTrans)
                     out->a2blk = ATL_AMM_A2BLK_an[ik];
                  else if (TA == AtlasConjTrans)
                     out->a2blk = ATL_AMM_AC2BLK_an[ik];
                  else
                     out->a2blk = ATL_AMM_AH2BLK_an[ik];
               }
               else
               {
                  if (TA == AtlasNoTrans)
                     out->a2blk = ATL_AMM_AT2BLK_aX[ik];
                  else if (TA == AtlasTrans)
                     out->a2blk = ATL_AMM_A2BLK_aX[ik];
                  else if (TA == AtlasConjTrans)
                     out->a2blk = ATL_AMM_AC2BLK_aX[ik];
                  else
                     out->a2blk = ATL_AMM_AH2BLK_aX[ik];
               }
            #else
               if (SCALAR_IS_NONE(alpha))
                  out->a2blk = (TA == AtlasNoTrans) ?
                               ATL_AMM_AT2BLK_an[ik] : ATL_AMM_A2BLK_an[ik];
               else
                  out->a2blk = (TA == AtlasNoTrans) ?
                               ATL_AMM_AT2BLK_aX[ik] : ATL_AMM_A2BLK_aX[ik];
               out->b2blk = (TB == AtlasNoTrans) ?
                            ATL_AMM_B2BLK_a1[ik] : ATL_AMM_BT2BLK_a1[ik];
            #endif
         }
         else /* apply alpha to B */
         {
            #ifdef TCPLX
               if (TA == AtlasNoTrans)
                  out->a2blk = ATL_AMM_AT2BLK_a1[ik];
               else if (TA == AtlasTrans)
                  out->a2blk = ATL_AMM_A2BLK_a1[ik];
               else if (TA == AtlasConjTrans)
                  out->a2blk = ATL_AMM_AC2BLK_a1[ik];
               else
                  out->a2blk = ATL_AMM_AH2BLK_a1[ik];
               if (SCALAR_IS_NONE(alpha))
               {
                  if (TB == AtlasNoTrans)
                      out->b2blk = ATL_AMM_B2BLK_an[ik];
                  else if (TB == AtlasTrans)
                      out->b2blk = ATL_AMM_BT2BLK_an[ik];
                  else if (TB == AtlasConjTrans)
                      out->b2blk = ATL_AMM_BH2BLK_an[ik];
                  else
                      out->b2blk = ATL_AMM_BC2BLK_an[ik];
               }
               else
               {
                  if (TB == AtlasNoTrans)
                      out->b2blk = ATL_AMM_B2BLK_aX[ik];
                  else if (TB == AtlasTrans)
                      out->b2blk = ATL_AMM_BT2BLK_aX[ik];
                  else if (TB == AtlasConjTrans)
                      out->b2blk = ATL_AMM_BH2BLK_aX[ik];
                  else
                      out->b2blk = ATL_AMM_BC2BLK_aX[ik];
               }
            #else
               out->a2blk = (TA == AtlasNoTrans) ?
                            ATL_AMM_AT2BLK_a1[ik] : ATL_AMM_A2BLK_a1[ik];
               if (SCALAR_IS_NONE(alpha))
                  out->b2blk = (TB == AtlasNoTrans) ?
                               ATL_AMM_B2BLK_an[ik] : ATL_AMM_BT2BLK_an[ik];
               else
                  out->b2blk = (TB == AtlasNoTrans) ?
                               ATL_AMM_B2BLK_aX[ik] : ATL_AMM_BT2BLK_aX[ik];
            #endif
         }
      }
   }
   return(appAl);
}
