@ROUT ATL_opsyr2k
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_kernel3.h"
#include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#ifdef Conj_
   #define syr2k_OP Mjoin(PATL,opher2k)
#else
   #define syr2k_OP Mjoin(PATL,opsyr2k)
#endif

@whiledef be X 1 N 0
   @addkeys bet=@(be)
static void geaddT_b@(be)
   (ATL_CSZT M, ATL_CSZT N, const TYPE *A, ATL_CSZT lda, 
    const SCALAR beta, TYPE *C, ATL_CSZT ldc)
/* C = beta*C + A^T, C is MxN */
{
   ATL_UINT j;
   #ifdef TCPLX
      register TYPE rb=*beta, ib=beta[1];
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      ATL_CSZT ldc2 = ldc+ldc, M2=M+M, lda2=lda+lda;
      for (j=0; j < N; j++, C += ldc2)
      {
         const TYPE *a=A+j+j;
         ATL_UINT i;
         for (i=0; i < M2; i += 2, a += lda2)
         {
   @mif be = "X
            const register TYPE rc=C[i], ic=C[i+1];
            C[i]   = *a   + rc*rb - ic*ib;
            #ifdef Conj_
               C[i+1] = rc*ib + ic*rb - a[1];
            #else
               C[i+1] = a[1] + rc*ib + ic*rb;
            #endif
   @endmif
   @mif be = "1
            C[i] += *a;
            #ifdef Conj_
               C[i+1] -= a[1];
            #else
               C[i+1] += a[1];
            #endif
   @endmif
   @mif be = "N
            C[i] = *a - C[i];
            #ifdef Conj_
               C[i+1] = -(a[1]+C[i+1]);
            #else
               C[i+1] = a[1] - C[i+1];
            #endif
   @endmif
   @mif be = "0
            C[i] = *a;
            C[i+1] = a[1];
   @endmif
         }
      }
   #else
      for (j=0; j < N; j++, C += ldc)
      {
         const TYPE *a=A+j;
         ATL_UINT i;
         for (i=0; i < M; i++, a += lda)
   @mif be = "0
            C[i] = *a;
   @endmif
   @mif be = "N
            C[i] = *a - C[i];
   @endmif
   @mif be = "1
            C[i] += *a;
   @endmif
   @mif be = "X
            C[i] = beta*C[i] + *a;
   @endmif
      }
   #endif
}
@endwhile

int syr2k_OP
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   #ifdef Conj_
   const TYPE rbeta,
      #define IFLG 1
   #else
      #define IFLG 0
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   void *vp=NULL;
   ablk2cmat_t blk2C_b0, blk2C_b1;
   ATL_SZT sz, szA, szB, nfnblks, nnblks;
   unsigned int szC;
   unsigned int mb, nb, KB;
   TYPE *aC, *bC;  /* access- and block-major C */
   TYPE *aA, *aB;  /* access-major A & B */
   void (*syput)(ATL_CSZT N, const TYPE *D, const SCALAR beta0, TYPE *A, 
                 ATL_CSZT lda);
   void (*geaddT)(ATL_CSZT M, ATL_CSZT N, const TYPE *A, ATL_CSZT lda, 
                  const SCALAR beta, TYPE *C, ATL_CSZT ldc);
   #ifdef TCPLX
      TYPE *aCr;
      const TYPE ZERO[2] = {ATL_rzero, ATL_rzero}, *ONE;
      #ifdef Conj_
         const TYPE beta[2]={rbeta, ATL_rzero};
      #endif
   #else
      #define ZERO ATL_rzero
      #define ONE ATL_rone
      #define aCr aC
   #endif
   opinfo_t op;

   if (!N)
      return(0);
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      if (SCALAR_IS_ONE(beta))
         return(0);
      Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
      return(0);
   }
   if (K < 3)
   {
      #if !defined(TCPLX) || defined(Conj_)
         #ifdef Conj_
         if (K == 1 && rbeta == ATL_rone && TA == AtlasNoTrans)
         #else
         if (K == 1 && SCALAR_IS_ONE(beta))
         #endif
         {
            ATL_SZT incA, incB;
            if (TA == AtlasTrans || TA == AtlasConjTrans)
            {
               incA = lda;
               incB = ldb;
            }
            else
            {
               incA = 1;
               incB = 1;
            }
            #ifdef Conj_
               Mjoin(PATL,her2)(Uplo, N, alpha, A, incA, B, incB, C, ldc);
            #else
               Mjoin(PATL,syr2)(Uplo, N, alpha, A, incA, B, incB, C, ldc);
            #endif
            return(0);
         }
      #endif
      #ifdef Conj_
         Mjoin(PATL,refher2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                              rbeta, C, ldc);
      #else
         Mjoin(PATL,refsyr2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                              beta, C, ldc);
      #endif
      return(0);
   }
   blk2C_b0 = Mjoin(PATL,opsyr2kInfo)(&op, IFLG, TA, N, K, lda, ldb, ldc, 
                                      alpha, beta);
   if (!blk2C_b0)
      return(2);
   blk2C_b1 = op.blk2C;
   KB = op.KB;
   #ifdef TCPLX
      ONE = op.ONE;
      #ifdef Conj_
         if (rbeta == ATL_rone)
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_b1):Mjoin(PATL,her2k_putL_b1));
            geaddT = geaddT_b1;
         }
         else if (rbeta == ATL_rzero)
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_b0):Mjoin(PATL,her2k_putL_b0));
            geaddT = geaddT_b0;
         }
         else
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_bXi0):Mjoin(PATL,her2k_putL_bXi0));
            geaddT = (rbeta == ATL_rnone) ? geaddT_bN:geaddT_bX;
         }
      #else
         if (beta[1] == ATL_rzero) /* real beta */
         {
            const TYPE rb=(*beta);
            if (rb == ATL_rone)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_b1):Mjoin(PATL,syr2k_putL_b1));
               geaddT = geaddT_b1;
            }
            else if (rb == ATL_rzero)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_b0):Mjoin(PATL,syr2k_putL_b0));
               geaddT = geaddT_b0;
            }
            else if (rb == ATL_rnone)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_bn1):Mjoin(PATL,syr2k_putL_bn1));
               geaddT = geaddT_bN;
            }
            else
            {
               syput = ((Uplo == AtlasUpper) ? 
                       Mjoin(PATL,syr2k_putU_bXi0):Mjoin(PATL,syr2k_putL_bXi0));
               geaddT = geaddT_bX;
            }
         }
         else
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,syr2k_putU_bX):Mjoin(PATL,syr2k_putL_bX));
            geaddT = geaddT_bX;
         }
      #endif
   #else
      if (beta == ATL_rone)
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_b1):Mjoin(PATL,syr2k_putL_b1));
         geaddT = geaddT_b1;
      }
      else if (beta == ATL_rzero)
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_b0):Mjoin(PATL,syr2k_putL_b0));
         geaddT = geaddT_b0;
      }
      else
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_bX):Mjoin(PATL,syr2k_putL_bX));
         geaddT = (beta == ATL_rnone) ? geaddT_bN:geaddT_bX;
      }
   #endif
   nfnblks = op.nfnblks;
   nnblks = nfnblks + op.npnblks;
   if (nfnblks) 
      mb = nb = op.nb;
   else
   {
      mb = op.pmb;
      nb = op.pnb;
   }
/*
 * This algorithm requires allocating all of A & B + 2 blks for C 
 */
   szC = mb*nb;    /* need 1 access-major & 1 block-major C workspace */
   szA = (mb*nfnblks + op.npnblks*op.pmb)*KB;
   szB = (nb*nfnblks + op.npnblks*op.pnb)*KB;
   sz = ATL_MulBySize(szA+szB+szC+szC) + 3*ATL_Cachelen;
   if (sz <= ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);
   bC = ATL_AlignPtr(vp);
   aC = bC + (szC SHIFT);
   aC = ATL_AlignPtr(aC);
   #ifdef TCPLX
     aCr = aC + szC;
     aA = aCr + szC;
   #else
      aA = aC + szC;
   #endif
   aA = ATL_AlignPtr(aA);
   aB = aA + (szA SHIFT);
   aB = ATL_AlignPtr(aB);
   szB = (nb*KB)SHIFT;    /* increment between normal B blks */
   szA = (mb*KB)SHIFT;    /* increment between normal A blks */
   if (Uplo == AtlasLower)
   {
      ATL_SZT j;
      ATL_CUINT NB = Mmin(mb,nb);
      TYPE *wAj=aA, *wBj=aB;

      for (j=0; j < nnblks; j++, C += nb*((ldc+1)SHIFT), wAj += szA, wBj += szB)
      {
         TYPE *wAi=wAj+szA, *wBi=wBj+szB;
         TYPE *pC = C;
         ATL_CSZT jn = (j < nnblks-1) ? j+1 : 0;
         ATL_SZT i;
         ATL_UINT n;

         if (j < nfnblks)
            nb = n = NB;
         else
         {
            nb = op.pnb;
            n = op.nF;
         }
/*
 *       First do diagonal block
 */
         Mjoin(PATL,opblk)(&op, j, j, A, B, NULL, wAj, wAj, 
                           wBj, wBj+szB, aCr, aC);
         #ifdef TCPLX
            blk2C_b0(n, n, ONE, aCr, aC, ZERO, bC, n);
         #else
            blk2C_b0(n, n, ONE, aC, ZERO, bC, n);
         #endif
         syput(n, bC, beta, pC, ldc);
         pC += n SHIFT;
         for (i=j+1; i < nnblks; i++, wAi += szA, wBi += szB)
         {
            ATL_CSZT in = (i < nnblks-1) ? i+1 : 0;
            ATL_UINT m;
            if (i < nfnblks)
               mb = m = NB;
            else
            {
               mb = op.pmb;
               m = op.mF;
            }
            Mjoin(PATL,opblk)(&op, j, i, NULL, B, NULL, wAj, wAi, 
                              wBi, wBj, aCr, aC);
            #ifdef TCPLX
               blk2C_b0(n, m, ONE, aCr, aC, ZERO, bC, n);
            #else
               blk2C_b0(n, m, ONE, aC, ZERO, bC, n);
            #endif
            if (m == n)
            {
               Mjoin(PATL,sqtrans)(n, bC, n);
               #ifdef Conj_  /* need hermitian transpose for HER2K! */
                  Mjoin(PATLU,scal)(n*n, ATL_rnone, bC+1, 2);
               #endif
            }
            else
               geaddT(m, n, bC, n, beta, pC, ldc);
            Mjoin(PATL,opblk)(&op, i, j, A, NULL, NULL, wAi, wAj+szA, 
                              wBj, wBi+szB, aCr, aC);
            if (m == n)
            {
               #ifdef TCPLX
                  blk2C_b1(n, n, ONE, aCr, aC, ONE, bC, n);
               #else
                  blk2C_b1(n, n, ONE, aC, ONE, bC, n);
               #endif
               Mjoin(PATL,geadd)(n, n, ONE, bC, n, beta, pC, ldc);
            }
            else
               #ifdef TCPLX
                  blk2C_b1(m, n, ONE, aCr, aC, ONE, pC, ldc);
               #else
                  blk2C_b1(m, n, ONE, aC, ONE, pC, ldc);
               #endif
            pC += m SHIFT;
         }
         A = NULL;
         B = NULL;
      }
   }
   else
      return(4);  /* Upper not yet supported */
   free(vp);
   return(0);
}
@ROUT ATL_syr2k
#include "atlas_amm.h"
#include "atlas_level3.h"
#include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
#ifdef Conj_
   #define SYR2K Mjoin(PATL,her2k)
   #define IFLG 4
#else
   #define SYR2K Mjoin(PATL,syr2k)
   #define IFLG 0
#endif
#ifdef Conj_
int Mjoin(PATL,opher2k_wrap)
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   return(Mjoin(PATL,opher2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                              *beta, C, ldc));
}
#else
typedef int (*syr2k_t)(const enum ATLAS_UPLO, const enum ATLAS_TRANS, 
                       ATL_CSZT, ATL_CSZT, const SCALAR, 
                       const TYPE*, ATL_CSZT, const TYPE*, ATL_CSZT, 
                       const SCALAR, TYPE*, ATL_CSZT);
void Mjoin(PATL,syr2k_rec)
(
   ATL_CUINT bv, /* 0:Upper?, 1:Transpose?, 2:HER2K? */
   ATL_CSZT  N,
   ATL_CSZT K,  /* if NoTrans, ncols of A&B, else nrows A&B */
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc,
   void *syr2kOP
)
{
   if (K <= ATL_VWopgen_MAX_KB)
   {
      syr2k_t opsyr2k = syr2kOP;
      const enum ATLAS_UPLO UL=(bv&1) ? AtlasUpper:AtlasLower;
      #ifdef TCPLX
         enum ATLAS_TRANS TA;
         if (bv&4)
            TA = (bv&2) ? AtlasConjTrans : AtlasNoTrans;
         else
            TA = (bv&2) ? AtlasTrans : AtlasNoTrans;
      #else
         const enum ATLAS_TRANS TA = (bv&2) ? AtlasTrans : AtlasNoTrans;
      #endif
      if (!opsyr2k(UL, TA, N, K, alpha, A, lda, B, ldb, beta, C, ldc))
         return;
/*
 *    Outer product can reduce required memory by splitting N or K; once we've
 *    got a small enough K to do opsyrk, don't reduce K until its bigger than N
 *    (this should never happen).  When we split along N, we wind up with two
 *    syr2k calls, and two calls to GEMM.
 */
      #if 0
      if (N >= K)
      {
         ATL_assert(0);
      }
      #endif
   }
/*
 * If we reach here, split K, resulting in 2 syr2k, 2nd with BETA=ONE
 */
   {
      ATL_SZT KL=(K>>1), KR = K - KL;
      #ifdef TCPLX
         const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      #else
         #define ONE ATL_rone
      #endif
      Mjoin(PATL,syr2k_rec)(bv, N, KL, alpha, A, lda, B, ldb, 
                             beta, C, ldc, syr2kOP);
      #ifdef TCPLX
         KL += KL;
      #endif
      if (bv&2)  /* K controls rows of A&B */
      {
         A += KL;
         B += KL;
      }
      else       /* K controls cols of A&B */
      {
         A += KL * lda;
         B += KL * ldb;
      }
      Mjoin(PATL,syr2k_rec)(bv, N, KR, alpha, A, lda, B, ldb, ONE, C, ldc, 
                            syr2kOP);
   }
}
#endif
void SYR2K
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   #ifdef Conj_
      const TYPE rbeta,
   #else
      const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   void *vp;
   #ifdef Conj_
      const TYPE beta[2] = {rbeta, ATL_rzero};
   #endif
   ATL_UINT bv;
   if (!N)
      return;
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      #ifdef Conj_
         if (rbeta == ATL_rone)
            return;
      #else
         if (SCALAR_IS_ONE(beta))
            return;
      #endif
      Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
      #ifdef Conj_
         Mjoin(PATLU,zero)(N, C+1, (ldc+1)<<1);
      #endif
      return;
   }
/*
 * Outer-product syr2k handles degenerate K, along with any 1-block K
 */
   if (K <= ATL_VWopgen_MAX_KB)
   #ifdef Conj_
      if (!Mjoin(PATL,opher2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                               rbeta, C, ldc))
         return;
      vp = Mjoin(PATL,opher2k_wrap);
      bv = 4;
      if (TA == AtlasConjTrans)
         bv |= 2;
   #else
      if (!Mjoin(PATL,opsyr2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                               beta, C, ldc))
         return;
      vp = Mjoin(PATL,opsyr2k);
      bv = 0;
      #ifdef TCPLX
         if (TA == AtlasTrans) 
      #else
         if (TA == AtlasTrans || TA == AtlasConjTrans)
      #endif
            bv |= 2;
   #endif
   bv |= (Uplo == AtlasUpper);
   Mjoin(PATL,syr2k_rec)(bv, N, K, alpha, A, lda, B, ldb, beta, C, ldc, vp);
}

@ROUT ATL_syrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2016
#define ATL_GLOBIDX 1
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_syrk.h))
#ifndef Conj_
   #define ATL_DECL_ 1
#endif
#include Mstr(Mjoin(ATLAS_PRE,syrk_view.h))
#ifndef Conj_
   #undef ATL_DECL_
#endif
/*
 * Service routine, particularly for parallel.  Takes its blocking from ip
 * (assuming that is what is being used below diagonal blocks
 * flag bits, meaning if set (opposite if unset):
 * 0/1: C is upper
 * 1/2: TA == AtlasNoTrans
 * 2/4: use beta=0 syrk kernel (else use beta=1)
 *
 * If (Uplo==Upper && sy2blk) 
 *    (1) flag&1 == 1; (2) wU non-NULL; (3) sy2blk is beta=0.
 * ==> wU can be aliased wt wS if you don't need correct wS on output
 */
#ifdef Conj_
   #define syrkBlk Mjoin(PATL,herkBlk)
   #define syrk_K  Mjoin(PATL,herk_KLoop)
   #define syrk_amm  Mjoin(PATL,herk_amm)
   #define opsyrk  Mjoin(PATL,opherk)
   #define ipsyrk  Mjoin(PATL,ipherk)
   #define SYRK Mjoin(PATL,herk)
   #define herk_FLG 1
#else
   #define syrkBlk Mjoin(PATL,syrkBlk)
   #define syrk_K  Mjoin(PATL,syrk_KLoop)
   #define syrk_amm  Mjoin(PATL,syrk_amm)
   #define opsyrk  Mjoin(PATL,opsyrk)
   #define ipsyrk  Mjoin(PATL,ipsyrk)
   #define SYRK Mjoin(PATL,syrk)
   #define herk_FLG 0
#endif
void syrkBlk
(
   ipinfo_t *ip,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans */
   size_t d,      /* which global diagonal blk of C is being computed */
   size_t k,      /* which K block of A is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   cm2am_t sy2blk,/* copy A to syrk storage */
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   const SCALAR beta, /* only needed if blk2c non-NULL */
   TYPE *C,       /* if blk2c && non-NULL, which C to write to */
   TYPE *rS,      /* real portion of wS (unused for real routines) */
   TYPE *wS,      /* space to store syrk A; */
   TYPE *wA,      /* if non-NULL, ip-based A workspace */
   TYPE *wAn,     /* next A wrkspc to be prefetched */
   TYPE *wB,      /* if non-NULL ip-based At workspace */
   TYPE *wBn,     /* next B wrkspc to be prefetched */
   TYPE *rC,      /* real portion of wC (unused for real routines) */
   TYPE *wC,      /* if non-NULL: ptr to syrk-storage C wrkspc */
   TYPE *wU       /* reflection space for Upper if non-NULL */
)
{
   ATL_CUINT kb = (k != ip->nfkblks) ? ip->kb : ip->kb0;
   ATL_UINT nb, kbS, nnu;
   size_t nfblks = ip->nfnblks;
   #ifdef TCPLX 
      TYPE *rA, *rB;
   #endif
   if (d == nfblks + ip->npnblks - 1)
   {
      nb = ip->nF;
      #ifdef TCPLX
         if (d < nfblks)
         {
            rA = wA + ip->szA;
            rB = wB + ip->szB;
         }
         else
         {
            rA = wA + ip->pszA;
            rB = wB + ip->pszB;
         }
      #endif
   }
   else if (d < nfblks)
   {
      nb = ip->nb;
      #ifdef TCPLX
         rA = wA + ip->szA;
         rB = wB + ip->szB;
      #endif
   }
   else
   {
      nb = ip->pnb;
      #ifdef TCPLX
         rA = wA + ip->pszA;
         rB = wB + ip->pszB;
      #endif
   }
   nnu = (nb+ATL_SYRKK_NU-1)/ATL_SYRKK_NU;
   kbS = ((kb+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   if (A)  /* want to copy input array */
   {
      A = IdxA_ip(ip, A, d, k);
      if (wA)  /* want to copy A to gemm storage too! */
      {
         #ifdef TCPLX
            ip->a2blk(kb, nb, ip->alpA, A, ip->lda, rA, wA);
         #else
            ip->a2blk(kb, nb, ip->alpA, A, ip->lda, wA);
         #endif
         if (ip->a2blk == sy2blk)
         {
            wS = wA;
            #ifdef TCPLX
               rS = rA;
            #endif
         }
      }
      if (wB)  /* want to copy At to gemm storage too! */
      {
         #ifdef TCPLX
            ip->b2blk(kb, nb, ip->alpB, A, ip->ldb, rB, wB);
         #else
            ip->b2blk(kb, nb, ip->alpB, A, ip->ldb, wB);
         #endif
         if (ip->b2blk == sy2blk)
         {
            wS = wB;
            #ifdef TCPLX
               rS = rB;
            #endif
         }
      }
      if (wS != wA && wS != wB)
      {
         #ifdef TCPLX
            sy2blk(kb, nb, ip->ONE, A, ip->lda, rS, wS);
         #else
            sy2blk(kb, nb, ATL_rone, A, ip->lda, wS);
         #endif
      }
   }
   if (wC && wS)  /* want to compute SYRK on this block into wC */
   {
      #ifdef TCPLX
         #ifdef Conj_
            TYPE *crA=(flag&2)?rS:wS, *ciA=(flag&2)?wS:rS;
            if (flag&4)
            {
               Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, wS, wS, rC, crA, ciA, wC);
               Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, crA, ciA, wC, rS, rS, rC);
            }
            else
            {
               Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, wS, wS, rC, crA, ciA, wC);
               Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, crA, ciA, wC, rS, rS, rC);
            }
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, rS, rS, rC, ciA, crA, wC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, ciA, crA, wC, wS, wS, rC);
         #else
            if (flag&4)
            {
               Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, wS, wS, rC, rS, wS, wC);
               Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, rS, wS, wC, rS, rS, rC);
            }
            else
            {
               Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, wS, wS, rC, rS, wS, wC);
               Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, rS, wS, wC, rS, rS, rC);
            }
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, rS, rS, rC, wS, rS, wC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, wS, rS, wC, wS, wS, rC);
         #endif
      #else
         if (flag&4)
            Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, wS, wS, wC, wS, wS, wC);
         else
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, wS, wS, wC, wS, wS, wC);
      #endif
   }
   if (blk2c)
   {
      const size_t ldc=ip->ldc;
      #ifdef TCPLX
         const TYPE *alp = ip->alpC;
      #else
         TYPE alp = ip->alpC;
      #endif
      if (ip->alpA != ip->alpB)
         alp = (ip->alpA != ip->alpC) ? ip->alpA : ip->alpB;
      @beginskip
      if (flag&1)  /* Upper matrix */
      {
         #ifdef TCPLX
            const TYPE zero[2] = {ATL_rzero, ATL_rzero};
            blk2c(nb, nb, alp, rC, wC, zero, wU, nb);
         #else
            blk2c(nb, nb, alp, wC, ATL_rzero, wU, nb);
         #endif
      }
      else if (C)
      @endskip
      if (C)
      {
         C = IdxC_ip(ip, C, d, d);
         #ifdef TCPLX
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
            blk2c(nb, nb, alp, wC, beta, C, ldc);
         #endif
      }
   }
   #if 0
   if ((flag&1) && C && wU)  /* need to reflect from Lower to Upper */
   {
      size_t ldc2=(ip->ldc)SHIFT;
      #ifdef Conj_
         for (k=0; k < nb; k++, C += ldc2, wU += 2)
         {
            Mjoin(PATL,axpbyConj)(k+1, ip->ONE, wU, nb, beta, C, 1);
            C[((k+1)<<1)-1] = ATL_rzero;
         }
      #else
         if (SCALAR_IS_ZERO(beta))
            for (k=0; k < nb; k++, wU += (1 SHIFT), C += ldc2)
               Mjoin(PATL,copy)(k+1, wU, nb, C, 1);
         else
            for (k=0; k < nb; k++, wU += (1 SHIFT), C += ldc2)
            #ifdef TCPLX
               Mjoin(PATL,axpby)(k+1, ip->ONE, wU, nb, beta, C, 1);
            #else
               Mjoin(PATL,axpby)(k+1, ATL_rone, wU, nb, beta, C, 1);
            #endif
      #endif
   }
   #endif
}

/*
 * This helper function computes one block of C by looping over the K dim.
 * flag bits, meaning if set (opposite if unset):
 * 0/1: C is upper
 * 1/2: TA == AtlasNoTrans
 */
void syrk_K  /* inner-product based syrk/herk loop over K loop */
(
   ipinfo_t *ip,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans */
   size_t d,      /* which global diagonal blk of C is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   cm2am_t sy2blk,/* copy A to syrk storage */
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   const SCALAR beta, /* only needed if blk2c non-NULL */
   TYPE *C,       /* if blk2c non-NULL, which C to write to, else ignored */
   TYPE *rS,      /* real portion of wS (unused in real routines) */
   TYPE *wS,      /* space to store syrk A; */
   TYPE *wA,      /* if non-NULL, ip-based A workspace */
   TYPE *wB,      /* if non-NULL ip-based At workspace */
   TYPE *rC,      /* real portion of wC (unused in real routines) */
   TYPE *wC,      /* if non-NULL: ptr to syrk-storage C wrkspc */
   TYPE *wU       /* NBxNB wrkspc needed for Upper C storage & blk2c != NULL */
)
{
   const size_t nfkblks = ip->nfkblks;
   size_t k;
   ATL_UINT szA, szB;
   if (d < ip->nfnblks)
      szA = szB = ip->szA;
   else
   {
      szA = ip->pszA;
      szB = ip->pszB;
   }
   #ifdef TCPLX
      szA += szA;
      szB += szB;
   #endif
/*
 * For first K block, use beta=0 kernel to init wC
 */
   if (nfkblks)
   {
      TYPE *wAn=(wA)? wA+szA:NULL, *wBn=(wB) ? wB+szB : NULL;
      syrkBlk(ip, flag|4, d, 0, A, sy2blk, NULL, beta, NULL, rS, wS, 
              wA, wAn, wB, wBn, rC, wC, wU);
      wA = wAn;
      wB = wBn;
   }
   else /* this is first & last block! */
   {
      syrkBlk(ip, flag|4, d, 0, A, sy2blk, blk2c, beta, C, rS, wS, 
              wA, wA, wB, wB, rC, wC, wU);
      return;
   }
/*
 * Handle all blocks except first (handled above) & last (handled below)
 */
   for (k=1; k < nfkblks; k++)
   {
      TYPE *wAn=(wA)? wA+szA:NULL, *wBn=(wB) ? wB+szB : NULL;
      syrkBlk(ip, flag, d, k, A, sy2blk, NULL, beta, NULL, rS, wS, 
              wA, wAn, wB, wBn, rC, wC, wU);
      wA = wAn;
      wB = wBn;
   }
/*
 * Last block actually writes to C
 */
   syrkBlk(ip, flag, d, k, A, sy2blk, blk2c, beta, C, rS, wS, 
           wA, wA, wB, wB, rC, wC, wU);
}

int syrk_amm
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_iptr_t  N,
   ATL_iptr_t K,
   #ifdef Conj_
   const TYPE ralpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_iptr_t lda,
   #ifdef Conj_
   const TYPE rbeta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_iptr_t ldc
)
{
   size_t sz, szA, szB, szC, szS, nnblks, extra;
   void *vp;
   TYPE *wA, *wB, *wC, *wS, *wCs, *rC, *rCs, *rS;
   double timG;
   int nb, nbS, flg, idx;
   #ifdef Conj_
      TYPE alpha[2]={ralpha, ATL_rzero}, beta[2]={rbeta, ATL_rzero};
      const enum ATLAS_TRANS TB=(TA==AtlasNoTrans)?AtlasConjTrans:AtlasNoTrans;
   #else
      const enum ATLAS_TRANS TB = (TA==AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
   #endif
   ipinfo_t ip;
   cm2am_t sy2blk;
   ablk2cmat_t blk2sy, blk2c;

   if (N == 0)     /* no output */
      return(0);   /* so return with no-op */
@BEGINSKIP
/*
 * Does the operation not involve A at all?
 */
   #ifdef Conj_
      if (ralpha == ATL_rzero || !K)
      {
         if (rbeta != ATL_rone)
            Mjoin(PATL,hescal)(Uplo, N, N, rbeta, C, ldc);
         return(0);
      }
   #else
      if (SCALAR_IS_ZERO(alpha) || !K)
      {
         if (!SCALAR_IS_ONE(beta))
            Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
         return(0);
      }
   #endif
   if (N == 1) /* really a dot product */
   {
      const ATL_iptr_t incA = (TA == AtlasNoTrans) ? lda : 1;
      #ifdef TCPLX
         TYPE dot[2];
      #endif
      #ifdef Conj_
         TYPE d0;
         ATL_zdotc_sub(K, A, incA, A, incA, dot);
         C[1] = ATL_rzero;
         d0 = *dot * ralpha;
         if (rbeta == ATL_rzero)
            C[0] = d0;
         else 
            C[0] = C[0] * rbeta + d0;
      #elif defined(TCPLX)
         const TYPE ra=(*alpha), ia=alpha[1], rb=(*beta), ib=beta[1];
         TYPE rd, id, rt;
         ATL_zdotu_sub(K, A, incA, A, incA, dot);
         rt = rd = dot[0];
         id = dot[1];
         rd = rd*ra - id*ia;
         id = rt*ia + id*ra;
         if (ib == ATL_rzero) /* beta is a real number only */
         {
            if (rb == ATL_rzero) /* beta is 0 */
            {
               C[0] = rd;
               C[1] = id;
            }
            else
            {
               C[0] = C[0] * rb + rd;
               C[1] = C[1] * rb + id;
            }
         }
         else
         {
            const register rc=(*C), ic=C[1];
            C[0] = rc*rb - ic*ib + rd;
            C[1] = rc*ib + ic*rb + id;
         }
      #else /* real */
         TYPE dot, c;
         c = SCALAR_IS_ZERO(beta) ? ATL_rzero : *C * beta;
         dot = Mjoin(PATL,dot)(K, A, incA, A, incA);
         if (!SCALAR_IS_ONE(alpha))
            dot *= alpha;
         *C = c + dot;
      #endif
   }
@skip   else if (K < 3) /* really a rank-1 or rank-2 update */
   else if (K == 1) /* really rank-1 update, for now just use two-pass */
   {                /* thru C for BETA!=1, optimize later with axpby */
      const ATL_iptr_t incA = (TA == AtlasNoTrans) ? 1 : lda;
      #ifdef Conj_
         if (rbeta != ATL_rone)
            Mjoin(PATL,hescal)(Uplo, N, N, rbeta, C, ldc);
         Mjoin(PATL,her)(Uplo, N, ralpha, A, incA, C, ldc);
      #else
         if (!SCALAR_IS_ONE(beta))
            Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
         Mjoin(PATL,syr)(Uplo, N, alpha, A, incA, C, ldc);
      #endif
   }
@ENDSKIP
   if (K < 3 || SCALAR_IS_ZERO(alpha))      /* degenerate case handled by*/
   {                                        /* ipsyrk */
      #ifdef Conj_
         ipsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
      #else
         ipsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
      #endif
      return(0);
   }

/*
 * Inner-product version calls nothing by SYRK kernels, and is called in
 * LAPACK's default left-looking Cholesky.  _IP handles L1/L2BLAS cases too.
 */
   timG = Mjoin(PATL,ipsyrkInfo)(&ip,herk_FLG, TA, N, K, lda, ldc, alpha, beta);
   nb = (ip.nfnblks) ? ip.nb : ip.pnb;
   #if 1
   if (timG < 0.0)
   {
      #ifdef Conj_
         ipsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
      #else
         ipsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
      #endif
      return(0);
   }
   #endif
/*
 * Outer product version will call outer-product-optimized amm, and since
 * N is too large to call ipsyrk, we expect amm perf to dominate this case.
 * Outer product SYRK is used in right-looking Cholesky.
 */
   #if 1
   if (K <= ATL_VWopgen_BEST_KB)
   {
      int ierr;
   #ifdef Conj_
      ierr = opsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
   #else
      ierr = opsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   #endif
      if (ierr)
      {
         if (ierr == 1)  /* if we failed to malloc */
            return(1);   /* tell recursion to continue */
         if (nb >= N)    /* if we can do it with ipsyrk or opsyrk */
         {               /* use ipsyrk if opsyrk fails */
            #ifdef Conj_
               ipsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
            #else
               ipsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
            #endif
            return(0);
         }
      }
   }
   #endif
   #if 1
   #else
      Mjoin(PATL,ipmenInfo)(&ip, TA, TB, N, N, K, lda, lda, ldc, alpha, beta);
   #endif
   #if 0
   printf("D=(%u,%u), B=(%u,%u,%u), b=(%u,%u,%u), nB=(%u,%u,%u)\n", 
          (unsigned int)N,(unsigned int)K, ip.mb, ip.nb, ip.kb,
          ip.pmb, ip.pnb, ip.kb0, ip.nfmblks, ip.nfnblks, ip.nfkblks);
   #endif
/*
 * Will eventually need syrk timed for all square blocks to select best case.
 * For now, just pretend syrk time doesn't matter
 */
/*
 * Need space for only one column-panel of At
 */
   szB = ip.nfnblks ? ip.szA : ip.pszA;
   szB *= (ip.nfkblks+1);
/*
 * A needs entire matrix minus one row/col panel
 */
   szA = szB * (ip.nfnblks + ip.npnblks - 1);
   nb = (ip.nfnblks) ? ip.nb : ip.pnb;
   nbS = (nb+ATL_SYRKK_NU-1)/ATL_SYRKK_NU;
   szC = ((nbS+1)*nbS)>>1;  /* only need lower tri blks, not full nnu*nnu */
   nbS *= ATL_SYRKK_NU;
   szC *= ((ATL_SYRKK_NU*ATL_SYRKK_NU+ATL_SYRKK_VLEN-1)/ATL_SYRKK_VLEN)
          * ATL_SYRKK_VLEN;
   extra = ip.exsz;
   extra = Mmax(extra, (ATL_SYRKK_NU+ATL_SYRKK_NU)*ATL_SYRKK_NU);
   @beginskip
   if (Uplo == AtlasUpper)
      extra = Mmax(extra, ip.szC);
   @endskip
   szS = ((ip.kb + ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   szS *= nbS;
   sz = Mmax(ip.szC,szC);
   sz = ATL_MulBySize(sz + szS + szA+szB + extra) + 5*ATL_Cachelen;
   if (sz < ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);  /* keep recurring, can't malloc space! */
   wA = ATL_AlignPtr(vp);
   wB = wA + (szA SHIFT);
   wB = ATL_AlignPtr(wB);
   wS = wB + (szB SHIFT);
   wS = ATL_AlignPtr(wS);
   wC = wS + (szS SHIFT);
   wC = ATL_AlignPtr(wC);
   if (!szA)
      wA = NULL;
@skip   if (Uplo == AtlasLower)
   wCs = wC;
   @beginskip
   else
   {
      wCs = wC + (szC SHIFT);
      wCs = ATL_AlignPtr(wCs);
   }
   @endskip
   #ifdef TCPLX
      rC = wC + ip.szC;
      rCs = wC + szC;
      rS = wS + szS;
   #else
      rCs = rC = wC;
      rS = wS;
   #endif
/*
 * ============================================================================
 * First, we compute diagonals of C, and in the process we will copy A/A^T
 * for use in computing non-diaginal blocks using inner-product amm.
 * ============================================================================
 */
   sy2blk = IS_COLMAJ(TA) ? Mjoin(PATL,a2blk_syrkT) : Mjoin(PATL,a2blk_syrkN);
      
   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb1);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b1):Mjoin(PATL,SyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbN);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bN):Mjoin(PATL,SyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb0);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbX);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bX):Mjoin(PATL,SyrkIntoC_aXbX);
      }
   }
   else
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb1_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b1_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb1_L2UT);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbN_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bN_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbN_L2UT);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb0_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b0_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb0_L2UT);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbX_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bX_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbX_L2UT);
      }
@beginskip
      if (SCALAR_IS_NONE(alpha))
         blk2sy = Mjoin(PATL,SyrkIntoC_aNb0);
      else
         blk2sy = SCALAR_IS_ONE(alpha) ?
                  Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
@endskip
   }
   nnblks = ip.nfnblks + ip.npnblks;
   flg = (TA == AtlasNoTrans) ? 2 : 0;
/*
 * Upper doesn't need to copy first row panel of A or last col panel of At
 * to GEMM storage.  If C only block, should call ipsyrk instead!
 */
   if (Uplo == AtlasUpper)
   {
      flg |= 1;
      syrk_K(&ip, flg, 0, A, sy2blk, blk2sy, beta, C, rS, wS, wB, NULL, 
             rCs, wC, wCs);
      if (N > nb)
      {
         const size_t incC = nb*((ldc+1)SHIFT);
         size_t i;
/*
 *       Compute all C blks within this rowpan of C, copy rest of At
 */
         blk2c = ip.blk2c;
         Mjoin(PATL,iploopsNK)(&ip, 0, 1, NULL, A, C, 11, wB, wA, rC, wC,
                               beta, blk2c);
/*
 *       Loop over all col-pans of C, excepting first & last;
 *       A already fully copied, B will be copied by syrk_Kloop call.
 */
         for (i=1; i < nnblks-1; i++)
         {
            syrk_K(&ip, flg, i, A, sy2blk, blk2sy, beta, C, rS, wS, wB, NULL, 
                   rCs, wC, wCs);
            wA += szB SHIFT;
            Mjoin(PATL,iploopsNK)(&ip, i, i+1, NULL, NULL, C+i*(nb SHIFT), 11, 
                                  wB, wA, rC, wC, beta, blk2c);
         }
/*
 *       Last colpan is only 1 diag blk, so don't copy A or B for gemm
 */
         syrk_K(&ip, flg, i, A, sy2blk, blk2sy, beta, C, rS, wS, NULL, NULL, 
                rCs, wC, wCs);
      }
   }
/*
 * Lower doesn't need to copy first row panel of A or last col panel of At
 * to GEMM storage.  If C only block, should call ipsyrk instead!
 */
   else
   {
      const size_t incC = (ldc SHIFT) * nb;
      size_t j;
      TYPE *c;
/*
 *    Compute first diag block, copying At to wB for use by all of this colpan
 *    of C's gemm computation
 */
      syrk_K(&ip, flg, 0, A, sy2blk, blk2sy, beta, C, rS, wS, NULL, wB, 
             rCs, wC, wCs);
      if (N > nb)
      {
/*
 *       Compute all C blks within this colpan of C, copying rest of A
 */
         blk2c = ip.blk2c;
         Mjoin(PATL,iploopsMK)(&ip, 1, 0, A, NULL, C, 7, wA, wB, rC, wC, 
                               beta, blk2c);
/* 
 *       Loop over all col-pans of C, excepting first & last;
 *       A already fully copied, B will be copied by syrk_Kloop call.
 */
         c = C + incC;
         for (j=1; j < nnblks-1; j++)
         {
            syrk_K(&ip, flg, j, A, sy2blk, blk2sy, beta, C, rS, wS,
                   NULL, wB, rCs, wC, wCs);
            wA += szB SHIFT;
            Mjoin(PATL,iploopsMK)(&ip, j+1, j, NULL, NULL, c, 7, wA, wB, rC, wC,
                                  beta, blk2c);
            c += incC;
         }
/*
 *       Last colpan is only 1 diag blk, so don't copy A or B for gemm
 */
         syrk_K(&ip, flg, j, A, sy2blk, blk2sy, beta, C, rS, wS, 
                NULL, NULL, rCs, wC, wCs);
      }
   }
   free(vp);
   return(0);
}

static void syrk_rec
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE alpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_iptr_t lda,
   #ifdef Conj_
   const TYPE beta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   #if defined(Conj_) || defined(TREAL)
      #define ONE ATL_rone
   #else
      TYPE ONE[2] = {ATL_rone, ATL_rzero};
   #endif
/*
 * If we cannot solve problem at this size, recursively cut dims until we can
 */
   if (syrk_amm(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc))
   {
      if (N > K)
      {
         ATL_iptr_t nL=N>>1, nR=N-nL;
         const TYPE *Ar = A+((TA==AtlasNoTrans)?(nL SHIFT):lda*(nL SHIFT));
         TYPE *Ct = C + (ldc+1)*(nL SHIFT);
         const enum ATLAS_TRANS TB =
         #ifdef Conj_
               (TA == AtlasNoTrans) ? AtlasConjTrans:AtlasNoTrans;
            const TYPE galp[2]={alpha,ATL_rzero}, gbet[2]={beta,ATL_rzero};
         #else
               (TA == AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
            #define galp alpha
            #define gbet beta
         #endif
         syrk_rec(Uplo, TA, nL, K, alpha, A, lda, beta, C, ldc);
         syrk_rec(Uplo, TA, nR, K, alpha, Ar, lda, beta, Ct, ldc);
         if (Uplo == AtlasUpper)
            Mjoin(PATL,gemm)(TA, TB, nL, nR, K, galp, A, lda, Ar, lda, 
                             gbet, Ct-(nL SHIFT), ldc);
         else
            Mjoin(PATL,gemm)(TA, TB, nR, nL, K, galp, Ar, lda, A, lda, 
                             gbet, C+(nL SHIFT), ldc);
         #ifndef Conj_
            #undef galp
            #undef gbet
         #endif
      }
      else
      {
         ATL_iptr_t kL=K>>1, kR=K-kL, incA=((TA == AtlasNoTrans)?lda:1)SHIFT;
         syrk_rec(Uplo, TA, N, kL, alpha, A, lda, beta, C, ldc);
         syrk_rec(Uplo, TA, N, kR, alpha, A+incA*kL, lda, ONE, C, ldc);
      }
   }
}
#if defined(Conj_) || defined(TREAL)
   #undef ONE
#endif

void SYRK
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE alpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_CSZT lda,
   #ifdef Conj_
   const TYPE beta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
#if 1
   #ifdef Conj_
      Mjoin(PATL,herk_APR)(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   #else
      Mjoin(PATL,syrk_APR)(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   #endif
   return;
#endif
   syrk_rec(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);

}
@ROUT ATL_opsyrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2016
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_syrk.h))
#ifdef Conj_
   #define syrkBlk Mjoin(PATL,herkBlk_OP)
   #define opsyrk Mjoin(PATL,opherk)
#else
   #define syrkBlk Mjoin(PATL,syrkBlk_OP)
   #define opsyrk Mjoin(PATL,opsyrk)
#endif

/*
 * Indexes both A and C from base ptrs according to d (diagonal blk)
 */
void syrkBlk
(
   opinfo_t *op,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans */
   size_t d,      /* which global diagonal blk of C is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   cm2am_t sy2blk,/* copy A to syrk storage */
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   TYPE *C,       /* if blk2c non-NULL, which C to write to, else ignored */
   TYPE *rS,      /* real ptr (unused for real types) */
   TYPE *wS,      /* space to store syrk A; */
   TYPE *wA,      /* if non-NULL, op-based A workspace */
   TYPE *wAn,     /* next A wrkspc to be prefetched */
   TYPE *wB,      /* if non-NULL op-based At workspace */
   TYPE *wBn,     /* next B wrkspc to be prefetched */
   TYPE *rC,      /* real ptr (unused for real routs) */
   TYPE *wC,      /* if non-NULL: ptr to syrk-storage C wrkspc */
   TYPE *wU       /* NBxNB wrkspc needed for Upper C storage & blk2c != NULL */
)
{
   ATL_CSZT lda = op->lda, nfblks = op->nfnblks;
   ATL_CUINT KB = op->KB, kb = op->kb;
   ATL_UINT nb, kbS, nnu;
   #ifdef TCPLX
      ATL_UINT szC, szA;
      TYPE *rA, *rB;
   #endif
   const SCALAR beta=op->beta;
   if (d == nfblks + op->npnblks - 1)  /* last block is SYRK only */
   {
      nb = op->nF;
      nb = (nb) ? nb : op->nb;
      #ifdef TCPLX
         if (d < nfblks)
         {
            rA = wA + op->szA;
            rB = wB + op->szB;
         }
         else
         {
            rA = wA + op->pszA;
            rB = wB + op->pszB;
         }
      #endif
   }
   else if (d < nfblks)
   {
      nb = op->nb;
      #ifdef TCPLX
         rA = wA + op->szA;
         rB = wB + op->szB;
      #endif
   }
   else
   {
      nb = op->pnb;
      #ifdef TCPLX
         rA = wA + op->pszA;
         rB = wB + op->pszB;
      #endif
   }
   nnu = (nb+ATL_SYRKK_NU-1)/ATL_SYRKK_NU;
   kbS = ((kb+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   if (A)  /* want to copy input array */
   {
/*
 *    Move A ptr to d'th block
 */
      if (d)
      {
         size_t n = Mmin(d, nfblks);
         A += n*op->incAm;
         n = d - n;  /* # of partial blocks remaining in d */
         A += n*op->pincAm;
      }
      if (wA)  /* want to copy A to gemm storage too! */
      {
         #ifdef TCPLX
            op->a2blk(kb, nb, op->alpA, A, lda, rA, wA);
         #else
            op->a2blk(kb, nb, op->alpA, A, lda, wA);
         #endif
         if (op->a2blk == sy2blk)
         {
            wS = wA;
            #ifdef TCPLX
               rS = rA;
            #endif
         }
      }
      if (wB)  /* want to copy At to gemm storage too! */
      {
         #ifdef TCPLX
            op->b2blk(kb, nb, op->alpB, A, lda, rB, wB);
         #else
            op->b2blk(kb, nb, op->alpB, A, lda, wB);
         #endif
         if (op->b2blk == sy2blk)
         {
            wS = wB;
            #ifdef TCPLX
               rS = rB;
            #endif
         }
      }
      if (wS != wA && wS != wB)
      {
         #ifdef TCPLX
            sy2blk(kb, nb, op->ONE, A, lda, rS, wS);
         #else
            sy2blk(kb, nb, ATL_rone, A, lda, wS);
         #endif
      }
   }
   if (wC)  /* want to compute SYRK on this block into wC */
   {
      #ifdef TCPLX
         #ifdef Conj_
            TYPE *crA=(flag&2)?rS:wS, *ciA=(flag&2)?wS:rS;
            Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, wS, wS, rC, crA, ciA, wC);
            Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, crA, ciA, wC, rS, rS, rC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, rS, rS, rC, ciA, crA, wC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, ciA, crA, wC, wS, wS, rC);
         #else
            Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, wS, wS, rC, rS, wS, wC);
            Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, rS, wS, wC, rS, rS, rC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, rS, rS, rC, wS, rS, wC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, wS, rS, wC, wS, wS, rC);
         #endif
      #else
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, wS, wS, wC, wS, wS, wC);
      #endif
   }
   if (blk2c)
   {
      const size_t ldc=op->ldc;
      int k;
      #ifdef TCPLX
         const TYPE *alp = (op->alpA == op->ONE) ? op->alpB : op->alpA;
      #else
         TYPE alp = (op->alpA == ATL_rone) ? op->alpB : op->alpA;
      #endif
      C += d*op->nb*((ldc+1)SHIFT);
      if (flag&1)  /* Upper matrix */
      {
         @BEGINSKIP
         #ifdef TCPLX
            const TYPE zero[2] = {ATL_rzero, ATL_rzero};
            blk2c(nb, nb, alp, rC, wC, zero, wU, nb);
            #ifdef Conj_  /* must zero imag part of diagonal for HERK */
            {
               ATL_CINT ldc2=ldc+ldc;
               for (k=0; k < nb; k++, C += ldc2, wU += 2)
               {
                  Mjoin(PATL,axpbyConj)(k+1, op->ONE, wU, nb, beta, C, 1);
                  C[((k+1)<<1)-1] = ATL_rzero;
               }
            }
            #endif
         #else
            blk2c(nb, nb, alp, wC, ATL_rzero, wU, nb);
         #endif
/*
 *       Copy matrix back to original C while applying beta
 */
         #ifndef Conj_
         if (SCALAR_IS_ZERO(beta))
            for (k=0; k < nb; k++, wU += (1 SHIFT), C += (ldc SHIFT))
               Mjoin(PATL,copy)(k+1, wU, nb, C, 1);
         else
            for (k=0; k < nb; k++, wU += (1 SHIFT), C += (ldc SHIFT))
            #ifdef TCPLX
               Mjoin(PATL,axpby)(k+1, op->ONE, wU, nb, beta, C, 1);
            #else
               Mjoin(PATL,axpby)(k+1, ATL_rone, wU, nb, beta, C, 1);
            #endif
         #endif
         @ENDSKIP
         #ifdef TCPLX
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
            blk2c(nb, nb, alp, wC, beta, C, ldc);
         #endif
      }
      else
      {
         #ifdef TCPLX
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
            blk2c(nb, nb, alp, wC, beta, C, ldc);
         #endif
      }
   }
}

int opsyrk
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE ralpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_CSZT lda,
   #ifdef Conj_
   const TYPE rbeta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   size_t sz, szA, szC, szU, szS, nnblks, szAblk;
   void *vp;
   TYPE *wA, *wB, *wC, *wS, *wU, *rC, *rCs, *rS;
   int nb, nbS, flg, idx, extra;
   #ifdef Conj_
      TYPE alpha[2]={ralpha, ATL_rzero}, beta[2]={rbeta, ATL_rzero};
      const enum ATLAS_TRANS TB=(TA==AtlasNoTrans)?AtlasConjTrans:AtlasNoTrans;
   #else
      const enum ATLAS_TRANS TB = (TA==AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
   #endif
   opinfo_t op;
   cm2am_t sy2blk;
   ablk2cmat_t blk2sy, blk2c;

   return(1);  /* need debugging from Majedul */
@skip   Mjoin(PATL,GetSyrkOP)(&op, 1, TA, TB, N, K, lda, ldc, alpha, beta);
@skip   Mjoin(PATL,ipmenInfo)(&ip, idx, TA, TB, N, N, K, lda, lda, ldc, alpha, beta);
   #ifdef Conj_
      if (Mjoin(PATL,opsyrkInfo)(&op, 1, TA, N, K, lda, ldc, alpha, beta))
   #else
      if (Mjoin(PATL,opsyrkInfo)(&op, 0, TA, N, K, lda, ldc, alpha, beta))
   #endif
         return(2);
   fprintf(stderr, "D=(%u,%u), B=(%u,%u,%u), pB=(%u,%u,%u)\n",
           (unsigned int)N, (unsigned int)K, op.mb, op.nb, op.KB, 
           op.pmb, op.pnb, op.kb);
   nnblks = op.nfnblks + op.npnblks;
   sy2blk = IS_COLMAJ(TA) ? Mjoin(PATL,a2blk_syrkT) : Mjoin(PATL,a2blk_syrkN);
      
   if (Uplo == AtlasLower)
   {
      szU = 0;
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb1);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b1):Mjoin(PATL,SyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbN);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bN):Mjoin(PATL,SyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb0);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbX);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bX):Mjoin(PATL,SyrkIntoC_aXbX);
      }
   }
   else  /* C is Upper */
   {
      szU = 0;
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb1_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                        Mjoin(PATL,SyrkIntoC_a1b1_L2UT)
                        :Mjoin(PATL,SyrkIntoC_aXb1_L2UT);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbN_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                        Mjoin(PATL,SyrkIntoC_a1bN_L2UT)
                        :Mjoin(PATL,SyrkIntoC_aXbN_L2UT);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb0_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                        Mjoin(PATL,SyrkIntoC_a1b0_L2UT)
                        :Mjoin(PATL,SyrkIntoC_aXb0_L2UT);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbX_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                        Mjoin(PATL,SyrkIntoC_a1bX_L2UT)
                        :Mjoin(PATL,SyrkIntoC_aXbX_L2UT);
      }
@BEGINSKIP
      szU = N*N;
      if (SCALAR_IS_NONE(alpha))
         blk2sy = Mjoin(PATL,SyrkIntoC_aNb0);
      else
         blk2sy = SCALAR_IS_ONE(alpha) ?
                  Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
@ENDSKIP
   }
   extra = (ATL_SYRKK_NU+ATL_SYRKK_NU)*ATL_SYRKK_NU;
   flg = (TA == AtlasNoTrans) ? 2 : 0;
   if (TA == AtlasUpper)
   {
      flg |= 1;
      extra -= Mmin(extra, szU);
   }
   if (nnblks == 1)  /* we've got a 1 block of SYRK only! */
   {
      nbS = (N+ATL_SYRKK_NU-1)/ATL_SYRKK_NU;
      szC = ((nbS+1)*nbS)>>1;  /* only need lower tri blks, not full nnu*nnu */
      nbS *= ATL_SYRKK_NU;
      szC *= ((ATL_SYRKK_NU*ATL_SYRKK_NU+ATL_SYRKK_VLEN-1)/ATL_SYRKK_VLEN)
             * ATL_SYRKK_VLEN;
      #if ATL_SYRKK_KVEC > 1
         szS = ((K+ATL_SYRKK_KVEC-1)/ATL_SYRKK_KVEC)*ATL_SYRKK_KVEC;
         szS *= nbS;
      #else
         szS = nbS * K;
      #endif
      szU = Mmax(op.szC, szU);
      sz = ATL_MulBySize(szU + szC + szS + extra) + 3*ATL_Cachelen;
      vp = malloc(sz);
      if (!vp)
         return(1);
      wS = ATL_AlignPtr(vp);
      wC = wS + (szS SHIFT);
      wC = ATL_AlignPtr(wC);
      wU = wC + (szC SHIFT);
      wU = ATL_AlignPtr(wU);
      #ifdef TCPLX
         rC = wC + szC;
         rS = wS + szS;
      #else
         rC = wC;
         rS = wS;
      #endif
      flg |= (Uplo == AtlasUpper) ? 1 : 0;
      syrkBlk(&op, flg, 0, A, sy2blk, blk2sy, C, rS, wS, 
              NULL, NULL, NULL, NULL, rC, wC, wU);
      free(vp);
      return(0);
   }
/*
 * If we reach here, we have at rank-K SYRK update requiring both SYRK & GEMM
 * Since nnblks > 1, nfnblks > 1 as well.
 */
   nbS = (op.nb+ATL_SYRKK_NU-1)/ATL_SYRKK_NU;
   szC = ((nbS+1)*nbS)>>1;  /* only need lower tri blks, not full nnu*nnu */
   nbS *= ATL_SYRKK_NU;
   szC *= ((ATL_SYRKK_NU*ATL_SYRKK_NU+ATL_SYRKK_VLEN-1)/ATL_SYRKK_VLEN)
          * ATL_SYRKK_VLEN;
   #if ATL_SYRKK_KVEC > 1
      szS = ((K+ATL_SYRKK_KVEC-1)/ATL_SYRKK_KVEC)*ATL_SYRKK_KVEC;
      szS *= nbS;
   #else
      szS = nbS * K;
   #endif
   szU = Mmax(op.szC, szU);
   szAblk = op.szA;
   szA = szAblk * (nnblks-1);
   sz = ATL_MulBySize(szA+szAblk + szS + szC + szU + extra) + 5*ATL_Cachelen;
   vp = malloc(sz);
   if (!vp)
      return(1);
   wA = ATL_AlignPtr(vp);
   wB = wA + (szA SHIFT);
   wB = ATL_AlignPtr(wB);
   wS = wB + (szAblk SHIFT);
   wS = ATL_AlignPtr(wS);
   wC = wS + (szS SHIFT);
   wC = ATL_AlignPtr(wC);
   wU = wC + (szC SHIFT);
   wU = ATL_AlignPtr(wU);
   #ifdef TCPLX
      rC = wC + op.szC;
      rCs = wC + szC;
      rS = wS + szS;
   #else
      rC = wC;
      rCs = wC;
      rS = wS + szS;
   #endif
   if (Uplo == AtlasLower)
   {
      size_t j;
/*
 *    Do first diagonal block, don't copy A blk to GEMM storage since it is
 *    used only for this diagonal (SYRK)
 */
      syrkBlk(&op, flg, 0, A, sy2blk, blk2sy, C, rS, wS, NULL, NULL, wB, wB, 
              rCs, wC, wU);
/*
 *    Do rank-K update on ge blks beneath diag, copying entire A at same time
 */
      Mjoin(PATL,oploopsM)(&op, 1, 0, A, NULL, C, 1, wA, wB, rC, wC);
/*
 *    For remaining column panels of C, syrkBlk copies B, reusues wA
 */
      for (j=1; j < nnblks-1; j++)
      {
         syrkBlk(&op, flg, j, A, sy2blk, blk2sy, C, rS, wS, NULL, NULL, wB, wB, 
                 rCs, wC, wU);
         wA += (szAblk SHIFT);
         Mjoin(PATL,oploopsM)(&op, j+1, j, NULL, NULL, C, 1, wA, wB, rC, wC);
      }
/*
 *    Last col panel is only one diagonal
 */
      syrkBlk(&op, flg, j, A, sy2blk, blk2sy, C, rS, wS, NULL, NULL, NULL, NULL,
              rCs, wC, wU);
   }
   else
   {
      size_t i;
/*
 *    Do first diagonal block, don't copy A^T blk to GEMM storage since it is
 *    used only for this diagonal (SYRK)
 */
      flg |= 1;
      syrkBlk(&op, flg, 0, A, sy2blk, blk2sy, C, rS, wS, wB, wB, NULL, NULL, 
              rCs, wC, wU);
/*
 *    Do rank-K update on ge blks beneath diag, copying entire A^T at same time
 */
      Mjoin(PATL,oploopsN)(&op, 0, 1, NULL, A, C, 2, wB, wA, rC, wC);
/*
 *    For remaining column panels of C, syrkBlk copies A, reuses A^T
 */
      for (i=1; i < nnblks-1; i++)
      {
         syrkBlk(&op, flg, i, A, sy2blk, blk2sy, C, rS, wS, wB, wB, NULL, NULL,
                 rCs, wC, wU);
         wA += (szAblk SHIFT);
         Mjoin(PATL,oploopsN)(&op, i, i+1, NULL, NULL, C, 2, wB, wA, rC, wC);
      }
/*
 *    Last col panel is only one diagonal
 */
      syrkBlk(&op, flg, i, A, sy2blk, blk2sy, C, rS, wS, NULL, NULL, NULL, NULL,
              rCs, wC, wU);
   }
   free(vp);
   return(0);
}
@ROUT ATL_ipsyrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2015 
#define ATL_GLOBIDX 1
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
@skip #include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
@skip #include Mstr(Mjoin(ATLAS_PRE,amm_sum.h))
#include Mstr(Mjoin(ATLAS_PRE,syrk_view.h)) /* blocking & perf info */
#include Mstr(Mjoin(ATLAS_PRE,amm_syrk.h))  /* syrk kernel info */

static INLINE void ATL_syr1
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
#ifdef Conj_
   const TYPE ralpha,
#else
   const SCALAR alpha,
#endif
   const TYPE *A,
   ATL_CSZT lda,
#ifdef Conj_
   const TYPE rbeta,
#else
   const SCALAR beta,
#endif
   TYPE *C,
   ATL_CSZT ldc
)
{
/*
 * First, see if we can simply call the Level-2 BLAS
 */
   #ifdef Conj_
      TYPE *c=C+1;
   #endif
   #ifndef TCPLX
      if (beta == 1.0)
      {
         Mjoin(PATL,syr)(Uplo, N, alpha, A, TA==AtlasNoTrans?1:lda, C, ldc);
         return;
      }
   #endif
   {
      size_t k;
      TYPE *X=(TYPE*)A;
      void *vp=NULL;
      #ifdef Conj_
         const TYPE beta[2] = {rbeta, ATL_rzero};
      #endif
/*
 *    Copy A if it's a row so it is contiguous for all N axpby calls
 */
      #ifdef Conj_
      if (TA == AtlasConjTrans)
      #else
      if (TA == AtlasTrans || TA == AtlasConjTrans)
      #endif
      {
         vp = malloc(ATL_MulBySize(N)+ATL_Cachelen);
         ATL_assert(vp);
         X = ATL_AlignPtr(vp);
         #ifdef Conj_
            Mjoin(PATL,copyConj)(N, A, lda, X, 1);
         #else
            Mjoin(PATL,copy)(N, A, lda, X, 1);
         #endif
      }
      #ifdef Conj_
         if (rbeta == 1.0)
         {
            Mjoin(PATL,her)(Uplo, N, ralpha, X, 1, C, ldc);
            if (vp)
               free(vp);
            return;
         }
      #endif  /* NO syr for complex, so cplx SYR has to use axpy-based code */
      #ifdef TCPLX
         if (Uplo == AtlasUpper)
         {
            size_t ldc2 = ldc+ldc;
            #ifndef Conj_
               const register TYPE ra=(*alpha), ia=alpha[1];
            #endif
            for (k=0; k < N; k++, C += ldc2)
            {
               size_t k2=k+k;
               #ifndef Conj_
                  const register TYPE rx=X[k2], ix=X[k2+1];
               #endif
               TYPE scal[2];
               #ifdef Conj_
                  scal[0] = ralpha*X[k2];
                  scal[1] = -ralpha*X[k2+1];
               #else
                  scal[0] = ra*rx - ia*ix;
                  scal[1] = ra*ix + ia*rx;
               #endif
               Mjoin(PATL,axpby)(k+1, scal, X, 1, beta, C, 1);
            }
         }
         else   /* Uplo == AtlasLower */
         {
            size_t ldcp1 = (ldc+1)SHIFT;
            #ifndef Conj_
               const register TYPE ra=(*alpha), ia=alpha[1];
            #endif
            for (k=0; k < N; k++, C += ldcp1, X += 2)
            {
               #ifndef Conj_
                  const register TYPE rx=*X, ix=X[1];
               #endif
               TYPE scal[2];
               #ifdef Conj_
                  scal[0] = ralpha* *X;
                  scal[1] = ralpha * (-X[1]);
               #else
                  scal[0] = ra*rx - ia*ix;
                  scal[1] = ra*ix + ia*rx;
               #endif
               Mjoin(PATL,axpby)(N-k, scal, X, 1, beta, C, 1);
            }
         }
      #else  /* real with beta != 1.0 */
         if (Uplo == AtlasUpper)
         {
            for (k=0; k < N; k++, C += ldc)
               Mjoin(PATL,axpby)(k+1, X[k]*alpha,  X, 1, beta, C, 1);
         }
         else   /* Uplo == AtlasLower */
         {
            for (k=0; k < N; k++, C += (ldc+1), X++)
               Mjoin(PATL,axpby)(N-k, (*X)*alpha,  X, 1, beta, C, 1);
         }
      #endif
      if (vp)
         free(vp);
      @beginskip
         {
            size_t n=N;
            TYPE zero[2] = {ATL_rzero, ATL_rzero;
            else
               vp = NULL;
            if (Uplo == Upper)
            {
               if (SCALAR_IS_ONE(alpha))
               {
                  for (k=0; k < N; k++, B += incB, C += ldc2)
                     Mjoin(PATL,axpby)(M, X+k+k,  X, 1, beta, C, 1);
               }
               else if (SCALAR_IS_NONE(alpha))
               {
                  for (k=0; k < N; k++, B += incB, C += ldc2)
                  {
                     const TYPE scal[2] = {-X[k+k], -X[k+k+1]};
                     Mjoin(PATL,axpby)(M, scal,  X, 1, beta, C, 1);
                  }
               }
               else  /* alpha should be multiplied */
               {
                  const register TYPE ralp=*alpha, ialp=alpha[1];
                  for (k=0; k < N; k++, B += incB, C += ldc2)
                  {
                     TYPE scal[2];
                     const register TYPE rx=X[k+k], ix=X[k+k+1];
                     scal[0] = rx*ralp - ix*ialp;
                     scal[1] = rx*ialp + ix*ralp;
                     Mjoin(PATL,axpby)(M, scal,  X, 1, beta, C, 1);
                  }
               }
            }
            else  /* Uplo == Lower */
            {
            }
         }
         @endskip
   }
   #ifdef Conj_  /* must zero complex part of diagonal for HERK! */
      Mjoin(PATLU,zero)(N, c, (ldc+1)SHIFT);
   #endif
}

#include "atlas_cache.h"
#include "atlas_reflevel3.h"
/*
 * This routine assumes 1st col of A is x, 2nd y, and NoTrans case
 */
static void ATL_syr2_axpy
(
   const enum ATLAS_UPLO Uplo,
   ATL_CSZT N,
#ifdef Conj_
   const TYPE ralpha,
#else
   const SCALAR alpha,
#endif
   const TYPE *x,
   const TYPE *y,
#ifdef Conj_
   const TYPE rbeta,
#else
   const SCALAR beta,
#endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   #ifdef Conj_
      const TYPE beta[2] ={rbeta,  ATL_rzero};
   #endif
   if (Uplo == AtlasLower)
   {
      ATL_CSZT ldcp1 = (ldc+1)SHIFT;
      ATL_SZT j;
      for (j=0; j < N; j++, C += ldcp1)
      {
         ATL_CSZT n = N-j;
         #ifdef Conj_
            const TYPE alpx[2] = {ralpha*x[j+j], -ralpha*x[j+j+1]};
            const TYPE alpy[2] = {ralpha*y[j+j], -ralpha*y[j+j+1]};
         #elif defined(TCPLX)
            const TYPE ralp=alpha[0], ialp=alpha[1];
            TYPE alpx[2], alpy[2], rx=x[j+j], ix=x[j+j+1];
            if (ialp == ATL_rzero)
            {
               alpx[0] = ralp*rx;
               alpx[1] = ralp*ix;
               rx=y[j+j], ix=y[j+j+1];
               alpy[0] = ralp*rx;
               alpy[1] = ralp*ix;
            }
            else
            {
               alpx[0] = ralp*rx - ialp*ix;
               alpx[1] = ralp*ix + ialp*rx;
               rx=y[j+j], ix=y[j+j+1];
               alpy[0] = ralp*rx - ialp*ix;
               alpy[1] = ralp*ix + ialp*rx;
            }
         #else
            const TYPE alpx = alpha * x[j], alpy = alpha * y[j];
         #endif
         Mjoin(PATL,axpby)(n, alpx, x+(j SHIFT), 1, beta, C, 1);
         Mjoin(PATL,axpy)(n, alpy, y+(j SHIFT), 1, C, 1);
         #ifdef Conj_
            C[1] = ATL_rzero;
         #endif
      }
   }
   else /* Uplo == AtlasUpper */
   {
      ATL_CSZT ldc2 = ldc SHIFT;
      ATL_SZT j;
      for (j=0; j < N; j++, C += ldc2)
      {
         #ifdef Conj_
            const TYPE alpx[2] = {ralpha*x[j+j], -ralpha*x[j+j+1]};
            const TYPE alpy[2] = {ralpha*y[j+j], -ralpha*y[j+j+1]};
         #elif defined(TCPLX)
            const TYPE ralp=alpha[0], ialp=alpha[1];
            TYPE alpx[2], alpy[2], rx=x[j+j], ix=x[j+j+1];
            if (ialp == ATL_rzero)
            {
               alpx[0] = ralp*rx;
               alpx[1] = ralp*ix;
               rx=y[j+j], ix=y[j+j+1];
               alpy[0] = ralp*rx;
               alpy[1] = ralp*ix;
            }
            else
            {
               alpx[0] = ralp*rx - ialp*ix;
               alpx[1] = ralp*ix + ialp*rx;
               rx=y[j+j], ix=y[j+j+1];
               alpy[0] = ralp*rx - ialp*ix;
               alpy[1] = ralp*ix + ialp*rx;
            }
         #else
            const TYPE alpx = alpha * x[j], alpy = alpha * y[j];
         #endif
         Mjoin(PATL,axpby)(j+1, alpx, x, 1, beta, C, 1);
         Mjoin(PATL,axpy)(j+1, alpy, y, 1, C, 1);
         #ifdef Conj_
            C[j+j+1] = ATL_rzero;
         #endif
      }
   }
}

#ifdef Conj_
   #define ATL_ger2 Mjoin(PATL,ger2c)
#elif defined(TCPLX)
   #define ATL_ger2 Mjoin(PATL,ger2u)
#else
   #define ATL_ger2 Mjoin(PATL,ger2)
#endif
static void ATL_syr2
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
#ifdef Conj_
   const TYPE ralpha,
#else
   const SCALAR alpha,
#endif
   const TYPE *A,
   ATL_CSZT lda,
#ifdef Conj_
   const TYPE rbeta,
#else
   const SCALAR beta,
#endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   void *vp=NULL;
   TYPE *x, *y;
   #ifdef TCPLX
      ATL_CSZT lda2 = lda+lda, ldc2 = ldc+ldc;
   #else
      #define lda2 lda
      #define ldc2 ldc
   #endif
   #ifdef Conj_
      const TYPE alpha[2]={ralpha, ATL_rzero};
      const TYPE beta[2] ={rbeta,  ATL_rzero};
   #endif
/*
 * If A cols are strided, copy them to contiguous & aligned storage
 */
   if (TA != AtlasNoTrans)
   {
      vp = malloc(ATL_MulBySize(N+N) + ATL_Cachelen+ATL_Cachelen);
      ATL_assert(vp);
      x = ATL_AlignPtr(vp);
      y = x + (N SHIFT);
      y = ATL_AlignPtr(y);
      #ifdef Conj_
         Mjoin(PATL,copyConj)(N, A, lda, x, 1);
         Mjoin(PATL,copyConj)(N, A+(1 SHIFT), lda, y, 1);
      #else
         Mjoin(PATL,copy)(N, A, lda, x, 1);
         Mjoin(PATL,copy)(N, A+(1 SHIFT), lda, y, 1);
      #endif
   }
   else
   {
      x = (TYPE *) A;
      y = (TYPE *) (A + lda2);
   }
/*
 * If BETA != 1, then we must pass through C twice, so use daxpy-based code
 */
   #ifdef Conj_
   if (rbeta != ATL_rone)
   #else
   if (!SCALAR_IS_ONE(beta))
   #endif
   {
      #ifdef Conj_
         ATL_syr2_axpy(Uplo, N, ralpha, x, y, rbeta, C, ldc);
      #else
         ATL_syr2_axpy(Uplo, N, alpha, x, y, beta, C, ldc);
      #endif
   }
   else /* beta=1 can use ger2 based code, make only 1 pass thru C */
   {
      #ifdef Conj_
         const TYPE alpha[2] = {ralpha, ATL_rzero};
      #endif
      #if L1C_ELTS >= 16384
         unsigned int Np = (N > 128) ? 120 : N;
      #elif L1C_ELTS >= 8192
         unsigned int Np = (N > 90) ? 80 : N;
      #elif L1C_ELTS >= 4096
         unsigned int Np = (N > 64) ? 60 : N;
      #elif L1C_ELTS >= 2048
         unsigned int Np = (N > 48) ? 40 : N;
      #else
         unsigned int Np = (N > 40) ? 24 : N;
      #endif
      if (Uplo == AtlasLower)
      {
         ATL_CSZT incC=((ldc+1)SHIFT)*Np, incX=(Np SHIFT);
         ATL_SZT j;
         for (j=0; j < N; j += Np, C += incC, x += incX, y += incX)
         {
            const unsigned nb = Mmin(N-j, Np), nb2=nb SHIFT;
            #ifdef Conj_
               ATL_syr2_axpy(Uplo, nb, ralpha, x, y, rbeta, C, ldc);
            #else
               ATL_syr2_axpy(Uplo, nb, alpha, x, y, beta, C, ldc);
            #endif
            ATL_ger2(N-j-nb, nb, alpha, x+nb2, 1, x, 1, alpha, y+nb2, 1, y, 1, 
                     C+nb2, ldc);
         }
      }
      else
      {
         const TYPE *x0 = x, *y0 = y;
         ATL_CSZT incC=((ldc)SHIFT)*Np, incX=(Np SHIFT);
         ATL_SZT j;
         for (j=0; j < N; j += Np, C += incC, x += incX, y += incX)
         {
            const unsigned nb = Mmin(N-j, Np), nb2=nb SHIFT;
            if (j)
               ATL_ger2(j, nb, alpha, x0, 1, x, 1, alpha, y0, 1, y, 1,
                        C, ldc);
            #ifdef Conj_
               ATL_syr2_axpy(Uplo, nb, ralpha, x, y, rbeta, C+(j SHIFT), ldc);
            #else
               ATL_syr2_axpy(Uplo, nb, alpha, x, y, beta, C+(j SHIFT), ldc);
            #endif
         }
      }
   }
   if (vp)
      free(vp);
}

@ROUT ATL_ipsyrk N2Idx
static INLINE int N2Idx(const unsigned int N)
/*
 * Uses Recursive halving to find smallest NB >= N in VWsyrk.
 */
{
   unsigned int idxB=ATL_VWsyrk_NCASES-1, idxS=0, idxM;
   unsigned int nbB, nbS=ATL_VWsyrk_MIN_NB, nbM;
   if (N <= ATL_VWsyrk_MIN_NB)
      return(0);
   nbB = ATL_GetVWsyrkMB(idxB);
   if (N >= nbB)
      return(ATL_VWsyrk_NCASES-1);
   KEEP_ON:
      idxM = ((idxB-idxS)>>1)+idxS;
      if (idxM == idxS)
         return((nbS >= N) ? idxS:idxB);
      nbM = ATL_GetVWsyrkMB(idxM);
      if (nbM > N)
      {
         idxB = idxM;
         nbB = nbM;
      }
      else if (nbM < N)
      {
         idxS = idxM;
         nbS = nbM;
      }
      else /* if (nbM == N) */
         return(idxM);
   goto KEEP_ON;
}
@ROUT ATL_ipsyrk

#ifdef Conj_
void Mjoin(PATL,ipherk)
#else
void Mjoin(PATL,ipsyrk)
#endif
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
   ATL_CSZT K,
#ifdef Conj_
   const TYPE ralpha,
#else
   const SCALAR alpha,
#endif
   const TYPE *A,
   ATL_CSZT lda,
#ifdef Conj_
   const TYPE rbeta,
#else
   const SCALAR beta,
#endif
   TYPE *C,
   ATL_CSZT ldc
)
/* 
 * C NxN, A NxK
 * SYRK:
 *    C = alpha * A * A^T + beta*C, if TA == AtlasNoTrans
 *    C = alpha * A^T * A + beta*C, if TA == AtlasTrans
 * HERK:
 *    C = alpha * A * A^H + beta*C, if TA == AtlasNoTrans
 *    C = alpha * A^H * A + beta*C, if TA == AtlasTrans
 */
{
   cm2am_t a2blk;
   ablk2cmat_t blk2c;
   void *vp;
   #ifdef TCPLX
      TYPE *rA, *iA, *rC, *iC, *c;
      TYPE one[2] = {ATL_rone, ATL_rzero};
      #ifdef Conj_
         TYPE *crA, *ciA;
         const TYPE alpha[2] = {ralpha, ATL_rzero};
         const TYPE beta[2] = {rbeta, ATL_rzero};
      #endif
   #else
      TYPE *pA, *pC, *c;
      #define one ATL_rone
   #endif
   size_t szA, szC, szE, incAk, nkb, k;
   ATL_CUINT nnu = (N+ATL_SYRKK_NU-1)/ATL_SYRKK_NU, NN=nnu*ATL_SYRKK_NU;
   ATL_UINT kb, kbS, kb0, KB0, idx;
/*
 * Handle degenerate cases
 */
   if (!N)                            /* no output! */
      return;
   if (SCALAR_IS_ZERO(alpha) || !K)  /* really scale of C */
   {
      if (SCALAR_IS_ONE(beta))       /* no-op */
         return;
      if (SCALAR_IS_ZERO(beta))      /* explicit zero */
      {
         if (Uplo == AtlasLower)
            Mjoin(PATL,trsetL)(N, N, beta, beta, C, ldc);
         else
            Mjoin(PATL,trsetU)(N, N, beta, beta, C, ldc);
         return;
      }
      Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
      #ifdef Conj_  /* must zero complex part of diagonal for HERK! */
         Mjoin(PATLU,zero)(N, C+1, (ldc+1)SHIFT);
      #endif
      return;
   }
   if (K == 1)  /* Level-2/1 BLAS */
   {
      #ifdef Conj_
         ATL_syr1(Uplo, TA, N, ralpha, A, lda, rbeta, C, ldc);
      #else
         ATL_syr1(Uplo, TA, N, alpha, A, lda, beta, C, ldc);
      #endif
      return;
   }
   if (K == 2)  /* Level-2/1 BLAS */
   {
      #ifdef Conj_
         ATL_syr2(Uplo, TA, N, ralpha, A, lda, rbeta, C, ldc);
      #else
         ATL_syr2(Uplo, TA, N, alpha, A, lda, beta, C, ldc);
      #endif
      return;
   }
   if (N == 1)  /* dot product */
   {
      const size_t incA = (TA==AtlasNoTrans) ? lda : 1;
      #ifdef TCPLX
         TYPE dot[2];
         #ifdef Conj_
            Mjoin(PATL,dotc_sub)(K, A, incA, A, incA, dot);
            *dot   *= ralpha;
            if (rbeta != ATL_rzero)
               *dot   += rbeta * *C;
            *C = *dot;
            C[1] = ATL_rzero;
         #else
            const register TYPE ra=(*alpha), ia=alpha[1];
            register TYPE rd, id, rr;
            Mjoin(PATL,dotu_sub)(K, A, incA, A, incA, dot);
            rr = rd = dot[0];
            id = dot[1];
            rd = rr*ra - id*ia;
            id = rr*ia + id*ra;
            if (!SCALAR_IS_ZERO(beta))
            {
               const register TYPE rb=(*beta), ib=beta[1];
               const register TYPE rc=(*C), ic=C[1];
               rd += rb*rc - ib*ic;
               id += rb*ic + ib*rc;
            }
            C[0] = rd;
            C[1] = id;
         #endif
      #else
         TYPE dot;
         dot = Mjoin(PATL,dot)(K, A, incA, A, incA);
         dot *= alpha;
         if (beta != ATL_rzero)
            dot += beta * *C;
         *C = dot;
      #endif
      return;
   }
/*
 * Find NB closest to our present N, and set initial KB to its tuned version
 */
   idx = N2Idx(NN);
   kb = ATL_GetVWsyrkKB(idx);
   szC = ((ATL_SYRKK_NU*ATL_SYRKK_NU+ATL_SYRKK_VLEN-1)/ATL_SYRKK_VLEN)
         * ATL_SYRKK_VLEN;
   szC *= ((nnu+1)*nnu)>>1;  /* only need lower tri blks, not full nnu*nnu */
/*
 * Our SYRK C copy is always to Lower, so if output is Upper, will need
 * workspace to put the Lower part, before reflecting it to Upper.
 * Need max of this extra space, or preload distance.
 */
@skip   szE = (Uplo == AtlasLower) ? 0 : N*N;
@skip   szE = Mmax(szE, ATL_SYRKK_NU*ATL_SYRKK_NU*2);
   szE = (ATL_SYRKK_NU*ATL_SYRKK_NU)<<1;
   if (K > kb)
   {
      nkb = K / kb;
      kb0 = K - nkb*kb;
      if (!kb0)
      {
         kb0 = kb;
         nkb--;
      }
      KB0 = ((kb0+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
      kbS = ((kb+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   }
   else
   {
      nkb = 0;
      kb0 = K;
      kbS = kb = KB0 = ((kb0+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   }
   if (IS_COLMAJ(TA))
   {
      incAk = lda*(kb SHIFT);
      a2blk = Mjoin(PATL,a2blk_syrkT);
   }
   else
   {
      incAk = kb SHIFT;
      a2blk = Mjoin(PATL,a2blk_syrkN);
   }
@skip   szA = nnu*ATL_SYRKK_NU;
@skip   k = (Uplo == AtlasUpper) ? Mmax(kb,N) : kb;
@skip   szA *= k;
   szA = nnu*ATL_SYRKK_NU * kbS;
   vp = malloc(ATL_MulBySize(szA + szC + szE) 
               + 2*ATL_Cachelen);
   ATL_assert(vp);
   #ifdef TCPLX
      iA = ATL_AlignPtr(vp);
      rA = iA + szA;
      iC = rA + szA;
      iC = ATL_AlignPtr(iC);
      rC = iC + szC;
      #ifdef Conj_
         crA = (TA == AtlasNoTrans) ? rA : iA;
         ciA = (TA == AtlasNoTrans) ? iA : rA;
      #endif
      c = rC + szC;
   #else
      pA = ATL_AlignPtr(vp);
      pC = pA + (szA SHIFT);
      pC = ATL_AlignPtr(pC);
      c = pC + szC;
   #endif
#if 0
   ipinfo_t ip;
   int i, flg;
   Mjoin(PATL,ipgenInfo)(&ip, 0, TA, TA, N, N, K, lda, lda, ldc, alpha, beta);
   flg = (Uplo == AtlasLower) ? 0 : 1;
   if (TA == AtlasNoTrans)
      flg |= 2;
   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb1);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                    Mjoin(PATL,SyrkIntoC_a1b1):Mjoin(PATL,SyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbN);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                    Mjoin(PATL,SyrkIntoC_a1bN):Mjoin(PATL,SyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb0);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                    Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbX);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                    Mjoin(PATL,SyrkIntoC_a1bX):Mjoin(PATL,SyrkIntoC_aXbX);
      }
   }
   else
   {
      if (SCALAR_IS_NONE(alpha))
         blk2c = Mjoin(PATL,SyrkIntoC_aNb0);
      else
         blk2c = SCALAR_IS_ONE(alpha) ?
                 Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
   }
   Mjoin(PATL,syrkBlk)(&ip, flg|4, 0, 0, A, a2blk, K<=ip.kb?blk2c:NULL, beta, C,
                       pA, NULL, NULL, NULL, NULL, pC, pA);
//   A += (kb0 SHIFT) * (IS_COLMAJ(TA) ? lda : 1);
   nkb = K / ip.kb;
   if (nkb * ip.kb == K)
      nkb--;
   for (k=0; k < nkb; k++)
      Mjoin(PATL,syrkBlk)(&ip, flg, 0, k+1, A, a2blk, k == nkb-1 ? blk2c:NULL, 
                          beta, C, pA, NULL, NULL, NULL, NULL, pC, pA);
#else

   #ifdef TCPLX
      a2blk(kb0, N, one, A, lda, rA, iA);
      #ifdef Conj_
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, iA, iA, rC, crA, ciA, iC);
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, crA, ciA, iC, rA, rA, rC);
         Mjoin(PATL,amsyrkK_b1)(nnu, nnu, KB0, rA, rA, rC, ciA, crA, iC);
         Mjoin(PATL,amsyrkK_bn)(nnu, nnu, KB0, ciA, crA, iC, iA, iA, rC);
      #else
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, iA, iA, rC, rA, iA, iC);
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, rA, iA, iC, rA, rA, rC);
         Mjoin(PATL,amsyrkK_bn)(nnu, nnu, KB0, rA, rA, rC, iA, rA, iC);
         Mjoin(PATL,amsyrkK_b1)(nnu, nnu, KB0, iA, rA, iC, iA, iA, rC);
      #endif
   #else
      a2blk(kb0, N, ATL_rone, A, lda, pA);
      Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, pA, pA, pC, pA, pA, pC);
   #endif
   A += (kb0 SHIFT) * (IS_COLMAJ(TA) ? lda : 1);
   for (k=0; k < nkb; k++, A += incAk)
   {
      #ifdef TCPLX
         a2blk(kb, N, one, A, lda, rA, iA);
         #ifdef Conj_
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, iA, iA, rC, crA, ciA, iC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kb, crA, ciA, iC, rA, rA, rC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, rA, rA, rC, ciA, crA, iC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kb, ciA, crA, iC, iA, iA, rC);
         #else
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kb, iA, iA, rC, rA, iA, iC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, rA, iA, iC, rA, rA, rC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kb, rA, rA, rC, iA, rA, iC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, iA, rA, iC, iA, iA, rC);
         #endif
      #else
         a2blk(kb, N, ATL_rone, A, lda, pA);
         Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, pA, pA, pC, pA, pA, pC);
      #endif
   }
   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb1);
         else
            blk2c = SCALAR_IS_ONE(alpha) ? 
                    Mjoin(PATL,SyrkIntoC_a1b1):Mjoin(PATL,SyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbN);
         else
            blk2c = SCALAR_IS_ONE(alpha) ? 
                    Mjoin(PATL,SyrkIntoC_a1bN):Mjoin(PATL,SyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb0);
         else
            blk2c = SCALAR_IS_ONE(alpha) ? 
                    Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbX);
         else
            blk2c = SCALAR_IS_ONE(alpha) ? 
                    Mjoin(PATL,SyrkIntoC_a1bX):Mjoin(PATL,SyrkIntoC_aXbX);
      }
      #ifdef TCPLX
         blk2c(N, N, alpha, rC, iC, beta, C, ldc);
         #ifdef Conj_  /* must zero complex part of diagonal! */
            Mjoin(PATLU,zero)(N, C+1, (ldc+1)SHIFT);
         #endif
      #else
         blk2c(N, N, alpha, pC, beta, C, ldc);
      #endif
   }
   else /* Upper */
   {
      @BEGINSKIP
      if (SCALAR_IS_NONE(alpha))
         blk2c = Mjoin(PATL,SyrkIntoC_aNb0);
      else
         blk2c = SCALAR_IS_ONE(alpha) ? 
                 Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      #ifdef TCPLX
         blk2c(N, N, alpha, rC, iC, beta, c, N);
         #ifdef Conj_  /* must zero imag part of diagonal for HERK */
         {
            ATL_CINT ldc2=ldc+ldc;
            for (k=0; k < N; k++, c += 2, C += ldc2)
            {
               Mjoin(PATL,axpbyConj)(k+1, one, c, N, beta, C, 1);
               C[((k+1)<<1)-1] = ATL_rzero;
            }
         }
         #endif
      #else
         blk2c(N, N, alpha, pC, beta, c, N);
      #endif
      #ifndef Conj_
      if (SCALAR_IS_ZERO(beta))
         for (k=0; k < N; k++, c += (1 SHIFT), C += (ldc SHIFT))
            Mjoin(PATL,copy)(k+1, c, N, C, 1);
      else
         for (k=0; k < N; k++, c += (1 SHIFT), C += (ldc SHIFT))
            Mjoin(PATL,axpby)(k+1, one, c, N, beta, C, 1);
      #endif
      @ENDSKIP
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb1_L2UT);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b1_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb1_L2UT);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbN_L2UT);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bN_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbN_L2UT);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb0_L2UT);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b0_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb0_L2UT);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbX_L2UT);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bX_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbX_L2UT);
      }
      #ifdef TCPLX
         blk2c(N, N, alpha, rC, iC, beta, C, ldc);
         #ifdef Conj_  /* must zero complex part of diagonal! */
            Mjoin(PATLU,zero)(N, C+1, (ldc+1)SHIFT);
         #endif
      #else
         blk2c(N, N, alpha, pC, beta, C, ldc);
      #endif
   }
#endif
   free(vp);
}
#undef one
