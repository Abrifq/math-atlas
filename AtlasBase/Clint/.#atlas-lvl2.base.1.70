@ifdef ! incd
   @define incd @/home/rwhaley/Base/ATLAS@
@endifdef
@extract -b @(topd)/gen.inc what=crsetup
@ROUT r1ktest
@extract -b @(topd)/gen.inc what=cw @(cw09)
@ROUT r1test mvtest gmvsearchT
@extract -b @(topd)/gen.inc what=cw @(cw00)
@ROUT mvsearch r1search ATL_symv gemvtune ger1tune ATL_cger1_axpy @\ 
      ATL_cger1_2x1p ATL_cger1_dummy ATL_ger1_4x4_1 ATL_ger1_8x4_0 @\
      ATL_ger1_1x4_0 atlas_r1.h ATL_ger ATL_gemv ATL_gemvN_dummy2 @\
      ATL_gemvT_dummy2 ATL_cgemvN_4x2_1 ATL_cgemvN_2x2_0 ATL_cgemvN_mm @\
      ATL_cgemvN_1x1_1 ATL_cgemvN_1x1_1a ATL_gemvN_4x4_1 ATL_gemvN_4x2_0 @\
      ATL_gemvN_mm ATL_gemvN_8x32_2 ATL_gemvN_8x4_1 ATL_gemvN_16x2_1 @\
      ATL_gemvN_16x4_1 ATL_gemvN_32x4_1 ATL_gemvN_1x1_1 ATL_gemvN_1x1_1a @\
      ATL_gpmvN_32x4_1 ATL_gpmvN_1x1_1a ATL_cgemvT_2x4_1 ATL_cgemvT_2x2_0 @\
      ATL_cgemvT_mm ATL_cgemvT_1x1_1 ATL_gemvT_4x8_1 ATL_gemvT_2x8_0 @\
      ATL_gemvT_mm ATL_gemvT_4x16_1 TL_gemvT_2x16_1 ATL_gemvT_1x1_1 @\
      ATL_trmvUT ATL_trmvUN ATL_trmvLN ATL_trmvLT ATL_trmv symv l2blastst @\
      atlas_lvl2.h atlas_level2.h ATL_gemvN_dummy ATL_gemvT_2x16_1 @\
      ATL_gemvT_dummy
@extract -b @(topd)/gen.inc what=cw @(cw99)

@ROUT mvsearch r1search gmvsearchT
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <assert.h>
#include "atlas_fopen.h"
#include <string.h>

@ROUT mvsearch
#define ATL_MVIsMM(iflag_) ( ((iflag_) | 8) == (iflag_) )
#define ATL_MVIsAxpy(iflag_) ( ((iflag_) | 16) == (iflag_) )
#define ATL_MVIsDot(iflag_) ( !ATL_MVIsMM(iflag_) && !ATL_MVIsAxpy(iflag_) )
#define ATL_MVNoBlock(iflag_) ( ((iflag_) | 32) == (iflag_) )

@ROUT r1search
#define ATL_NoBlock(iflag_) ( ((iflag_) | 32) == (iflag_) )

@ROUT mvsearch r1search gmvsearchT
double GetAvg(int n, double tolerance, double *mflop)
{
   int i, j;
   double t0, tavg;
/*
 * Sort results, largest first
 */
   for (i=0; i != n; i++)
   {
      for (j=i+1; j < n; j++)
      {
         if (mflop[i] < mflop[j])
         {
            t0 = mflop[i];
            mflop[i] = mflop[j];
            mflop[j] = t0;
         }
      }
   }
/*
 * Throw out result if it is outside tolerance; rerun if two mflop not within
 * tolerance;  this code assumes n == 3
 */
   if (tolerance*mflop[1] < mflop[0])  /* too big a range in results */
   {
      if (tolerance*mflop[2] < mflop[1]) return(-1.0);
      tavg = (mflop[1] + mflop[2]) / 2.0;
   }
   else if (tolerance*mflop[2] < mflop[0]) tavg = (mflop[0] + mflop[1]) / 2.0;
   else tavg = (mflop[0] + mflop[1] + mflop[2]) / 3.0;

   return(tavg);
}

int GetL1CacheSize()
{
   FILE *L1f;
   int L1Size;

   if (!FileExists("res/L1CacheSize"))
   {
      assert(system("make res/L1CacheSize\n") == 0);
   }
   L1f = fopen("res/L1CacheSize", "r");
   assert(L1f != NULL);
   fscanf(L1f, "%d", &L1Size);
   fclose(L1f);
   fprintf(stderr, "\n      Read in L1 Cache size as = %dKB.\n",L1Size);
   return(L1Size);
}

@ROUT mvsearch
int mvtstcase(char pre, char TA, char *mvnam, char *cc, char *ccflags)
{
   char ln[256];
   if (cc[0] != '\0' && ccflags[0] != '\0')
      sprintf(ln, 
              "make %cmvtstcase%c mvrout=%s %cMVCC=\"%s\" %cMVFLAGS=\"%s\"\n",
              pre, TA, mvnam, pre, cc, pre, ccflags);
   else if (cc[0] == '\0' && ccflags[0] != '\0')
      sprintf(ln, "make %cmvtstcase%c mvrout=%s EXTFLAGS=\"%s\"\n",
              pre, TA, mvnam, ccflags);
   else sprintf(ln, "make %cmvtstcase%c mvrout=%s\n", pre, TA, mvnam);
   return(system(ln));
}

double svcase
   (char pre, int cas, int l1mul, int mu, int nu, int flag,
    char *mvnamN, char *ccN, char *ccflagsN,
    char *mvnamT, char *ccT, char *ccflagsT)
{
   char ln[1024], fnam[64];
   const int imul = l1mul;
   int i, mb;
   double mfs[3], mf;
   FILE *fp;

   sprintf(fnam, "res/%csymvS_%d_0", pre, cas);
   if (!FileExists(fnam))
   {
      i = sprintf(ln, "make %csvcase mvrout=%s svrout=%s cas=%d xu=%d yu=%d l1mul=%d iflag=%d gmvout=\"-o %s\"",
              pre, mvnamT, mvnamN, cas, nu, mu, imul, flag, fnam);
      if (ccN[0] != '\0' && ccflagsN[0] != '\0')
         i += sprintf(ln+i, " %cSVCC=\"%s\" %cSVFLAGS=\"%s\"", 
                      pre, ccN, pre, ccflagsN);
      else if (ccN[0] == '\0' && ccflagsN[0] != '\0')
      {
         i += sprintf(ln+i, 
           " SEXTFLAGS=\"%s -DATL_NOL1PREFETCH -DATL_NOL2PREFETCH\"", ccflagsN);
      }
      else i += sprintf(ln+i, 
           " SEXTFLAGS=\"-DATL_NOL1PREFETCH -DATL_NOL2PREFETCH\"");
      if (ccT[0] != '\0' && ccflagsT[0] != '\0')
         i += sprintf(ln+i, " %cMVCC=\"%s\" %cMVFLAGS=\"%s\"", 
                      pre, ccT, pre, ccflagsT);
      else if (ccT[0] == '\0' && ccflagsT[0] != '\0')
         i += sprintf(ln+i, " SEXTFLAGS=\"%s\"", ccflagsT);
      sprintf(ln+i, "\n");
      fprintf(stderr, "%s", ln);
      if (system(ln)) return(-1.0);  /* won't compile here */
   }
   fp = fopen(fnam, "r");
   assert(fp);
   assert(fscanf(fp, " %lf %lf %lf", mfs, mfs+1, mfs+2) == 3);
   fclose(fp);
   mf = GetAvg(3, 1.20, mfs);
   if (mf == -1.0)
   {
      fprintf(stderr, 
"\n\n%s : VARIATION EXCEEDS TOLERENCE, RERUN WITH HIGHER REPS.\n\n", fnam);
      sprintf(ln, "rm -f %s\n", fnam);
      system(ln);
      exit(-1);
   }
   return(mf);
}

double mvcase(int SY, char pre, char *mvnam, char TA, int flag, int mu, int nu, 
              int cas, char *cc, char *ccflags, int l1mul)
{
   char nTA;
   char ln[1024], fnam[64];
   const int imul = l1mul;
   int i, mb;
   double mfs[3], mf;
   FILE *fp;

   if (TA == 'n' || TA == 'N') nTA = 'T';
   else nTA = 'N';
   if (mu == 0) mu = 1;
   if (nu == 0) nu = 1;

   if (SY) sprintf(fnam, "res/%csymv%c_%d_0", pre, TA, cas);
   else
   {
      if (ATL_MVNoBlock(flag)) sprintf(fnam, "res/%cgemv%c_%d_0", pre, TA, cas);
      else sprintf(fnam, "res/%cgemv%c_%d_%d", pre, TA, cas, imul);
   }
   if (!FileExists(fnam))
   {
      i = sprintf(ln, "make %cmvcase%c mvrout=%s cas=%d xu=%d yu=%d l1mul=%d iflag=%d gmvout=\"-o %s\"",
              pre, TA, mvnam, cas, nu, mu, imul, flag, fnam);
      if (cc[0] != '\0' && ccflags[0] != '\0')
         i += sprintf(ln+i, " %cMVCC=\"%s\" %cMVFLAGS=\"%s\"", 
                      pre, cc, pre, ccflags);
      else if (cc[0] == '\0' && ccflags[0] != '\0')
      {
         if (SY) i += sprintf(ln+i, 
            " EXTFLAGS=\"%s -DATL_NOL1PREFETCH -DATL_NOL2PREFETCH\"", ccflags);
         else i += sprintf(ln+i, " EXTFLAGS=\"%s\"", ccflags);
      }
      if (SY)
      {
         if (pre == 'd' || pre == 'c') mb = 1024 / 8;
         else if (pre == 's') mb = 1024 / 4;
         else if (pre == 'z') mb = 1024 / 16;
         mb = 0.01*l1mul*mb*GetL1CacheSize();
         mb = (mb-2*nu)/(nu+2);
         if (mb > mu) mb = (mb/mu)*mu;
         if (!(cc[0] == '\0' && ccflags[0] != '\0'))
            i += sprintf(ln+i, 
                         " EXTFLAGS=\"-DATL_NOL1PREFETCH -DATL_NOL2PREFETCH\"");
         i += sprintf(ln+i, " opt=\"-2 1 -L %d\" M=%d N=%d", mb, mb, nu);
      }
      sprintf(ln+i, "\n");
      fprintf(stderr, "%s", ln);
      if (system(ln)) return(-1.0);  /* won't compile here */
   }
   fp = fopen(fnam, "r");
   assert(fp);
   assert(fscanf(fp, " %lf %lf %lf", mfs, mfs+1, mfs+2) == 3);
   fclose(fp);
   mf = GetAvg(3, 1.20, mfs);
   if (mf == -1.0)
   {
      fprintf(stderr, 
"\n\n%s : VARIATION EXCEEDS TOLERENCE, RERUN WITH HIGHER REPS.\n\n", fnam);
      sprintf(ln, "rm -f %s\n", fnam);
      system(ln);
      exit(-1);
   }
   return(mf);
}

int FindL1Mul(char pre, int cas, char *mvnam, char *cc, char *ccflags,
              char TA, int flag, int mu, int nu)
{
   double low = .5, high = 1.0;
   double mflow, mfhigh;
   int ilow, ihigh;

   if (ATL_MVNoBlock(flag)) flag -= 32;  /* always actually block these times */
   do
   {
      ilow = (low  * 100.0);
      ihigh = (high * 100.0);
      mflow  = mvcase(0, pre, mvnam, TA, flag, mu, nu, cas, cc, ccflags, ilow);
      mfhigh = mvcase(0, pre, mvnam, TA, flag, mu, nu, cas, cc, ccflags, ihigh);
      fprintf(stdout, "      %d%% %.2fMFLOP  ---  %d%% %.2fMFLOP\n",
              ilow, mflow, ihigh, mfhigh);
      if (mflow < 1.005*mfhigh) low += 0.5*(high-low);
      else high -= 0.5 * (high-low);
   }
   while (ihigh-ilow);
   fprintf(stdout, "\n\nBEST %% of L1 cache: %d\n", ilow);
   return(ilow);
}

int ConfirmBlock(char pre, char *mvnam, char *cc, char *ccflags, char TA,
                 int flag, int mu, int nu, int cas, int l1mul)
{
   int bflag;
   double mfblock, mfnoblock;

   if ( ATL_MVNoBlock(flag) )
   {
      bflag = flag - 32;
      mfblock   = mvcase(0, pre, mvnam, TA, bflag, mu, nu, cas, cc, ccflags, 
                         l1mul);
      mfnoblock = mvcase(0, pre, mvnam, TA,  flag, mu, nu, cas, cc, ccflags,
                         l1mul);
      fprintf(stdout, "\nWith blocking=%lf, without=%lf\n\n", 
              mfblock, mfnoblock);
      if (mfblock >= mfnoblock) return(bflag);
   }
   return(flag);
}

@ROUT r1search mvsearch
void NoEndLineWhiteSpace(char *ln)
{
   int i;

   for (i=0; ln[i]; i++);
   if (i)
      for (i--; isspace(ln[i]); i--) ln[i] = '\0';
}

int LineIsCont(char *ln)
{
   int i, iret=0;
   for(i=0; ln[i]; i++);
   if (i)
   {
      for(i--; isspace(ln[i]); i--);
      if (ln[i] == '\\') iret = 1;
   }
   return(iret);
}

@ROUT mvsearch
int iGetIDCase(FILE *fp, int ID, char *fnam, char *auth, char *cc,
               char *ccflags, int *flag, int *mu, int *nu)
{
   char ln[256];
   int i, n, id;

   assert(fgets(ln, 128, fp));
   assert(sscanf(ln, " %d", &n) == 1);
   for (i=0; i < n; i++)
   {
      assert(fgets(ln, 256, fp));
      assert(sscanf(ln, " %d %d %d %d %s \"%[^\"]", 
                    &id, flag, mu, nu, fnam, auth) == 6);
      if (LineIsCont(ln))
      {
         assert(fgets(cc, 256, fp));
         assert(fgets(ccflags, 256, fp));
         NoEndLineWhiteSpace(cc);
         NoEndLineWhiteSpace(ccflags);
      }
      else cc[0] = ccflags[0] = '\0';
      if (id == ID) break;
   }
   return(id);
}

void GetIDCase(char pre, int ID, char *fnam, char *auth, char *cc,
               char *ccflags, int *flag, int *mu, int *nu)
{
   char ln[256];
   int i, n, id;
   FILE *fp;

   sprintf(ln, "%ccases.dsc", pre);
   fp = fopen(ln, "r");
   assert(fp);

   id = iGetIDCase(fp, ID, fnam, auth, cc, ccflags, flag, mu, nu);
   if (id != ID) id = iGetIDCase(fp, ID, fnam, auth, cc, ccflags, flag, mu, nu);

   fclose(fp);
   assert(id == ID);
}

void GetCases(FILE *fp, int *N, int **IDs, char ***fnams, char ***auths,
              char ***CC, char ***CCFLAGS, int **flags, int **mus, int **nus)
{
   int i, j, n;
   int *mu, *nu, *flag, *id;
   char **fnam, **auth, **cc, **ccflags;
   char ln[256];

   assert(fgets(ln, 128, fp));
   assert(sscanf(ln, " %d", &n) == 1);
   assert(n < 100 && n > 0);
   fnam    = malloc(n * sizeof(char*));
   auth    = malloc(n * sizeof(char*));
   cc      = malloc(n * sizeof(char*));
   ccflags = malloc(n * sizeof(char*));
   assert(fnam && auth && cc && ccflags);
   for (i=0; i < n; i++)
   {
      assert(fnam[i] = malloc(64*sizeof(char)));
      assert(auth[i] = malloc(64*sizeof(char)));
   }
   id = malloc(n * sizeof(int));
   mu = malloc(n * sizeof(int));
   nu = malloc(n * sizeof(int));
   flag = malloc(n * sizeof(int));
   assert(id && mu && nu && flag);
   for (i=0; i < n; i++)
   {
      assert(fgets(ln, 256, fp));
      assert(sscanf(ln, " %d %d %d %d %s \"%[^\"]", 
                    id+i, flag+i, mu+i, nu+i, fnam[i], auth[i]) == 6);
      assert(mu[i] >= 0 && nu[i] >= 0 && fnam[i][0] != '\0' && id[i] > 0);
      if (LineIsCont(ln))
      {
         fgets(ln, 256, fp);
         NoEndLineWhiteSpace(ln);
         if (ln[0] == '+' && (ln[1] == '\0' || ln[1] == ' ')) /* adding flags */
            cc[i] = NULL;
         else
         {
            j = strlen(ln);
            cc[i] = malloc((j+1)*sizeof(char));
            assert(cc[i]);
            strcpy(cc[i], ln);
         }
         fgets(ln, 256, fp);
         NoEndLineWhiteSpace(ln);
         j = strlen(ln);
         ccflags[i] = malloc((j+1)*sizeof(char));
         assert(ccflags[i]);
         strcpy(ccflags[i], ln);
      }
      else cc[i] = ccflags[i] = NULL;
   }
   for (i=0; i < n; i++) /* fix cc & ccflags */
   {
      if (cc[i] == NULL)
      {
         cc[i] = malloc(2*sizeof(char));
         assert(cc[i]);
         cc[i][0] = cc[i][1] = '\0';
      }
      if (ccflags[i] == NULL)
      {
         ccflags[i] = malloc(2*sizeof(char));
         assert(ccflags[i]);
         ccflags[i][0] = ccflags[i][1] = '\0';
      }
   }
   
   *N = n;
   *IDs = id;
   *fnams = fnam;
   *auths = auth;
   *CC = cc;
   *CCFLAGS = ccflags;
   *flags = flag;
   *mus = mu;
   *nus = nu;
}

int RunTransCases(int SY, char pre, char TA, int ncases, int *ids, char **fnams,
                  char **cc, char **ccflags, int *flags, int *mus, int *nus)
{
   int i, imax=0;
   double mf, mfmax=0.0;

   for (i=0; i < ncases; i++)
   {
      mf = mvcase(SY, pre, fnams[i], TA, flags[i], mus[i], nus[i], ids[i], 
                  cc[i], ccflags[i], 75);
      fprintf(stdout, "%s : %.2f\n", fnams[i], mf);
      if (mf > mfmax)
      {
         if (mvtstcase(pre, TA, fnams[i], cc[i], ccflags[i]) == 0)
         { /* ensure it passes test */
            mfmax = mf;
            imax = i+1;
         }
         else fprintf(stderr, "\n\nROUTINE %s FAILED TESTS!!!\n\n", fnams[i]);
      }
   }
   assert(imax);
   fprintf(stdout, 
           "\nbest %cgemv%c : ID=%d, mu=%d, nu=%d at %.2f MFLOPS\n\n", 
           pre, TA, ids[imax-1], mus[imax-1], nus[imax-1], mfmax);
   return(imax-1);
}

void ReadSum(char pre, int *l1mul,
int *idN, char *fnamN, char *authN, int *flagN, int *muN, int *nuN, double *mfN,
int *idT, char *fnamT, char *authT, int *flagT, int *muT, int *nuT, double *mfT,
int *idS, char *fnamS, char *authS, int *flagS, int *muS, int *nuS, double *mfS)
{
   char ln[256];
   int i;
   FILE *fp;
   double t0;

   sprintf(ln, "res/%cMVRES", pre);
   fp = fopen(ln, "r");
   assert(fp);

   assert(fgets(ln, 256, fp));
   assert(sscanf(ln, " %d %d %d %d %d %lf %s \"%[^\"]", 
                 idN, flagN, muN, nuN, l1mul, mfN, fnamN, authN) == 8);
   assert(fgets(ln, 256, fp));
   assert(sscanf(ln, " %d %d %d %d %d %lf %s \"%[^\"]", 
                 idT, flagT, muT, nuT, l1mul, mfT, fnamT, authT) == 8);
   assert(fgets(ln, 256, fp));
   assert(sscanf(ln, " %d %d %d %d %d %lf %s \"%[^\"]", 
                 idS, flagS, muS, nuS, &i, mfS, fnamS, authS) == 8);
   fclose(fp);
}

void CreateSum
   (char pre, int l1mul,
    int idN, char *fnamN, char *authN, int flagN, int muN, int nuN, double mfN, 
    int idT, char *fnamT, char *authT, int flagT, int muT, int nuT, double mfT,
    int idS, char *fnamS, char *authS, int flagS, int muS, int nuS, double mfS)
{
   char fnam[32];
   FILE *fp;

   sprintf(fnam, "res/%cMVRES", pre);
   fp = fopen(fnam, "w");
   assert(fp);
   fprintf(fp, "%d %d %d %d %d %.2f %s \"%s\"\n", 
           idN, flagN, muN, nuN, l1mul, mfN, fnamN, authN);
   fprintf(fp, "%d %d %d %d %d %.2f %s \"%s\"\n",
           idT, flagT, muT, nuT, l1mul, mfT, fnamT, authT);
   fprintf(fp, "%d %d %d %d %d %.2f %s \"%s\"\n",
           idS, flagS, muS, nuS, l1mul, mfS, fnamS, authS);
   fclose(fp);
}

void GenMakefile(char pre, char *ccN, char *ccflagsN, char *ccT, char *ccflagsT,
                 char *ccS, char *ccflagsS)
{
   char ln[256];
   char renam[128];
   char *bet[4] = {"0", "1", "X", "XI0"};
   char *tts[6] = {"N", "T", "S", "N",  "T"};
   char *TAs[6] = {"N", "T", "S", "Nc", "C"};
   char *typ, *ct;
   char UPR;
   FILE *fp;
   int i, j, nbet=3, ntran=3;

   if (pre == 's') typ = "SREAL";
   else if (pre == 'd') typ = "DREAL";
   else if (pre == 'c') typ = "SCPLX";
   else if (pre == 'z') typ = "DCPLX";
   else assert(0);
   UPR = (pre == 's' || pre == 'c') ? 'S' : 'D';
   sprintf(ln, "Make_%cmv", pre);
   fp = fopen(ln, "w");
   assert(fp);
   fprintf(fp, "include Make.inc\n\n");

   if (ccN[0] == '\0') fprintf(fp, "MVNCC = $(%cKC)\n", UPR);
   else fprintf(fp, "MVNCC = %s\n", ccN);
   if (ccN[0] == '\0' && ccflagsN[0] != '\0')
      fprintf(fp, "MVNFLAGS = $(CDEFS) $(%cKCFLAGS) %s -D%s\n", 
              UPR, ccflagsN, typ);
   else if (ccflagsN[0] != '\0')
      fprintf(fp, "MVNFLAGS = $(CDEFS) %s -D%s\n", ccflagsN, typ);
   else fprintf(fp, "MVNFLAGS = $(CDEFS) $(%cKCFLAGS) -D%s\n", UPR, typ);
   if (pre == 'c' || pre == 'z')
   {
      fprintf(fp, "MVNcCC = $(MVNCC)\n");
      fprintf(fp, "MVNcFLAGS = $(MVNFLAGS) -DConj_\n\n");
   }

   if (ccT[0] == '\0') fprintf(fp, "MVTCC = $(%cKC)\n", UPR);
   else fprintf(fp, "MVTCC = %s\n", ccT);
   if (ccT[0] == '\0' && ccflagsT[0] != '\0')
      fprintf(fp, "MVTFLAGS = $(CDEFS) $(%cKCFLAGS) %s -D%s\n", 
              UPR, ccflagsT, typ);
   else if (ccflagsT[0] != '\0')
      fprintf(fp, "MVTFLAGS = $(CDEFS) %s -D%s\n", ccflagsT, typ);
   else fprintf(fp, "MVTFLAGS = $(CDEFS) $(%cKCFLAGS) -D%s\n", UPR, typ);
   if (pre == 'c' || pre == 'z')
   {
      fprintf(fp, "MVCCC = $(MVTCC)\n");
      fprintf(fp, "MVCFLAGS = $(MVTFLAGS) -DConj_\n\n");
   }

   if (ccS[0] == '\0') fprintf(fp, "MVSCC = $(%cKC)\n", UPR);
   else fprintf(fp, "MVSCC = %s\n", ccS);
   if (ccS[0] == '\0' && ccflagsS[0] != '\0')
      fprintf(fp, "MVSFLAGS = $(CDEFS) $(%cKCFLAGS) %s -D%s", 
              UPR, ccflagsS, typ);
   else if (ccflagsS[0] != '\0')
      fprintf(fp, "MVSFLAGS = $(CDEFS) %s -D%s", ccflagsS, typ);
   else fprintf(fp, "MVSFLAGS = $(CDEFS) $(%cKCFLAGS) -D%s", UPR, typ);
   fprintf(fp, " -DATL_NOL1PREFETCH -DATL_NOL2PREFETCH\n\n");

   if (pre == 's' || pre == 'd')
   {
      fprintf(fp, "\nobj = ");
      for (i=0; i < ntran; i++)
      {
         fprintf(fp, 
         "\\\n      ATL_%cgemv%s_b0.o ATL_%cgemv%s_b1.o ATL_%cgemv%s_bX.o ",
                 pre, TAs[i], pre, TAs[i], pre, TAs[i]);
      }
   }
   else
   {
      nbet = 4;
      ntran = 5;
      fprintf(fp, "\nobj = ");
      for (i=0; i < ntran; i++)
      {
         fprintf(fp, 
"\\\n      ATL_%cgemv%s_b0.o ATL_%cgemv%s_b1.o ATL_%cgemv%s_bX.o ATL_%cgemv%s_bXI0.o ",
                 pre, TAs[i], pre, TAs[i], pre, TAs[i], pre, TAs[i]);
      }
   }
   fprintf(fp, "\n\n");
   fprintf(fp, "%clib : lib\n", pre);
   fprintf(fp, "lib : %cmvk.grd\n", pre);
   fprintf(fp, "%cmvk.grd : $(obj)\n", pre);
   fprintf(fp, "\t$(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(obj)\n");
   fprintf(fp, "\t$(RANLIB) $(ATLASlib)\n");
   fprintf(fp, "\ttouch %cmvk.grd\n\n", pre);

   fprintf(fp, "clean :\n\t rm -f $(obj) %cmvk.grd\n", pre);
   fprintf(fp, "%cclean : clean\n\n", pre);

   for (j=0; j < ntran; j++)
   {
      for (i=0; i < nbet; i++)
      {
         if (TAs[j][0] == 'S')
         {
            if (i == 3)  /* hack to get cap correct without rewriting */
               sprintf(renam, 
                  " -DATL_%cgemvN_a1_x1_bXi0_y1=ATL_%cgemvS_a1_x1_bXi0_y1 ",
                       pre, pre);
            else
               sprintf(renam, 
                       " -DATL_%cgemvN_a1_x1_b%s_y1=ATL_%cgemvS_a1_x1_b%s_y1 ",
                       pre, bet[i], pre, bet[i]);
            fprintf(fp, "ATL_%cgemvS_b%s.o : ATL_%cgemvS.c\n", 
                    pre, bet[i], pre);
            fprintf(fp, 
                    "\t$(MVSCC) -o $@ -c $(MVSFLAGS) -DBETA%s -DALPHA1 %s \\\n",
                    bet[i], renam);
            fprintf(fp, "                 ATL_%cgemvS.c\n", pre);
         }
         else
         {
            fprintf(fp, "ATL_%cgemv%s_b%s.o : ATL_%cgemv%s.c\n", 
                    pre, TAs[j], bet[i], pre, tts[j]);
            fprintf(fp, 
"\t$(MV%sCC) -o $@ -c $(MV%sFLAGS) -DBETA%s -DALPHA1 ATL_%cgemv%s.c\n",
                    TAs[j], TAs[j], bet[i], pre, tts[j]);
         }
      }
   }
   fclose(fp);
}

void mvinstall(char pre, int l1mul,
               int idN, char *fnamN, char *authN, char *ccN, char *ccflagsN,
               int flagN, int muN, int nuN, 
               int idT, char *fnamT, char *authT, char *ccT, char *ccflagsT,
               int flagT, int muT, int nuT,
               int idS, char *fnamS, char *authS, char *ccS, char *ccflagsS,
               int flagS, int muS, int nuS)
{
   char ln[256];
   double mfN, mfT, mfS;

   GenMakefile(pre, ccN, ccflagsN, ccT, ccflagsT, ccS, ccflagsS);
   mfS = mvcase(1,pre, fnamS, 'N', flagS, muS, nuS, 5000, ccT, ccflagsT, l1mul);
   mfN = mvcase(0,pre, fnamN, 'N', flagN, muN, nuN, 5000, ccN, ccflagsN, l1mul);
   mfT = mvcase(0,pre, fnamT, 'T', flagT, muT, nuT, 5000, ccT, ccflagsT, l1mul);
   sprintf(ln, "make xemit_head \n");
   assert(system(ln) == 0);
   sprintf(ln, "./xemit_head -p %c -l %d -N -f %d -y %d -x %d -T -f %d -y %d -x %d -S -f %d -y %d -x %d\n", pre, l1mul, flagN, muN, nuN, flagT, muT, nuT, flagS, muS, nuS);
   fprintf(stderr, "%s", ln);
   assert(system(ln) == 0);
   sprintf(ln, "make %cinstall mvNrout=%s mvTrout=%s mvSrout=%s\n", 
           pre, fnamN, fnamT, fnamS);
   fprintf(stderr, "%s", ln);
   assert(system(ln) == 0);
   CreateSum(pre, l1mul, idN, fnamN, authN, flagN, muN, nuN, mfN, 
             idT, fnamT, authT, flagT, muT, nuT, mfT,
             idS, fnamS, authS, flagS, muS, nuS, mfS);
}

static int ilcm(const int m, const int n)
{
   int ia, iq, ir, ilcm;

   if (m == n) return(n);
   if (m >= n)
   {
      ia = m;
      ilcm = n;
   }
   else
   {
      ia = n;
      ilcm = m;
   }
   do
   {
      iq = ia / ilcm;
      ir = ia - iq * ilcm;
      if (ir == 0) return( (m*n)/ilcm );
      ia = ilcm;
      ilcm = ir;
   }
   while(1);
}

int RunSymmCases(char pre, char *fnamT, char *ccT, char *ccflagsT, 
                 int muT, int nuT, int flagT, int ncases, 
                 int *ids, char **fnams, char **cc, char **ccflags,
                 int *flags, int *mus, int *nus, int *muS, int *nuS)
{
   int i, mu, nu;
   int imax=(-1);
   double mf, mfB=0.0;

   if (ATL_MVIsMM(flagT)) /* if using gemm for trans, use it for notrans too */
   {
      *muS = *nuS = 80;
      for (i=0; i < ncases; i++) if (ATL_MVIsMM(flags[i])) return(i);
      assert(0);
   }
   for (i=0; i < ncases; i++)
   {
      if (ATL_MVIsAxpy(flags[i]))  /* only try axpy-based routs */
      {
         mu = ilcm(muT, nus[i]);
         nu = ilcm(nuT, mus[i]);
         mf = svcase(pre, ids[i], 75, mu, nu, flags[i], fnams[i], 
                     cc[i], ccflags[i], fnamT, ccT, ccflagsT);
         if (mf > mfB)
         {
            mfB = mf;
            imax = i;
            *muS = mu;
            *nuS = nu;
         }
      }
   }
   assert(imax != -1);
   return(imax);
}

void RunCases(char pre)
{
   char fnam[128];
   char Nfnam[256], Tfnam[256], Nauth[256], Ncc[256], Tauth[256], Tcc[256];
   char Nccflags[512], Tccflags[512];
   char Sfnam[256], Sauth[256], Scc[256], Sccflags[512];
   char **fnamN, **fnamT, **authN, **authT, **ccN, **ccflagsN, 
        **ccT, **ccflagsT;
   int i, nNTcases, nTcases, Nbest, Tbest, Sbest;
   int Nid, Nflag, Nmu, Nnu, Tid, Tflag, Tmu, Tnu;
   int Sid, Sflag, Smu, Snu;
   int *flagN, *muN, *nuN, *flagT, *muT, *nuT, *idN, *idT;
   int l1mul;
   FILE *fp;

/*
 * Read in cases to try
 */
   sprintf(fnam, "%ccases.dsc", pre);
   fp = fopen(fnam, "r");
   assert(fp);
   GetCases(fp, &nNTcases, &idN, &fnamN, &authN, &ccN, &ccflagsN, &flagN,
            &muN, &nuN);
   GetCases(fp, &nTcases,  &idT, &fnamT, &authT, &ccT, &ccflagsT, &flagT,
            &muT, &nuT);
   fclose(fp);
/*
 * Try all cases for each trans case
 */
   Nbest = RunTransCases(0, pre, 'N', nNTcases, idN, fnamN, ccN, ccflagsN, 
                         flagN, muN, nuN);
   Tbest = RunTransCases(0, pre, 'T', nTcases, idT, fnamT, ccT, ccflagsT,
                         flagT, muT, nuT);
   Sbest = RunSymmCases(pre, fnamT[Tbest], ccT[Tbest], ccflagsT[Tbest], 
                        muT[Tbest], nuT[Tbest], flagT[Tbest], 
                        nNTcases, idN, fnamN, ccN, ccflagsN, flagN, muN, nuN,
                        &Smu, &Snu);
   Nid = idN[Nbest]; Nflag = flagN[Nbest]; Tflag = flagT[Tbest];
   Nmu = muN[Nbest]; Nnu = nuN[Nbest];
   strcpy(Nfnam, fnamN[Nbest]); strcpy(Nauth, authN[Nbest]);
   strcpy(Ncc, ccN[Nbest]);
   strcpy(Nccflags, ccflagsN[Nbest]);
   Tid = idT[Tbest]; Tmu = muT[Tbest]; Tnu = nuT[Tbest];
   strcpy(Tfnam, fnamT[Tbest]); strcpy(Tauth, authT[Tbest]);
   strcpy(Tcc, ccT[Tbest]);
   strcpy(Tccflags, ccflagsT[Tbest]);
   if (Sbest == -1) Sbest = Nbest;
   Sid = idN[Sbest]; Sflag = flagN[Sbest];
   strcpy(Sfnam, fnamN[Sbest]); strcpy(Sauth, authN[Sbest]);
   strcpy(Scc, ccN[Sbest]);
   strcpy(Sccflags, ccflagsN[Sbest]);

   free(flagN); free(flagT); free(muN); free(muT); free(nuN); free(nuT);
   for (i=0; i < nNTcases; i++)
   {
      free(fnamN[i]);
      free(authN[i]);
      free(ccN[i]);
      free(ccflagsN[i]);
   }
   free(fnamN); free(authN); free(ccN); free(ccflagsN);
   for (i=0; i < nTcases; i++)
   {
      free(fnamT[i]);
      free(authT[i]);
      free(ccT[i]);
      free(ccflagsT[i]);
   }
   free(fnamT); free(authT); free(ccT); free(ccflagsT);
   l1mul = FindL1Mul(pre, Tid, Tfnam, Tcc, Tccflags, 'T', Tflag, Tmu, Tnu);
   Tflag = ConfirmBlock(pre, Tfnam, Tcc, Tccflags, 'T', Tflag, Tmu, Tnu,
                        Tid, l1mul);
   Nflag = ConfirmBlock(pre, Nfnam, Ncc, Nccflags, 'N', Nflag, Nmu, Nnu,
                        Nid, l1mul);
   CreateSum(pre, l1mul, Nid, Nfnam, Nauth, Nflag, Nmu, Nnu, -1.0, 
             Tid, Tfnam, Tauth, Tflag, Tmu, Tnu, -1.0,
             Sid, Sfnam, Sauth, Sflag, Smu, Snu, -1.0);
}

void GoToTown(pre)
{
   char fnamN[256], authN[256], fnamT[256], authT[256], ln[128];
   char ccN[256], ccflagsN[512], ccT[256], ccflagsT[512];
   char fnamS[256], authS[256], ccS[256], ccflagsS[512];
   int idN, flagN, muN, nuN, idT, flagT, muT, nuT, l1mul;
   int idS, flagS, muS, nuS, i, j;
   double mfN, mfT, mfS;

   sprintf(ln, "res/%cMVRES", pre);
   if (!FileExists(ln)) RunCases(pre);
   else  /* if default does not pass tester, rerun cases */
   {
      ReadSum(pre, &l1mul, &idN, fnamN, authN, &flagN, &muN, &nuN, &mfN,
              &idT, fnamT, authT, &flagT, &muT, &nuT, &mfT,
              &idS, fnamS, authS, &flagS, &muS, &nuS, &mfS);
      GetIDCase(pre, idN, fnamN, authN, ccN, ccflagsN, &flagN, &muN, &nuN);
      GetIDCase(pre, idT, fnamT, authT, ccT, ccflagsT, &flagT, &muT, &nuT);
      GetIDCase(pre, idS, fnamS, authS, ccS, ccflagsS, &flagS, &i, &j);
      if ( (mvtstcase(pre, 'N', fnamN, ccN, ccflagsN) != 0) ||
           (mvtstcase(pre, 'T', fnamT, ccT, ccflagsT) != 0) ||
           (mvtstcase(pre, 'N', fnamS, ccS, ccflagsS) != 0) )
      {
         assert(remove(ln) == 0);
         RunCases(pre);
      }
   }
   ReadSum(pre, &l1mul, &idN, fnamN, authN, &flagN, &muN, &nuN, &mfN,
           &idT, fnamT, authT, &flagT, &muT, &nuT, &mfT,
           &idS, fnamS, authS, &flagS, &muS, &nuS, &mfS);
   GetIDCase(pre, idN, fnamN, authN, ccN, ccflagsN, &flagN, &muN, &nuN);
   GetIDCase(pre, idT, fnamT, authT, ccT, ccflagsT, &flagT, &muT, &nuT);
   GetIDCase(pre, idS, fnamS, authS, ccS, ccflagsS, &flagS, &i, &j);
   mvinstall(pre, l1mul, idN, fnamN, authN, ccN, ccflagsN, flagN, muN, nuN,
             idT, fnamT, authT, ccT, ccflagsT, flagT, muT, nuT,
             idS, fnamS, authS, ccS, ccflagsS, flagS, muS, nuS);
}

void PrintUsage(char *fnam)
{
   fprintf(stderr, "USAGE: %s [-p <s,d,c,z>]\n", fnam);
   exit(-1);
}

void GetFlags(int nargs, char **args, char *pre, char *TA, int *mu, int *nu)
{
   char ctmp;
   int i;
   *pre = 'd';
   *mu = *nu = 0;
   *TA = ' ';
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(&args[0][0]);
      switch(args[i][1])
      {
      case 'p':
         ctmp = args[++i][0];
         ctmp = tolower(ctmp);
         if (ctmp == 's' || ctmp == 'd' || ctmp == 'c' || ctmp == 'z')
            *pre = ctmp;
         else PrintUsage(&args[0][0]);
         break;
      case 'm':
         *mu = atoi(args[++i]);
         assert(*mu > 0);
         break;
      case 'n':
         *nu = atoi(args[++i]);
         assert(*nu > 0);
         break;
      case 'A':
         ctmp = args[++i][0];
         ctmp = toupper(ctmp);
         if (ctmp == 'N' || ctmp == 'T') *TA = ctmp;
         else PrintUsage(args[0]);
         break;
      default:
         fprintf(stderr, "Unknown flag : %s\n", args[i]);
         PrintUsage(&args[0][0]);
      }
   }
   if (*mu == 0 && *nu) *mu = *nu;
   else if (*nu == 0 && *mu) *nu = *mu;
   if ( (*mu || *nu) && *TA == ' ') *TA = 'N';
}


main(int nargs, char **args)
{
   char pre, TA;
   int mu, nu;
   GetFlags(nargs, args, &pre, &TA, &mu, &nu);
   GoToTown(pre);
   exit(0);
}
@ROUT gmvsearchT

double gmvcaseT(char pre, int lat, int nY, int ngap, int gap, int aregs,
                int xregs, int yregs, int l1mul)
{
   double mfs[3], mf;
   FILE *fp;
   const int gapmul=1, beta=1;
   char ln[256], fnam[64];

   sprintf(fnam, "%cgemvT_%dx%dx%dx%dx%dx%dx%d_%d", 
           pre, lat, nY, ngap, gap, aregs, xregs, yregs, l1mul);
   if (!FileExists(fnam))
   {
      sprintf(ln, "make %cgmvcaseTT lat=%d nY=%d, ngap=%d agap=%d gapmul=%d aregs=%d xregs=%d yregs=%d beta=%d iflag=0 xu=%d yu=%d gmvout=\"-o %s\"\n",
              pre, lat, nY, ngap, gap, gapmul, aregs, xregs, yregs, beta, 
              ngap*gap*gapmul, nY, fnam);
      fprintf(stdout, "%s", ln);
      assert(system(ln) == 0);
   }
   fp = fopen(fnam, "r");
   if (fp == NULL)
   {
      fprintf(stderr, "\n\nERROR: COMMAND FAILED:\n%s\n", ln);
      exit(-1);
   }
   assert(fscanf(fp, " %lf %lf %lf", mfs, mfs+1, mfs+2) == 3);
   fclose(fp);
   mf = GetAvg(3, 1.20, mfs);
   if (mf == -1.0)
   {
      fprintf(stderr,
"\n\n%s : VARIATION EXCEEDS TOLERENCE, RERUN WITH HIGHER REPS.\n\n", fnam);
      sprintf(ln, "rm -f %s\n", fnam);
      system(ln);
      exit(-1);
   }
   return(mf);
}

int GetGoodLat(int lat, int mul)
{
   int i;

   if (mul%lat == 0) return(lat);
   if (mul%(lat+1) == 0) return(lat+1);
   for (i=1; i < lat; i++)
   {
      if (mul%(lat+i+1) == 0) return(lat+i+1);
      if (mul%(lat-i) == 0) return(lat-i);
   }
   return(1);
}

void FindNU_gmv(char pre, int nregs, int lat0, int nY, int yregs,
                int maxNU, int *latB, int *ngapB, int *gapB, int *xregsB,
                int *aregsB, double *mfB)
{
   int tmul, lat, nu, gap, ngap, xregs, aregs;
   double mf;

   if (pre == 's') tmul = 2;
   else tmul = 1;

   for (nu=1; nu <= maxNU; nu += 4*tmul)
   {
      for (gap=1; gap <= nu; gap += 2*tmul)
      {
         ngap = nu / gap;
         if (ngap * gap != nu) continue;
         for (xregs=1; xregs <= 2; xregs++)
         {
            lat = lat0;
            if (lat0) lat = GetGoodLat(lat0, nu*nY);
            if (xregs + lat/nY > nu) continue;
            aregs = lat+1;
            while((nu*nY)%aregs)
            {
               aregs++;
               if (aregs > nu*nY) { lat=0; aregs=1; break; }
            }
            do
            {
               mf = gmvcaseT(pre, lat, nY, ngap, gap, aregs, xregs, yregs,0.75);
               fprintf(stdout, "\n   pre=%c, lat=%d, nY=%d, ngap=%d, gap=%d, aregs=%d, xregs=%d yregs=%d, mf=%f\n", 
                       pre, lat, nY, ngap, gap, aregs, xregs, yregs, mf);
               if (mf > *mfB)
               {
                  *mfB = mf;
                  *latB = lat;
                  *ngapB = ngap;
                  *gapB = gap;
                  *xregsB = xregs;
                  *aregsB = aregs;
               }
               aregs++;
               while((nu*nY)%aregs) aregs++;
            }
            while (xregs+xregs+yregs <= nregs);
         }
         if (gap == 1) gap = 0;
      }
      if (nu == 1) nu = 0;
   }
}

void FindNY_gmv(char pre, int nregs, int mlat, int maxNY, 
                int *nYB, int *yregsB, int *latB, int *ngapB, int *gapB,
                int *xregsB, int *aregsB, double *mfB)
{
   double mf;
   int ngap=2, gap=8, yregmax, yreg, areg, xreg;
   int i, nreg, ny;

   fprintf(stdout, "\n\nFINDING nY\n");
   for (i=1; i < nregs; i <<= 1);
   if (i < 8) nreg = 7;
   else if (i <= 32) nreg = i-1;
   else nreg = i - 4;

   for (ny=1; ny < maxNY; ny++)
   {
      yregmax = ((mlat+ny-1)/ny)*ny;
      if (yregmax < ny) yregmax = ny;
      for (yreg=ny; yreg <= yregmax; yreg += ny)
      {
         areg = nreg - yreg - 1;
         if (areg < 1) areg=1;
         if (mlat)
         {
            while ((ny*ngap*gap)%mlat) ngap++;
            for (areg=mlat+1; ny*ngap*gap%areg; areg++);
         }
         else while ((ny*ngap*gap)%areg) areg--;
         if (yreg+areg+2 <= nreg) xreg = 2;
         else xreg=1;
         mf = gmvcaseT(pre, mlat, ny, ngap, gap, areg, xreg, yreg, 0.75);
         fprintf(stdout, "\n   pre=%c, lat=%d, nY=%d, ngap=%d, gap=%d, aregs=%d, xregs=%d yregs=%d, mf=%f\n", 
                       pre, mlat, ny, ngap, gap, areg, xreg, yreg, mf);
         if (mf > *mfB)
         {
            *mfB = mf;
            *latB = mlat;
            *nYB = ny;
            *yregsB = yreg;
            *ngapB = ngap;
            *gapB = gap;
            *xregsB = xreg;
            *aregsB = areg;
         }
      }
   }
   fprintf(stdout, "\n\nBEST nY = %d\n", *nYB);
}

void FindBest0(char pre, int mlat, int nregs, int nY, int yregs,
               int *nYB, int *yregsB, int *latB, int *ngapB, int *gapB,
               int *xregsB, int *aregsB, double *mfB)
{
  if (nY < 1) FindNY_gmv(pre, nregs, mlat, 8, nYB, yregsB, latB, 
                         ngapB, gapB, xregsB, aregsB, mfB);
  else
  {
     *nYB = nY;
     *yregsB = yregs;
  }
  FindNU_gmv(pre, nregs, mlat, *nYB, *yregsB, 64, latB, ngapB, gapB, 
             xregsB, aregsB, mfB);
}

void FindBest(char pre, int mlat, int nregs, int nY, int yregs)
{
  double mfB;
  int nYB, yregsB, latB, ngapB, gapB, xregsB, aregsB;

  mfB = 0.0;
  yregsB = nYB = 2;
  latB = 0;
  ngapB = gapB = xregsB = aregsB = 1;

  FindBest0(pre, mlat, nregs, nY, yregs, &nYB, &yregsB, &latB, &ngapB, &gapB,
            &xregsB, &aregsB, &mfB);
  if (mlat)
     FindBest0(pre, 0, nregs, nY, yregs, &nYB, &yregsB, &latB, &ngapB, &gapB,
               &xregsB, &aregsB, &mfB);

  fprintf(stdout, "\n\nBEST GENERATED CASE GOT %f MFLOPS, USING:\n", mfB);
  fprintf(stdout, "nY=%d, yregs=%d lat=%d ngap=%d, gap=%d xreg=%d areg=%d\n\n",
          nYB, yregsB, latB, ngapB, gapB, xregsB, aregsB);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -l <lat> -r <nregs> -y <yregs> -Y <nY>\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, char *pre, int *mlat, int *nregs, 
              int *nY, int *yregs)
{
   int i;

   *pre = 'd';
   *mlat = *nregs = *yregs = *nY = -1;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'p':
         i++;
         *pre = tolower(args[i][0]);
         assert(*pre == 's' || *pre == 'd');
         break;
      case 'l':
         *mlat = atoi(args[++i]);
         break;
      case 'r':
         *nregs = atoi(args[++i]);
         break;
      case 'y':
         *yregs = atoi(args[++i]);
         break;
      case 'Y':
         *nY = atoi(args[++i]);
         break;
      }
   }

   #include "atlas_dsysinfo.h"
   if (*pre == 'd')
   {
      if (*mlat == -1) *mlat = ATL_fplat;
      if (*nregs == -1) *nregs = ATL_lbnreg;
   }
   #undef ATL_SYSINFO_H
   @whiledef nm NOMULADD MULADD
   #ifdef ATL_@(nm)
      #undef ATL_@(nm)
   #endif
   @endwhile
   @whiledef nm L1elts fplat lbnreg mmnreg
   #undef ATL_@(nm)
   @endwhile

   #include "atlas_ssysinfo.h"
   if (*pre == 's')
   {
      if (*mlat == -1) *mlat = ATL_fplat;
      if (*nregs == -1) *nregs = ATL_lbnreg;
   }

   if (*nY != -1) assert(*yregs != -1);
   else if (*yregs != -1) assert(*nY != -1);
}

main(int nargs, char **args)
{
   int mlat, nregs, yregs, nY;
   char pre;

   GetFlags(nargs, args, &pre, &mlat, &nregs, &nY, &yregs);
   FindBest(pre, mlat, nregs, nY, yregs);
   exit(0);
}
@rout r1test r1ktest
#include "atlas_misc.h"
#include "atlas_tst.h"
#include "atlas_lvl2.h"
int FAx=0, MAx=0, FAy=0, MAy=0, FAa=0, MAa=0;
@extract -b @(topd)/FAmalloc.inc

static void dumb_ger(int Conj, int M, int N, SCALAR alpha, TYPE *X, int incX, 
                     TYPE *Y, int incY, TYPE *A, int lda)
{
   #ifdef TCPLX
      TYPE tmp[2];
   #endif
   int j;
   ATL_assert(incX == 1);
   ATL_assert( SCALAR_IS_ONE(alpha) );
   for (j=0; j < N; j++)
   {
   #ifdef TREAL
      Mjoin(PATL,axpy)(M, Y[j*incY], X, 1, A+lda*j, 1);
   #else
      tmp[0] = Y[2*j*incY];
      tmp[1] = Y[2*j*incY+1];
      if (Conj) tmp[1] = -tmp[1];
      Mjoin(PATL,axpy)(M, tmp, X, 1, A+2*lda*j, 1);
   #endif
   }
}

static int CheckAns(int M, int N, TYPE *G, int ldg, TYPE *U, int ldu)
{
   TYPE diff, eps;
   int i, j, ierr=0;
   #ifdef TREAL
      const int M2 = M, emul=4;
   #else
      const int M2 = M<<1, emul=16;
      ldg <<= 1; ldu <<= 1;
   #endif

   eps = Mjoin(PATL,epsilon)();
   for (j=0; j < N; j++, G += ldg, U += ldu)
   {
      for (i=0; i < M2; i++)
      {
         diff = G[i] - U[i];
         if (diff < ATL_rzero) diff = -diff;
         if (diff > emul*eps)
         {
            fprintf(stderr, "A(%d,%d): Good=%f, Computed=%f\n", 
                    i, j, G[i], U[i]);
            if (!ierr) ierr = i+j*M+1;
         }
      }
   }
   return(ierr);
}

@rout r1test
#ifdef TCPLX
   #define ATL_gerT Mjoin(PATL,geru)
#else
   #define ATL_gerT Mjoin(PATL,ger)
#endif
void ATL_gerT(ATL_CINT M, ATL_CINT N, const SCALAR alpha,
              const TYPE *X, ATL_CINT incX, const TYPE *Y, ATL_CINT incY,
              TYPE *A, ATL_CINT lda);
@rout r1test r1ktest

static int RunTest(int CONJ, int M, int N, int incY, int lda)
{
   #ifdef TCPLX
      TYPE one[2] = {ATL_rone, ATL_rzero};
   #else
      TYPE one = ATL_rone;
   #endif
   TYPE *A, *A0, *X, *Y, *y;
   const int aincY = Mabs(incY), incX=1;
   int ierr;

   fprintf(stdout, "   TEST CONJ=%d, M=%d, N=%d, lda=%d, incY=%d, STARTED\n",
           CONJ, M, N, lda, incY);
   A = FA_malloc(ATL_MulBySize(lda)*N, FAa, MAa);
   A0 = FA_malloc(ATL_MulBySize(M)*N, FAa, MAa);
   X = FA_malloc(ATL_MulBySize(M), FAx, MAx);
   Y = FA_malloc(ATL_MulBySize(N)*aincY, FAy, MAy);
   ATL_assert(A && A0 && X && Y);
   Mjoin(PATL,gegen)(1, N, Y, aincY, N*aincY);
   Mjoin(PATL,gegen)(M, 1, X, M, N*aincY+127*50+77);
   Mjoin(PATL,gegen)(M, N, A0, M, N*M+513*7+90);
   Mjoin(PATL,gegen)(M, N, A, lda, N*M+513*7+90);
   if (incY < 0) Y += (N-1) * (aincY SHIFT);

@rout r1test
   ATL_gerT(M, N, alpha, X, incX, Y, incY, A, lda);
@beginskip
#ifdef TCPLX
   if (CONJ)
      Mjoin(PATL,ger1c_a1_x1_yX)(M, N, one, X, 1, Y, incY, A, lda);
   else Mjoin(PATL,ger1u_a1_x1_yX)(M, N, one, X, 1, Y, incY, A, lda);
#else
   Mjoin(PATL,ger1_a1_x1_yX)(M, N, one, X, 1, Y, incY, A, lda);
#endif
@endskip
@rout r1ktest
#ifdef TCPLS
   if (CONJ)
      ATL_GERK_Conj(M, N, one, X, 1, Y, incY, A, lda);
   else
#endif
      ATL_UGERK(M, N, one, X, 1, Y, incY, A, lda);
@rout r1test r1ktest
   dumb_ger(CONJ, M, N, one, X, 1, Y, incY, A0, M);

   if (incY < 0) Y -= (N-1) * (aincY SHIFT);
   FA_free(Y, FAy, MAy);
   FA_free(X, FAx, MAx);
   ierr = CheckAns(M, N, A0, M, A, lda);
   FA_free(A, FAa, MAa);
   FA_free(A0, FAa, MAa);

   if (ierr)
      fprintf(stdout, "   TEST CONJ=%d, M=%d, N=%d, lda=%d, incY=%d, FAILED\n",
              CONJ, M, N, lda, incY);
   else fprintf(stdout, 
                "   TEST CONJ=%d, M=%d, N=%d, lda=%d, incY=%d, PASSED\n",
                CONJ, M, N, lda, incY);
   return(ierr);
}

@rout r1ktest
int RunTests(int verb, int *CONJs, int *Ms, int *Ns, int *incYs, int *ldas)
{
   int iy, ix, ic, in, im;
   ATL_INT m, n, lda, conj, incy;
   int nerr=0;

   assert(ldas[0] == Ms[0]);
   for (in=1; in <= Ns[0]; in++)
   {
      n = Ns[in];
      for (im=1; im <= Ms[0]; im++)
      {
         m = Ms[im];
         lda = ldas[im];
         for (iy=1; iy <= incYs[0]; iy++)
         {
            incy = incYs[iy];
            for (ic=1; ic <= CONJs[0]; ic++)
            {
               conj = CONJs[ic];
               nerr += RunTest(conj, m, n, incy, lda);
               if (nerr && !verb)
                  return(nerr);
            }
         }
      }
   }
   return(nerr);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", 
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);

   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -n <#> <N1> ... <N#>\n");
   fprintf(stderr, "   -N <Nstart> <Nend> <Ninc>\n");
   fprintf(stderr, "   -m <#> <M1> ... <M#>\n");
   fprintf(stderr, "   -M <Mstart> <Mend> <Minc>\n");
   fprintf(stderr, "   -l <#> <lda1> ... <lda#>\n");
   fprintf(stderr, "   -g <ldagap> : lda = M + <ldagap> foreach M\n");
   fprintf(stderr, "   -y <#> <incY1> ... <incY#>\n");
   fprintf(stderr, "   -x <#> <incX1> ... <incX#>\n");
   fprintf(stderr, "   -C <#> <conj1> ... <conj#>\n");
   fprintf(stderr, 
           "   -v [0,1] : 0 - stop on first error, else keep testing\n");
   fprintf(stderr,
"   -F[x,y,a] <#> : if(# > 0) -> force op to be aligned to at least # bytes\n");
   fprintf(stderr,
      "                   if(# < 0) -> force op to be aligned to < # bytes.\n");
        
   exit(ierr ? ierr : -1);
}

@extract -b @(basd)/atlas-parse.base rout=getflagarrs

int GetFlags(int nargs, char **args, int **CONJs, int **Ms, int **Ns, 
             int **LDAs, int **incYs, int **incXs)
{
   int verb, i, k, *ip;
   char ch;
   int ldagap = 8;

   *Ns = *Ms = *LDAs = *incYs = *incXs = *CONJs = NULL;
   verb = 0;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      ch = args[i][1];
      switch(ch)
      {
      case 'v':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, "out of flags in -g ");
         verb = atoi(args[i]);
         break;
      case 'g':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, "out of flags in -g ");
         ldagap = atoi(args[i]);
         break;
      case 'M':
      case 'N':
         if (i+3 >= nargs)
            PrintUsage(args[0], i-1, "out of flags in -N/M ");
         ip = IntRange2IntList(atoi(args[i+1]),atoi(args[i+2]),atoi(args[i+3]));
         if (ch == 'M')
            *Ms = ip;
         else
            *Ns = ip;
         i += 3;
         break;
      case 'n':
      case 'm':
      case 'l':
      case 'y':
      case 'x':
         ip = GetIntList(nargs, args, i, 1);
         i += ip[0] + 1;
         switch(ch)
         {
         case 'n':
            *Ns = ip;
            break;
         case 'm':
            *Ms = ip;
            break;
         case 'l':
            *LDAs = ip;
            break;
         case 'y':
            *incYs = ip;
            break;
         case 'x':
            *incXs = ip;
            break;
         }
         break;
      case 'F':
         ch = args[i][2];
         k = atoi(args[++i]);
         if (ch == 'a')
         {
            if (k < 0)
              MAa = -k;
            else 
              FAa = k;
         }
         else if (ch == 'y')
         {
            if (k < 0)
              MAy = -k;
            else 
              FAy = k;
         }
         else
         {
            if (k < 0)
              MAx = -k;
            else 
              FAx = k;
         }
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   if (*CONJs == NULL)
   #ifdef TCPX
      *CONJs = GetIntList2(0, 1);
   #else
      *CONJs = GetIntList1(0);
   #endif
   if (*incXs == NULL)
      *incXs = GetIntList1(1);
   if (*incYs == NULL)
      *incYs = GetIntList2(1, -1);
   if (*Ms == NULL)
      *Ms = GetIntList1(977);
   if (*Ns == NULL)
      *Ns = GetIntList1(77);
   if (*LDAs == NULL)
   {
      *LDAs = DupIntList(*Ms);
      for (i=1; i <= (*LDAs)[0]; i++)
         (*LDAs)[i] += ldagap;
   }
   assert((*LDAs)[0] == (*Ms)[0]);
   return(verb);
}

int main(int nargs, char **args)
{
   int *Ms, *Ns, *LDAs, *incYs, *incXs, *CONJs;
   int verb, ierr=0;

   verb = GetFlags(nargs, args, &CONJs, &Ms, &Ns, &LDAs, &incYs, &incXs);
   ierr = RunTests(verb, CONJs, Ms, Ns, incYs, LDAs);
   free(CONJs);
   free(Ms);
   free(Ns);
   free(LDAs);
   free(incXs);
   free(incYs);
   exit(ierr);
}
@rout r1test
static int RunTests(int M, int N, int incY, int lda)
{
   int j, k=0, ierr = 0;

   ATL_assert(incY != 0);

#ifdef TCPLX
   for (k=0; k < 2; k++)
#endif
   {
      j = RunTest(k, M, N, 1, lda);
      if (!ierr) ierr = j;
      j = RunTest(k, M, N, incY, lda);
      if (!ierr) ierr = j;
      j = RunTest(k, M, N, -incY, lda);
      if (!ierr) ierr = j;
   }
   return(ierr);
}

static void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -m <M> -n <N> -Y <incY> -l <lda>\n",
           nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, int *M, int *N, int *incY, int *lda)
{
   int i, k;
   char ch;

   *M = 997;
   *N = 177;
   *incY = 3;
   *lda = -1;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'F':
         ch = args[i][2];
         k = atoi(args[++i]);
         if (ch == 'a')
         {
            if (k < 0)
              MAa = -k;
            else 
              FAa = k;
         }
         else if (ch == 'y')
         {
            if (k < 0)
              MAy = -k;
            else 
              FAy = k;
         }
         else
         {
            if (k < 0)
              MAx = -k;
            else 
              FAx = k;
         }
         break;
      case 'm':
         *M = atoi(args[++i]);
         break;
      case 'n':
         *N = atoi(args[++i]);
         break;
      case 'l':
         *lda = atoi(args[++i]);
         break;
      case 'Y':
         *incY = atoi(args[++i]);
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   if (*lda < *M) *lda = *M + 9;
}

main(int nargs, char **args)
{
   int M, N, incY, lda, ierr=0;

   GetFlags(nargs, args, &M, &N, &incY, &lda);
   ierr = RunTests(M, N, incY, lda);
   exit(ierr);
}
@ROUT r1search

void emit_r1head(char pre, int l1mul, int flag, int mu, int nu)
{
   char ln[256];
   sprintf(ln, "./xemit_r1h -p %c -l %d -f %d -x %d -y %d\n", 
           pre, l1mul, flag, mu, nu);
   assert(system(ln) == 0);
}

int r1tstcase(char pre, char *r1nam, char *cc, char *ccflags)
{
   char ln[256];

   if (cc[0] != '\0' && ccflags[0] != '\0')
      sprintf(ln, 
              "make %cr1tstcase r1rout=%s %cR1CC=\"%s\" %cR1FLAGS=\"%s\"\n",
              pre, r1nam, pre, cc, pre, ccflags);
   else if (cc[0] == '\0' && ccflags[0] != '\0')
      sprintf(ln, "make %cr1tstcase r1rout=%s EXTFLAGS=\"%s\"\n",
              pre, r1nam, ccflags);
   else sprintf(ln, "make %cr1tstcase r1rout=%s\n", pre, r1nam);


   return(system(ln));
}

double r1case(char pre, char *r1nam, int flag, int mu, int nu, int cas, 
              char *cc, char *ccflags, int l1mul)
{
   char fnam[128], ln[128];
   double mf, mfs[3];
   int i;
   FILE *fp;

   if (ATL_NoBlock(flag)) sprintf(fnam, "res/%cger1_%d_0", pre, cas);
   else sprintf(fnam, "res/%cger1_%d_%d", pre, cas, l1mul);
   if (!FileExists(fnam))
   {
      i = sprintf(ln, 
              "make %cr1case r1rout=%s cas=%d l1mul=%d iflag=%d xu=%d yu=%d",
              pre, r1nam, cas, l1mul, flag, mu, nu);
      if (cc[0] != '\0' && ccflags[0] != '\0')
         i += sprintf(ln+i, " %cR1CC=\"%s\" %cR1FLAGS=\"%s\"", 
                      pre, cc, pre, ccflags);
      else if (cc[0] == '\0' && ccflags[0] != '\0')
         i += sprintf(ln+i, " EXTFLAGS=\"%s\"", ccflags);
      i += sprintf(ln+i, "\n");
      fprintf(stderr, "%s", ln);
      if (system(ln)) return(-1.0);  /* won't compile here */
   }
   fp = fopen(fnam, "r");
   assert(fp);
   assert(fscanf(fp, " %lf %lf %lf", mfs, mfs+1, mfs+2) == 3);
   fclose(fp);
   mf = GetAvg(3, 1.20, mfs);
   if (mf == -1.0)
   {
      fprintf(stderr,
"\n\n%s : VARIATION EXCEEDS TOLERENCE, RERUN WITH HIGHER REPS.\n\n", fnam);
      sprintf(ln, "rm -f %s\n", fnam);
      system(ln);
      exit(-1);
   }
   return(mf);
}

void CreateSum(char pre, int l1mul, int ID, char *r1nam, char *auth,
               int flag, int mu, int nu, double mf)
{
   char fnam[64];
   FILE *fp;

   sprintf(fnam, "res/%cR1RES", pre);
   fp = fopen(fnam, "w");
   assert(fp);
   fprintf(fp, "%d %d %d %d %d %.2f %s \"%s\"\n", ID, flag, mu, nu, l1mul, mf,
           r1nam, auth);
   fclose(fp);
}

void ReadSum(char pre, int *l1mul, int *ID, char *r1nam, char *auth,
             int *flag, int *mu, int *nu, double *mf)
{
   char fnam[64];
   FILE *fp;

   sprintf(fnam, "res/%cR1RES", pre);
   fp = fopen(fnam, "r");
   assert(fp);
   assert(fscanf(fp, " %d %d %d %d %d %lf %s \"%[^\"]", 
                 ID, flag, mu, nu, l1mul, mf, r1nam, auth) == 8);
   fclose(fp);
}

void GenMakefile(char pre, char *cc, char *ccflags)
{
   int i;
   FILE *fp;
   char *typ, *comp, *cflags;
   char ln[64];

   if (pre == 's') typ = "SREAL";
   else if (pre == 'd') typ = "DREAL";
   else if (pre == 'c') typ = "SCPLX";
   else if (pre == 'z') typ = "DCPLX";
   else assert(0);
   if (pre == 's' || pre == 'c')
   {
      comp = "$(SKC)";
      cflags = "$(SKCFLAGS)";
   }
   else
   {
      comp = "$(DKC)";
      cflags = "$(DKCFLAGS)";
   }
   sprintf(ln, "Make_%cr1", pre);
   fp = fopen(ln, "w");
   assert(fp);
   fprintf(fp, "include Make.inc\n\n");

   if (cc[0] == '\0') fprintf(fp, "R1CC = %s\n", comp);
   else fprintf(fp, "R1CC = %s\n", cc);
   if (cc[0] == '\0' && ccflags[0] != '\0')
      fprintf(fp, "R1FLAGS = $(CDEFS) %s %s -D%s\n", cflags, ccflags, typ);
   else if (ccflags[0] != '\0')
      fprintf(fp, "R1FLAGS = $(CDEFS) %s -D%s\n", ccflags, typ);
   else fprintf(fp, "R1FLAGS = $(CDEFS) %s -D%s\n", cflags, typ);

   if (pre == 's' || pre == 'd')
      fprintf(fp, "\nobj = ATL_%cger1_a1_x1_yX.o\n\n", pre);
   else
      fprintf(fp, "\nobj = ATL_%cger1u_a1_x1_yX.o ATL_%cger1c_a1_x1_yX.o\n\n",
              pre, pre);

   fprintf(fp, "%clib : lib\nlib : %cr1k.grd\n", pre, pre);
   fprintf(fp, "%cr1k.grd : $(obj)\n", pre);
   fprintf(fp, "\t$(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(obj)\n");
   fprintf(fp, "\t$(RANLIB) $(ATLASlib)\n");
   fprintf(fp, "\ttouch %cr1k.grd\n\n", pre);

   fprintf(fp, "clean :\n\t rm -f $(obj) %cr1k.grd\n", pre);
   fprintf(fp, "%cclean : clean\n\n", pre);
   if (pre == 's' || pre == 'd')
   {
      fprintf(fp, "ATL_%cger1_a1_x1_yX.o : ATL_%cger1.c\n", pre, pre);
      fprintf(fp, "\t$(R1CC) -o $@ -c $(R1FLAGS) ATL_%cger1.c\n", pre);
   }
   else
   {
      fprintf(fp, "ATL_%cger1u_a1_x1_yX.o : ATL_%cger1.c\n", pre, pre);
      fprintf(fp, "\t$(R1CC) -o $@ -c $(R1FLAGS) -D%s ATL_%cger1.c\n",
              typ, pre);
      fprintf(fp, "ATL_%cger1c_a1_x1_yX.o : ATL_%cger1.c\n", pre, pre);
      fprintf(fp, "\t$(R1CC) -o $@ -c $(R1FLAGS) -DConj_ ATL_%cger1.c\n",
              pre);
   }
   fclose(fp);
}

void r1install(char pre, int id, char *r1nam, char *auth, int l1mul,
               int flag, char *cc, char *ccflags, int mu, int nu)
{
   char ln[128];
   double mf;

   GenMakefile(pre, cc, ccflags);
   mf = r1case(pre, r1nam, flag, mu, nu, id, cc, ccflags, l1mul);
   emit_r1head(pre, l1mul, flag, mu, nu);
   sprintf(ln, "make %cinstall r1rout=%s\n", pre, r1nam);
   fprintf(stderr, "%s", ln);
   assert(system(ln) == 0);
   CreateSum(pre, l1mul, id, r1nam, auth, flag, mu, nu, mf);
}

int FindL1Mul(char pre, int cas, char *r1nam, int flag, int mu, int nu,
              char *cc, char *ccflags)
{
   double low = .5, high = 1.0;
   double mflow, mfhigh;
   int ilow, ihigh;

   if (ATL_NoBlock(flag)) flag -= 32;  /* always actually block these times */
   do
   {
      ilow = (low  * 100.0);
      ihigh = (high * 100.0);
      mflow  = r1case(pre, r1nam, flag, mu, nu, cas, cc, ccflags, ilow);
      mfhigh = r1case(pre, r1nam, flag, mu, nu, cas, cc, ccflags, ihigh);
      fprintf(stdout, "      %d%% %.2fMFLOP  ---  %d%% %.2fMFLOP\n",
              ilow, mflow, ihigh, mfhigh);
      if (mflow < mfhigh) low += 0.5*(high-low);
      else high -= 0.5 * (high-low);
   }
   while (ihigh-ilow);
   fprintf(stdout, "\n\nBEST %% of L1 cache: %.2f\n", low*100.0);
   return(ilow);
}

int ConfirmBlock(char pre, char *r1nam, int flag, int mu, int nu, int cas, 
                 char *cc, char *ccflags, int l1mul)
{
   int bflag;
   double mfblock, mfnoblock;

   if ( ATL_NoBlock(flag) )
   {
      bflag = flag - 32;
      mfblock   = r1case(pre, r1nam, bflag, mu, nu, cas, cc, ccflags, l1mul);
      mfnoblock = r1case(pre, r1nam,  flag, mu, nu, cas, cc, ccflags, l1mul);
      fprintf(stdout, "\nWith blocking=%lf, without=%lf\n\n", 
              mfblock, mfnoblock);
      if (mfblock >= mfnoblock) return(bflag);
   }
   return(flag);
}

void iGetIDCase(char pre, int ID, char *r1nam, char *auth,
                char *cc, char *ccflags, int *flag, int *mu, int *nu)
{
   char ln[512];
   FILE *fp;
   int i, id, n;

   sprintf(ln, "%ccases.dsc", pre);
   fp = fopen(ln, "r");
   assert(fp);

   assert(fgets(ln, 128, fp));
   assert(sscanf(ln, " %d", &n) == 1);
   for (i=0; i < n; i++)
   {
      assert(fgets(ln, 512, fp));
      assert(sscanf(ln, " %d %d %d %d %s \"%[^\"]", 
                    &id, flag, mu, nu, r1nam, auth) == 6);
      if (LineIsCont(ln))
      {
         assert(fgets(cc, 256, fp));
         assert(fgets(ccflags, 512, fp));
         NoEndLineWhiteSpace(cc);
         NoEndLineWhiteSpace(ccflags);
      }
      else cc[0] = ccflags[0] = '\0';
      if (id == ID) break;
   }
   fclose(fp);
}

void GetCases(char pre, int *ncases, int **IDs, char ***r1nams, char ***auths,
              char ***CC, char ***CCFLAGS, int **flags, int **mus, int **nus)
{
   int n, i, j;
   char fnam[64], ln[512];
   char **r1nam, **auth, **cc, **ccflags;
   int *flag, *mu, *nu, *id;
   FILE *fp;

   sprintf(fnam, "%ccases.dsc", pre);
   fp = fopen(fnam, "r");
   assert(fp);

   assert(fgets(ln, 128, fp));
   assert(sscanf(ln, " %d", &n) == 1);
   assert(n < 100 && n > 0);

   r1nam   = malloc(n * sizeof(char*));
   auth    = malloc(n * sizeof(char*));
   cc      = malloc(n * sizeof(char*));
   ccflags = malloc(n * sizeof(char*));
   assert(r1nam && auth && cc && ccflags);
   for (i=0; i < n; i++)
   {
      assert(r1nam[i] = malloc(64*sizeof(char)));
      assert(auth[i] = malloc(64*sizeof(char)));
   }
   mu = malloc(n * sizeof(int));
   nu = malloc(n * sizeof(int));
   id = malloc(n * sizeof(int));
   flag = malloc(n * sizeof(int));
   assert(mu && nu && flag && id);
   for (i=0; i < n; i++)
   {
      assert(fgets(ln, 512, fp));
      assert(sscanf(ln, " %d %d %d %d %s \"%[^\"]", 
                    id+i, flag+i, mu+i, nu+i, r1nam[i], auth[i]) == 6);
      assert(mu[i] >= 0 && nu[i] >= 0 && r1nam[i][0] != '\0');
      if (LineIsCont(ln))
      {
         fgets(ln, 512, fp);
         NoEndLineWhiteSpace(ln);
         if (ln[0] == '+' && (ln[1] == '\0' || ln[1] == ' ')) /* adding flags */
            cc[i] = NULL;
         else
         {
            j = strlen(ln);
            cc[i] = malloc((j+1)*sizeof(char));
            assert(cc[i]);
            strcpy(cc[i], ln);
         }
         fgets(ln, 256, fp);
         NoEndLineWhiteSpace(ln);
         j = strlen(ln);
         ccflags[i] = malloc((j+1)*sizeof(char));
         assert(ccflags[i]);
         strcpy(ccflags[i], ln);
      }
      else cc[i] = ccflags[i] = NULL;
   }
   fclose(fp);
   for (i=0; i < n; i++) /* fix cc & ccflags */
   {
      if (cc[i] == NULL)
      {
         cc[i] = malloc(2*sizeof(char));
         assert(cc[i]);
         cc[i][0] = cc[i][1] = '\0';
      }
      if (ccflags[i] == NULL)
      {
         ccflags[i] = malloc(2*sizeof(char));
         assert(ccflags[i]);
         ccflags[i][0] = ccflags[i][1] = '\0';
      }
   }
   *IDs = id;
   *ncases = n;
   *r1nams = r1nam;
   *auths = auth;
   *CC = cc;
   *CCFLAGS = ccflags;
   *flags = flag;
   *mus = mu;
   *nus = nu;
}

void RunCases(char pre)
{
   char **r1nams, **auths, **cc, **ccflags;
   int ncases, *ids, *flags, *mus, *nus;
   int i, imax=0;
   int l1mul, mf, mfmax=0.0;

   GetCases(pre, &ncases, &ids, &r1nams, &auths, &cc, &ccflags, &flags,
            &mus, &nus);

   for (i=0; i < ncases; i++)
   {
      mf = r1case(pre, r1nams[i], flags[i], mus[i], nus[i], ids[i],
                  cc[i], ccflags[i], 75);
      fprintf(stdout, "%s : %.2f\n", r1nams[i], mf);
      if (mf > mfmax)
      {
         if (r1tstcase(pre, r1nams[i], cc[i], ccflags[i]) == 0)
         {    /* make it pass tester */
            mfmax = mf;
            imax = i+1;
         }
      }
   }

   assert(imax);
   imax--;
   l1mul = FindL1Mul(pre, imax+1, r1nams[imax], flags[imax], mus[imax], 
                     nus[imax], cc[imax], ccflags[imax]);
   flags[imax] = ConfirmBlock(pre, r1nams[imax], flags[imax], mus[imax], 
                              nus[imax], ids[imax], cc[imax],
                              ccflags[imax], l1mul);
   fprintf(stdout, "\nBEST: %s, case %d, mu=%d, nu=%d; at %.2f MFLOPS\n\n",
           r1nams[imax], imax+1, mus[imax], nus[imax], mfmax);
   CreateSum(pre, l1mul, ids[imax], r1nams[imax], auths[imax], flags[imax], 
             mus[imax], nus[imax], mfmax);

   for (i=0; i < ncases; i++)
   {
      free(r1nams[i]);
      free(auths[i]);
      free(cc[i]);
      free(ccflags[i]);
   }
   free(cc);
   free(ccflags);
   free(r1nams);
   free(auths);
   free(flags);
   free(mus);
   free(nus);
}

void GoToTown(pre)
{
   char r1nam[128], auth[128], ln[128], cc[256], ccflags[512];
   int flag, mu, nu, id, l1mul;
   double mf;
   FILE *fp;

   sprintf(ln, "res/%cR1RES", pre);
   if (!FileExists(ln))
   {
      RunCases(pre);
      fp = fopen(ln, "r");
      assert(fp);
   }
   else /* if default does not pass tester, rerun cases */
   {
      fp = fopen(ln, "r");
      ReadSum(pre, &l1mul, &id, r1nam, auth, &flag, &mu, &nu, &mf);
      iGetIDCase(pre, id, r1nam, auth, cc, ccflags, &flag, &mu, &nu);
      if (r1tstcase(pre, r1nam, cc, ccflags) != 0)
      {
         fclose(fp);
         assert(remove(ln) == 0);
         RunCases(pre);
         fp = fopen(ln, "r");
         assert(fp);
      }
   }
   fclose(fp);
   ReadSum(pre, &l1mul, &id, r1nam, auth, &flag, &mu, &nu, &mf);
   iGetIDCase(pre, id, r1nam, auth, cc, ccflags, &flag, &mu, &nu);
   fprintf(stdout, "\nBEST: %s, mu=%d, nu=%d; at %.2f MFLOPS\n\n",
           r1nam, mu, nu, mf);
   r1install(pre, id, r1nam, auth, l1mul, flag, cc, ccflags, mu, nu);
}

void PrintUsage(char *fnam)
{
   fprintf(stderr, "USAGE: %s [-p <d/s/z/c>]\n", fnam);
   exit(-1);
}

void GetFlags(int nargs, char **args, char *pre)
{
   char ctmp;
   int i;
   *pre = 'd';
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(&args[0][0]);
      switch(args[i][1])
      {
      case 'p':
         ctmp = args[++i][0];
         ctmp = tolower(ctmp);
         if (ctmp == 's' || ctmp == 'd' || ctmp == 'c' || ctmp == 'z')
            *pre = ctmp;
         else PrintUsage(&args[0][0]);
         break;
      default:
         fprintf(stderr, "Unknown flag : %s\n", args[i]);
         PrintUsage(&args[0][0]);
      }
   }
}

main(int nargs, char **args)
{
   char pre;
   GetFlags(nargs, args, &pre);
   GoToTown(pre);
   exit(0);
}
@ROUT ATL_symv

#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include <assert.h>
#include Mstr(Mjoin(Mjoin(atlas_,PRE),mv.h))
@skip #include Mstr(Mjoin(Mjoin(atlas_,PRE),mvS.h))

#define gemvN Mjoin(PATL,gemvN_a1_x1_b1_y1)
#define gemvT Mjoin(PATL,gemvT_a1_x1_b1_y1)

static void refsymvL
   (const int N, const SCALAR alpha, const TYPE *A, const int lda,
    const TYPE *X, const int incX, const SCALAR beta, TYPE *Y, const int incY)
{
#ifdef TREAL
   register TYPE t0, t1, t2;
   const int ldap1=lda+1;
   int j, i, iaij, jaj;

   for (j=jaj=0; j < N; j++, jaj+=ldap1)
   {
      t0 = X[j]; t1 = ATL_rzero; Y[j] += t0 * A[jaj];
      for (i=j+1, iaij=1+jaj; i < N; i++, iaij++)
      {
         t2 = A[iaij];
         Y[i] += t2 * t0; 
         t1 += t2 * X[i];
      }
      Y[j] += t1;
   }
#else
   register TYPE yr, yi, ar, ai, xr, xi, Xr, Xi;
   const int ldap1=(lda+1)SHIFT, N2=(N SHIFT);
   const TYPE *a, *x;
   TYPE *y=Y;
   int i, j;

   for (j=0; j < N; j++, A += ldap1, X += 2, Y += 2)
   {
      yr = yi = ATL_rzero;
      xr = *X; xi = X[1];
      ar = *A;
      *Y += ar*xr; Y[1] += ar*xi;
      for (y=Y+2, x=X+2, a=A+2, i=j+1; i < N; i++, a += 2, x += 2, y += 2)
      {
         ar = *a; ai = a[1];
         Xr = *x; Xi = x[1];
         *y   += ar*xr + ai*xi;
         y[1] += ar*xi - ai*xr;
         yr += ar * Xr - ai * Xi;
         yi += ar * Xi + ai * Xr;
      }
      *Y = yr; Y[1] = yi;
   }
#endif
}
static void RsymvL(const int N, const TYPE *A, const int lda, const TYPE *X,
                   const SCALAR beta, TYPE *Y)
{
   int mb, nb, jb, jbs, j, m;
   const TYPE *x0=X, *A0=A;
   const SCALAR alpha=beta;
   TYPE *y0=Y;

   ATL_GetPartSYMV(A, lda, &mb, &nb);

   for (j=0; j < N; j += nb)
   {
      jb = N-j;
      jb = Mmin(jb,nb);
      refsymvL(jb, alpha, A, lda, X, 1, beta, Y, 1);
      m = N-j-jb;
      if (m)
      {
         jbs = jb SHIFT; X += jbs; Y += jbs;
         gemvT(jb, m, alpha, A+jbs, lda, X, 1, beta, y0, 1);
         gemvN(m, jb, alpha, A+jbs, lda, x0, 1, beta, Y, 1);
         A += jbs*(lda+1); x0 = X; y0 = Y;
      }
   }
}
void Mjoin(PATL,symv)
   (const enum ATLAS_UPLO Uplo, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
   int mb, nb, jb, mb1, incA1, incA, incXY, incXY1, n, j;
   const int lda2=(lda SHIFT);
   const TYPE *x0=X, *x1, *A0=A, *A1;
   TYPE *y1, *y0=Y;

   assert(incX==1 && incY==1 && Uplo == AtlasLower);
   #ifdef TREAL
      assert(alpha == ATL_rone && beta == ATL_rone);
   #else
      assert(*alpha == ATL_rone && *beta == ATL_rone);
      assert(alpha[1] == ATL_rzero && beta[1] == ATL_rzero);
   #endif

   ATL_GetPartSYMV(A, lda, &mb, &nb);
   mb1 = N - ( (N-1) / mb ) * mb;
   incA1 = nb * lda2;  incXY1 = (nb SHIFT);
   incA = incXY = mb SHIFT;
   n = (N-mb)SHIFT;
   A += n; X += n; Y += n; 
   for (n=N-mb; n > 0; n -= mb, A -= incA, X -= incXY, Y -= incXY)
   {
      RsymvL(mb, A+n*lda2, lda, X, beta, Y);
      for (j=0, A1=A, x1=x0, y1=y0; j < n; j += nb, A1 += incA1, x1 += incXY1,
           y1 += incXY1)
      {
         jb = n - j;
         jb = Mmin(jb, nb);
         gemvT(jb, mb, alpha, A1, lda, X, 1, beta, y1, 1);
         gemvN(mb, jb, alpha, A1, lda, x1, 1, beta, Y, 1);
      }
   }
   RsymvL(mb1, A0, lda, x0, beta, y0);
}
@ROUT gemvtune
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_fopen.h"
#include <string.h>

int FAx=0, MAx=0, FAy=0, MAy=0, FAa=0, MAa=0;
@extract -b @(topd)/FAmalloc.inc

#define ATL_MVNoBlock(iflag_) ( ((iflag_) | 32) == (iflag_) )

double time00();
double gemvcase(const int MFLOP, const enum ATLAS_TRANS TA, const int l2size,
                const int M, const int N, const SCALAR alpha, const int lda,
                const SCALAR beta)
{
   unsigned long reps;
   int i, lx, ly, la;
   #ifdef TREAL
      const double flops = 2.0 * M * N;
   #else
      const double flops = 8.0 * M * N;
   #endif
   double ttest, mftest, t0;
   const int aincY=1, aincX=1, incY=1, incX=1;
   const int inca = (TA == AtlasNoTrans) ? lda * (N SHIFT) : lda * (M SHIFT);
   const int incx = N*incX SHIFT, incy = M*incY SHIFT;
   TYPE *a, *A, *stA, *A0, *x, *X, *X0, *stX, *y, *Y, *Y0, *stY;
   #ifdef TREAL
      const TYPE nbeta = -beta;
      TYPE bet = beta;
   #else
      const TYPE *bet = beta;
      TYPE nbeta[2];
      nbeta[0] = -beta[0]; nbeta[1] = -beta[1];
   #endif

   i = (ATL_DivBySize(l2size)+N-1)/N;
   if (i < 1) i = 1;
   lx = i * N * aincX;
   X0 = X = x = FA_malloc(ATL_MulBySize(lx), FAx, MAx);
   if (x == NULL) return(-1);

   i = (ATL_DivBySize(l2size)+M-1)/M;
   if (i < 1) i = 1;
   ly = i * M * aincY;
   Y0 = Y = y = FA_malloc(ATL_MulBySize(ly), FAy, MAy);
   if (y == NULL)
   {
      FA_free(x, FAx, MAx);
      return(-1);
   }
   i = (ATL_DivBySize(l2size)+M*N)/(M*N);
   la = i * inca;
   A0 = A = a = FA_malloc(ATL_MulBySize(la), FAa, MAa);
   if (a == NULL)
   {
      FA_free(x, FAx, MAx);
      FA_free(y, FAy, MAy);
      return(-1);
   }
   if (incX < 1)
   {
      stX = x;
      x = X = x + (lx SHIFT);
   }
   else stX = x + (lx SHIFT);
   if (incY < 1)
   {
      stY = y;
      y = Y = y + (ly SHIFT);
   }
   else stY = y + (ly SHIFT);
   stA = a + (la SHIFT);

   reps = (MFLOP * 1000000.0) / flops;
   if (reps < 1) reps = 1;
   Mjoin(PATL,gegen)(ly, 1, Y0, ly, M*incY);
   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incY+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N*M+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      #ifdef SYMM_
         Mjoin(PATL,symv)(AtlasLower, N, alpha, a, lda, x, incX, beta, y, incY);
      #else
         Mjoin(PATL,gemv)(TA, M, N, alpha, a, lda, x, incX, beta, y, incY);
      #endif
      x += incx;
      y += incy;
      a += inca;
      if (x == stX) x = X;
      if (y == stY)
      {
         y = Y;
         if (bet == beta) bet = nbeta;
         else bet = beta;
      }
      if (a == stA) a = A;
   }
   ttest = time00() - t0;

   if (ttest > 0.0) mftest = (reps * flops) / (1000000.0 * ttest);
   else mftest = 0.0;

   FA_free(A0, FAa, MAa);
   FA_free(X0, FAx, MAx);
   FA_free(Y0, FAy, MAy);
   return(mftest);
}
void PrintUsage(char *nam)
{
   fprintf(stderr, 
      "USAGE: %s -C <case #> -l <l1mul> -F <mflop> -A <t/n> -m <M> -n <N> -L <lda> -b <beta> -o <output filename> -2 <flush size (kbytes)>\n\n",
           nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, char *pre, int *l2size, int *MFLOP,
              char *cta, int *M, int *N, TYPE *alpha, int *lda,
              TYPE *beta, char *outnam)
{
   char ctmp, ch;
   int i, k, cas=0, iflag=0;
   int l1mul=75;

   *cta = 'N';
   outnam[0] = '\0';
   *l2size = L2SIZE;
   #if defined(DREAL)
      *pre = 'd';
   #elif defined(SREAL)
      *pre = 's';
   #elif defined(SCPLX)
      *pre = 'c';
   #elif defined(DCPLX)
      *pre = 'z';
   #endif
   #ifdef ATL_nkflop
      *MFLOP = (ATL_nkflop) / 1000.0;
      if (*MFLOP < 1) *MFLOP = 1;
   #else
      *MFLOP = 100;
   #endif
   *lda = *M = *N = 1000;
   *beta = *alpha = ATL_rone;
   #ifdef TCPLX
      beta[1] = alpha[1] = ATL_rzero;
   #endif
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'C': /* case */
         cas = atoi(args[++i]);
         break;
      case 'F': /* mflops */
         ch = args[i][2];
         k = atoi(args[++i]);
         if (ch == 'a')
         {
            if (k < 0)
              MAa = -k;
            else 
              FAa = k;
         }
         else if (ch == 'y')
         {
            if (k < 0)
              MAy = -k;
            else 
              FAy = k;
         }
         else if (ch == 'x')
         {
            if (k < 0)
              MAx = -k;
            else 
              FAx = k;
         }
         else *MFLOP = k;
         break;
      case '2':
         *l2size = atoi(args[++i])*1024;
         break;
      case 'f': /* iflag */
         iflag = atoi(args[++i]);
         break;
      case 'L':
         *lda = atoi(args[++i]);
	 break;
      case 'l': /* mflops */
         l1mul = atoi(args[++i]);
         break;
      case 'A': /* trans */
         i++;
         ctmp = toupper(args[i][0]);
         if (ctmp == 'n') ctmp = 'N';
         else if (ctmp == 't') ctmp = 'T';
         else if (ctmp != 'N' && ctmp != 'T') PrintUsage(args[0]);
         *cta = ctmp;
         break;
      case 'm':
         *M = atoi(args[++i]);
         break;
      case 'n':
         *N = atoi(args[++i]);
         break;
      case 'b':
         *beta = atof(args[++i]);
         #ifdef TCPLX
            beta[1] = atof(args[++i]);
         #endif
         break;
      case 'o':
         strcpy(outnam, args[++i]);
         break;
      default: 
         PrintUsage(args[0]);
      }
   }
   #ifdef SYMM_
      if (*M > *N) *N = *M;
      else if (*N > *M) *M = *N;
   #endif
   if (*cta == 'N') { ATL_assert(*lda >= Mmax(1,*M)); }
   else { ATL_assert(*lda >= Mmax(1,*N)); }
   if (outnam[0] == '\0')
   {
      #ifdef SYMM_
         if (ATL_MVNoBlock(iflag)) 
            sprintf(outnam, "res/%csymv%c_%d_0", *pre,*cta, cas);
         else sprintf(outnam, "res/%csymv%c_%d_%d", *pre,*cta, cas, l1mul);
      #else
         if (ATL_MVNoBlock(iflag)) 
            sprintf(outnam, "res/%cgemv%c_%d_0", *pre,*cta, cas);
         else sprintf(outnam, "res/%cgemv%c_%d_%d", *pre,*cta, cas, l1mul);
      #endif
   }
}

main(int nargs, char **args)
{
   char pre, fnam[128], cta;
   enum ATLAS_TRANS TA;
   int MFLOP, M, N, lda, i, l2size;
   double mf, mfs[3];
   #ifdef TREAL
      TYPE alpha, beta;
   #else
      TYPE alpha[2], beta[2];
   #endif
   FILE *fp;

   GetFlags(nargs, args, &pre, &l2size, &MFLOP, &cta, &M, &N, SADD alpha, &lda, 
            SADD beta, fnam);

   if (cta == 'N' || cta == 'n') TA = AtlasNoTrans;
   else TA = AtlasTrans;
@skip   sprintf(fnam, "res/%cgemv%c_%d", pre, cta, cas);
   if (!FileExists(fnam))
   {
      fp = fopen(fnam, "w");
      ATL_assert(fp);
      for (i=0; i < 3; i++)
      {
         mf = gemvcase(MFLOP, TA, l2size, M, N, alpha, lda, beta);
         fprintf(stdout, "      %s : %f MFLOPS\n", fnam, mf);
         fprintf(fp, "%lf\n", mf);
         mfs[i] = mf;
      }
   }
   else
   {
      fp = fopen(fnam, "r");
      for (i=0; i < 3; i++) ATL_assert(fscanf(fp, " %lf", &mfs[i]) == 1);
   }
   fclose(fp);
   mf = (mfs[0] + mfs[1] + mfs[2]) / 3.0;
   fprintf(stdout, "   %s : %.2f MFLOPS\n", fnam, mf);
   exit(0);
}
@ROUT GER1TUNE
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_fopen.h"
#include <string.h>

int FAx=0, MAx=0, FAy=0, MAy=0, FAa=0, MAa=0;
@extract -b @(topd)/FAmalloc.inc

#define ATL_NoBlock(iflag_) ( ((iflag_) | 32) == (iflag_) )

double time00();
#ifdef TREAL
   #define test_ger(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,ger)(M, N, alpha, X, incX, Y, incY, A, lda)
#else
   #define test_ger(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,geru)(M, N, alpha, X, incX, Y, incY, A, lda)
#endif

double gercase(const int MFLOP, const int M, const int N, const SCALAR alpha,
               const int lda)
{
   unsigned long reps;
   const int aincX = 1, aincY = 1;
   const int incX = 1, incY = 1;
   int i, lx, ly, la;
   #ifdef TREAL
      const double flops = 2.0 * M * N;
   #else
      const double flops = 8.0 * M * N;
   #endif
   double ttest, mftest, t0;
   const int inca = lda*N SHIFT, incx = M*incX SHIFT, incy = N*incY SHIFT;
   TYPE *a, *A, *stA, *A0, *x, *X, *X0, *stX, *y, *Y, *Y0, *stY;
   #ifdef TREAL
      const TYPE nalpha = -alpha;
      TYPE alp = alpha;
   #else
      const TYPE *alp = alpha;
      TYPE nalpha[2];
   #endif
   #ifdef TCPLX
      nalpha[0] = -alpha[0]; nalpha[1] = alpha[1];
   #endif

   i = (ATL_DivBySize(L2SIZE)+M-1)/M;
   lx = i * M * aincX;
   X0 = X = x = FA_malloc(ATL_MulBySize(lx), FAx, MAx);
   if (x == NULL) return(-1);

   i = (ATL_DivBySize(L2SIZE)+N-1)/N;
   ly = i * N * aincY;
   Y0 = Y = y = FA_malloc(ATL_MulBySize(ly), FAy, MAy);
   if (y == NULL)
   {
      FA_free(x, FAx, MAx);
      return(-1);
   }
   i = (ATL_DivBySize(L2SIZE)+M*N)/(M*N);
   la = i * lda*N;
   A0 = A = a = FA_malloc(ATL_MulBySize(la), FAa, MAa);
   if (a == NULL)
   {
      FA_free(x, FAy, MAy);
      FA_free(y, FAy, MAy);
      return(-1);
   }
   if (incX < 1)
   {
      stX = x;
      x = X = x + (lx SHIFT);
   }
   else stX = x + (lx SHIFT);
   if (incY < 1)
   {
      stY = y;
      y = Y = y + (ly SHIFT);
   }
   else stY = y + (ly SHIFT);
   stA = a + (la SHIFT);

   reps = (MFLOP * 1000000.0) / flops;
   if (reps < 1) reps = 1;
   Mjoin(PATL,gegen)(ly, 1, Y0, ly, M*incY);
   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incY+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N*M+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      test_ger(M, N, alp, x, incX, y, incY, A0, lda);
      x += incx;
      y += incy;
      a += inca;
      if (x == stX) x = X;
      if (y == stY) y = Y;
      if (a == stA)
      {
         a = A;
         if (alp == alpha) alp = nalpha;
         else alp = alpha;
      }
   }
   ttest = time00() - t0;

   if (ttest > 0.0) mftest = (reps * flops) / (1000000.0 * ttest);
   else mftest = 0.0;

   FA_free(A0, FAa, MAa);
   FA_free(X0, FAx, MAx);
   FA_free(Y0, FAy, MAy);
   return(mftest);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s [flags], where flags are:\n", nam);
   fprintf(stderr, 
           "   -C # : case #; if negative, don't produce & ignore log files\n");
   fprintf(stderr, 
           "   -l <l1mul> : percent (as int) of L1CacheSize to block for\n");
   fprintf(stderr, "   -F <#> : do at least # MFLOPS in each timing interval\n");
   fprintf(stderr, "   -m <#> : set m=#\n");
   fprintf(stderr, "   -n <#> : set n=#\n");
   fprintf(stderr, "   -L <#> : set lda=#\n");
   fprintf(stderr, "   -f <#> : set iflag=#\n");
   fprintf(stderr, "   -a <fp#> : set alpha=fp#; need fp# pair for complex\n");
   fprintf(stderr, "   -o <outfile> : set outfile to given name.\n");
   exit(-1);
}

void GetFlags(int nargs, char **args, char *pre, int *MFLOP, 
              int *M, int *N, TYPE *alpha, int *lda, char *outnam)
{
   int l1mul;
   int i, k, cas, iflag=0;
   char ch;

   l1mul = 75;
   outnam[0] = '\0';
   #if defined(DREAL)
      *pre = 'd';
   #elif defined(SREAL)
      *pre = 's';
   #elif defined(SCPLX)
      *pre = 'c';
   #elif defined(DCPLX)
      *pre = 'z';
   #endif
   #ifdef ATL_nkflop
      *MFLOP = (ATL_nkflop) / 2000.0;
      if (*MFLOP < 1) *MFLOP = 1;
   #else
      *MFLOP = 75;
   #endif
   *lda = *M = *N = 1000;
   *alpha = ATL_rone;
   #ifdef TCPLX
      alpha[1] = ATL_rzero;
   #endif
   cas = 1;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'C': /* case */
         cas = atoi(args[++i]);
         break;
      case 'F': /* mflops */
         ch = args[i][2];
         k = atoi(args[++i]);
         if (ch == 'a')
         {
            if (k < 0)
              MAa = -k;
            else 
              FAa = k;
         }
         else if (ch == 'y')
         {
            if (k < 0)
              MAy = -k;
            else 
              FAy = k;
         }
         else if (ch == 'x')
         {
            if (k < 0)
              MAx = -k;
            else 
              FAx = k;
         }
         else *MFLOP = k;
         break;
      case 'f': /* iflag */
         iflag = atoi(args[++i]);
         break;
      case 'm':
         *M = atoi(args[++i]);
         break;
      case 'n':
         *N = atoi(args[++i]);
         break;
      case 'l':
         l1mul = atoi(args[++i]);
         break;
      case 'a':
         *alpha = atof(args[++i]);
         #ifdef TCPLX
            alpha[1] = atof(args[++i]);
         #endif
         break;
      case 'o':
         strcpy(outnam, args[++i]);
         break;
      default: 
         PrintUsage(args[0]);
      }
   }
   if (cas > 0 && outnam[0] == '\0')
   {
      if (ATL_NoBlock(iflag))
         sprintf(outnam, "res/%cger1_%d_0", *pre, cas);
      else sprintf(outnam, "res/%cger1_%d_%d", *pre, cas, l1mul);
   }
   else if (cas > 0)
      outnam[0] = '\0';
}

static void SortDoubles(int N, double *d)
/*
 * Sorts doubles into least-to-greatest order using O(N^2) selection sort
 */
{
   int i, j, imin;
   double dmin;

   for (i=0; i < N-1; i++)
   {
      imin = i;
      dmin = d[i];
      for (j=i+1; j < N; j++)
      {
         if (d[j] < dmin)
         {
            imin = j;
            dmin = d[j];
         }
      }
      d[imin] = d[i];
      d[i] = dmin;
   }
}

main(int nargs, char **args)
{
   char pre, fnam[128];
   int MFLOP, M, N, lda, cas, i;
   double mf, mfs[3];
   #ifdef TREAL
      TYPE alpha;
   #else
      TYPE alpha[2];
   #endif
   FILE *fp;

   GetFlags(nargs, args, &pre, &MFLOP, &M, &N, SADD alpha, &lda, fnam);

@skip   sprintf(fnam, "res/%cger1_%d", pre, cas);
   if (!fnam[0] || !FileExists(fnam))
   {
      if (fnam[0])
      {
         fp = fopen(fnam, "w");
         ATL_assert(fp);
      }
      for (i=0; i < 3; i++)
      {
         mf = gercase(MFLOP, M, N, alpha, lda);
         fprintf(stdout, "      %s : %f MFLOPS\n", fnam, mf);
         if (fp) fprintf(fp, "%lf\n", mf);
         mfs[i] = mf;
      }
   }
   else
   {
      fp = fopen(fnam, "r");
      for (i=0; i < 3; i++) ATL_assert(fscanf(fp, " %lf", &mfs[i]) == 1);
   }
   if (fp)
      fclose(fp);
   SortDoubles(3, mfs);
   #if defined(PentiumMhz) || defined (WALL)
      mf = mfs[2];
   #else
      mf = mfs[1];
   #endif
   fprintf(stdout, "   %s : %.2f MFLOPS\n", fnam[0] ? fnam : "GER", mf);
   exit(0);
}
@ROUT ATL_cger1_axpy
#include "atlas_misc.h"
#include "atlas_lvl2.h"

@ROUT ATL_cger1_axpy
static void ger1(const int M, const int N, const SCALAR alpha, const TYPE *X,
                 const TYPE *Y, const int incY, TYPE *A, const int lda)
{
   const int incy = incY<<1, lda2 = lda<<1;
   const TYPE *stY = Y + N*incy;
   #ifdef Conj_
      TYPE y[2];
   #else
      #define y Y
   #endif
   do
   {
      #ifdef Conj_
         *y = *Y;
         y[1] = -Y[1];
      #endif
      Mjoin(PATL,axpy)(M, y, X, 1, A, 1);
      Y += incy;
      A += lda2;
   }
   while (Y != stY);
}
void ATL_UGERK
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
{
   ger1(M, N, alpha, X, Y, incY, A, lda);
}
@ROUT ATL_cger1_2x1p
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_prefetch.h"

static void ger1(const int M, const int N, const SCALAR alpha, const TYPE *X,
                 const TYPE *Y, const int incY, TYPE *A, const int lda)
{
   const int mr = M - ((M>>1)<<1);
   const int incA = ((lda-M+mr)<<1), incy = incY+incY, lda2=lda+lda;
   const TYPE *stY = Y + N*incy, *stX = X + ((M>>1)<<2), *x;
   register TYPE ry, iy, rx, ix, ra, ia;
   if ( N > 0)
   {
      if (M > 1)
      {
         do
         {
            #ifdef Conj_
               ry = *Y;
               iy = -Y[1];
            #else
               ry = *Y;
               iy = Y[1];
            #endif
            x = X;
            do
            {
               rx = *x; ix = x[1];
               ra = *A; ia = A[1];
               ra += rx * ry; ATL_pfl1W(A+16);
               ia += rx * iy;
               ra -= ix * iy;
               ia += ix * ry;
               *A = ra;
               A[1] = ia;
               rx = x[2]; ix = x[3]; x += 4;
               ra = A[2]; ia = A[3];
               ra += rx * ry;
               ia += rx * iy;
               ra -= ix * iy;
               ia += ix * ry;
               A[2] = ra;
               A[3] = ia; A += 4;
            }
            while (x != stX);
            if (!mr) goto L1;
            else
            {
               rx = *x; ix = x[1];
               ra = *A; ia = A[1];
               ra += rx * ry;
               ra -= ix * iy;
               ia += rx * iy;
               ia += ix * ry;
               *A = ra;
               A[1] = ia;
            }
L1:         Y += incy;
            A += incA;
         }
         while (Y != stY);
      }
      else if (M == 1) 
      {
         #ifdef Conj_
            rx = *X; ix = X[1];
            do
            {
               ry = *Y; iy = Y[1];
               ra = *A; ia = A[1];
               ra += rx * ry;
               ia -= rx * iy;
               ra += ix * iy;
               ia += ix * ry;
               *A = ra;
               A[1] = ia;
               Y += incy;
               A += lda2;
            }
            while (Y != stY);
         #else
            Mjoin(PATL,axpy)(N, X, Y, incY, A, lda);
         #endif
      }
   }
}
void ATL_UGERK
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
{
   ger1(M, N, alpha, X, Y, incY, A, lda);
}

@ROUT ATL_cger1_dummy
#include "atlas_misc.h"
#include "atlas_lvl2.h"

void Mjoin(PATL,ger1c_a1_x1_yX)
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
{
   exit(-1);
}
@ROUT ATL_GER1_axpy ATL_ger1_4x4_1 ATL_ger1_8x4_0 ATL_ger1_1x4_0
#include "atlas_misc.h"
#include "atlas_lvl2.h"
@ROUT ATL_ger1_axpy `#include "atlas_prefetch.h"`

static void ger_Mle8(const int M, const int N, const TYPE *X, 
                     const TYPE *Y, const int incY, TYPE *A, const int lda)
{
   const TYPE *stY = Y + incY*N;
   register TYPE y0, x0, x1, x2, x3, x4, x5, x6, x7;

   switch(M)
   {
   case 1:
      x0 = *X;
      do
      {
         *A += *Y * x0;
         A += lda;
         Y += incY;
      }
      while (Y != stY);
      break;
   case 2:
      x0 = *X;
      x1 = X[1];
      do
      {
         y0 = *Y;
         *A += y0 * x0; Y += incY;
         A[1] += y0 * x1;
         A += lda;
      }
      while (Y != stY);
      break;
   case 3:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      do
      {
         y0 = *Y;
         *A += y0 * x0;
         A[1] += y0 * x1; Y += incY;
         A[2] += y0 * x2; A += lda;
      }
      while (Y != stY);
      break;
   case 4:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      do
      {
         y0 = *Y;
         *A += y0 * x0;
         A[1] += y0 * x1; Y += incY;
         A[2] += y0 * x2;
         A[3] += y0 * x3; A += lda;
      }
      while (Y != stY);
      break;
   case 5:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      do
      {
         y0 = *Y;
         *A += y0 * x0;
         A[1] += y0 * x1; Y += incY;
         A[2] += y0 * x2;
         A[3] += y0 * x3;
         A[4] += y0 * x4; A += lda;
      }
      while (Y != stY);
      break;
   case 6:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      x5 = X[5];
      do
      {
         y0 = *Y;
         *A += y0 * x0;
         A[1] += y0 * x1; Y += incY;
         A[2] += y0 * x2;
         A[3] += y0 * x3;
         A[4] += y0 * x4;
         A[5] += y0 * x5; A += lda;
      }
      while (Y != stY);
      break;
   case 7:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      x5 = X[5];
      x6 = X[6];
      do
      {
         y0 = *Y;
         *A += y0 * x0;
         A[1] += y0 * x1;
         A[2] += y0 * x2; Y += incY;
         A[3] += y0 * x3;
         A[4] += y0 * x4;
         A[5] += y0 * x5;
         A[6] += y0 * x6; A += lda;
      }
      while (Y != stY);
      break;
   case 8:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      x5 = X[5];
      x6 = X[6];
      x7 = X[7];
      do
      {
         y0 = *Y;
         *A += y0 * x0;
         A[1] += y0 * x1;
         A[2] += y0 * x2; Y += incY;
         A[3] += y0 * x3;
         A[4] += y0 * x4;
         A[5] += y0 * x5;
         A[6] += y0 * x6;
         A[7] += y0 * x7; A += lda;
      }
      while (Y != stY);
      break;
   default:
      ATL_assert(M == 0);
   }
}
static void ger_Nle4(const int M, const int N, const TYPE *X, 
                     const TYPE *Y, const int incY, TYPE *A, const int lda)
{
   register TYPE y0, y1, y2, y3, x0;
   TYPE *A0 = A, *A1 = A+lda, *A2 = A1+lda, *A3 = A2+lda;
   int i;

   switch(N)
   {
   case 1:
      y0 = *Y;
      for (i=0; i != M; i++) A0[i] += y0 * X[i];
      break;
   case 2:
      y0 = *Y; y1 = Y[incY];
      for (i=0; i != M; i++)
      {
         x0 = X[i];
         A0[i] += y0 * x0;
         A1[i] += y1 * x0;
      }
      break;
   case 3:
      y0 = *Y; y1 = Y[incY]; y2 = Y[incY<<1];
      for (i=0; i != M; i++)
      {
         x0 = X[i];
         A0[i] += y0 * x0;
         A1[i] += y1 * x0;
         A2[i] += y2 * x0;
      }
      break;
   case 4:
      y0 = *Y; y1 = Y[incY]; y2 = Y[incY+incY]; y3 = Y[(incY<<1)+incY];
      for (i=0; i != M; i++)
      {
         x0 = X[i];
         A0[i] += y0 * x0;
         A1[i] += y1 * x0;
         A2[i] += y2 * x0;
         A3[i] += y3 * x0;
      }
      break;
   default:;
   }
}
void ATL_UGERK
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
{
@ROUT ATL_ger1_1x4_0
   int i, j;
   const TYPE *x;
   TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   const TYPE *Y1 = Y+incY, *Y2 = Y1+incY, *Y3 = Y2+incY;
   const int N4 = (N>>2)<<2, incAn = (lda<<2) - M + 1, incY4 = incY<<2;
   register TYPE m0, m1, m2, m3, x0, y0, y1, y2, y3;

   if (M > 8)
   {
      for (j=N4; j; j -= 4)
      {
         y0 = *Y;  Y  += incY4;
         y1 = *Y1; Y1 += incY4;
         y2 = *Y2; Y2 += incY4;
         y3 = *Y3; Y3 += incY4;
         x = X;
         x0 = *X; x = X + 1;
         m0 = y0 * x0;
         m1 = y1 * x0;
         m2 = y2 * x0;
         m3 = y3 * x0;
         for (i=M-1; i; i--)
         {
            x0 = *x++;
            *A0++ += m0; m0 = y0 * x0;
            *A1++ += m1; m1 = y1 * x0;
            *A2++ += m2; m2 = y2 * x0;
            *A3++ += m3; m3 = y3 * x0;
         }
         *A0 += m0; A0 += incAn;
         *A1 += m1; A1 += incAn;
         *A2 += m2; A2 += incAn;
         *A3 += m3; A3 += incAn;
      }
      if (N-N4) ger_Nle4(M, N-N4, X, Y, incY, A0, lda);
   }
   else ger_Mle8(M, N, X, Y, incY, A, lda);
@ROUT ATL_ger1_8x4_0
   int i, j;
   const int incy = incY<<2;
   const TYPE *Y1= Y + incY, *Y2 = Y1 + incY, *Y3 = Y2 + incY;
   const TYPE *x;
   TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   const int M8 = ((M-1)>>3)<<3, mr = M-M8-1;
   const int N4 = (N>>2)<<2, incAn = (lda<<2) - M + 1;
   register TYPE m0, m1, m2, m3, x0, y0, y1, y2, y3;

   if (M8)
   {
      for (j=N4; j; j -= 4)
      {
         y0 = *Y; y1 = *Y1; y2 = *Y2; y3 = *Y3; 
         x0 = *X; x = X + 1;
         m0 = y0 * x0; Y += incy; 
         m1 = y1 * x0; Y1 += incy; 
         m2 = y2 * x0; Y2 += incy; 
         m3 = y3 * x0; Y3 += incy;
         for (i=M8; i; i -= 8)
         {
            x0 = *x;
            *A0 += m0; m0 = y0 * x0;
            *A1 += m1; m1 = y1 * x0;
            *A2 += m2; m2 = y2 * x0;
            *A3 += m3; m3 = y3 * x0;
            x0 = x[1];
            A0[1] += m0; m0 = y0 * x0;
            A1[1] += m1; m1 = y1 * x0;
            A2[1] += m2; m2 = y2 * x0;
            A3[1] += m3; m3 = y3 * x0;
            x0 = x[2];
            A0[2] += m0; m0 = y0 * x0;
            A1[2] += m1; m1 = y1 * x0;
            A2[2] += m2; m2 = y2 * x0;
            A3[2] += m3; m3 = y3 * x0;
            x0 = x[3];
            A0[3] += m0; m0 = y0 * x0;
            A1[3] += m1; m1 = y1 * x0;
            A2[3] += m2; m2 = y2 * x0;
            A3[3] += m3; m3 = y3 * x0;
            x0 = x[4];
            A0[4] += m0; m0 = y0 * x0;
            A1[4] += m1; m1 = y1 * x0;
            A2[4] += m2; m2 = y2 * x0;
            A3[4] += m3; m3 = y3 * x0;
            x0 = x[5];
            A0[5] += m0; m0 = y0 * x0;
            A1[5] += m1; m1 = y1 * x0;
            A2[5] += m2; m2 = y2 * x0;
            A3[5] += m3; m3 = y3 * x0;
            x0 = x[6];
            A0[6] += m0; m0 = y0 * x0;
            A1[6] += m1; m1 = y1 * x0;
            A2[6] += m2; m2 = y2 * x0;
            A3[6] += m3; m3 = y3 * x0;
            x0 = x[7]; x += 8;
            A0[7] += m0; m0 = y0 * x0; A0 += 8;
            A1[7] += m1; m1 = y1 * x0; A1 += 8;
            A2[7] += m2; m2 = y2 * x0; A2 += 8;
            A3[7] += m3; m3 = y3 * x0; A3 += 8;
         }
         if (mr)
         {
            for (i=mr; i; i--)
            {
               x0 = *x++;
               *A0++ += m0; m0 = y0 * x0;
               *A1++ += m1; m1 = y1 * x0;
               *A2++ += m2; m2 = y2 * x0;
               *A3++ += m3; m3 = y3 * x0;
            }
         }
         *A0 += m0; A0 += incAn;
         *A1 += m1; A1 += incAn;
         *A2 += m2; A2 += incAn;
         *A3 += m3; A3 += incAn;
      }
      if (N-N4) ger_Nle4(M, N-N4, X, Y, incY, A0, lda);
   }
   else ger_Mle8(M, N, X, Y, incY, A, lda);
@ROUT ATL_ger1_4x4_1
   int i, j;
   const int incy = incY<<2;
   const TYPE *Y1= Y + incY, *Y2 = Y1 + incY, *Y3 = Y2 + incY;
   const TYPE *x;
   TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   const int M4 = (M>>2)<<2, N4 = (N>>2)<<2, incAn = (lda<<2) - M4;
   register TYPE x0, x1, x2, x3, y0, y1, y2, y3;

   if (M4)
   {
      for (j=N4; j; j -= 4)
      {
         y0 = *Y;  Y  += incy;
         y1 = *Y1; Y1 += incy;
         y2 = *Y2; Y2 += incy;
         y3 = *Y3; Y3 += incy;
         x = X;
         for (i=M4; i; i -= 4)
         {
            x0 = *x; x1 = x[1]; x2 = x[2]; x3 = x[3];
            *A0 += y0 * x0;
            x += 4;
            *A1 += y1 * x0;
            *A2 += y2 * x0;
            *A3 += y3 * x0;
            A0[1] += y0 * x1;
            A1[1] += y1 * x1;
            A2[1] += y2 * x1;
            A3[1] += y3 * x1;
            A0[2] += y0 * x2;
            A1[2] += y1 * x2;
            A2[2] += y2 * x2;
            A3[2] += y3 * x2;
            A0[3] += y0 * x3; A0 += 4;
            A1[3] += y1 * x3; A1 += 4;
            A2[3] += y2 * x3; A2 += 4;
            A3[3] += y3 * x3; A3 += 4;
         }
         switch(M-M4)
         {
         case 1:
            x0 = *x;
            *A0 += y0 * x0;
            *A1 += y1 * x0;
            *A2 += y2 * x0;
            *A3 += y3 * x0;
            break;
         case 2:
            x0 = *x; x1 = x[1];
            *A0 += y0 * x0;
            *A1 += y1 * x0;
            *A2 += y2 * x0;
            *A3 += y3 * x0;
            A0[1] += y0 * x1;
            A1[1] += y1 * x1;
            A2[1] += y2 * x1;
            A3[1] += y3 * x1;
            break;
         case 3:
            x0 = *x; x1 = x[1]; x2 = x[2];
            *A0 += y0 * x0;
            *A1 += y1 * x0;
            *A2 += y2 * x0;
            *A3 += y3 * x0;
            A0[1] += y0 * x1;
            A1[1] += y1 * x1;
            A2[1] += y2 * x1;
            A3[1] += y3 * x1;
            A0[2] += y0 * x2;
            A1[2] += y1 * x2;
            A2[2] += y2 * x2;
            A3[2] += y3 * x2;
            break;
         }
         A0 += incAn;
         A1 += incAn;
         A2 += incAn;
         A3 += incAn;
      }
      if (N-N4) ger_Nle4(M, N-N4, X, Y, incY, A0, lda);
   }
   else ger_Mle8(M, N, X, Y, incY, A, lda);
@ROUT ATL_ger1_axpy
   const TYPE *stY = Y + N*incY;
@beginskip
   #ifdef ATL_AltiVec
      int cwrd = ATL_MulBySize(N)>>4;
      if (cwrd >= 64) cwrd = ATL_GetCtrl(512, (cwrd+31)>>5, 0);
      else cwrd = ATL_GetCtrl(64, (cwrd+3)>>2, 4);
   #endif
@endskip
   if (M > 8)
   {
      do
      {
@beginskip
         #ifdef ATL_AltiVec
            ATL_pfavW(A, cwrd, 0);
         #endif
@endskip
         Mjoin(PATL,axpy)(M, *Y, X, 1, A, 1);
         Y += incY;
         A += lda;
      }
      while (Y != stY);
   }
   else ger_Mle8(M, N, X, Y, incY, A, lda);
@ROUT ATL_ger1_axpy ATL_ger1_4x4_1 ATL_ger1_8x4_0 ATL_ger1_1x4_0
}
@ROUT atlas_r1.h
#ifdef SREAL
   #include "atlas_sr1.h"
#elif defined(DREAL)
   #include "atlas_dr1.h"
#elif defined(SCPLX)
   #include "atlas_cr1.h"
#elif defined(DCPLX)
   #include "atlas_zr1.h"
#endif
@beginskip
#ifndef ATLAS_R1_H
   #define ATLAS_R1_H

#if defined(ATL_MULADD) && ATL_mmnreg >= 29
   #define ATL_GetPartR1(A_, lda_, mb_, nb_) \
   { \
      (mb_) = (((((3*ATL_L1elts)>>2) - 4) / 10)>>2)<<2; \
      if (!(mb_)) (mb_) = 4; \
      (nb_) = 4; \
   }  
#else
   #define ATL_GetPartR1(A_, lda_, mb_, nb_) \
   { \
      (mb_) = (((3*ATL_l1elts)>>2)>>4)<<2; \
      if (!(mb_)) (mb_) = 4; \
      (nb_) = 1; \
   }
#endif

#endif
@endskip
@ROUT ATL_GER
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_lvl3.h"
#if defined(ATL_INL1)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r1_L1.h))
#elif defined(ATL_INL2)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r1_L2.h))
#else
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r1.h))
#endif

@ROUT ATL_GER ATL_Align2Ptr
static void *ATL_Align2Ptr(void *pu, void *pA)
/*
 * Aligns pu%ATL_Cachelen to pA%ATL_Cachelen by adding at most ATL_Cachlen
 * to pu
 */
{
   size_t tu = (size_t) pu, ta = (size_t) pA;

   tu -= (tu/ATL_Cachelen)*ATL_Cachelen;
   ta -= (ta/ATL_Cachelen)*ATL_Cachelen;
   if (tu <= ta)
      tu = ta;
   else
      tu = ta + ATL_Cachelen-tu;
   tu += (size_t) pu;
   return((void*) tu);
}

@ROUT ATL_GER
#ifdef TREAL
   #define ATL_ger Mjoin(PATL,ger)
#else
   #ifdef Conj_
      #define ATL_ger Mjoin(PATL,gerc)
   #else
      #define ATL_ger Mjoin(PATL,geru)
   #endif
#endif
void ATL_ger(const int M, const int N, const SCALAR alpha,
             const TYPE *X, const int incX, const TYPE *Y, const int incY,
             TYPE *A, const int lda)
/* 
 * This dumb version just to get things working.  Later on, only copy
 * Y if we are blocking along X, or the kernel requires it, handle
 * restricted usages, see if we want to enforce alignment, etc.
 */
{
   void (*getX)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, TYPE *Y, const int incY);
   void *vp=NULL;
   size_t t1, t2;
   TYPE *x = (TYPE*)X, *y = (TYPE*)Y;
   const int ALPHA_IS_ONE = SCALAR_IS_ONE(alpha);
   int APPLYALPHAX=0, COPYX, COPYY, ALIGNX2A=0;
   int incy=1, imb, mb, k, m, Nm=N, nr=0;
   #ifdef TREAL
      #define one ATL_rone
   #else
      TYPE one[2] = {ATL_rone, ATL_rzero};
   #endif
   void (*gerk)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT, 
                const TYPE*, ATL_CINT, TYPE*, ATL_CINT);

   if (M < 1 || N < 1 || SCALAR_IS_ZERO(alpha))
      return;
/*
 * ATLAS's GER kernels loop over M in inner loop, which is bad news if M is
 * very small.  Call code that requires no copy of A & B for these degenerate
 * cases
 */
   if (M < 16)
   {
      #ifdef Conj_
         Mjoin(PATL,gerck_Mlt16)(M, N, alpha, X, incX, Y, incY, A, lda);
      #else
         Mjoin(PATL,gerk_Mlt16)(M, N, alpha, X, incX, Y, incY, A, lda);
      #endif
      return;
   }
/*
 * For very small N, we can't afford the data copy, so call AXPY-based routine
 */
   if (N < 4)
   {
      #ifdef Conj_
         Mjoin(PATL,gerck_axpy)(M, N, alpha, X, incX, Y, incY, A, lda);
      #else
         Mjoin(PATL,gerk_axpy)(M, N, alpha, X, incX, Y, incY, A, lda);
      #endif
      return;
   }
   #ifndef ATL_R1NOBLOCK
      imb = mb = M;
   #else
      ATL_GetPartR1(A, lda, mb, i);
      imb = mb;
   #endif
   #ifdef ATL_r1ALIGNX2A
      ALIGNX2A = 1;
   #endif
   #ifdef ATL_r1NMUL
      Nm = (N/ATL_r1NU)*ATL_r1NU;
      nr = N - Nm;
   #endif
   gerk = ATL_GERK;
   #ifdef ATL_r1USERESTRICTK
      if (ATL_r1UseRestrictK(M, N, A, lda))
      {
         #ifndef ATL_R1NOBLOCKr
            imb = mb = M;
         #else
            ATL_GetPartR1r(A, lda, mb, i);
            imb = mb;
         #endif
         #ifdef ATL_r1ALIGNX2Ar
            ALIGNX2A = 1;
         #else
            ALIGNX2A = 0;
         #endif
         #ifdef ATL_r1NMUL
            Nm = (N/ATL_r1NUr)*ATL_r1NUr;
            nr = N - Nm;
         #endif
         gerk = ATL_GERKr;
      }
   #endif
   #ifdef Conj_
      COPYY = 1;
   #else
      COPYY = (incY != 1);
   #endif
   COPYX = (incX != 1);
   if (ALIGNX2A && !COPYX)
   {
      t1 = (size_t) A;
      t2 = (size_t) X;
      COPYX = (t1-(t1/ATL_Cachelen)*ATL_Cachelen) != 
              (t2-(t2/ATL_Cachelen)*ATL_Cachelen);
   }
/*
 * If both vectors are copied or neither is, apply alpha to the shortest
 * vector (apply to Y on tie in order to match lapack).
 * If exactly one vector is copied, then apply alpha to the one we are already
 * copying, regardless of size (copy with scale is typically not noticably
 * slower than copying, despite the extra flops).
 */
   if (COPYX != COPYY)
      APPLYALPHAX = COPYX;
   else if (!COPYY && !COPYX)
   {
      APPLYALPHAX = M < N;
      if (!ALPHA_IS_ONE)
      {
         COPYX = APPLYALPHAX;
         COPYY = !APPLYALPHAX;
      }
   }
   else /* if (COPYY && COPYX) */
      APPLYALPHAX = M < N;
   
   if (COPYX | COPYY)
   {
      k = Mmax(imb, mb);
      k = Mmin(k, M);
      vp = malloc(ATL_MulBySize(COPYX*k+COPYY*N) + 2*ATL_Cachelen);
/* 
 *    If we cannot allocate enough space to copy the vectors, give up and
 *    call the axpy-based implementation
 */
      if (!vp)
      {
         Mjoin(PATL,gerk_axpy)(M, N, alpha, X, incX, Y, incY, A, lda);
         return;
      }
      if (COPYY)
      {
         y = ATL_AlignPtr(vp);
         x = y + N;
         if (ALIGNX2A)
            x = ATL_Align2Ptr(x, A);
         else
            x = ATL_AlignPtr(x);
         if (!APPLYALPHAX && !ALPHA_IS_ONE)  /* need to apply alpha to Y */
         #ifdef Conj_
            Mjoin(PATL,moveConj)(N, alpha, Y, incY, y, 1);
         #else
            Mjoin(PATL,cpsc)(N, alpha, Y, incY, y, 1);
         #endif
         else  /* do not apply alpha */
         #ifdef Conj_
            Mjoin(PATL,copyConj)(N, Y, incY, y, 1);
         #else
            Mjoin(PATL,copy)(N, Y, incY, y, 1);
         #endif
      }
      else if (ALIGNX2A)
         x = ATL_Align2Ptr(vp, A);
      else
         x = ATL_AlignPtr(vp);
   }
   getX = (COPYX) ? Mjoin(PATL,cpsc) : NULL;
   m = M;
   imb = (imb) ? imb : mb;
   imb = Mmin(imb, m);
   do
   {
/*
 *    Copy X if necessary
 */
      if (getX)
         getX(imb, alpha, X, incX, x, 1);
      else 
         x = (TYPE*) X;
/*
 *    Call optimized kernel (can be restricted or general)
 */
      gerk(imb, Nm, one, x, 1, y, incy, A, lda);
/*
 *    Some kernels require N%NU=0; if so nr is remainder, do cleanup with axpy
 */
      if (nr)
         Mjoin(PATL,gerk_axpy)(imb, nr, one, x, 1, y+(Nm SHIFT), 1, 
                               A+lda*Nm, lda);
      A += imb SHIFT;
      X += (imb*incX)SHIFT;
      m -= imb;
      imb = Mmin(m,mb);
   }
   while(m);
   if (vp)
      free(vp);
}
@ROUT ATL_GER_old
@skip HERE HERE HERE
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_lvl3.h"
#if defined(ATL_INL1)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r1_L1.h))
#elif defined(ATL_INL2)
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r1_L2.h))
#else
   #include Mstr(Mjoin(Mjoin(atlas_,PRE),r1.h))
#endif

@beginskip
#ifdef ATL_TUNING
   #ifdef Conj_
      #define ATL_ger1c ATL_UGERK_Conj
      #define ATL_ger1u ATL_UGERK
   #else
      #define ATL_ger1 ATL_UGERK
   #endif
#else
   #ifdef TREAL
      #define ATL_ger1 Mjoin(PATL,ger1_a1_x1_yX)
   #elif defined(Conj_)
      #define ATL_ger1c  Mjoin(PATL,ger1c_a1_x1_yX)
      #define ATL_ger1u  Mjoin(PATL,ger1u_a1_x1_yX)
   #else
      #define ATL_ger1 Mjoin(PATL,ger1u_a1_x1_yX)
   #endif
#endif

#ifdef Conj_
   void ATL_ger1u(const int M, const int N, const SCALAR alpha,
                  const TYPE *X, const int incX, const TYPE *Y, 
                  const int incY, TYPE *A, const int lda);
   void ATL_ger1c(const int M, const int N, const SCALAR alpha,
                  const TYPE *X, const int incX, const TYPE *Y, 
                  const int incY, TYPE *A, const int lda);
#else
   void ATL_ger1(const int M, const int N, const SCALAR alpha,
                 const TYPE *X, const int incX, const TYPE *Y, 
                 const int incY, TYPE *A, const int lda);
#endif
@endskip

#ifdef TREAL
   #define ATL_ger Mjoin(PATL,ger)
#else
   #ifdef Conj_
      #define ATL_ger Mjoin(PATL,gerc)
   #else
      #define ATL_ger Mjoin(PATL,geru)
   #endif
#endif
void ATL_ger(const int M, const int N, const SCALAR alpha,
             const TYPE *X, const int incX, const TYPE *Y, const int incY,
             TYPE *A, const int lda)
{
   int imb, mb, mb0, m=M, i;
   int incy=incY;
   #ifdef TREAL
      #define one ATL_rone
   #else
      static TYPE one[2] = {ATL_rone, ATL_rzero};
   #endif
   void *vx=NULL;
   TYPE *x, *y = (TYPE*) Y;
   void (*getX)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, TYPE *Y, const int incY);
   void Mjoin(PATL,gerk_Mlt16)(const int M, const int N, const SCALAR alpha,
                               const TYPE *X, const int incX, const TYPE *Y, 
                               const int incY, TYPE *A, const int lda);


   if ( !M || !N || SCALAR_IS_ZERO(alpha) ) return;
/*
 * ATLAS's GER kernels loop over M in inner loop, which is bad news if M is
 * very small.  Call code that requires no copy of A & B for these degenerate
 * cases
 */
   if (M < 16)
   {
      Mjoin(PATL,gerk_Mlt16)(M, N, alpha, X, incX, Y, incY, A, lda);
      return;
   }

   #ifdef ATL_R1NOBLOCK
      imb = mb = M;
   #else
      ATL_FindMatAdjust(A, lda, imb);
      ATL_GetPartR1(A, lda, mb, i);
   #endif

   if (incX != 1 || !SCALAR_IS_ONE(alpha))
   {
/*
 *    Apply alpha to Y if X has stride 1 & Y is MUCH smaller
 *    The LAPACK barfs if you  switch which vector alpha is applied to,
 *    since it tests tiny matrices, so make it apply to X when they are
 *    close to even
 */
      if (incX == 1 && N < (M>>4))
      {
         vx = malloc(ATL_Cachelen + ATL_MulBySize(N));
         ATL_assert(vx);
         y = ATL_AlignPtr(vx);
         #ifdef Conj_
            Mjoin(PATL,moveConj)(N, alpha, Y, incY, y, 1);
         #else
            Mjoin(PATL,cpsc)(N, alpha, Y, incY, y, 1);
         #endif
         incy = 1;
         getX = NULL;
      }
      else
      {
         i = Mmax(imb,mb);
         i = Mmin(i,M);
         vx = malloc(ATL_Cachelen + ATL_MulBySize(i));
         ATL_assert(vx);
         x = ATL_AlignPtr(vx);
         getX = Mjoin(PATL,cpsc);
      }
   }
   else getX = NULL;

   if (imb) mb0 = Mmin(imb,m);
   else mb0 = Mmin(mb,m);
   do
   {
      if (getX) getX(mb0, alpha, X, incX, x, 1);
      else x = (TYPE*) X;
      ATL_ger1(mb0, N, one, x, 1, y, incy, A, lda);
      A += mb0 SHIFT;
      X += mb0*incX SHIFT;
      m -= mb0;
      mb0 = Mmin(m,mb);
   }
   while(m);
   if (vx) free(vx);
}
@ROUT atlas_mv.h
#ifndef ATLAS_MV_H
   #define ATLAS_MV_H

#include "atlas_misc.h"
#if defined(SREAL)
   #include "atlas_smv.h"
#elif defined(DREAL)
   #include "atlas_dmv.h"
#elif defined(SCPLX)
   #include "atlas_cmv.h"
#elif defined(DCPLX)
   #include "atlas_zmv.h"
#endif

#endif
@ROUT atlas_mv.h_old
#ifndef ATLAS_MV_H
   #define ATLAS_MV_H

#include "atlas_misc.h"

/*
 * Header file for figuring how big a matvec to do at a time, and still keep
 * operands in L1 cache.  Here we use 3/4 of L1 only, to ensure a good amount
 * of operands remain in cache despite conflicts, noise, etc.  Later on we'll
 * determine this empirically, exactly as CacheEdge does for L2 cache.
 * We set # of TLB entries and pagesizes to good defaults.  We will try to
 * probe for them in subsequent releases.
 */
#ifndef ATL_pagesize
   #define ATL_pagesize ATL_DivBySize(4096)
#endif
#ifndef ATL_ntlb
   #define ATL_ntlb 56  /* # of tlb entries; emperically determine later */
#endif

#if (defined(ATL_NOMULADD) && (ATL_mmnreg >= 22)) || \
    (defined(ATL_MULADD) && (ATL_mmnreg >= 28))
   #define ATL_GetPartMVN(A_, lda_, mb_, nb_) \
   { \
      *(nb_) = (((3*(ATL_L1elts - 4)) / (20))>>2)<<1; \
      if (ATL_pagesize > (lda_)) \
      { \
         *(mb_) = (ATL_pagesize / (lda_)) * ATL_ntlb; \
         if ( (*mb_) < *(nb_) ) *(nb_) = ((*(mb_))>>1)<<1; \
      } \
      else *(nb_) = ATL_ntlb; \
      *(mb_) = ( ((3*ATL_L1elts)>>2) - *(nb_) ) / ((*(nb_)+1)<<1); \
@skip      *(mb_) = 4; \
   }
   #define ATL_GetPartMVT(A_, lda_, mb_, nb_) \
   { \
      *(mb_) = (((3*ATL_L1elts) / 20)>>2)<<2; \
      *(nb_) = 2; \
   }
#else
   #include "atlas_lvl3.h"

   #define ATL_GetPartMVN(A_, lda_, mb_, nb_) \
   { \
      *(mb_) = Mmax(2,ATL_mmMU); \
      *(nb_) = ( ((3*ATL_L1elts)>>2) - ((*(mb_))<<1)  ) / ( ((*(mb_))<<1)+1 ); \
      if (ATL_pagesize > (lda_)) \
         (*nb_) = Mmin(*(nb_), (ATL_pagesize/(lda_)) *ATL_ntlb); \
      else *(nb_) = ATL_ntlb; \
      if (*(nb_) > NB) *(nb_) = ATL_MulByNB(ATL_DivByNB(*(nb_))); \
      else (*nb_) = NB; \
      *(mb_) = ( ((3*ATL_L1elts)>>2) - *(nb_) ) / ((*(nb_)+1)<<1); \
      if (*(mb_) > ATL_mmMU) (*mb_) = ((*mb_) / ATL_mmMU)*ATL_mmMU; \
      else *(mb_) = ATL_mmMU; \
   }
   #define ATL_GetPartMVT(A_, lda_, mb_, nb_) \
   { \
      *(nb_) = Mmax(2,ATL_mmMU); \
      *(mb_) = ( ((3*ATL_L1elts)>>2) - ((*(nb_))<<1) ) / ( ((*(nb_))<<1)+1 ); \
      if (*(mb_) > NB) *(mb_) = ATL_MulByNB(ATL_DivByNB(*(mb_))); \
      else *(mb_) = NB; \
   }
#endif

#endif
@ROUT ATL_GEMV
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_mv.h"

/*
 * Special case for NoTrans gemv based on multiple axpys instead of usual
 * multiple dot products
 */
#ifdef ATL_AXPYMV
static void gemvNaxpy
   (const enum ATLAS_TRANS TA, const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX, 
    const SCALAR beta, TYPE *Y, const int incY)
{
   int i, mb, incYY, incy;
   void *vx=NULL, *vy=NULL;
   TYPE *x = (TYPE *) X, *y=Y;
   #ifdef TREAL
      #define ONE ATL_rone
      #define ZERO ATL_rzero
      TYPE alphaY = alpha, betaY, betamv=beta;
   #else
      const TYPE ONE[2]={ATL_rone, ATL_rzero}, ZERO[2]={ATL_rzero, ATL_rzero};
      const TYPE *alphaY = alpha, *betaY, *betamv=beta;
   #endif
   void (*putY)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, const SCALAR beta, TYPE *Y, const int incY);
   void (*gemv)(const int M, const int N, const SCALAR alpha,
                const TYPE *A, const int lda, const TYPE *X, const int incX,
                const SCALAR beta, TYPE *Y, const int incY);

   #ifdef ATL_mvNNOBLOCK
      mb = M;
   #else
      ATL_GetPartMVN(A, lda, &mb, &i);
      if (mb > M) mb = M;
   #endif
   if ( (incX != 1) || (!SCALAR_IS_ONE(alpha) && incY == 1 && M >= N) )
   {
      alphaY = ONE;
      vx = malloc(ATL_Cachelen + ATL_MulBySize(N));
      ATL_assert(vx);
      x = ATL_AlignPtr(vx);
      Mjoin(PATL,cpsc)(N, alpha, X, incX, x, 1);
   }
   if ( (incY != 1) || !SCALAR_IS_ONE(alphaY) )
   {
      betaY = beta;
      betamv = ZERO;
      #ifdef TREAL
         gemv = Mjoin(PATL,gemvN_a1_x1_b0_y1);
      #else
         if (TA == AtlasNoTrans) gemv = Mjoin(PATL,gemvN_a1_x1_b0_y1);
         else gemv = Mjoin(PATL,gemvNc_a1_x1_b0_y1);
      #endif
      vy = malloc(ATL_Cachelen + ATL_MulBySize(mb));
      ATL_assert(vy);
      y = ATL_AlignPtr(vy);
      putY = Mjoin(PATL,axpby);
   }
   else if ( SCALAR_IS_ONE(beta) )
   {
      putY = NULL;
      #ifdef TREAL
         gemv = Mjoin(PATL,gemvN_a1_x1_b1_y1);
      #else
         if (TA == AtlasNoTrans) gemv = Mjoin(PATL,gemvN_a1_x1_b1_y1);
         else gemv = Mjoin(PATL,gemvNc_a1_x1_b1_y1);
      #endif
   }
   else if ( SCALAR_IS_ZERO(beta) )
   {
      putY = NULL;
      #ifdef TREAL
         gemv = Mjoin(PATL,gemvN_a1_x1_b0_y1);
      #else
         if (TA == AtlasNoTrans) gemv = Mjoin(PATL,gemvN_a1_x1_b0_y1);
         else gemv = Mjoin(PATL,gemvNc_a1_x1_b0_y1);
      #endif
   }
   else
   {
      putY = NULL;
      #ifdef TREAL
         gemv = Mjoin(PATL,gemvN_a1_x1_bX_y1);
      #else
         if (TA == AtlasNoTrans) gemv = Mjoin(PATL,gemvN_a1_x1_bX_y1);
         else gemv = Mjoin(PATL,gemvNc_a1_x1_bX_y1);
      #endif
   }
   i = M;
   incYY = mb * incY SHIFT;
   if (putY) incy = 0;
   else incy = incYY;

   do
   {
      if (mb > i) mb = i;
      gemv(mb, N, ONE, A, lda, x, 1, betamv, y, 1);
      if (putY) putY(mb, alphaY, y, 1, betaY, Y, incY);
      A += mb SHIFT;
      Y += incYY;
      y += incy;
      i -= mb;
   }
   while(i);

   if (vx) free(vx);
   if (vy) free(vy);
}
#endif

void Mjoin(PATL,gemv)
   (const enum ATLAS_TRANS TA, const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX, 
    const SCALAR beta, TYPE *Y, const int incY)
/*
 *  y <- alpha * A * x + beta*y   .. or ..  y <- alpha * A' * x + beta*y
 *  .. or ..  y <- alpha * conj(A') * x + beta*y
 *
 *  Note:  M = length of Y
 *         N = length of X
 */
{
   const int BetaIsZero = SCALAR_IS_ZERO(beta); 
   const int BetaIsOne = SCALAR_IS_ONE(beta);
   const int AlphaIsOne = SCALAR_IS_ONE(alpha);
   const int AlphaIsZero = SCALAR_IS_ZERO(alpha);
   int i, imb, nb, incAn, incx;
   void *vx=NULL, *vy=NULL;
   TYPE *x = (TYPE *) X, *y=Y;
   #ifdef TREAL
      TYPE alphaY = alpha, beta0=beta;
      #define ONE ATL_rone
      #define ZERO ATL_rzero
   #else
      const TYPE *alphaY = alpha, *beta0 = beta;
      const TYPE ONE[2]={ATL_rone, ATL_rzero}, ZERO[2]={ATL_rzero, ATL_rzero};
   #endif
   void (*getX)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, TYPE *Y, const int incY);
   void (*putY)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, const SCALAR beta, TYPE *Y, const int incY);
   void (*gemv0)(const int M, const int N, const SCALAR alpha,
                 const TYPE *A, const int lda, const TYPE *X, const int incX,
                 const SCALAR beta, TYPE *Y, const int incY);
   void (*gemv1)(const int M, const int N, const SCALAR alpha,
                 const TYPE *A, const int lda, const TYPE *X, const int incX,
                 const SCALAR beta, TYPE *Y, const int incY);
   #define gemv1_N Mjoin(PATL,gemvN_a1_x1_b1_y1)
   #define gemv1_Nc Mjoin(PATL,gemvNc_a1_x1_b1_y1)
   #define gemv1_T Mjoin(PATL,gemvT_a1_x1_b1_y1)
   #define gemv1_C Mjoin(PATL,gemvC_a1_x1_b1_y1)

   if (!M || !N) return;
   if (AlphaIsZero)  /* y <- beta * y */
   {
      if (!BetaIsOne) Mjoin(PATL,scal)(M, beta, Y, incY);
      return;
   }

   if (TA == AtlasNoTrans || TA == AtlasConj)
   {
      #ifdef ATL_AXPYMV
         gemvNaxpy(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY);
         return;
      #else
         #ifdef ATL_mvNNOBLOCK
            nb = N;
         #else
            ATL_GetPartMVN(A, lda, &i, &nb);
            if (nb > N) nb = N;
         #endif
         incAn = nb * lda SHIFT;
         #ifdef TREAL
            gemv1 = gemv1_N;
         #else
            if (TA == AtlasNoTrans) gemv1 = gemv1_N;
            else gemv1 = gemv1_Nc;
         #endif
      #endif
   }
   else
   {
      #ifdef ATL_mvTNOBLOCK
         nb = N;
      #else
         ATL_GetPartMVT(A, lda, &nb, &i);
         if (nb > N) nb = N;
      #endif
      incAn = nb SHIFT;
      #ifdef TREAL
         gemv1 = gemv1_T;
      #else
         if (TA == AtlasTrans) gemv1 = gemv1_T;
         else gemv1 = gemv1_C;
      #endif
   }

   if (incX != 1 || (incY == 1 && !AlphaIsOne && (M>>2) >= N))
   {
      vx = malloc((ATL_Cachelen<<1) + ATL_MulBySize(nb));
      ATL_assert(vx);
      x = ATL_AlignPtr(vx);
/*
 *    In trans case, adjust X to have same misalignment as A
 */
      if (TA == AtlasTrans)
      {
         ATL_FindMatAdjust(A, lda, imb);
         if (imb)
         {
            i = (int) (x - ((TYPE*)(vx)));
            #ifdef TCPLX
               i >>= 1;
            #endif
            if (imb <= i) x -= (i-imb)SHIFT;
            else x += imb SHIFT;
         }
      }
      getX = Mjoin(PATL,cpsc);
      alphaY = ONE;
   }
   else getX = NULL;
   if (incY != 1 || !SCALAR_IS_ONE(alphaY))  /* gotta buffer Y */
   {
      vy = malloc(ATL_Cachelen + ATL_MulBySize(M));
      ATL_assert(vy);
      y = ATL_AlignPtr(vy);
      putY = Mjoin(PATL,axpby);
      if (TA == AtlasNoTrans) gemv0 = Mjoin(PATL,gemvN_a1_x1_b0_y1);
      #ifdef TCPLX
         else if (TA == AtlasConj) gemv0 = Mjoin(PATL,gemvNc_a1_x1_b0_y1);
         else if (TA == AtlasConjTrans) gemv0 = Mjoin(PATL,gemvC_a1_x1_b0_y1);
      #endif
      else gemv0 = Mjoin(PATL,gemvT_a1_x1_b0_y1);
      beta0 = ZERO;
   }
   else  /* can use user's own Y */
   {
      putY = NULL;
      if (BetaIsOne)
      {
         if (TA == AtlasNoTrans) gemv0 = Mjoin(PATL,gemvN_a1_x1_b1_y1);
         #ifdef TCPLX
            else if (TA == AtlasConj) 
               gemv0 = Mjoin(PATL,gemvNc_a1_x1_b1_y1);
            else if (TA == AtlasConjTrans) 
               gemv0 = Mjoin(PATL,gemvC_a1_x1_b1_y1);
         #endif
         else gemv0 = Mjoin(PATL,gemvT_a1_x1_b1_y1);
      }
      else if (BetaIsZero)
      {
         if (TA == AtlasNoTrans) gemv0 = Mjoin(PATL,gemvN_a1_x1_b0_y1);
         #ifdef TCPLX
            else if (TA == AtlasConj) 
               gemv0 = Mjoin(PATL,gemvNc_a1_x1_b0_y1);
            else if (TA == AtlasConjTrans) 
               gemv0 = Mjoin(PATL,gemvC_a1_x1_b0_y1);
         #endif
         else gemv0 = Mjoin(PATL,gemvT_a1_x1_b0_y1);
      }
      #ifdef TCPLX
         else if (beta[1] == ATL_rzero)
         {
            if (TA == AtlasNoTrans) gemv0 = Mjoin(PATL,gemvN_a1_x1_bXi0_y1);
            else if (TA == AtlasConj) gemv0 = Mjoin(PATL,gemvNc_a1_x1_bXi0_y1);
            else if (TA == AtlasConjTrans) 
               gemv0 = Mjoin(PATL,gemvC_a1_x1_bXi0_y1);
            else gemv0 = Mjoin(PATL,gemvT_a1_x1_bXi0_y1);
         }
      #endif
      else
      {
         if (TA == AtlasNoTrans) gemv0 = Mjoin(PATL,gemvN_a1_x1_bX_y1);
         #ifdef TCPLX
            else if (TA == AtlasConj) gemv0 = Mjoin(PATL,gemvNc_a1_x1_bX_y1);
            else if (TA == AtlasConjTrans) 
               gemv0 = Mjoin(PATL,gemvC_a1_x1_bX_y1);
         #endif
         else gemv0 = Mjoin(PATL,gemvT_a1_x1_bX_y1);
      }
   }
   incx = nb * incX SHIFT;
   i = N;
   do
   {
      if (nb > i) nb = i;
      if (getX) getX(nb, alpha, X, incX, x, 1);
      else x = (TYPE*) X;
      gemv0(M, nb, ONE, A, lda, x, 1, beta0, y, 1);
      beta0 = ONE;
      gemv0 = gemv1;
      i -= nb;
      X += incx;
      A += incAn;
   }
   while (i);
   if (vx) free(vx);

   if (putY)
   {
      putY(M, alphaY, y, 1, beta, Y, incY);
      free(vy);
   }
}
@ROUT ATL_gemvN_dummy2 ATL_gemvT_dummy2
#include "atlas_misc.h"
#include "atlas_level2.h"
@ROUT ATL_gemvN_dummy2
#ifdef Conj_
   void Mjoin(Mjoin(Mjoin(Mjoin(Mjoin(PATL,gemvNc),NM),_x1),BNM),_y1)
#else
   void Mjoin(Mjoin(Mjoin(Mjoin(Mjoin(PATL,gemvN),NM),_x1),BNM),_y1)
#endif
@ROUT ATL_gemvT_dummy2
#ifdef Conj_
   void Mjoin(Mjoin(Mjoin(Mjoin(Mjoin(PATL,gemvC),NM),_x1),BNM),_y1)
#else
   void Mjoin(Mjoin(Mjoin(Mjoin(Mjoin(PATL,gemvT),NM),_x1),BNM),_y1)
#endif
@ROUT ATL_gemvN_dummy2 ATL_gemvT_dummy2
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
   exit(-1);  /* should never be called */
}
@ROUT ATL_gemvN_dummy
   @define tt @N@
   @define tc @Nc@
@ROUT ATL_gemvT_dummy
   @define tt @T@
   @define tc @C@
@ROUT ATL_gemvN_dummy ATL_gemvT_dummy
#include "atlas_misc.h"
#include "atlas_level2.h"
#define gemv0 Mjoin(Mjoin(Mjoin(Mjoin(gemv@(tt),NM),_x1),BNM),_y1)
#define gemvC Mjoin(Mjoin(Mjoin(Mjoin(gemvC,NM),_x1),BNM),_y1)
#define gemvNc Mjoin(Mjoin(Mjoin(Mjoin(gemvNc,NM),_x1),BNM),_y1)
void Mjoin(PATL,gemv0)
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
   exit(-1);  /* should never be called */
}
#ifdef TCPLX
void Mjoin(PATL,gemvNc)
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
   exit(-1);  /* should never be called */
}
void Mjoin(PATL,gemvC)
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
   exit(-1);  /* should never be called */
}
#endif
@undef tt
@undef tc
@ROUT ATL_cgemvN_4x2_1 ATL_cgemvN_2x2_0 ATL_cgemvN_mm ATL_cgemvN_1x1_1 ATL_cgemvN_1x1_1a
#include "atlas_misc.h"
#include "atlas_level2.h"
#include "atlas_level1.h"
@ROUT ATL_cgemvN_4x2_1 `#include "atlas_prefetch.h"`

#ifdef Conj_
   #define PEQ -=
   #define MEQ +=
#else
   #define PEQ +=
   #define MEQ -=
#endif

@ROUT ATL_cgemvN_mm
#include "atlas_lvl3.h"

#ifdef Conj_
void Mjoin(PATL,Mjoin(Mjoin(Mjoin(Mjoin(gemvNc,NM),_x1),BNM),_y1))
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
/*
 *  Use trick: y <- alpha * conj(A) + y ==> 
 *             trans(y) <- alpha * trans(x) * ConjTrans(A) + trans(y)
 */
{
   TYPE one[2] = {ATL_rone, ATL_rzero};
   Mjoin(PATL,NCmmJIK)(AtlasTrans, AtlasConjTrans, 1, M, N, one, X, 1,
                       A, lda, beta, Y, 1);
}
#else
void Mjoin(PATL,Mjoin(Mjoin(Mjoin(Mjoin(gemvN,NM),_x1),BNM),_y1))
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
   TYPE one[2] = {ATL_rone, ATL_rzero};
   Mjoin(PATL,NCmmJIK)(AtlasNoTrans, AtlasNoTrans, M, 1, N, one, A, lda,
                       X, N, beta, Y, M);
}
#endif
@ROUT ATL_cgemvN_4x2_1 ATL_cgemvN_2x2_0 ATL_cgemvN_1x1_1 ATL_cgemvN_1x1_1a
#ifdef Conj_
   #define gemv0 Mjoin(Mjoin(Mjoin(Mjoin(gemvNc,NM),_x1),BNM),_y1)
#else
   #define gemv0 Mjoin(Mjoin(Mjoin(Mjoin(gemvN,NM),_x1),BNM),_y1)
#endif

static void gemvMlt4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
   #if defined(BETAX) || defined(BETA1) || defined(BETAXI0)
      register TYPE yr1, yi1;
   #endif
   #ifdef BETAXI0
      const register TYPE rbeta = *beta;
   #endif
   #ifdef BETAX
      register TYPE yr0, yi0;
      const register TYPE rbeta = *beta, ibeta = beta[1];
   #endif

   for(i=M; i; i--, A += 2, Y += 2)
   {
      #ifdef BETA0
         #ifdef Conj_
            Mjoin(PATL,dotc_sub)(N, A, lda, X, 1, Y);
         #else
            Mjoin(PATL,dotu_sub)(N, A, lda, X, 1, Y);
         #endif
      #else
         #ifdef BETAX
            yr0 = *Y;
            yi0 = Y[1];
            yr1 = yr0 * rbeta - yi0 * ibeta;
            yi1 = yr0 * ibeta + yi0 * rbeta;
         #else
            yr1 = *Y;
            yi1 = Y[1];
            #ifdef BETAXI0
               yr1 *= rbeta;
               yi1 *= rbeta;
            #endif
         #endif
         #ifdef Conj_
            Mjoin(PATL,dotc_sub)(N, A, lda, X, 1, Y);
         #else
            Mjoin(PATL,dotu_sub)(N, A, lda, X, 1, Y);
         #endif
         *Y += yr1;
         Y[1] += yi1;
      #endif
   }
}

static void gemvNlt2(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   if (N)
   {
      #if defined(BETA0)
         #ifdef Conj_
            Mjoin(PATL,moveConj)(M, X, A, 1, Y, 1);
         #else
            Mjoin(PATL,cpsc)(M, X, A, 1, Y, 1);
         #endif
      #elif defined(BETAX) || defined(BETAXI0)
         #ifdef Conj_
            Mjoin(PATL,axpbyConj)(M, X, A, 1, beta, Y, 1);
         #else
            Mjoin(PATL,axpby)(M, X, A, 1, beta, Y, 1);
         #endif
      #else
         #ifdef Conj_
            Mjoin(PATL,axpyConj)(M, X, A, 1, Y, 1);
         #else
            Mjoin(PATL,axpy)(M, X, A, 1, Y, 1);
         #endif
      #endif
   }
}

@ROUT ATL_cgemvN_4x2_1
static void gemvN4x2(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   const int M4 = (M>>2)<<2, N2 = (N>>1)<<1, nr = N-N2;
   const int incA = (lda<<2), incAm = (4 - N2*lda)<<1;
   const TYPE *A0 = A, *A1 = A + (lda<<1);
   const TYPE *x, *stX = X + (N2<<1);
   TYPE *stY = Y + (M4<<1);
   register TYPE ar00, ar10, ar20, ar30, ai00, ai10, ai20, ai30;
   register TYPE ar01, ar11, ar21, ar31, ai01, ai11, ai21, ai31;
   register TYPE yr0, yr1, yr2, yr3, yi0, yi1, yi2, yi3;
   register TYPE xr0, xi0, xr1, xi1, p0, p1;
   #ifdef ATL_AltiVec
   const int cwrd=ATL_GetCtrl(ATL_MulBySize(lda), Mmin(N,255), ATL_sizeof>>1);
   #endif


   if (N2)
   {
      if (M4)
      {
         do
         {
            #ifdef ATL_AltiVec
               ATL_pfavR(A0, cwrd, 0);
            #endif
            #ifdef BETA0
               yr0 = yi0 = yr1 = yi1 = yr2 = yi2 = yr3 = yi3 = ATL_rzero;
            #elif defined(BETAX)
               xr0 = *beta; xi0 = beta[1];
               ar00 = *Y;   ai00 = Y[1]; ar10 = Y[2]; ai10 = Y[3];
               ar20 = Y[4]; ai20 = Y[5]; ar30 = Y[6]; ai30 = Y[7];
               yr0 = ar00 * xr0 - ai00 * xi0;
               yi0 = ar00 * xi0 + ai00 * xr0;
               yr1 = ar10 * xr0 - ai10 * xi0;
               yi1 = ar10 * xi0 + ai10 * xr0;
               yr2 = ar20 * xr0 - ai20 * xi0;
               yi2 = ar20 * xi0 + ai20 * xr0;
               yr3 = ar30 * xr0 - ai30 * xi0;
               yi3 = ar30 * xi0 + ai30 * xr0;
            #else
               yr0 = *Y;   yi0 = Y[1]; yr1 = Y[2]; yi1 = Y[3];
               yr2 = Y[4]; yi2 = Y[5]; yr3 = Y[6]; yi3 = Y[7];
               #ifdef BETAXI0
                  xr0 = *beta;
                  yr0 *= xr0; yi0 *= xr0;
                  yr1 *= xr0; yi1 *= xr0;
                  yr2 *= xr0; yi2 *= xr0;
                  yr3 *= xr0; yi3 *= xr0;
               #endif
            #endif
            xr0 = *X; xi0 = X[1]; xr1 = X[2]; xi1 = X[3]; x = X + 4;
            ar00 = *A0;   ar01 = *A1;   ai00 = A0[1]; ai01 = A1[1];
            ar10 = A0[2]; ar11 = A1[2]; ai10 = A0[3]; ai11 = A1[3];
            ar20 = A0[4]; ar21 = A1[4]; ai20 = A0[5]; ai21 = A1[5];
            ar30 = A0[6]; ar31 = A1[6]; ai30 = A0[7]; ai31 = A1[7];
            A0 += incA;  A1 += incA;
            if (N2 != 2)
            {
               do
               {
                  yr0 += ar00 * xr0;
                  yi0 += ar01 * xi1;
                  yr1 += ar10 * xr0; p0 = A1[2];
                  yi1 += ar11 * xi1;
                  yr2 += ar20 * xr0; p1 = A0[2];
                  yi2 += ar21 * xi1;
                  yr3 += ar30 * xr0;
                  yi3 += ar31 * xi1;

                  yr0 += ar01 * xr1; ar01 = *A1;
                  yi0 += ar00 * xi0; ar00 = *A0;
                  yr1 += ar11 * xr1; ar11 = p0;
                  yi1 += ar10 * xi0; ar10 = p1;
                  yr2 += ar21 * xr1; ar21 = A1[4];
                  yi2 += ar20 * xi0; ar20 = A0[4];
                  yr3 += ar31 * xr1; ar31 = A1[6];
                  yi3 += ar30 * xi0; ar30 = A0[6];

                  yr0 MEQ ai00 * xi0;
                  yi0 PEQ ai01 * xr1;
                  yr1 MEQ ai10 * xi0; p0 = *x;
                  yi1 PEQ ai11 * xr1;
                  yr2 MEQ ai20 * xi0; p1 = A1[3];
                  yi2 PEQ ai21 * xr1;
                  yr3 MEQ ai30 * xi0; xi0 = x[1];
                  yi3 PEQ ai31 * xr1; xr1 = x[2];

                  yr0 MEQ ai01 * xi1; ai01 = A1[1];
                  yi0 PEQ ai00 * xr0; ai00 = A0[1];
                  yr1 MEQ ai11 * xi1; ai11 = p1;
                  yi1 PEQ ai10 * xr0; ai10 = A0[3];
                  yr2 MEQ ai21 * xi1; ai21 = A1[5];
                  yi2 PEQ ai20 * xr0; ai20 = A0[5];
                  yr3 MEQ ai31 * xi1; ai31 = A1[7]; xi1 = x[3]; A1 += incA;
                  yi3 PEQ ai30 * xr0; xr0 = p0; ai30 = A0[7]; A0 += incA; 
                  x += 4;
               }
               while (x != stX);
            }
            if (!nr)  /* 2 cols left to do, all fetching done */
            {
               yr0 += ar00 * xr0;
               yi0 += ar01 * xi1;
               yr1 += ar10 * xr0;
               yi1 += ar11 * xi1;
               yr2 += ar20 * xr0;
               yi2 += ar21 * xi1;
               yr3 += ar30 * xr0;
               yi3 += ar31 * xi1;

               yr0 += ar01 * xr1;
               yi0 += ar00 * xi0;
               yr1 += ar11 * xr1;
               yi1 += ar10 * xi0;
               yr2 += ar21 * xr1;
               yi2 += ar20 * xi0;
               yr3 += ar31 * xr1;
               yi3 += ar30 * xi0;

               yr0 MEQ ai00 * xi0;
               yi0 PEQ ai01 * xr1;
               yr1 MEQ ai10 * xi0;
               yi1 PEQ ai11 * xr1;
               yr2 MEQ ai20 * xi0;
               yi2 PEQ ai21 * xr1;
               yr3 MEQ ai30 * xi0;
               yi3 PEQ ai31 * xr1;

               yr0 MEQ ai01 * xi1;
               yi0 PEQ ai00 * xr0;
               yr1 MEQ ai11 * xi1;
               yi1 PEQ ai10 * xr0;
               yr2 MEQ ai21 * xi1;
               yi2 PEQ ai20 * xr0;
               yr3 MEQ ai31 * xi1;
               yi3 PEQ ai30 * xr0;
            }
            else  /* 3 cols left, 2 already fetched */
            {
               yr0 += ar00 * xr0;
               yi0 += ar01 * xi1;
               yr1 += ar10 * xr0; p0 = A0[2];
               yi1 += ar11 * xi1;
               yr2 += ar20 * xr0; p1 = A0[6];
               yi2 += ar21 * xi1;
               yr3 += ar30 * xr0;
               yi3 += ar31 * xi1;

               yr0 += ar01 * xr1;
               yi0 += ar00 * xi0; ar00 = *A0;
               yr1 += ar11 * xr1;
               yi1 += ar10 * xi0; ar10 = p0;
               yr2 += ar21 * xr1;
               yi2 += ar20 * xi0; ar20 = A0[4];
               yr3 += ar31 * xr1;
               yi3 += ar30 * xi0; ar30 = p1;

               yr0 MEQ ai00 * xi0;
               yi0 PEQ ai01 * xr1;
               yr1 MEQ ai10 * xi0; p0 = *x;
               yi1 PEQ ai11 * xr1;
               yr2 MEQ ai20 * xi0;
               yi2 PEQ ai21 * xr1;
               yr3 MEQ ai30 * xi0; xi0 = x[1];
               yi3 PEQ ai31 * xr1;

               yr0 MEQ ai01 * xi1;
               yi0 PEQ ai00 * xr0; ai00 = A0[1];
               yr1 MEQ ai11 * xi1;
               yi1 PEQ ai10 * xr0; ai10 = A0[3];
               yr2 MEQ ai21 * xi1;
               yi2 PEQ ai20 * xr0; ai20 = A0[5];
               yr3 MEQ ai31 * xi1;
               yi3 PEQ ai30 * xr0; xr0 = p0; ai30 = A0[7];

               yr0 += ar00 * xr0;
               yi0 += ar00 * xi0;
               yr1 += ar10 * xr0;
               yi1 += ar10 * xi0;
               yr2 += ar20 * xr0;
               yi2 += ar20 * xi0;
               yr3 += ar30 * xr0;
               yi3 += ar30 * xi0;

               yr0 MEQ ai00 * xi0;
               yi0 PEQ ai00 * xr0;
               yr1 MEQ ai10 * xi0;
               yi1 PEQ ai10 * xr0;
               yr2 MEQ ai20 * xi0;
               yi2 PEQ ai20 * xr0;
               yr3 MEQ ai30 * xi0;
               yi3 PEQ ai30 * xr0;
            }
            *Y   = yr0;
            Y[1] = yi0;
            A0 += incAm;
            Y[2] = yr1;
            Y[3] = yi1;
            A1 += incAm;
            Y[4] = yr2;
            Y[5] = yi2;
            Y[6] = yr3;
            Y[7] = yi3;
            Y += 8;
         }
         while(Y != stY);
      }
      if (M-M4) gemvMlt4(M-M4, N, A0, lda, X, beta, Y);
   }
   else if (N && M) gemvNlt2(M, N, A, lda, X, beta, Y);
}
@ROUT ATL_cgemvN_4x2_1 ATL_cgemvN_2x2_0 ATL_cgemvN_1x1_1 ATL_cgemvN_1x1_1a
void Mjoin(PATL,gemv0)
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
@ROUT ATL_cgemvN_1x1_1a
   int j;
   const int lda2 = lda<<1, N2 = N<<1;

   #ifdef Conj_
      #define axpycj Mjoin(PATL,axpyConj)
      Mjoin(PATL,axpbyConj)(M, X, A, 1, beta, Y, 1);
   #else
      #define axpycj Mjoin(PATL,axpy)
      Mjoin(PATL,axpby)(M, X, A, 1, beta, Y, 1);
   #endif
   if (N != 1)
   {
      A += lda2;
      X += 2;
      for (j=N-1; j; j--, A += lda2, X += 2) axpycj(M, X, A, 1, Y, 1);
   }
}
@ROUT ATL_cgemvN_1x1_1
   int i, j;
   const int M2 = M<<1, N2 = N<<1;
   #if defined(BETAX) || defined(BETAXI0)
      const TYPE rbeta = *beta, ibeta = beta[1];
   #endif
   register TYPE ra, ia, rx, ix, ry, iy;

   for (i=0; i != M2; i += 2)
   {
      #ifdef BETA0
         ry = iy = ATL_rzero;
      #elif defined(BETAX)
         rx = rbeta; ix = ibeta;
         ra = Y[i]; ia = Y[i+1];
         ry = ra * rx - ia * ix;
         iy = ra * ix + ia * rx;
      #else
         ry = Y[i];
         iy = Y[i+1];
         #ifdef BETAXI0
            rx = rbeta;
            ry *= rx;
            iy *= rx;
         #endif
      #endif
      for(j=0; j != N2; j += 2)
      {
         ra = A[i+j*lda]; ia = A[i+j*lda+1];
         rx = X[j]; ix = X[j+1];
         ry += ra * rx;
         iy += ra * ix;
         ry MEQ ia * ix;
         iy PEQ ia * rx;
      }
      Y[i] = ry;
      Y[i+1] = iy;
   }
}
@ROUT ATL_cgemvN_4x2_1
   gemvN4x2(M, N, A, lda, X, beta, Y);
@ROUT ATL_cgemvN_2x2_0
   const int N2 = (N>>1)<<1, M2 = (M>>1)<<1, nr = N-N2; 
   const int incA = lda<<2, incAm = 4 - N2 * (lda<<1);
   const TYPE *x, *stX = X + (N2<<1), *A0 = A, *A1 = A + (lda<<1);
   TYPE *stY = Y + (M2<<1);
   register TYPE xr0, xi0, xr1, xi1, yr0, yi0, yr1, yi1, yyr0, yyi0, yyr1, yyi1;
   register TYPE ar00, ai00, ar10, ai10, ar01, ai01, ar11, ai11;
   register TYPE m0, m1, m2, m3;

   if (N2)
   {
      if (M2)
      {
         do
         {
            #ifdef BETA0
               yr0 = yi0 = yr1 = yi1 = yyr0 = yyi0 = yyr1 = yyi1 = ATL_rzero;
            #elif defined(BETAX)
               xr0 = *beta; xi0 = beta[1];
               ar00 = *Y; ai00 = Y[1]; ar10 = Y[2]; ai10 = Y[3];
               yyr0 = ar00 * xr0 - ai00 * xi0;
               yyi0 = ar00 * xi0 + ai00 * xr0;
               yyr1 = ar10 * xr0 - ai10 * xi0;
               yyi1 = ar10 * xi0 + ai10 * xr0;
               yr0 = yi0 = yr1 = yi1 = ATL_rzero;
            #else
               yyr0 = *Y; yyi0 = Y[1]; yyr1 = Y[2]; yyi1 = Y[3];
               yr0 = yi0 = yr1 = yi1 = ATL_rzero;
               #ifdef BETAXI0
                 xr0 = *beta;
                 yyr0 *= xr0; yyi0 *= xr0;
                 yyr1 *= xr0; yyi1 *= xr0;
               #endif
            #endif
            x = X + 4;
            ar00 = *A0; ai00 = A0[1]; ar10 = A0[2]; ai10 = A0[3]; A0 += incA;
            xr0 = *X; xi0 = X[1]; xr1 = X[2]; xi1 = X[3];
            ar01 = *A1; ai01 = A1[1]; ar11 = A1[2]; ai11 = A1[3]; A1 += incA;
            m0 = ar00 * xr0;
            m1 = ar01 * xr1;
            m2 = ar00 * xi0;
            m3 = ar01 * xi1;
            if (N2 != 2)
            {
               do
               {
                  ar00 = *A0; ar01 = *A1;
                  yr0  += m0; m0 = ai00 * xi0;
                  yyr0 += m1; m1 = ai01 * xi1;
                  yi0  += m2; m2 = ai00 * xr0; ai00 = A0[1];
                  yyi0 += m3; m3 = ai01 * xr1; ai01 = A1[1];
                  #ifndef Conj_
                     yr0  -= m0; m0 = ar10 * xr0;
                     yyr0 -= m1; m1 = ar11 * xr1;
                     yi0  += m2; m2 = ar10 * xi0; ar10 = A0[2];
                     yyi0 += m3; m3 = ar11 * xi1; ar11 = A1[2];
                  #else
                     yr0  += m0; m0 = ar10 * xr0;
                     yyr0 += m1; m1 = ar11 * xr1;
                     yi0  -= m2; m2 = ar10 * xi0; ar10 = A0[2];
                     yyi0 -= m3; m3 = ar11 * xi1; ar11 = A1[2];
                  #endif

                  yr1  += m0; m0 = ai10 * xi0; xi0 = x[1];
                  yyr1 += m1; m1 = ai11 * xi1; xi1 = x[3];
                  yi1  += m2; m2 = ai10 * xr0; xr0 = *x; 
                              ai10 = A0[3]; A0 += incA;
                  yyi1 += m3; m3 = ai11 * xr1; xr1 = x[2]; x += 4;
                              ai11 = A1[3]; A1 += incA;
                  #ifndef Conj_
                     yr1  -= m0; m0 = ar00 * xr0;
                     yyr1 -= m1; m1 = ar01 * xr1;
                     yi1  += m2; m2 = ar00 * xi0;
                     yyi1 += m3; m3 = ar01 * xi1;
                  #else
                     yr1  += m0; m0 = ar00 * xr0;
                     yyr1 += m1; m1 = ar01 * xr1;
                     yi1  -= m2; m2 = ar00 * xi0;
                     yyi1 -= m3; m3 = ar01 * xi1;
                  #endif
               }
               while (x != stX);
            }
            if (!nr)  /* drain pipe, no cleanup needed */
            {
               yr0  += m0; m0 = ai00 * xi0;
               yyr0 += m1; m1 = ai01 * xi1;
               yi0  += m2; m2 = ai00 * xr0;
               yyi0 += m3; m3 = ai01 * xr1;
               #ifndef Conj_
                  yr0  -= m0; m0 = ar10 * xr0;
                  yyr0 -= m1; m1 = ar11 * xr1;
                  yi0  += m2; m2 = ar10 * xi0;
                  yyi0 += m3; m3 = ar11 * xi1;
               #else
                  yr0  += m0; m0 = ar10 * xr0;
                  yyr0 += m1; m1 = ar11 * xr1;
                  yi0  -= m2; m2 = ar10 * xi0;
                  yyi0 -= m3; m3 = ar11 * xi1;
               #endif

               yr1  += m0; m0 = ai10 * xi0;
               yyr1 += m1; m1 = ai11 * xi1;
               yi1  += m2; m2 = ai10 * xr0;
               yyi1 += m3; m3 = ai11 * xr1;
               #ifndef Conj_
                  yr1  -= m0;
                  yyr1 -= m1;
                  yi1  += m2;
                  yyi1 += m3;
               #else
                  yr1  += m0;
                  yyr1 += m1;
                  yi1  -= m2;
                  yyi1 -= m3;
               #endif
            }
            else  /* drain pipe, and do 1 extra elt of X */
            {
               ar00 = *A0;
               yr0  += m0; m0 = ai00 * xi0;
               yyr0 += m1; m1 = ai01 * xi1;
               yi0  += m2; m2 = ai00 * xr0; ai00 = A0[1];
               yyi0 += m3; m3 = ai01 * xr1;
               #ifndef Conj_
                  yr0  -= m0; m0 = ar10 * xr0;
                  yyr0 -= m1; m1 = ar11 * xr1;
                  yi0  += m2; m2 = ar10 * xi0; ar10 = A0[2];
                  yyi0 += m3; m3 = ar11 * xi1;
               #else
                  yr0  += m0; m0 = ar10 * xr0;
                  yyr0 += m1; m1 = ar11 * xr1;
                  yi0  -= m2; m2 = ar10 * xi0; ar10 = A0[2];
                  yyi0 -= m3; m3 = ar11 * xi1;
               #endif

               yr1  += m0; m0 = ai10 * xi0; xi0 = x[1];
               yyr1 += m1; m1 = ai11 * xi1;
               yi1  += m2; m2 = ai10 * xr0; xr0 = *x; ai10 = A0[3];
               yyi1 += m3; m3 = ai11 * xr1;
               #ifndef Conj_
                  yr1  -= m0; m0 = ar00 * xr0;
                  yyr1 -= m1; m1 = ar00 * xi0;
                  yi1  += m2; m2 = ar10 * xr0;
                  yyi1 += m3; m3 = ar10 * xi0;
               #else
                  yr1  += m0; m0 = ar00 * xr0;
                  yyr1 += m1; m1 = ar00 * xi0;
                  yi1  -= m2; m2 = ar10 * xr0;
                  yyi1 -= m3; m3 = ar10 * xi0;
               #endif

               yr0 += m0; m0 = ai00 * xi0;
               yi0 += m1; m1 = ai00 * xr0;
               yr1 += m2; m2 = ai10 * xi0;
               yi1 += m3; m3 = ai10 * xr0;
               #ifndef Conj_
                  yr0 -= m0;
                  yi0 += m1;
                  yr1 -= m2;
                  yi1 += m3;
               #else
                  yr0 += m0;
                  yi0 -= m1;
                  yr1 += m2;
                  yi1 -= m3;
               #endif
            }
            A0 += incAm;
            A1 += incAm;
            yr0 += yyr0;
            yi0 += yyi0;
            yr1 += yyr1;
            yi1 += yyi1;
            *Y = yr0;
            Y[1] = yi0;
            Y[2] = yr1;
            Y[3] = yi1;
            Y += 4;
         }
         while(Y != stY);
      }
      if (M-M2) gemvMlt4(M-M2, N, A0, lda, X, beta, Y);
   }
   else gemvNlt2(M, N, A, lda, X, beta, Y);
@ROUT ATL_cgemvN_4x2_1 ATL_cgemvN_2x2_0
@beginskip
   TYPE *stY = Y + (M<<1);
   TYPE dot[2];
   const register TYPE rbeta = *beta, ibeta = beta[1];
   register TYPE ry, iy, t0;
   if (M)
   {
         do
         {
            t0 = ry = *Y;
            iy = Y[1];
            ry = ry * rbeta - iy * ibeta;
            iy = t0 * ibeta + iy * rbeta;
            Mjoin(PATL,dotu_sub)(N, X, 1, A, lda, dot);
            ry += *dot;
            iy += dot[1];
            *Y = ry;
            Y[1] = iy;
            Y += 2;
            A += 2;
         }
         while (Y != stY);
   }
@endskip
}

@ROUT ATL_gemvN_4x4_1 ATL_gemvN_4x2_0 ATL_gemvN_mm ATL_gemvN_8x32_2 @\
      ATL_gemvN_8x4_1 ATL_gemvN_16x2_1 ATL_gemvN_16x4_1 ATL_gemvN_32x4_1 @\
      ATL_gemvN_1x1_1 ATL_gemvN_1x1_1a ATL_gpmvN_32x4_1 ATL_gpmvN_1x1_1a
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_lvl2.h"
@ROUT ATL_gemvN_8x4_1 `#include "atlas_prefetch.h"`
@ROUT ATL_gemvN_mm `#include "atlas_lvl3.h"`

@ROUT ATL_gpmvN_32x4_1 ATL_gpmvN_1x1_1a
#ifdef TREAL
   #ifdef Lower_
      #define MpIncInc(inc_) (inc_)--
   #else
      #define MpIncInc(inc_) (inc_)++
   #endif
#else
   #ifdef Lower_
      #define MpIncInc(inc_) (inc_) -= 2;
   #else
      #define MpIncInc(inc_) (inc_) += 2;
   #endif
#endif
@ROUT ATL_gemvN_8x32_2
#define Yass(y_) (y_) += 
@beginskip
#ifdef BETA0
   #define Yass(y_) (y_) = 
#elif defined(BETAX)
   #define Yass(y_) (y_) = (y_)*beta +
#else
   #define Yass(y_) (y_) += 
#endif
@endskip

#ifdef BETA1
static void gemv8x32(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * Try to let compiler do all the work
 */
{
   const TYPE *A0=A, *A1=A+lda, *A2=A1+lda, *A3=A2+lda;
   const TYPE *A4=A3+lda, *A5=A4+lda, *A6=A5+lda, *A7=A6+lda;
   const TYPE *A8=A7+lda, *A9=A8+lda, *A10=A9+lda, *A11=A10+lda;
   const TYPE *A12=A11+lda, *A13=A12+lda, *A14=A13+lda, *A15=A14+lda;
   const TYPE *A16=A15+lda, *A17=A16+lda, *A18=A17+lda, *A19=A18+lda;
   const TYPE *A20=A19+lda, *A21=A20+lda, *A22=A21+lda, *A23=A22+lda;
   const TYPE *A24=A23+lda, *A25=A24+lda, *A26=A25+lda, *A27=A26+lda;
   const TYPE *A28=A27+lda, *A29=A28+lda, *A30=A29+lda, *A31=A30+lda;
   const TYPE x0=*X, x1=X[1], x2=X[2], x3=X[3];
   const TYPE x4=X[4], x5=X[5], x6=X[6], x7=X[7];
   const TYPE x8=X[8], x9=X[9], x10=X[10], x11=X[11];
   const TYPE x12=X[12], x13=X[13], x14=X[14], x15=X[15];
   const TYPE x16=X[16], x17=X[17], x18=X[18], x19=X[19];
   const TYPE x20=X[20], x21=X[21], x22=X[22], x23=X[23];
   const TYPE x24=X[24], x25=X[25], x26=X[26], x27=X[27];
   const TYPE x28=X[28], x29=X[29], x30=X[30], x31=X[31];
   TYPE *stY = Y + ((M>>3)<<3);

   ATL_assert(M >= 8 && (N == 32));
   do
   {
      Yass(*Y) *A0 * x0 + *A1 * x1 + *A2 * x2 + *A3 * x3 +
               *A4 * x4 + *A5 * x5 + *A6 * x6 + *A7 * x7 +
               *A8 * x8 + *A9 * x9 + *A10 * x10 + *A11 * x11 +
               *A12 * x12 + *A13 * x13 + *A14 * x14 + *A15 * x15 +
               *A16 * x16 + *A17 * x17 + *A18 * x18 + *A19 * x19 +
               *A20 * x20 + *A21 * x21 + *A22 * x22 + *A23 * x23 +
               *A24 * x24 + *A25 * x25 + *A26 * x26 + *A27 * x27 +
               *A28 * x28 + *A29 * x29 + *A30 * x30 + *A31 * x31;
   @whiledef r 7 6 5 4 3 2 1
      Yass(Y[@(r)]) A0[@(r)]*x0 + A1[@(r)]*x1 + A2[@(r)]*x2 + A3[@(r)]*x3 +
                 A4[@(r)]*x4 + A5[@(r)]*x5 + A6[@(r)]*x6 + A7[@(r)]*x7 +
                 A8[@(r)]*x8 + A9[@(r)]*x9 + A10[@(r)]*x10 + A11[@(r)]*x11 +
                 A12[@(r)]*x12 + A13[@(r)]*x13 + A14[@(r)]*x14 + A15[@(r)]*x15 +
                 A16[@(r)]*x16 + A17[@(r)]*x17 + A18[@(r)]*x18 + A19[@(r)]*x19 +
                 A20[@(r)]*x20 + A21[@(r)]*x21 + A22[@(r)]*x22 + A23[@(r)]*x23 +
                 A24[@(r)]*x24 + A25[@(r)]*x25 + A26[@(r)]*x26 + A27[@(r)]*x27 +
                 A28[@(r)]*x28 + A29[@(r)]*x29 + A30[@(r)]*x30 + A31[@(r)]*x31;
   @endwhile
   @multidef col 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
   @whiledef col 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
      A@(col) += 8;
   @endwhile
      Y += 8;
   }
   while (Y != stY);
}
static void gemv1x32(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * Try to let compiler do all the work
 */
{
   const TYPE *A0=A, *A1=A+lda, *A2=A1+lda, *A3=A2+lda;
   const TYPE *A4=A3+lda, *A5=A4+lda, *A6=A5+lda, *A7=A6+lda;
   const TYPE *A8=A7+lda, *A9=A8+lda, *A10=A9+lda, *A11=A10+lda;
   const TYPE *A12=A11+lda, *A13=A12+lda, *A14=A13+lda, *A15=A14+lda;
   const TYPE *A16=A15+lda, *A17=A16+lda, *A18=A17+lda, *A19=A18+lda;
   const TYPE *A20=A19+lda, *A21=A20+lda, *A22=A21+lda, *A23=A22+lda;
   const TYPE *A24=A23+lda, *A25=A24+lda, *A26=A25+lda, *A27=A26+lda;
   const TYPE *A28=A27+lda, *A29=A28+lda, *A30=A29+lda, *A31=A30+lda;
   const TYPE x0=*X, x1=X[1], x2=X[2], x3=X[3];
   const TYPE x4=X[4], x5=X[5], x6=X[6], x7=X[7];
   const TYPE x8=X[8], x9=X[9], x10=X[10], x11=X[11];
   const TYPE x12=X[12], x13=X[13], x14=X[14], x15=X[15];
   const TYPE x16=X[16], x17=X[17], x18=X[18], x19=X[19];
   const TYPE x20=X[20], x21=X[21], x22=X[22], x23=X[23];
   const TYPE x24=X[24], x25=X[25], x26=X[26], x27=X[27];
   const TYPE x28=X[28], x29=X[29], x30=X[30], x31=X[31];
   TYPE *stY = Y + M;

   ATL_assert(N == 32);
   do
   {
      Yass(*Y) *A0 * x0 + *A1 * x1 + *A2 * x2 + *A3 * x3 +
               *A4 * x4 + *A5 * x5 + *A6 * x6 + *A7 * x7 +
               *A8 * x8 + *A9 * x9 + *A10 * x10 + *A11 * x11 +
               *A12 * x12 + *A13 * x13 + *A14 * x14 + *A15 * x15 +
               *A16 * x16 + *A17 * x17 + *A18 * x18 + *A19 * x19 +
               *A20 * x20 + *A21 * x21 + *A22 * x22 + *A23 * x23 +
               *A24 * x24 + *A25 * x25 + *A26 * x26 + *A27 * x27 +
               *A28 * x28 + *A29 * x29 + *A30 * x30 + *A31 * x31;
      Y++;
   @multidef col 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
   @whiledef col 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
      A@(col)++;
   @endwhile
   }
   while (Y != stY);
}
static void gemv8x16(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * Try to let compiler do all the work
 */
{
   const TYPE *A0=A, *A1=A+lda, *A2=A1+lda, *A3=A2+lda;
   const TYPE *A4=A3+lda, *A5=A4+lda, *A6=A5+lda, *A7=A6+lda;
   const TYPE *A8=A7+lda, *A9=A8+lda, *A10=A9+lda, *A11=A10+lda;
   const TYPE *A12=A11+lda, *A13=A12+lda, *A14=A13+lda, *A15=A14+lda;
   const TYPE x0=*X, x1=X[1], x2=X[2], x3=X[3];
   const TYPE x4=X[4], x5=X[5], x6=X[6], x7=X[7];
   const TYPE x8=X[8], x9=X[9], x10=X[10], x11=X[11];
   const TYPE x12=X[12], x13=X[13], x14=X[14], x15=X[15];
   TYPE *stY = Y + ((M>>3)<<3);

   ATL_assert(M >= 8 && (N == 16));
   do
   {
      Yass(*Y) *A0 * x0 + *A1 * x1 + *A2 * x2 + *A3 * x3 +
               *A4 * x4 + *A5 * x5 + *A6 * x6 + *A7 * x7 +
               *A8 * x8 + *A9 * x9 + *A10 * x10 + *A11 * x11 +
               *A12 * x12 + *A13 * x13 + *A14 * x14 + *A15 * x15;
   @whiledef r 7 6 5 4 3 2 1
      Yass(Y[@(r)]) A0[@(r)]*x0 + A1[@(r)]*x1 + A2[@(r)]*x2 + A3[@(r)]*x3 +
                 A4[@(r)]*x4 + A5[@(r)]*x5 + A6[@(r)]*x6 + A7[@(r)]*x7 +
                 A8[@(r)]*x8 + A9[@(r)]*x9 + A10[@(r)]*x10 + A11[@(r)]*x11 +
                 A12[@(r)]*x12 + A13[@(r)]*x13 + A14[@(r)]*x14 + A15[@(r)]*x15;
   @endwhile
   @whiledef col 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
      A@(col) += 8;
   @endwhile
      Y += 8;
   }
   while (Y != stY);
}
static void gemv8x8(const int M, const int N, const TYPE *A, const int lda,
                    const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * Try to let compiler do all the work
 */
{
   const TYPE *A0=A, *A1=A+lda, *A2=A1+lda, *A3=A2+lda;
   const TYPE *A4=A3+lda, *A5=A4+lda, *A6=A5+lda, *A7=A6+lda;
   const TYPE x0=*X, x1=X[1], x2=X[2], x3=X[3];
   const TYPE x4=X[4], x5=X[5], x6=X[6], x7=X[7];
   TYPE *stY = Y + ((M>>3)<<3);

   ATL_assert(M >= 8 && (N == 8));
   do
   {
      Yass(*Y) *A0 * x0 + *A1 * x1 + *A2 * x2 + *A3 * x3 +
               *A4 * x4 + *A5 * x5 + *A6 * x6 + *A7 * x7;
   @whiledef r 7 6 5 4 3 2 1
      Yass(Y[@(r)]) A0[@(r)]*x0 + A1[@(r)]*x1 + A2[@(r)]*x2 + A3[@(r)]*x3 +
                 A4[@(r)]*x4 + A5[@(r)]*x5 + A6[@(r)]*x6 + A7[@(r)]*x7;
   @endwhile
   @whiledef col 7  6  5  4  3  2  1  0
      A@(col) += 8;
   @endwhile
      Y += 8;
   }
   while (Y != stY);
}

static void gemv8x4(const int M, const int N, const TYPE *A, const int lda,
                    const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * Try to let compiler do all the work
 */
{
   const TYPE *A0=A, *A1=A+lda, *A2=A1+lda, *A3=A2+lda;
   const TYPE x0=*X, x1=X[1], x2=X[2], x3=X[3];
   TYPE *stY = Y + ((M>>3)<<3);

   ATL_assert(M >= 8 && (N == 4));
   do
   {
      Yass(*Y) *A0 * x0 + *A1 * x1 + *A2 * x2 + *A3 * x3;
   @whiledef r 7 6 5 4 3 2 1
      Yass(Y[@(r)]) A0[@(r)]*x0 + A1[@(r)]*x1 + A2[@(r)]*x2 + A3[@(r)]*x3;
   @endwhile
   @whiledef col 3  2  1  0
      A@(col) += 8;
   @endwhile
      Y += 8;
   }
   while (Y != stY);
}

static void gemv1x1(const int M, const int N, const TYPE *A, const int lda,
                    const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
   for (i=0; i < M; i++) Y[i] += Mjoin(PATL,dot)(N, X, 1, A+i, lda);
}
#endif

static void gemv(const int M, const int N, const TYPE *A, const int lda,
                 const TYPE *X, const SCALAR beta, TYPE *Y)
{
#ifdef BETA0
   Mjoin(PATL,zero)(M, Y, 1);
   Mjoin(PATL,gemvN_a1_x1_b1_y1)(M, N, A, lda, X, beta, Y);
#elif defined(BETAX)
   Mjoin(PATL,scal)(M, beta, Y, 1);
   Mjoin(PATL,gemvN_a1_x1_b1_y1)(M, N, A, lda, X, beta, Y);
#else
   int i, n;
   const int n32 = N>>5, M8 = (M>>3)<<3, mr = M-M8, incA = lda<<5;

   #ifndef BETA1
      ATL_assert(beta == ATL_rone);
   #endif
   for (i=n32; i; i--)
   {
      if (M8) gemv8x32(M8, 32, A, lda, X, beta, Y);
      if (mr) gemv1x32(mr, 32, A+M8, lda, X, beta, Y+M8);
      A += incA;
      X += 32;
   }
   n = N - (n32<<5);
   if (n >= 16)
   {
      n -= 16;
      if (M8) gemv8x16(M8, 16, A, lda, X, beta, Y);
      if (mr) gemv1x1(mr, 16, A+M8, lda, X, beta, Y+M8);
      A += incA>>1;
      X += 16;
   }
   if (n >= 8)
   {
      n -= 8;
      if (M8) gemv8x8(M8, 8, A, lda, X, beta, Y);
      if (mr) gemv1x1(mr, 8, A+M8, lda, X, beta, Y+M8);
      A += incA>>2;
      X += 8;
   }
   if (n >= 4)
   {
      n -= 4;
      if (M8) gemv8x4(M8, 4, A, lda, X, beta, Y);
      if (mr) gemv1x1(mr, 4, A+M8, lda, X, beta, Y+M8);
      A += incA>>3;
      X += 4;
   }
   if (n) gemv1x1(M, n, A, lda, X, beta, Y);
#endif
}

@ROUT ATL_gemvN_8x4_1 ATL_gemvN_4x4_1 ATL_gemvN_16x2_1 ATL_gemvN_16x4_1 @\
      ATL_gemvN_32x4_1 ATL_gemvN_4x2_0 ATL_gpmvN_32x4_1
@ROUT @push

static void gemvMlt8(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y);
static void gemvNle4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y);
#ifdef BETA0
   #define Yget(y_, yp_, bet_) (y_) = ATL_rzero
#elif defined BETAX
   #define Yget(y_, yp_, bet_) (y_) = (yp_) * (bet_)
#else
   #define Yget(y_, yp_, bet_) (y_) = (yp_)
#endif
static void gemvN32x4(const int M, const int N, const TYPE *A, const int lda,
                      const TYPE *x, const SCALAR beta0, TYPE *y)
/*
 * rank-4 daxpy based NoTrans gemv
 */
{
   const int M16 = (M>>4)<<4;
   TYPE *stY = y + M16 - 32;
@ROUT - ATL_gpmvN_32x4_1
   const TYPE *A0 = A, *A1 = A+lda, *A2 = A1 + lda, *A3 = A2 + lda;
@ROUT ATL_gpmvN_32x4_1
   #ifdef Upper_
      const TYPE *A0 = A, *A1 = A+lda, *A2 = A1 + lda+1, *A3 = A2 + lda+2;
   #else
      const TYPE *A0 = A, *A1 = A+lda, *A2 = A1 + lda-1, *A3 = A2 + lda-2;
   #endif
@ROUT @peek
   register TYPE z0, z1, z2, z3, z4, z5, z6, z7;
   register TYPE y0, y1, y2, y3, y4, y5, y6, y7;
   const register TYPE x0 = *x, x1 = x[1], x2 = x[2], x3 = x[3];
   #ifdef BETAX
      const register TYPE beta = beta0;
   #else
      #define beta beta0
   #endif

   ATL_assert(N == 4);
   if (M16 >= 32)
   {
      #ifdef BETA0
         y0 = y1 = y2 = y3 = y4 = y5 = y6 = y7 = ATL_rzero;
      #else
         y0 = *y;   y1 = y[1]; y2 = y[2]; y3 = y[3]; 
         y4 = y[4]; y5 = y[5]; y6 = y[6]; y7 = y[7]; 
         #ifdef BETAX
            y0 *= beta; y1 *= beta; y2 *= beta; y3 *= beta;
            y4 *= beta; y5 *= beta; y6 *= beta; y7 *= beta;
         #endif
      #endif
      y0 += x0 * *A0;   Yget(z0, y[8], beta);   
      y1 += x1 * A1[1];
      y2 += x2 * A2[2]; Yget(z1, y[9], beta);
      y3 += x3 * A3[3];
      y4 += x0 * A0[4]; Yget(z2, y[10], beta);
      y5 += x1 * A1[5];
      y6 += x2 * A2[6]; Yget(z3, y[11], beta);
      y7 += x3 * A3[7];

      y0 += x1 * *A1;   Yget(z4, y[12], beta);
      y1 += x2 * A2[1];
      y2 += x3 * A3[2]; Yget(z5, y[13], beta);
      y3 += x0 * A0[3];
      y4 += x1 * A1[4]; Yget(z6, y[14], beta);
      y5 += x2 * A2[5];
      y6 += x3 * A3[6]; Yget(z7, y[15], beta);
      y7 += x0 * A0[7];

      y0 += x2 * *A2;
      y1 += x3 * A3[1];
      y2 += x0 * A0[2];
      y3 += x1 * A1[3];
      y4 += x2 * A2[4];
      y5 += x3 * A3[5];
      y6 += x0 * A0[6];
      y7 += x1 * A1[7];

      y0 += x3 * *A3; 
      y1 += x0 * A0[1];
      y2 += x1 * A1[2];
      y3 += x2 * A2[3];
      y4 += x3 * A3[4];
      y5 += x0 * A0[5];
      y6 += x1 * A1[6];
      y7 += x2 * A2[7];

      z0 += x0 * A0[8]; *y = y0;
      z1 += x1 * A1[9]; 
      z2 += x2 * A2[10]; y[1] = y1;
      z3 += x3 * A3[11];
      z4 += x0 * A0[12]; y[2] = y2;
      z5 += x1 * A1[13];
      z6 += x2 * A2[14]; y[3] = y3;
      z7 += x3 * A3[15];

      z0 += x1 * A1[8]; y[4] = y4;
      z1 += x2 * A2[9];
      z2 += x3 * A3[10]; y[5] = y5;
      z3 += x0 * A0[11];
      z4 += x1 * A1[12]; y[6] = y6;
      z5 += x2 * A2[13];
      z6 += x3 * A3[14]; y[7] = y7;
      z7 += x0 * A0[15];

      z0 += x2 * A2[8];  Yget(y0, y[16], beta);
      z1 += x3 * A3[ 9];
      z2 += x0 * A0[10]; Yget(y1, y[17], beta);
      z3 += x1 * A1[11];
      z4 += x2 * A2[12]; Yget(y2, y[18], beta);
      z5 += x3 * A3[13];
      z6 += x0 * A0[14]; Yget(y3, y[19], beta);
      z7 += x1 * A1[15];

      z0 += x3 * A3[8];  Yget(y4, y[20], beta);
      z1 += x0 * A0[9];
      z2 += x1 * A1[10]; Yget(y5, y[21], beta);
      z3 += x2 * A2[11];
      z4 += x3 * A3[12]; Yget(y6, y[22], beta); A3 += 16;
      z5 += x0 * A0[13];                        A0 += 16;
      z6 += x1 * A1[14]; Yget(y7, y[23], beta); A1 += 16;
      z7 += x2 * A2[15];                        A2 += 16;
      if (M16 != 32)
      {
         do
         {
            y0 += x0 * *A0;   y[8] = z0;
            y1 += x1 * A1[1];
            y2 += x2 * A2[2]; y[9] = z1;
            y3 += x3 * A3[3];
            y4 += x0 * A0[4]; y[10] = z2;
            y5 += x1 * A1[5];
            y6 += x2 * A2[6]; y[11] = z3;
            y7 += x3 * A3[7];
   
            y0 += x1 * *A1;   y[12] = z4;
            y1 += x2 * A2[1];
            y2 += x3 * A3[2]; y[13] = z5;
            y3 += x0 * A0[3];
            y4 += x1 * A1[4]; y[14] = z6;
            y5 += x2 * A2[5];
            y6 += x3 * A3[6]; y[15] = z7; y += 16;
            y7 += x0 * A0[7];
   
            y0 += x2 * *A2;   Yget(z0, y[8], beta);
            y1 += x3 * A3[1];
            y2 += x0 * A0[2]; Yget(z1, y[9], beta);
            y3 += x1 * A1[3];
            y4 += x2 * A2[4]; Yget(z2, y[10], beta);
            y5 += x3 * A3[5];
            y6 += x0 * A0[6]; Yget(z3, y[11], beta);
            y7 += x1 * A1[7];
   
            y0 += x3 * *A3;   Yget(z4, y[12], beta);
            y1 += x0 * A0[1];
            y2 += x1 * A1[2]; Yget(z5, y[13], beta);
            y3 += x2 * A2[3];
            y4 += x3 * A3[4]; Yget(z6, y[14], beta);
            y5 += x0 * A0[5];
            y6 += x1 * A1[6]; Yget(z7, y[15], beta);
            y7 += x2 * A2[7];
   
            z0 += x0 * A0[8];  *y = y0;
            z1 += x1 * A1[9];
            z2 += x2 * A2[10]; y[1] = y1;
            z3 += x3 * A3[11];
            z4 += x0 * A0[12]; y[2] = y2;
            z5 += x1 * A1[13];
            z6 += x2 * A2[14]; y[3] = y3;
            z7 += x3 * A3[15];
   
            z0 += x1 * A1[8]; y[4] = y4;
            z1 += x2 * A2[9];
            z2 += x3 * A3[10]; y[5] = y5;
            z3 += x0 * A0[11];
            z4 += x1 * A1[12]; y[6] = y6;
            z5 += x2 * A2[13];
            z6 += x3 * A3[14]; y[7] = y7;
            z7 += x0 * A0[15];
   
            z0 += x2 * A2[8];  Yget(y0, y[16], beta);
            z1 += x3 * A3[ 9];
            z2 += x0 * A0[10]; Yget(y1, y[17], beta);
            z3 += x1 * A1[11];
            z4 += x2 * A2[12]; Yget(y2, y[18], beta);
            z5 += x3 * A3[13];
            z6 += x0 * A0[14]; Yget(y3, y[19], beta);
            z7 += x1 * A1[15];
   
            z0 += x3 * A3[8];  Yget(y4, y[20], beta);
            z1 += x0 * A0[9];
            z2 += x1 * A1[10]; Yget(y5, y[21], beta);
            z3 += x2 * A2[11];
            z4 += x3 * A3[12]; Yget(y6, y[22], beta);  A3 += 16;
            z5 += x0 * A0[13];                         A0 += 16;
            z6 += x1 * A1[14]; Yget(y7, y[23], beta);  A1 += 16;
            z7 += x2 * A2[15];                         A2 += 16;
         }
         while (y != stY);
      }
      y0 += x0 * *A0;   y[8] = z0;
      y1 += x1 * A1[1];
      y2 += x2 * A2[2]; y[9] = z1;
      y3 += x3 * A3[3];
      y4 += x0 * A0[4]; y[10] = z2;
      y5 += x1 * A1[5];
      y6 += x2 * A2[6]; y[11] = z3;
      y7 += x3 * A3[7];

      y0 += x1 * *A1;   y[12] = z4;
      y1 += x2 * A2[1];
      y2 += x3 * A3[2]; y[13] = z5;
      y3 += x0 * A0[3];
      y4 += x1 * A1[4]; y[14] = z6;
      y5 += x2 * A2[5];
      y6 += x3 * A3[6]; y[15] = z7; y += 16;
      y7 += x0 * A0[7];
   
      y0 += x2 * *A2;   Yget(z0, y[8], beta);
      y1 += x3 * A3[1];
      y2 += x0 * A0[2]; Yget(z1, y[9], beta);
      y3 += x1 * A1[3];
      y4 += x2 * A2[4]; Yget(z2, y[10], beta);
      y5 += x3 * A3[5];
      y6 += x0 * A0[6]; Yget(z3, y[11], beta);
      y7 += x1 * A1[7];

      y0 += x3 * *A3;   Yget(z4, y[12], beta);
      y1 += x0 * A0[1];
      y2 += x1 * A1[2]; Yget(z5, y[13], beta);
      y3 += x2 * A2[3];
      y4 += x3 * A3[4]; Yget(z6, y[14], beta);
      y5 += x0 * A0[5];
      y6 += x1 * A1[6]; Yget(z7, y[15], beta);
      y7 += x2 * A2[7];

      z0 += x0 * A0[8];  *y = y0;
      z1 += x1 * A1[9];
      z2 += x2 * A2[10]; y[1] = y1;
      z3 += x3 * A3[11];
      z4 += x0 * A0[12]; y[2] = y2;
      z5 += x1 * A1[13];
      z6 += x2 * A2[14]; y[3] = y3;
      z7 += x3 * A3[15];

      z0 += x1 * A1[8]; y[4] = y4;
      z1 += x2 * A2[9];
      z2 += x3 * A3[10]; y[5] = y5;
      z3 += x0 * A0[11];
      z4 += x1 * A1[12]; y[6] = y6;
      z5 += x2 * A2[13];
      z6 += x3 * A3[14]; y[7] = y7;
      z7 += x0 * A0[15];

      z0 += x2 * A2[8];
      z1 += x3 * A3[ 9];
      z2 += x0 * A0[10];
      z3 += x1 * A1[11];
      z4 += x2 * A2[12];
      z5 += x3 * A3[13];
      z6 += x0 * A0[14];
      z7 += x1 * A1[15];

      z0 += x3 * A3[8];
      z1 += x0 * A0[9];
      z2 += x1 * A1[10];
      z3 += x2 * A2[11];
      z4 += x3 * A3[12];
      z5 += x0 * A0[13];
      z6 += x1 * A1[14];
      z7 += x2 * A2[15];
      y[8] = z0;
      y[9] = z1;
      y[10] = z2;
      y[11] = z3;
      y[12] = z4;
      y[13] = z5;
      y[14] = z6;
      y[15] = z7;
      if (M-M16) gemvMlt8(M-M16, N, A0+16, lda, x, beta, y+16);
   }
   else if (N) gemvMlt8(M, N, A, lda, x, beta, y);
}

static void gemv32x4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   #ifdef BETA1
      int j;
   #endif
@ROUT - ATL_gpmvN_32x4_1
   const int incA = lda<<2;
@ROUT ATL_gpmvN_32x4_1
   int incA = (lda<<2) - 6;
@ROUT @peek

   if (N >= 4)
   {
      if (M >= 32)
      {
         #ifdef BETA1
@ROUT - ATL_gpmvN_32x4_1
            for (j=(N>>2); j; j--, A += incA, X += 4)
@ROUT ATL_gpmvN_32x4_1
            for (j=(N>>2); j; j--, A += incA, incA -= 6, X += 4)
@ROUT @peek
               gemvN32x4(M, 4, A, lda, X, ATL_rone, Y);
            if ( (j = N-((N>>2)<<2)) ) gemvNle4(M, j, A, lda, X, ATL_rone, Y);
         #else
            gemvN32x4(M, 4, A, lda, X, beta, Y);
            if (N != 4)
               Mjoin(PATL,gemvN_a1_x1_b1_y1)
                  (M, N-4, ATL_rone, A+incA, lda, X+4, 1, ATL_rone, Y, 1);
         #endif
      }
      else gemvMlt8(M, N, A, lda, X, beta, Y);
   }
   else if (M) gemvNle4(M, N, A, lda, X, beta, Y);
}

@ROUT - ATL_gpmvN_32x4_1
static void gemvMlt8(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
   register TYPE y0;
   for (i=M; i; i--)
   {
      #ifdef BETA0
         y0 = Mjoin(PATL,dot)(N, A, lda, X, 1);
      #else
         Yget(y0, *Y, beta);
         y0 += Mjoin(PATL,dot)(N, A, lda, X, 1);
      #endif
      *Y++ = y0;
      A++;
   }
}
@ROUT ATL_gpmvN_32x4_1
static void gpmvM8(const int N, const TYPE *A, const int lda, const TYPE *X,
                   const SCALAR beta, TYPE *Y)
{
   #ifdef Upper_
      register int incA = lda-1;
   #else
      register int incA = lda+1;
   #endif
   #ifdef BETA0
      register TYPE y0=ATL_rzero, y1=ATL_rzero, y2=ATL_rzero, y3=ATL_rzero;
      register TYPE y4=ATL_rzero, y5=ATL_rzero, y6=ATL_rzero, y7=ATL_rzero;
   #else
      register TYPE y0 = *Y, y1 = Y[1], y2 = Y[2], y3 = Y[3];
      register TYPE y4 = Y[4], y5 = Y[5], y6 = Y[6], y7 = Y[7];
   #endif
      register TYPE x0;
   const TYPE *stX = X + N;

   #ifdef BETA1
      x0 = beta;
      y0 *= x0; y1 *= x0; y2 *= x0; y3 *= x0;
      y4 *= x0; y5 *= x0; y6 *= x0; y7 *= x0;
   #endif
   do
   {
      x0 = *X;
      y0 += *A * x0;
      y1 += A[1] * x0; MpIncInc(incA);
      y2 += A[2] * x0;
      y3 += A[3] * x0;
      y4 += A[4] * x0; X++;
      y5 += A[5] * x0;
      y6 += A[6] * x0;
      y7 += A[7] * x0;
      A += incA;
   }
   while (X != stX);
   *Y = y0;
   Y[1] = y1;
   Y[2] = y2;
   Y[3] = y3;
   Y[4] = y4;
   Y[5] = y5;
   Y[6] = y6;
   Y[7] = y7;
}
static void gpmvM4(const int N, const TYPE *A, const int lda, const TYPE *X,
                   const SCALAR beta, TYPE *Y)
{
   #ifdef Upper_
      register int incA = lda-1;
   #else
      register int incA = lda+1;
   #endif
   #ifdef BETA0
      register TYPE y0=ATL_rzero, y1=ATL_rzero, y2=ATL_rzero, y3=ATL_rzero, x0;
   #else
      register TYPE y0 = *Y, y1 = Y[1], y2 = Y[2], y3 = Y[3], x0;
   #endif
   const TYPE *stX = X + N;

   #ifndef BETA0
      #ifndef BETA1
         x0 = beta;
         y0 *= x0; y1 *= x0; y2 *= x0; y3 *= x0;
      #endif
   #endif
   do
   {
      x0 = *X;
      y0 += *A * x0; MpIncInc(incA);
      y1 += A[1] * x0;
      y2 += A[2] * x0; X++;
      y3 += A[3] * x0;
      A += incA;
   }
   while (X != stX);
   *Y = y0;
   Y[1] = y1;
   Y[2] = y2;
   Y[3] = y3;
}
static void gpmvM2(const int N, const TYPE *A, const int lda, const TYPE *X,
                   const SCALAR beta, TYPE *Y)
{
   #ifdef Upper_
      register int incA = lda-1;
   #else
      register int incA = lda+1;
   #endif
   #ifdef BETA0
      register TYPE y0=ATL_rzero, y1=ATL_rzero, x0;
   #else
      register TYPE y0 = *Y, y1 = Y[1], x0;
   #endif
   const TYPE *stX = X + N;

   #ifndef BETA0
      y0 = *Y; y1 = Y[1];
      #ifndef BETA1
         x0 = beta;
         y0 *= x0; y1 *= x0;
      #endif
   #endif
   do
   {
      x0 = *X;
      y0 += *A * x0;  MpIncInc(incA);
      y1 += A[1] * x0; X++;
      A += incA;
   }
   while (X != stX);
   *Y = y0;
   Y[1] = y1;
}
static void gpmvM1(const int N, const TYPE *A, const int lda, const TYPE *X,
                   const SCALAR beta, TYPE *Y)
{
   #ifdef Upper_
      register int incA = lda-1;
   #else
      register int incA = lda+1;
   #endif
   #ifdef BETA0
      register TYPE y0=ATL_rzero;
   #else
      register TYPE y0 = *Y;
   #endif

   #ifdef BETAX
      y0 *= beta;
   #endif
   do
   {
      y0 += *X * *A;
      #ifdef Upper_
         A += incA++;
      #else
         A += incA--;
      #endif
   }
   while (++X != stX);
}
static void gemvMlt8(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * Name is wrong, M _is_ small, but sometimes larger than 8
 */
{
   register int m = M;

   if (m>>3)
   {
      TYPE *stY;
      m = (M>>3)<<3;
      stY = Y + m;
      do
      {
         gpmvM8(N, A, lda, X, beta, Y);
         Y += 8;
         A += 8;
      }
      while (Y != stY);
      m = M - m;
   }
   if (m>>2)
   {
      gpmvM4(N, A, lda, X, beta, Y);
      m -= 4;
      Y += 4;
      A += 4;
   }
   if (m>>1)
   {
      gpmvM2(N, A, lda, X, beta, Y);
      m -= 2;
      Y += 2;
      A += 2;
   }
   if (m) gpmvM1(N, A, lda, X, beta, Y);
}
@ROUT @peek
static void gemvNle4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
@ROUT - ATL_gpmvN_32x4_1
   const TYPE *A0 = A, *A1 = A+lda, *A2 = A1+lda, *A3 = A2+lda;
@ROUT ATL_gpmvN_32x4_1
   #ifdef Lower_
      const TYPE *A0 = A, *A1 = A+lda, *A2 = A1+lda-1, *A3 = A2+lda-2;
   #else
      const TYPE *A0 = A, *A1 = A+lda, *A2 = A1+lda+1, *A3 = A2+lda+2;
   #endif
@ROUT @peek
   register TYPE x0, x1, x2, x3;
   #ifdef BETAX
      const register TYPE bet=beta;
   #endif

   switch(N)
   {
   case 1:
      #if defined(BETA0)
         Mjoin(PATL,cpsc)(M, *X, A, 1, Y, 1);
      #elif defined(BETAX)
         Mjoin(PATL,axpby)(M, *X, A, 1, beta, Y, 1);
      #else
         Mjoin(PATL,axpy)(M, *X, A, 1, Y, 1);
      #endif
      break;
   case 2:
      x0 = *X; x1 = X[1]; 
      for (i=0; i != M; i++)
      #ifdef BETA0
         Y[i] = A0[i] * x0 + A1[i] * x1;
      #elif defined(BETAX)
         Y[i] = Y[i]*bet + A0[i] * x0 + A1[i] * x1;
      #else
         Y[i] += A0[i] * x0 + A1[i] * x1;
      #endif
      break;
   case 3:
      x0 = *X; x1 = X[1]; x2 = X[2];
      for (i=0; i != M; i++)
      #ifdef BETA0
         Y[i] = A0[i] * x0 + A1[i] * x1 + A2[i] * x2;
      #elif defined(BETAX)
         Y[i] = Y[i]*bet + A0[i] * x0 + A1[i] * x1 + A2[i] * x2;
      #else
         Y[i] += A0[i] * x0 + A1[i] * x1 + A2[i] * x2;
      #endif
      break;
   case 4:
      if (M >= 32) gemv32x4(M, 4, A, lda, X, beta, Y);
      else
      {
         x0 = *X; x1 = X[1]; x2 = X[2]; x3 = X[3];
         for (i=0; i != M; i++)
         #ifdef BETA0
            Y[i] = A0[i] * x0 + A1[i] * x1 + A2[i] * x2 + A3[i] * x3;
         #elif defined(BETAX)
            Y[i] = Y[i]*bet + A0[i] * x0 + A1[i] * x1 + A2[i] * x2 + A3[i] * x3;
         #else
            Y[i] += A0[i] * x0 + A1[i] * x1 + A2[i] * x2 + A3[i] * x3;
         #endif
      }
      break;
   default:
      ATL_assert(!N);
   }
}

@ROUT ATL_gemvN_16x4_1
static void gemv16x4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * 16x4 with feeble prefetch
 */
{
   int j;
   const int M16 = (M>>4)<<4, N4 = (N>>2)<<2, nr = N-N4+4;
   const int incA = lda << 2, incAm = 16 - (N4-4)*lda, incAm0 = 16 - N*lda;
   const TYPE *stX = X + N4, *x; 
   const TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   TYPE *stY = Y + M16;
   register TYPE x0, x1, x2, x3;
   register TYPE y0, y1, y2, y3, y4, y5, y6, y7;
   register TYPE y8, y9, y10, y11, y12, y13, y14, y15;
   register TYPE p0, p1, p2, p3;

   if (N > 4)
   {
      if (M16)
      {
         do
         {
            #ifdef BETA0
               y0 = y1 = y2 = y3 = y4 = y5 = y6 = y7 = 
               y8 = y9 = y10 = y11 = y12 = y13 = y14 = y15 = ATL_rzero;
            #elif defined BETAX
               x0 = beta;
               y0 = *Y; y1 = Y[1]; y2 = Y[2];  y3 = Y[3];
               y8 = Y[8]; y9 = Y[9]; y10 = Y[10];  y11 = Y[11];
               y4 = Y[4]; y5 = Y[5]; y6 = Y[6];  y7 = Y[7];
               y12 = Y[12]; y13 = Y[13]; y14 = Y[14];  y15 = Y[15];
               y0 *= x0; y1 *= x0; y2 *= x0; y3 *= x0;
               y8 *= x0; y9 *= x0; y10 *= x0; y11 *= x0;
               y4 *= x0; y5 *= x0; y6 *= x0; y7 *= x0;
               y12 *= x0; y13 *= x0; y14 *= x0; y15 *= x0;
            #else
               y0 = *Y; y1 = Y[1]; y2 = Y[2];  y3 = Y[3];
               y8 = Y[8]; y9 = Y[9]; y10 = Y[10];  y11 = Y[11];
               y4 = Y[4]; y5 = Y[5]; y6 = Y[6];  y7 = Y[7];
               y12 = Y[12]; y13 = Y[13]; y14 = Y[14];  y15 = Y[15];
            #endif
            p0 = *A0; p1 = A1[1];
            p2 = A2[2]; p3 = A3[3];
            x0 = *X; x1 = X[1]; x2 = X[2]; x3 = X[3];
            x = X + 4;
            if (N4 != 4)
            {
               do
               {
                  y0  += x0 * p0; p0 = A0[incA];
                  y1  += x1 * p1; p1 = A1[incA+1];
                  y2  += x2 * p2; p2 = A2[incA+2];
                  y3  += x3 * p3; p3 = A3[incA+3];
                  y8  += x0 * A0[8];
                  y9  += x1 * A1[9];
                  y10 += x2 * A2[10];
                  y11 += x3 * A3[11];
                  y4  += x0 * A0[4];
                  y5  += x1 * A1[5];
                  y6  += x2 * A2[6];
                  y7  += x3 * A3[7];
                  y12 += x0 * A0[12];
                  y13 += x1 * A1[13];
                  y14 += x2 * A2[14];
                  y15 += x3 * A3[15];

                  y0  += x1 * *A1;
                  y1  += x0 * A0[1];
                  y2  += x0 * A0[2];
                  y3  += x0 * A0[3];
                  y8  += x1 * A1[8];
                  y9  += x0 * A0[9];
                  y10 += x0 * A0[10];
                  y11 += x0 * A0[11];
                  y4  += x1 * A1[4];
                  y5  += x0 * A0[5];
                  y6  += x0 * A0[6];
                  y7  += x0 * A0[7];
                  y12 += x1 * A1[12];
                  y13 += x0 * A0[13];
                  y14 += x0 * A0[14];
                  y15 += x0 * A0[15]; x0 = *x;

                  y0  += x2 * *A2;
                  y1  += x2 * A2[1]; A0 += incA;
                  y2  += x1 * A1[2];
                  y3  += x1 * A1[3];
                  y8  += x2 * A2[8];
                  y9  += x2 * A2[9];
                  y10 += x1 * A1[10];
                  y11 += x1 * A1[11];
                  y4  += x2 * A2[4];
                  y5  += x2 * A2[5];
                  y6  += x1 * A1[6];
                  y7  += x1 * A1[7];
                  y12 += x2 * A2[12];
                  y13 += x2 * A2[13];
                  y14 += x1 * A1[14];
                  y15 += x1 * A1[15]; x1 = x[1];

                  y0  += x3 * *A3;
                  y1  += x3 * A3[1];
                  y2  += x3 * A3[2]; A1 += incA;
                  y3  += x2 * A2[3];
                  y8  += x3 * A3[8];
                  y9  += x3 * A3[9];
                  y10 += x3 * A3[10];
                  y11 += x2 * A2[11];
                  y4  += x3 * A3[4];
                  y5  += x3 * A3[5];
                  y6  += x3 * A3[6];
                  y7  += x2 * A2[7];
                  y12 += x3 * A3[12];
                  y13 += x3 * A3[13];
                  y14 += x3 * A3[14]; x3 = x[3]; A3 += incA;
                  y15 += x2 * A2[15]; x2 = x[2]; x += 4; A2 += incA;
               }
               while (x != stX);
            }
            x -= 4;
            for (j=0; j != nr; j++, A0 += lda)
            {
               x0 = x[j];
               y0  += x0 * *A0;
               y1  += x0 * A0[1];
               y2  += x0 * A0[2];
               y3  += x0 * A0[3];
               y8  += x0 * A0[8];
               y9  += x0 * A0[9];
               y10 += x0 * A0[10];
               y11 += x0 * A0[11];
               y4  += x0 * A0[4];
               y5  += x0 * A0[5];
               y6  += x0 * A0[6];
               y7  += x0 * A0[7];
               y12 += x0 * A0[12];
               y13 += x0 * A0[13];
               y14 += x0 * A0[14];
               y15 += x0 * A0[15];
            }
            A0 += incAm0;
            *Y   = y0;
            Y[ 1] = y1 ;
            Y[ 2] = y2 ;
            Y[ 3] = y3 ;
            A1 += incAm;
            Y[ 8] = y8 ;
            Y[ 9] = y9 ;
            Y[10] = y10;
            Y[11] = y11;
            A2 += incAm;
            Y[ 4] = y4 ;
            Y[ 5] = y5 ;
            Y[ 6] = y6 ;
            Y[ 7] = y7 ;
            A3 += incAm;
            Y[12] = y12;
            Y[13] = y13;
            Y[14] = y14;
            Y[15] = y15;
            Y += 16;
         }
         while (Y != stY);
      }
      if (M-M16) gemvMlt8(M-M16, N, A0, lda, X, beta, Y);
   }
   else if (M) gemvNle4(M, N, A, lda, X, beta, Y);
}
@ROUT ATL_gemvN_16x2_1
static void gemv16x2(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
/*
 * 16x2 with feeble prefetch
 */
{
   const int M16 = (M>>4)<<4, N2 = (N>>1)<<1, nr = N-N2;
   const int incA = lda << 1, incAm = 16 - N2*lda;
   const TYPE *stX = X + N2 - 2, *x; 
   const TYPE *A0 = A, *A1 = A + lda;
   TYPE *stY = Y + M16;
   register TYPE x0, x1;
   register TYPE y0, y1, y2, y3, y4, y5, y6, y7;
   register TYPE y8, y9, y10, y11, y12, y13, y14, y15;
   register TYPE p0, p1;

   if (N > 4)
   {
      if (M16)
      {
         do
         {
            #ifdef BETA0
               y0 = y1 = y2 = y3 = y4 = y5 = y6 = y7 = 
               y8 = y9 = y10 = y11 = y12 = y13 = y14 = y15 = ATL_rzero;
            #elif defined BETAX
               x0 = beta;
               y0 = *Y; y1 = Y[1]; y2 = Y[2];  y3 = Y[3];
               y4 = Y[4]; y5 = Y[5]; y6 = Y[6];  y7 = Y[7];
               y8 = Y[8]; y9 = Y[9]; y10 = Y[10];  y11 = Y[11];
               y12 = Y[12]; y13 = Y[13]; y14 = Y[14];  y15 = Y[15];
               y0 *= x0; y1 *= x0; y2 *= x0; y3 *= x0;
               y4 *= x0; y5 *= x0; y6 *= x0; y7 *= x0;
               y8 *= x0; y9 *= x0; y10 *= x0; y11 *= x0;
               y12 *= x0; y13 *= x0; y14 *= x0; y15 *= x0;
            #else
               y0 = *Y; y1 = Y[1]; y2 = Y[2];  y3 = Y[3];
               y4 = Y[4]; y5 = Y[5]; y6 = Y[6];  y7 = Y[7];
               y8 = Y[8]; y9 = Y[9]; y10 = Y[10];  y11 = Y[11];
               y12 = Y[12]; y13 = Y[13]; y14 = Y[14];  y15 = Y[15];
            #endif
            p0 = *A0;
            p1 = A1[1];
            x = X;
            do
            {
               x0 = *x; x1 = x[1]; x += 2;
               y0 += x0 * p0; p0 = A0[incA];
               y1 += x1 * p1; p1 = A1[incA+1];
               y8 += x0 * A0[8];
               y9 += x1 * A1[9];
               y4 += x0 * A0[4];
               y5 += x1 * A1[5];
               y12 += x0 * A0[12];
               y13 += x1 * A1[13];
               y2 += x0 * A0[2];
               y3 += x1 * A1[3];
               y10 += x0 * A0[10];
               y11 += x1 * A1[11];
               y6 += x0 * A0[6];
               y7 += x1 * A1[7];
               y14 += x0 * A0[14];
               y15 += x1 * A1[15];

               y0  += x1 * *A1;
               y1  += x0 * A0[1];
               y8  += x1 * A1[8];
               y9  += x0 * A0[9];
               y4  += x1 * A1[4];
               y5  += x0 * A0[5];
               y12 += x1 * A1[12];
               y13 += x0 * A0[13];
               y2  += x1 * A1[2];
               y3  += x0 * A0[3];
               y10 += x1 * A1[10];
               y11 += x0 * A0[11];
               y6  += x1 * A1[6];
               y7  += x0 * A0[7];
               y14 += x1 * A1[14]; A1 += incA;
               y15 += x0 * A0[15]; A0 += incA;
            }
            while (x != stX);
            if (!nr) /* 2 cols left */
            {
               x0 = *x; x1 = x[1]; x += 2;
               y0 += x0 * p0;
               y1 += x1 * p1;
               y8 += x0 * A0[8];
               y9 += x1 * A1[9];
               y4 += x0 * A0[4];
               y5 += x1 * A1[5];
               y12 += x0 * A0[12];
               y13 += x1 * A1[13];
               y2 += x0 * A0[2];
               y3 += x1 * A1[3];
               y10 += x0 * A0[10];
               y11 += x1 * A1[11];
               y6 += x0 * A0[6];
               y7 += x1 * A1[7];
               y14 += x0 * A0[14];
               y15 += x1 * A1[15];

               y0  += x1 * *A1;
               y1  += x0 * A0[1];
               y8  += x1 * A1[8];
               y9  += x0 * A0[9];
               y4  += x1 * A1[4];
               y5  += x0 * A0[5];
               y12 += x1 * A1[12];
               y13 += x0 * A0[13];
               y2  += x1 * A1[2];
               y3  += x0 * A0[3];
               y10 += x1 * A1[10];
               y11 += x0 * A0[11];
               y6  += x1 * A1[6];
               y7  += x0 * A0[7];
               y14 += x1 * A1[14]; A1 += incA;
               y15 += x0 * A0[15]; A0 += incA;
            }
            else     /* 3 cols left */
            {
               x0 = *x; x1 = x[1]; x += 2;
               y0 += x0 * p0; p0 = A0[incA];
               y1 += x1 * p1;
               y8 += x0 * A0[8];
               y9 += x1 * A1[9];
               y4 += x0 * A0[4];
               y5 += x1 * A1[5];
               y12 += x0 * A0[12];
               y13 += x1 * A1[13];
               y2 += x0 * A0[2];
               y3 += x1 * A1[3];
               y10 += x0 * A0[10];
               y11 += x1 * A1[11];
               y6 += x0 * A0[6];
               y7 += x1 * A1[7];
               y14 += x0 * A0[14];
               y15 += x1 * A1[15];

               y0  += x1 * *A1;
               y1  += x0 * A0[1];
               y8  += x1 * A1[8];
               y9  += x0 * A0[9];
               y4  += x1 * A1[4];
               y5  += x0 * A0[5];
               y12 += x1 * A1[12];
               y13 += x0 * A0[13];
               y2  += x1 * A1[2];
               y3  += x0 * A0[3];
               y10 += x1 * A1[10];
               y11 += x0 * A0[11];
               y6  += x1 * A1[6];
               y7  += x0 * A0[7];
               y14 += x1 * A1[14]; A1 += incA;
               y15 += x0 * A0[15]; A0 += incA;

               x0 = *x;
               y0  += x0 * *A0;
               y1  += x0 * A0[1];
               y2  += x0 * A0[2];
               y3  += x0 * A0[3];
               y4  += x0 * A0[4];
               y5  += x0 * A0[5];
               y6  += x0 * A0[6];
               y7  += x0 * A0[7];
               y8  += x0 * A0[8];
               y9  += x0 * A0[9];
               y10 += x0 * A0[10];
               y11 += x0 * A0[11];
               y12 += x0 * A0[12];
               y13 += x0 * A0[13];
               y14 += x0 * A0[14];
               y15 += x0 * A0[15];
            }
            *Y = y0;
            A0 += incAm;
            Y[1] = y1;
            A1 += incAm;
            Y[2] = y2;
            Y[3] = y3;
            Y[4] = y4;
            Y[5] = y5;
            Y[6] = y6;
            Y[7] = y7;
            Y[8] = y8;
            Y[9] = y9;
            Y[10] = y10;
            Y[11] = y11;
            Y[12] = y12;
            Y[13] = y13;
            Y[14] = y14;
            Y[15] = y15;
            Y += 16;
         }
         while (Y != stY);
      }
      if (M-M16) gemvMlt8(M-M16, N, A0, lda, X, beta, Y);
   }
   else if (M) gemvNle4(M, N, A, lda, X, beta, Y);
}
@ROUT ATL_gemvN_8x4_1
static void gemv8x4(const int M, const int N, const TYPE *A, const int lda,
                    const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
   const int M8 = (M>>3)<<3, N4 = (N>>2)<<2, nr = N-N4;
   const int incA = lda << 2, incAm = 8 - N4*lda;
   const TYPE *stX = X + N4, *x; 
   const TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   TYPE *stY = Y + M8;
   register TYPE x0, x1, x2, x3;
   register TYPE y0, y1, y2, y3, y4, y5, y6, y7;
   #ifdef ATL_AltiVec
   const int cwrd=ATL_GetCtrl(ATL_MulBySize(lda), Mmin(N,255), ATL_sizeof>>1);
   #endif

   if (N > 4)
   {
      if (M8)
      {
         do
         {
            #ifdef ATL_AltiVec
               ATL_pfavR(A0, cwrd, 0);
            #endif
            #ifdef BETA0
               y0 = y1 = y2 = y3 = y4 = y5 = y6 = y7 = ATL_rzero;
            #elif defined BETAX
               x0 = beta;
               y0 = *Y; y1 = Y[1]; y2 = Y[2];  y3 = Y[3];
               y4 = Y[4]; y5 = Y[5]; y6 = Y[6];  y7 = Y[7];
               y0 *= x0; y1 *= x0; y2 *= x0; y3 *= x0;
               y4 *= x0; y5 *= x0; y6 *= x0; y7 *= x0;
            #else
               y0 = *Y; y1 = Y[1]; y2 = Y[2];  y3 = Y[3];
               y4 = Y[4]; y5 = Y[5]; y6 = Y[6];  y7 = Y[7];
            #endif
            x = X;
            do
            {
               x0 = *x; x1 = x[1]; x2 = x[2]; x3 = x[3]; x += 4;
               y0 += *A0 * x0;
               y1 += A1[1] * x1;
               y2 += A2[2] * x2;
               y3 += A3[3] * x3;
               y4 += A0[4] * x0;
               y5 += A1[5] * x1;
               y6 += A2[6] * x2;
               y7 += A3[7] * x3;

               y0 += *A1 * x1;
               y1 += A0[1] * x0;
               y2 += A0[2] * x0;
               y3 += A0[3] * x0;
               y4 += A1[4] * x1;
               y5 += A0[5] * x0;
               y6 += A0[6] * x0;
               y7 += A0[7] * x0;

               y0 += *A2 * x2; A0 += incA;
               y1 += A2[1] * x2;
               y2 += A1[2] * x1;
               y3 += A1[3] * x1;
               y4 += A2[4] * x2;
               y5 += A2[5] * x2;
               y6 += A1[6] * x1;
               y7 += A1[7] * x1;

               y0 += *A3 * x3; A1 += incA;
               y1 += A3[1] * x3;
               y2 += A3[2] * x3;
               y3 += A2[3] * x2;
               y4 += A3[4] * x3;
               y5 += A3[5] * x3;
               y6 += A3[6] * x3; A3 += incA;
               y7 += A2[7] * x2; A2 += incA;
            }
            while (x != stX);
            if (nr)
            {
               for (i=0; i < nr; i++, A0 += lda)
               {
                  x0 = x[i];
                  y0 += *A0 * x0;
                  y1 += A0[1] * x0;
                  y2 += A0[2] * x0;
                  y3 += A0[3] * x0;
                  y4 += A0[4] * x0;
                  y5 += A0[5] * x0;
                  y6 += A0[6] * x0;
                  y7 += A0[7] * x0;
               }
               A0 -= nr*lda;
            }
            *Y = y0;
            A0 += incAm;
            Y[1] = y1;
            A1 += incAm;
            Y[2] = y2;
            A2 += incAm;
            Y[3] = y3;
            A3 += incAm;
            Y[4] = y4;
            Y[5] = y5;
            Y[6] = y6;
            Y[7] = y7;
            Y += 8;
         }
         while(Y != stY);
      }
      if (M-M8) gemvMlt8(M-M8, N, A0, lda, X, beta, Y);
   }
   else if (M) gemvNle4(M, N, A, lda, X, beta, Y);
}
@ROUT ATL_gemvN_4x4_1
static void gemv4x4(const int M, const int N, const TYPE *A, const int lda,
                    const TYPE *X, const SCALAR beta, TYPE *Y)
{
   const int M4 = (M>>2)<<2, N4 = (N>>2)<<2, nr = N-N4;
   const int incA = lda << 2, incAm = 4 - N4*lda;
   const TYPE *stX = X + N4, *x; 
   const TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   TYPE *stY = Y + M4;
   register TYPE a00, a10, a20, a30, a01, a11, a21, a31;
   register TYPE a02, a12, a22, a32, a03, a13, a23, a33;
   register TYPE y0, y1, y2, y3, yy0, yy1, yy2, yy3;
   register TYPE x0, x1, x2, x3;

   if (N > 4)
   {
      if (M4)
      {
         do
         {
            a00 = *A0; a01 = *A1;  a02 = *A2; a03 = *A3;
            a10 = A0[1]; a11 = A1[1]; a12 = A2[1]; a13 = A3[1];
            a20 = A0[2]; a21 = A1[2]; a22 = A2[2]; a23 = A3[2];
            a30 = A0[3]; a31 = A1[3]; a32 = A2[3]; a33 = A3[3];
            A0 += incA; A1 += incA; A2 += incA; A3 += incA;
            #ifdef BETA0
               yy0 = yy1 = yy2 = yy3 = y0 = y1 = y2 = y3 = ATL_rzero;
            #elif defined BETAX
               y0 = beta;
               yy0 = *Y; yy1 = Y[1]; yy2 = Y[2];  yy3 = Y[3];
               yy0 *= y0; yy1 *= y0; yy2 *= y0; yy3 *= y0;
               y0 = y1 = y2 = y3 = ATL_rzero;
            #else
               yy0 = *Y; yy1 = Y[1]; yy2 = Y[2];  yy3 = Y[3];
               y0 = y1 = y2 = y3 = ATL_rzero;
            #endif
            x0 = *X; x1 = X[1]; x2 = X[2]; x3 = X[3];
            x = X + 4;
            if (N4 != 4)
            {
               do
               {
                  y0  += x0 * a00; a00 = *A0;
                  yy0 += x1 * a01; a01 = *A1;
                  y1  += x0 * a10; a10 = A0[1];
                  yy1 += x1 * a11; a11 = A1[1];
                  y2  += x0 * a20; a20 = A0[2];
                  yy2 += x1 * a21; a21 = A1[2];
                  y3  += x0 * a30; a30 = A0[3]; A0 += incA; x0 = *x;
                  yy3 += x1 * a31; a31 = A1[3]; A1 += incA; x1 = x[1];

                  y0  += x2 * a02; a02 = *A2;
                  yy0 += x3 * a03; a03 = *A3;
                  y1  += x2 * a12; a12 = A2[1];
                  yy1 += x3 * a13; a13 = A3[1];
                  y2  += x2 * a22; a22 = A2[2];
                  yy2 += x3 * a23; a23 = A3[2];
                  y3  += x2 * a32; a32 = A2[3]; A2 += incA; x2 = x[2];
                  yy3 += x3 * a33; a33 = A3[3]; A3 += incA; x3 = x[3]; x += 4;
               }
               while(x != stX);
            }
/*
 *          Drain pipe
 */
            y0  += x0 * a00;
            yy0 += x1 * a01;
            y1  += x0 * a10;
            yy1 += x1 * a11;
            y2  += x0 * a20;
            yy2 += x1 * a21;
            y3  += x0 * a30;
            yy3 += x1 * a31;

            y0  += x2 * a02;
            yy0 += x3 * a03;
            y1  += x2 * a12;
            yy1 += x3 * a13;
            y2  += x2 * a22;
            yy2 += x3 * a23;
            y3  += x2 * a32;
            yy3 += x3 * a33;
/*
 *          loop cleanup
 */
            switch(nr)
            {
            case 1:
               x0 = *x;
               y0 += x0 * *A0;
               y1 += x0 * A0[1];
               y2 += x0 * A0[2];
               y3 += x0 * A0[3];
               break;
            case 2:
               x0 = *x;
               x1 = x[1];
               y0  += x0 * *A0;
               yy0 += x1 * *A1;
               y1  += x0 * A0[1];
               yy1 += x1 * A1[1];
               y2  += x0 * A0[2];
               yy2 += x1 * A1[2];
               y3  += x0 * A0[3];
               yy3 += x1 * A1[3];
               break;
            case 3:
               x0 = *x; x1 = x[1]; x2 = x[2];
               y0  += x0 * *A0;
               yy0 += x1 * *A1;
               y1  += x0 * A0[1];
               yy1 += x1 * A1[1];
               y2  += x0 * A0[2];
               yy2 += x1 * A1[2];
               y3  += x0 * A0[3];
               yy3 += x1 * A1[3];
               y0 += x2 * *A2;
               y1 += x2 * A2[1];
               y2 += x2 * A2[2];
               y3 += x2 * A2[3];
               break;
            default:;
            }
            A0 += incAm;
            y0 += yy0;
            A1 += incAm;
            y1 += yy1;
            A2 += incAm;
            y2 += yy2;
            A3 += incAm;
            y3 += yy3;
            *Y = y0;
            Y[1] = y1;
            Y[2] = y2;
            Y[3] = y3;
            Y += 4;
         }
         while (Y != stY);
      }
      if (M-M4) gemvMlt8(M-M4, N, A0, lda, X, beta, Y);
   }
   else if (M) gemvNle4(M, N, A, lda, X, beta, Y);
}

@ROUT ATL_gemvN_4x4_1 ATL_gemvN_4x2_0 ATL_gemvN_mm ATL_gemvN_8x32_2 @\
      ATL_gemvN_8x4_1 ATL_gemvN_16x2_1 ATL_gemvN_16x4_1 ATL_gemvN_32x4_1 @\
      ATL_gemvN_1x1_1 ATL_gemvN_1x1_1a
void Mjoin(Mjoin(Mjoin(Mjoin(Mjoin(PATL,gemvN),NM),_x1),BNM),_y1)
   (const int M, const int N, const SCALAR alpha, const TYPE *A, const int lda,
    const TYPE *X, const int incX, const SCALAR beta, TYPE *Y, const int incY)
{
@ROUT ATL_gpmvN_1x1_1a ATL_gpmvN_32x4_1
#ifdef Upper_
void Mjoin(Mjoin(Mjoin(Mjoin(PATL,gpmvUN_a1),_x1),BNM),_y1)
#else
void Mjoin(Mjoin(Mjoin(Mjoin(PATL,gpmvLN_a1),_x1),BNM),_y1)
#endif
   (const int M, const int N, const SCALAR alpha, const TYPE *A, const int lda,
    const TYPE *X, const int incX, const SCALAR beta, TYPE *Y, const int incY)
{

   register int ld=(lda SHIFT);
   const TYPE *stX = X + (N SHIFT);
@ROUT ATL_gemvN_1x1_1a
   int j;
@ROUT ATL_gemvN_1x1_1a ATL_gpmvN_1x1_1a

   #ifdef BETA0
      Mjoin(PATL,zero)(M, Y, 1);
   #elif !defined(BETA1)
      Mjoin(PATL,scal)(M, beta, Y, 1);
   #endif
@ROUT ATL_gemvN_1x1_1a
   for (j=N; j; j--, A += lda, X++) Mjoin(PATL,axpy)(M, *X, A, 1, Y, 1);
@ROUT ATL_gpmvN_1x1_1a
   do
   {
      #ifdef TREAL
         Mjoin(PATL,axpy)(M, *X++, A, 1, Y, 1);
      #else
         Mjoin(PATL,axpy)(M, X, A, 1, Y, 1);
         X += 2;
      #endif
      A += ld;
      MpIncInc(ld);
   }
   while (X != stX);
@ROUT ATL_gemvN_1x1_1a ATL_gpmvN_1x1_1a
}
@ROUT ATL_gemvN_1x1_1
   int i, j;
   for (i=0; i != M; i++)
   {
      #ifdef BETA0
         Y[i] = ATL_rzero;
      #elif defined(BETAX)
         Y[i] *= beta;
      #endif
      for (j=0; j != N; j++) Y[i] += A[i+j*lda] * X[j];
   }
}
@ROUT ATL_gemvN_32x4_1
   gemv32x4(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_16x4_1
   gemv16x4(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_16x2_1
   gemv16x2(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_8x4_1
   gemv8x4(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_8x32_2
   gemv(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_4x4_1
   gemv4x4(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_4x2_0
   const int incA = lda<<1, incAm = 4 - ((N>>1)<<1)*lda;
   const int m4 = (M>>2)<<2;
   int n2, nr;
   register TYPE y0, y1, y2, y3, z0, z1, z2, z3, x0, x1, m0, m1, m2, m3;
   register TYPE a00, a10, a20, a30, a01, a11, a21, a31;
   const TYPE *x, *stX = X + ((N>>1)<<1)-2, *A0 = A, *A1 = A + lda;
   TYPE *stY = Y + m4;

   if (N > 4)
   {
      n2 = ((N-4)>>1)<<1;
      nr = N - n2;
      if (m4)
      {
         do
         {
            x = X + 2;
            #ifdef BETA0
               z0 = z1 = z2 = z3 = y0 = y1 = y2 = y3 = ATL_rzero;
            #else
               z0 = *Y;
               z1 = Y[1];
               z2 = Y[2];
               z3 = Y[3];
               #ifdef BETAX
                  y0 = beta;
                  z0 *= y0;
                  z1 *= y0;
                  z2 *= y0;
                  z3 *= y0;
               #endif
               y0 = y1 = y2 = y3 = ATL_rzero;
            #endif
            x0 = *X;
            x1 = X[1];
            a00 = *A0;
            a01 = *A1;
            a10 = A0[1];
            a11 = A1[1];
            a20 = A0[2];
            a21 = A1[2];
            a30 = A0[3];
            a31 = A1[3];
            A0 += incA;
            A1 += incA;
            m0 = x0 * a00;
            a00 = *A0;
            m1 = x1 * a01;
            a01 = *A1;
            m2 = x0 * a10;
            a10 = A0[1];
            m3 = x1 * a11;
            a11 = A1[1];
            if (n2)
            {
               do
               {
                  y0 += m0;
                  m0 = x0 * a20;
                  a20 = A0[2];
                  z0 += m1;
                  m1 = x1 * a21;
                  a21 = A1[2];
                  y1 += m2;
                  m2 = x0 * a30;
                  x0 = *x;
                  a30 = A0[3];
                  A0 += incA;
                  z1 += m3;
                  m3 = x1 * a31;
                  x1 = x[1];
                  a31 = A1[3];
                  x += 2;
                  A1 += incA;
         
                  y2 += m0;
                  m0 = x0 * a00;
                  a00 = *A0;
                  z2 += m1;
                  m1 = x1 * a01;
                  a01 = *A1;
                  y3 += m2;
                  m2 = x0 * a10;
                  a10 = A0[1];
                  z3 += m3;
                  m3 = x1 * a11;
                  a11 = A1[1];
               }
               while (x != stX);
            }
            if (nr == 4)
            {
               y0 += m0;
               m0 = x0 * a20;
               a20 = A0[2];
               z0 += m1;
               m1 = x1 * a21;
               a21 = A1[2];
               y1 += m2;
               m2 = x0 * a30;
               x0 = *x;
               a30 = A0[3];
               z1 += m3;
               m3 = x1 * a31;
               x1 = x[1];
               a31 = A1[3];

               y2 += m0;
               m0 = x0 * a00;
               z2 += m1;
               m1 = x1 * a01;
               y3 += m2;
               m2 = x0 * a10;
               z3 += m3;
               m3 = x1 * a11;

               y0 += m0;
               m0 = x0 * a20;
               z0 += m1;
               m1 = x1 * a21;
               y1 += m2;
               m2 = x0 * a30;
               z1 += m3;
               m3 = x1 * a31;

               y2 += m0;
               A0 += incA;
               z2 += m1;
               A1 += incA;
               y3 += m2;
               z3 += m3;
            }
            else /* nr == 5 */
            {
               y0 += m0;
               m0 = x0 * a20;
               a20 = A0[2];
               z0 += m1;
               m1 = x1 * a21;
               a21 = A1[2];
               y1 += m2;
               m2 = x0 * a30;
               x0 = *x;
               a30 = A0[3];
               A0 += incA;
               z1 += m3;
               m3 = x1 * a31;
               x1 = x[1];
               x += 2;
               a31 = A1[3];

               y2 += m0;
               m0 = x0 * a00;
               a00 = *A0;
               z2 += m1;
               m1 = x1 * a01;
               y3 += m2;
               m2 = x0 * a10;
               a10 = A0[1];
               z3 += m3;
               m3 = x1 * a11;

               y0 += m0;
               m0 = x0 * a20;
               a20 = A0[2];
               z0 += m1;
               m1 = x1 * a21;
               y1 += m2;
               m2 = x0 * a30;
               x0 = *x;
               a30 = A0[3];
               z1 += m3;
               m3 = x1 * a31;

               y2 += m0;
               m0 = x0 * a00;
               z2 += m1;
               m1 = x0 * a10;
               y3 += m2;
               m2 = x0 * a20;
               z3 += m3;
               m3 = x0 * a30;

               y0 += m0;
               A1 += incA;
               y1 += m1;
               y2 += m2;
               y3 += m3;
            }

            y0 += z0;
            A0 += incAm;
            y1 += z1;
            A1 += incAm;
            y2 += z2;
            y3 += z3;
            *Y = y0;
            Y[1] = y1;
            Y[2] = y2;
            Y[3] = y3;
            Y += 4;
         }
         while (Y != stY);
      }
      for (nr=M-m4; nr; nr--)
      {
         #ifdef BETA0
            y0 = Mjoin(PATL,dot)(N, A0, lda, X, 1);
         #else
            #if defined(BETAX)
               y0 = *Y * beta;
            #else
               y0 = *Y;
            #endif
            y0 += Mjoin(PATL,dot)(N, A0, lda, X, 1);
         #endif
         *Y++ = y0;
         A0++;
      }
   }
   else if (M) gemvNle4(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvN_mm
   Mjoin(PATL,NCmmJIK)(AtlasNoTrans, AtlasNoTrans, M, 1, N, ATL_rone, A, lda,
                       X, N, beta, Y, M);
@ROUT ATL_gemvN_4x4_1 ATL_gemvN_4x2_0 ATL_gemvN_mm ATL_gemvN_8x32_2 ATL_gemvN_8x4_1 ATL_gemvN_16x2_1 ATL_gemvN_16x4_1 ATL_gemvN_32x4_1
}
@ROUT ATL_gpmv_a1_x1_y1
#include "atlas_misc.h"

#if (ATL_mmnreg >= 24) && defined(TREAL)

   @extract -b @(incd)/atlas-lvl2.base rout=ATL_gpmvN_32x4_1

#else  /* ATL_mmnreg < 24 or complex */

   @extract -b @(incd)/atlas-lvl2.base rout=ATL_gpmvN_1x1_1a

#endif
@ROUT ATL_cgemvT_2x4_1 ATL_cgemvT_2x2_0 ATL_cgemvT_mm ATL_cgemvT_1x1_1
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
@ROUT ATL_cgemvT_mm `#include "atlas_lvl3.h"`
@ROUT ATL_cgemvT_2x4_1 ATL_cgemvT_2x2_0 `#include "atlas_prefetch.h"`

#ifdef Conj_
   #define PEQ -=
   #define MEQ +=
#else
   #define PEQ +=
   #define MEQ -=
#endif

@ROUT ATL_cgemvT_2x4_1 ATL_cgemvT_2x2_0
static void gemvMlt4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int j;
   const int lda2 = lda<<1;
   #ifndef BETA0
      register TYPE yr0, yi0, yr1, yi1; 
   #endif
   #if defined(BETAXI0)
      const register TYPE rbeta = *beta;
   #elif defined(BETAX)
      const register TYPE xr0 = *beta, xi0 = beta[1];
   #endif

   for (j=M; j; j--, A += lda2, Y += 2)
   {
   #ifdef BETA0
      #ifndef Conj_
         Mjoin(PATL,dotu_sub)(N, A, 1, X, 1, Y);
      #else
         Mjoin(PATL,dotc_sub)(N, A, 1, X, 1, Y);
      #endif
   #else
      #ifdef BETAX
         yr0 = *Y;
         yi0 = Y[1];
         yr1 = yr0 * xr0 - yi0 * xi0;
         yi1 = yr0 * xi0 + yi0 * xr0;
      #else
         yr1 = *Y;
         yi1 = Y[1];
         #ifdef BETAXI0
            yr1 *= rbeta;
            yi1 *= rbeta;
         #endif
      #endif
      #ifndef Conj_
         Mjoin(PATL,dotu_sub)(N, A, 1, X, 1, Y);
      #else
         Mjoin(PATL,dotc_sub)(N, A, 1, X, 1, Y);
      #endif
      *Y += yr1;
      Y[1] += yi1;
   #endif
   }
}

static void gemvNlt2(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   #ifdef BETA0
      #ifndef Conj_
         Mjoin(PATL,cpsc)(M, X, A, lda, Y, 1);
      #else
         Mjoin(PATL,moveConj)(M, X, A, lda, Y, 1);
      #endif
   #elif defined(BETAX) || defined(BETAXI0)
      #ifndef Conj_
         Mjoin(PATL,axpby)(M, X, A, lda, beta, Y, 1);
      #else
         Mjoin(PATL,axpbyConj)(M, X, A, lda, beta, Y, 1);
      #endif
   #else
      #ifndef Conj_
         Mjoin(PATL,axpy)(M, X, A, lda, Y, 1);
      #else
         Mjoin(PATL,axpyConj)(M, X, A, lda, Y, 1);
      #endif
   #endif
}

@ROUT ATL_cgemvT_2x4_1
static void gemv2x4(const int M, const int N, const TYPE *A, const int lda,
                    const TYPE *X, const SCALAR beta, TYPE *Y)
{
   const int N2 = (N>>1)<<1, M4 = (M>>2)<<2, nr = (N-N2);
   const int incAm = ((lda<<2) - N2)<<1;
   const TYPE *A0 = A, *A1 = A+(lda<<1), *A2 = A1+(lda<<1), *A3 = A2+(lda<<1);
   const TYPE *x, *stX = X + (N2<<1);
   TYPE *stY = Y + (M4<<1);
   #ifdef BETAX
      const TYPE rbeta = *beta, ibeta = beta[1];
   #elif defined(BETAXI0)
      const TYPE rbeta = *beta;
   #endif
   register TYPE yr0, yi0, yr1, yi1, yr2, yi2, yr3, yi3;
   register TYPE xr0, xi0, xr1, xi1;
   register TYPE ar00, ar01, ar02, ar03, ar10, ar11, ar12, ar13;
   register TYPE ai00, ai01, ai02, ai03, ai10, ai11, ai12, ai13;
   #ifdef ATL_AltiVec
      int cwrd = ATL_MulBySize(N)>>4;
      if (cwrd >= 64) cwrd = ATL_GetCtrl(512, (cwrd+31)>>5, 0);
      else cwrd = ATL_GetCtrl(64, (cwrd+3)>>2, 4);
   #endif


   if (N2)
   {
      if (M4)
      {
         do
         {
            #ifdef ATL_AltiVec
               ATL_pfavR(A0, cwrd, 0);
               ATL_pfavR(A1, cwrd, 1);
               ATL_pfavR(A2, cwrd, 2); 
               ATL_pfavR(A3, cwrd, 3);
            #endif

            #ifdef BETA0
               yr0 = yi0 = yr1 = yi1 = yr2 = yi2 = yr3 = yi3 = ATL_rzero;
            #elif defined(BETAX)
               ar00 =   *Y; ai00 = Y[1]; ar01 = Y[2]; ai01 = Y[3];
               ar02 = Y[4]; ai02 = Y[5]; ar03 = Y[6]; ai03 = Y[7];
               yr0 = rbeta * ar00 - ibeta * ai00;
               yi0 = rbeta * ai00 + ibeta * ar00;
               yr1 = rbeta * ar01 - ibeta * ai01;
               yi1 = rbeta * ai01 + ibeta * ar01;
               yr2 = rbeta * ar02 - ibeta * ai02;
               yi2 = rbeta * ai02 + ibeta * ar02;
               yr3 = rbeta * ar03 - ibeta * ai03;
               yi3 = rbeta * ai03 + ibeta * ar03;
            #else
               yr0 =   *Y; yi0 = Y[1]; yr1 = Y[2]; yi1 = Y[3];
               yr2 = Y[4]; yi2 = Y[5]; yr3 = Y[6]; yi3 = Y[7];
               #ifdef BETAXI0
                  yr0 *= rbeta; yi0 *= rbeta;
                  yr1 *= rbeta; yi1 *= rbeta;
                  yr2 *= rbeta; yi2 *= rbeta;
                  yr3 *= rbeta; yi3 *= rbeta;
               #endif
            #endif
            ar00 = *A0;   ar01 = *A1;    ar02 = *A2;   ar03 = *A3;
            ai00 = A0[1]; ai01 = A1[1];  ai02 = A2[1]; ai03 = A3[1];
            ar10 = A0[2]; ar11 = A1[2];  ar12 = A2[2]; ar13 = A3[2];
            ai10 = A0[3]; ai11 = A1[3];  ai12 = A2[3]; ai13 = A3[3];
            A0 += 4; A1 += 4; A2 += 4; A3 += 4;
            xr0 = *X; xi0 = X[1]; xr1 = X[2]; xi1 = X[3]; x = X + 4;
            if (N2 > 3)
            {
               do
               {
                  yr0 += xr0 * ar00;
                  yr1 += xr0 * ar01;
                  yr2 += xr0 * ar02;
                  yr3 += xr0 * ar03;
                  yi0 += xi0 * ar00; ar00 = *A0;
                  yi1 += xi0 * ar01; ar01 = *A1;
                  yi2 += xi0 * ar02; ar02 = *A2;
                  yi3 += xi0 * ar03; ar03 = *A3;
                  #ifndef Conj_
                     yr0 -= xi0 * ai00;
                     yr1 -= xi0 * ai01;
                     yr2 -= xi0 * ai02;
                     yr3 -= xi0 * ai03; xi0 = x[1];
                     yi0 += xr0 * ai00; ai00 = A0[1];
                     yi1 += xr0 * ai01; ai01 = A1[1];
                     yi2 += xr0 * ai02; ai02 = A2[1];
                     yi3 += xr0 * ai03; ai03 = A3[1]; xr0 = *x;
                  #else
                     yr0 += xi0 * ai00;
                     yr1 += xi0 * ai01;
                     yr2 += xi0 * ai02;
                     yr3 += xi0 * ai03; xi0 = x[1];
                     yi0 -= xr0 * ai00; ai00 = A0[1];
                     yi1 -= xr0 * ai01; ai01 = A1[1];
                     yi2 -= xr0 * ai02; ai02 = A2[1];
                     yi3 -= xr0 * ai03; ai03 = A3[1]; xr0 = *x;
                  #endif

                  yr0 += xr1 * ar10;
                  yr1 += xr1 * ar11;
                  yr2 += xr1 * ar12;
                  yr3 += xr1 * ar13;
                  yi0 += xi1 * ar10; ar10 = A0[2];
                  yi1 += xi1 * ar11; ar11 = A1[2];
                  yi2 += xi1 * ar12; ar12 = A2[2];
                  yi3 += xi1 * ar13; ar13 = A3[2];
                  #ifndef Conj_
                     yr0 -= xi1 * ai10;
                     yr1 -= xi1 * ai11;
                     yr2 -= xi1 * ai12;
                     yr3 -= xi1 * ai13; xi1 = x[3];
                     yi0 += xr1 * ai10; ai10 = A0[3]; A0 += 4;
                     yi1 += xr1 * ai11; ai11 = A1[3]; A1 += 4;
                     yi2 += xr1 * ai12; ai12 = A2[3]; A2 += 4;
                     yi3 += xr1 * ai13; ai13 = A3[3]; A3 += 4; xr1=x[2]; x += 4;
                  #else
                     yr0 += xi1 * ai10;
                     yr1 += xi1 * ai11;
                     yr2 += xi1 * ai12;
                     yr3 += xi1 * ai13; xi1 = x[3];
                     yi0 -= xr1 * ai10; ai10 = A0[3]; A0 += 4;
                     yi1 -= xr1 * ai11; ai11 = A1[3]; A1 += 4;
                     yi2 -= xr1 * ai12; ai12 = A2[3]; A2 += 4;
                     yi3 -= xr1 * ai13; ai13 = A3[3]; A3 += 4; xr1=x[2]; x += 4;
                  #endif
               }
               while (x != stX);
            }
            if (!nr) /* fetching done, just do 2 remaining ops */
            {
               yr0 += xr0 * ar00;
               yr1 += xr0 * ar01;
               yr2 += xr0 * ar02;
               yr3 += xr0 * ar03;
               yi0 += xi0 * ar00;
               yi1 += xi0 * ar01;
               yi2 += xi0 * ar02;
               yi3 += xi0 * ar03;
               #ifndef Conj_
                  yr0 -= xi0 * ai00;
                  yr1 -= xi0 * ai01;
                  yr2 -= xi0 * ai02;
                  yr3 -= xi0 * ai03;
                  yi0 += xr0 * ai00;
                  yi1 += xr0 * ai01;
                  yi2 += xr0 * ai02;
                  yi3 += xr0 * ai03;
               #else
                  yr0 += xi0 * ai00;
                  yr1 += xi0 * ai01;
                  yr2 += xi0 * ai02;
                  yr3 += xi0 * ai03;
                  yi0 -= xr0 * ai00;
                  yi1 -= xr0 * ai01;
                  yi2 -= xr0 * ai02;
                  yi3 -= xr0 * ai03;
               #endif

               yr0 += xr1 * ar10;
               yr1 += xr1 * ar11;
               yr2 += xr1 * ar12;
               yr3 += xr1 * ar13;
               yi0 += xi1 * ar10;
               yi1 += xi1 * ar11;
               yi2 += xi1 * ar12;
               yi3 += xi1 * ar13;
               #ifndef Conj_
                  yr0 -= xi1 * ai10;
                  yr1 -= xi1 * ai11;
                  yr2 -= xi1 * ai12;
                  yr3 -= xi1 * ai13;
                  yi0 += xr1 * ai10;
                  yi1 += xr1 * ai11;
                  yi2 += xr1 * ai12;
                  yi3 += xr1 * ai13;
               #else
                  yr0 += xi1 * ai10;
                  yr1 += xi1 * ai11;
                  yr2 += xi1 * ai12;
                  yr3 += xi1 * ai13;
                  yi0 -= xr1 * ai10;
                  yi1 -= xr1 * ai11;
                  yi2 -= xr1 * ai12;
                  yi3 -= xr1 * ai13;
               #endif
            }
            else  /* 3 rows left to do, 2 rows prefetched */
            {
               yr0 += xr0 * ar00;
               yr1 += xr0 * ar01;
               yr2 += xr0 * ar02;
               yr3 += xr0 * ar03;
               yi0 += xi0 * ar00; ar00 = *A0;
               yi1 += xi0 * ar01; ar01 = *A1;
               yi2 += xi0 * ar02; ar02 = *A2;
               yi3 += xi0 * ar03; ar03 = *A3;
               #ifndef Conj_
                  yr0 -= xi0 * ai00;
                  yr1 -= xi0 * ai01;
                  yr2 -= xi0 * ai02;
                  yr3 -= xi0 * ai03; xi0 = x[1];
                  yi0 += xr0 * ai00; ai00 = A0[1];
                  yi1 += xr0 * ai01; ai01 = A1[1];
                  yi2 += xr0 * ai02; ai02 = A2[1];
                  yi3 += xr0 * ai03; ai03 = A3[1]; xr0 = *x;
               #else
                  yr0 += xi0 * ai00;
                  yr1 += xi0 * ai01;
                  yr2 += xi0 * ai02;
                  yr3 += xi0 * ai03; xi0 = x[1];
                  yi0 -= xr0 * ai00; ai00 = A0[1];
                  yi1 -= xr0 * ai01; ai01 = A1[1];
                  yi2 -= xr0 * ai02; ai02 = A2[1];
                  yi3 -= xr0 * ai03; ai03 = A3[1]; xr0 = *x;
               #endif

               yr0 += xr1 * ar10;
               yr1 += xr1 * ar11;
               yr2 += xr1 * ar12;
               yr3 += xr1 * ar13;
               yi0 += xi1 * ar10;
               yi1 += xi1 * ar11;
               yi2 += xi1 * ar12;
               yi3 += xi1 * ar13;
               #ifndef Conj_
                  yr0 -= xi1 * ai10;
                  yr1 -= xi1 * ai11;
                  yr2 -= xi1 * ai12;
                  yr3 -= xi1 * ai13;
                  yi0 += xr1 * ai10;
                  yi1 += xr1 * ai11;
                  yi2 += xr1 * ai12;
                  yi3 += xr1 * ai13;
               #else
                  yr0 += xi1 * ai10;
                  yr1 += xi1 * ai11;
                  yr2 += xi1 * ai12;
                  yr3 += xi1 * ai13;
                  yi0 -= xr1 * ai10;
                  yi1 -= xr1 * ai11;
                  yi2 -= xr1 * ai12;
                  yi3 -= xr1 * ai13;
               #endif

               yr0 += xr0 * ar00;
               yr1 += xr0 * ar01;
               yr2 += xr0 * ar02;
               yr3 += xr0 * ar03;
               yi0 += xi0 * ar00;
               yi1 += xi0 * ar01;
               yi2 += xi0 * ar02;
               yi3 += xi0 * ar03;
               #ifndef Conj_
                  yr0 -= xi0 * ai00;
                  yr1 -= xi0 * ai01;
                  yr2 -= xi0 * ai02;
                  yr3 -= xi0 * ai03;
                  yi0 += xr0 * ai00;
                  yi1 += xr0 * ai01;
                  yi2 += xr0 * ai02;
                  yi3 += xr0 * ai03;
               #else
                  yr0 += xi0 * ai00;
                  yr1 += xi0 * ai01;
                  yr2 += xi0 * ai02;
                  yr3 += xi0 * ai03;
                  yi0 -= xr0 * ai00;
                  yi1 -= xr0 * ai01;
                  yi2 -= xr0 * ai02;
                  yi3 -= xr0 * ai03;
               #endif
            }
            *Y   = yr0;
            A0 += incAm;
            Y[1] = yi0;
            A1 += incAm;
            Y[2] = yr1;
            A2 += incAm;
            Y[3] = yi1;
            A3 += incAm;
            Y[4] = yr2;
            Y[5] = yi2;
            Y[6] = yr3;
            Y[7] = yi3;
            Y += 8;
         }
         while(Y != stY);
      }
      if (M-M4) gemvMlt4(M-M4, N, A0, lda, X, beta, Y);
   }
   else if (M && N) gemvNlt2(M, N, A, lda, X, beta, Y);
}
@ROUT ATL_cgemvT_2x4_1 ATL_cgemvT_2x2_0 ATL_cgemvT_mm ATL_cgemvT_1x1_1

#ifdef Conj_
@ROUT ATL_cgemvT_mm `   #define TransA AtlasConjTrans`
   #define gemv0 Mjoin(Mjoin(Mjoin(Mjoin(gemvC,NM),_x1),BNM),_y1)
#else
@ROUT ATL_cgemvT_mm `   #define TransA AtlasTrans`
   #define gemv0 Mjoin(Mjoin(Mjoin(Mjoin(gemvT,NM),_x1),BNM),_y1)
#endif
void Mjoin(PATL,gemv0)
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
@ROUT ATL_cgemvT_1x1_1
   int i, j;
   const int M2 = M<<1, N2 = N<<1;
   #ifdef BETAX
      const TYPE rbeta = *beta, ibeta = beta[1];
   #elif defined(BETAXI0)
      const TYPE rbeta = *beta;
   #endif
   register TYPE ra, ia, rx, ix, ry, iy;

   for (j=0; j != M2; j += 2)
   {
      #ifdef BETA0
         ry = iy = ATL_rzero;
      #elif defined(BETAX)
         rx = rbeta; ix = ibeta;
         ra = Y[j]; ia = Y[j+1];
         ry = ra * rx - ia * ix;
         iy = ra * ix + ia * rx;
      #else
         ry = Y[j];
         iy = Y[j+1];
         #ifdef BETAXI0
            ry *= rbeta;
            iy *= rbeta;
         #endif
      #endif
      for (i=0; i != N2; i += 2)
      {
         ra = A[i+j*lda]; ia = A[i+1+j*lda];
         rx = X[i]; ix = X[i+1];
         ry += ra * rx;
         iy += ra * ix;
         ry MEQ ia * ix;
         iy PEQ ia * rx;
      }
      Y[j] = ry;
      Y[j+1] = iy;
   }
}
@ROUT ATL_cgemvT_2x4_1
   gemv2x4(M, N, A, lda, X, beta, Y);
@ROUT ATL_cgemvT_2x2_0
   const int N2 = (N>>1)<<1, M2 = (M>>1)<<1;
   const int nr = N-N2, incAm = ((lda<<1) - N2)<<1;
   const TYPE *x, *stX = X + (N2<<1), *A0 = A, *A1 = A + (lda<<1);
   TYPE *stY = Y + (M2<<1);
   register TYPE xr0, xi0, xr1, xi1, yr0, yi0, yr1, yi1;
   register TYPE ar00, ai00, ar10, ai10, ar01, ai01, ar11, ai11;
   register TYPE m0, m1, m2, m3;
   #ifndef ATL_PFD
      #define ATL_PFD 8
   #endif

   if (N2)
   {
      if (M2)
      {
         do
         {
            #ifdef BETA0
               yr0 = yi0 = yr1 = yi1 = ATL_rzero;
            #elif defined(BETAX)
               xr0 = *beta; xi0 = beta[1];
               ar00 = *Y; ai00 = Y[1]; ar10 = Y[2]; ai10 = Y[3];
               yr0 = ar00 * xr0 - ai00 * xi0;
               yi0 = ar00 * xi0 + ai00 * xr0;
               yr1 = ar10 * xr0 - ai10 * xi0;
               yi1 = ar10 * xi0 + ai10 * xr0;
            #else
               yr0 = *Y; yi0 = Y[1]; yr1 = Y[2]; yi1 = Y[3];
               #ifdef BETAXI0
                  xr0 = *beta;
                  yr0 *= xr0; yi0 *= xr0;
                  yr1 *= xr0; yi1 *= xr0;
               #endif
            #endif
            x = X + 4;
            ar00 = *A0; ai00 = A0[1]; ar10 = A0[2]; ai10 = A0[3]; A0 += 4;
            xr0 = *X; xi0 = X[1]; xr1 = X[2]; xi1 = X[3];
            ar01 = *A1; ai01 = A1[1]; ar11 = A1[2]; ai11 = A1[3]; A1 += 4;
            m0 = ar00 * xr0;
            m1 = ar01 * xr0;
            m2 = ar00 * xi0;
            m3 = ar01 * xi0;
            if (N2 != 2)
            {
               do
               {
                  ar00 = *A0; ar01 = *A1;
                  yr0 += m0; m0 = ai00 * xi0;
                                  ATL_pfl1R(A0+ATL_PFD); ATL_pfl1R(A1+ATL_PFD);
                  yr1 += m1; m1 = ai01 * xi0; xi0 = x[1];
                  yi0 += m2; m2 = ai00 * xr0; ai00 = A0[1];
                  yi1 += m3; m3 = ai01 * xr0; ai01 = A1[1]; xr0 = *x;
                  #ifndef Conj_
                     yr0 -= m0; m0 = ar10 * xr1;
                     yr1 -= m1; m1 = ar11 * xr1;
                     yi0 += m2; m2 = ar10 * xi1; ar10 = A0[2];
                     yi1 += m3; m3 = ar11 * xi1; ar11 = A1[2];
                  #else
                     yr0 += m0; m0 = ar10 * xr1;
                     yr1 += m1; m1 = ar11 * xr1;
                     yi0 -= m2; m2 = ar10 * xi1; ar10 = A0[2];
                     yi1 -= m3; m3 = ar11 * xi1; ar11 = A1[2];
                  #endif

                  yr0 += m0; m0 = ai10 * xi1;
                  yr1 += m1; m1 = ai11 * xi1; xi1 = x[3];
                  yi0 += m2; m2 = ai10 * xr1; ai10 = A0[3]; A0 += 4;
                  yi1 += m3; m3 = ai11 * xr1; ai11 = A1[3]; A1 += 4;
                         xr1 = x[2]; x += 4; 
                  #ifndef Conj_
                     yr0 -= m0; m0 = ar00 * xr0;
                     yr1 -= m1; m1 = ar01 * xr0;
                     yi0 += m2; m2 = ar00 * xi0;
                     yi1 += m3; m3 = ar01 * xi0;
                  #else
                     yr0 += m0; m0 = ar00 * xr0;
                     yr1 += m1; m1 = ar01 * xr0;
                     yi0 -= m2; m2 = ar00 * xi0;
                     yi1 -= m3; m3 = ar01 * xi0;
                  #endif
               }
               while (x != stX);
            }
/*
 *          Drain pipes & store to Y
 */
            if (nr)
            {
               ar00 = *A0; ar01 = *A1;
               yr0 += m0; m0 = ai00 * xi0;
               yr1 += m1; m1 = ai01 * xi0; xi0 = x[1];
               yi0 += m2; m2 = ai00 * xr0; ai00 = A0[1];
               yi1 += m3; m3 = ai01 * xr0; ai01 = A1[1]; xr0 = *x;
               #ifndef Conj_
                  yr0 -= m0; m0 = ar10 * xr1;
                  yr1 -= m1; m1 = ar11 * xr1;
                  yi0 += m2; m2 = ar10 * xi1;
                  yi1 += m3; m3 = ar11 * xi1;
               #else
                  yr0 += m0; m0 = ar10 * xr1;
                  yr1 += m1; m1 = ar11 * xr1;
                  yi0 -= m2; m2 = ar10 * xi1;
                  yi1 -= m3; m3 = ar11 * xi1;
               #endif

               yr0 += m0; m0 = ai10 * xi1;
               yr1 += m1; m1 = ai11 * xi1;
               yi0 += m2; m2 = ai10 * xr1;
               yi1 += m3; m3 = ai11 * xr1;
               #ifndef Conj_
                  yr0 -= m0; m0 = ar00 * xr0;
                  yr1 -= m1; m1 = ar01 * xr0;
                  yi0 += m2; m2 = ar00 * xi0;
                  yi1 += m3; m3 = ar01 * xi0;
               #else
                  yr0 += m0; m0 = ar00 * xr0;
                  yr1 += m1; m1 = ar01 * xr0;
                  yi0 -= m2; m2 = ar00 * xi0;
                  yi1 -= m3; m3 = ar01 * xi0;
               #endif

               yr0 += m0; m0 = ai00 * xi0;
               yr1 += m1; m1 = ai01 * xi0;
               yi0 += m2; m2 = ai00 * xr0;
               yi1 += m3; m3 = ai01 * xr0;
               #ifndef Conj_
                  yr0 -= m0;
                  yr1 -= m1;
                  yi0 += m2;
                  yi1 += m3;
               #else
                  yr0 += m0;
                  yr1 += m1;
                  yi0 -= m2;
                  yi1 -= m3;
               #endif
            }
            else
            {
               yr0 += m0; m0 = ai00 * xi0;
               yr1 += m1; m1 = ai01 * xi0;
               yi0 += m2; m2 = ai00 * xr0;
               yi1 += m3; m3 = ai01 * xr0;
               #ifndef Conj_
                  yr0 -= m0; m0 = ar10 * xr1;
                  yr1 -= m1; m1 = ar11 * xr1;
                  yi0 += m2; m2 = ar10 * xi1;
                  yi1 += m3; m3 = ar11 * xi1;
               #else
                  yr0 += m0; m0 = ar10 * xr1;
                  yr1 += m1; m1 = ar11 * xr1;
                  yi0 -= m2; m2 = ar10 * xi1;
                  yi1 -= m3; m3 = ar11 * xi1;
               #endif
   
               yr0 += m0; m0 = ai10 * xi1;
               yr1 += m1; m1 = ai11 * xi1;
               yi0 += m2; m2 = ai10 * xr1;
               yi1 += m3; m3 = ai11 * xr1;
               #ifndef Conj_
                  yr0 -= m0;
                  yr1 -= m1;
                  yi0 += m2;
                  yi1 += m3;
               #else
                  yr0 += m0;
                  yr1 += m1;
                  yi0 -= m2;
                  yi1 -= m3;
               #endif
            }
   
            *Y = yr0;
            A0 += incAm;
            Y[1] = yi0;
            Y[2] = yr1;
            A1 += incAm;
            Y[3] = yi1;
            Y += 4;
         }
         while (Y != stY);
      }
      if (M-M2) gemvMlt4(M-M2, N, A0, lda, X, beta, Y);
   }
   else if (M && N) gemvNlt2(M, N, A, lda, X, beta, Y);
@ROUT ATL_cgemvT_mm
   TYPE one[2] = {ATL_rone, ATL_rzero};

   Mjoin(PATL,NCmmJIK)(TransA, AtlasNoTrans, M, 1, N, one, A, lda,
                       X, N, beta, Y, M);
@ROUT ATL_cgemvT_2x4_1 ATL_cgemvT_2x2_0 ATL_cgemvT_mm
@beginskip
   const int incA = lda<<1;
   TYPE *stY = Y + (M<<1);
   TYPE dot[2];
   const register TYPE rbeta = *beta, ibeta = beta[1];
   register TYPE ry, iy, t0;
   if (M)
   {
      if (ibeta == ATL_rzero)
      {
         if (rbeta == ATL_rzero)
         {
            do
            {
               Mjoin(PATL,dotu_sub)(N, X, 1, A, 1, Y);
               Y += 2;
               A += incA;
            }
            while (Y != stY);
         }
         else if (rbeta == ATL_rone)
         {
            do
            {
               ry = *Y;
               iy = Y[1];
               Mjoin(PATL,dotu_sub)(N, X, 1, A, 1, dot);
               ry += *dot;
               iy += dot[1];
               *Y = ry;
               Y[1] = iy;
               Y += 2;
               A += incA;
            }
            while (Y != stY);
         }
         else
         {
            do
            {
               ry = *Y;
               iy = Y[1];
               ry *= rbeta;
               iy *= rbeta;
               Mjoin(PATL,dotu_sub)(N, X, 1, A, 1, dot);
               ry += *dot;
               iy += dot[1];
               *Y = ry;
               Y[1] = iy;
               Y += 2;
               A += incA;
            }
            while (Y != stY);
         }
      }
      else
      {
         do
         {
            t0 = ry = *Y;
            iy = Y[1];
            ry = ry * rbeta - iy * ibeta;
            iy = t0 * ibeta + iy * rbeta;
            Mjoin(PATL,dotu_sub)(N, X, 1, A, 1, dot);
            ry += *dot;
            iy += dot[1];
            *Y = ry;
            Y[1] = iy;
            Y += 2;
            A += incA;
         }
         while (Y != stY);
      }
   }
@endskip
}
@ROUT ATL_gemvT_4x8_1 ATL_gemvT_2x8_0 ATL_gemvT_mm ATL_gemvT_4x16_1 ATL_gemvT_2x16_1 ATL_gemvT_1x1_1
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
@ROUT ATL_gemvT_mm `#include "atlas_lvl3.h"`
@ROUT ATL_gemvT_4x16_1 ATL_gemvT_2x16_1 `#include "atlas_prefetch.h"`

@ROUT ATL_gemvT_4x8_1 ATL_gemvT_2x8_0 ATL_gemvT_4x16_1
static void gemvT_Nsmall(const int M, const int N, const TYPE *A, const int lda,
                         const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
   register TYPE x0, x1, x2, x3, x4, x5, x6, x7, y0;
   TYPE *stY = Y + M;

   switch(N)
   {
   case 1:
      #ifdef BETA0
         Mjoin(PATL,cpsc)(M, *X, A, lda, Y, 1);
      #elif defined(BETAX)
         Mjoin(PATL,axpby)(M, *X, A, lda, beta, Y, 1);
      #else
         Mjoin(PATL,axpy)(M, *X, A, lda, Y, 1);
      #endif
      break;
   case 2:
      x0 = *X;
      x1 = X[1];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1];
         #else
            *Y += x0 * *A + x1 * A[1];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   case 3:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1] + x2 * A[2];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1] + x2 * A[2];
         #else
            *Y += x0 * *A + x1 * A[1] + x2 * A[2];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   case 4:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3];
         #else
            *Y += x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   case 5:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3] 
                 + x4 * A[4];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4];
         #else
            *Y += x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3] + x4 * A[4];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   case 6:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      x5 = X[5];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3] 
                 + x4 * A[4] + x5 * A[5];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4] + x5 * A[5];
         #else
            *Y += x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4] + x5 * A[5];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   case 7:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      x5 = X[5];
      x6 = X[6];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3] 
                 + x4 * A[4] + x5 * A[5] + x6 * A[6];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4] + x5 * A[5] + x6 * A[6];
         #else
            *Y += x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4] + x5 * A[5] + x6 * A[6];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   case 8:
      x0 = *X;
      x1 = X[1];
      x2 = X[2];
      x3 = X[3];
      x4 = X[4];
      x5 = X[5];
      x6 = X[6];
      x7 = X[7];
      do
      {
         #ifdef BETA0
            *Y = x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3] 
                 + x4 * A[4] + x5 * A[5] + x6 * A[6] + x7 * A[7];
         #elif defined(BETAX)
            y0 = *Y;
            *Y = y0 * beta + x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4] + x5 * A[5] + x6 * A[6] + x7 * A[7];
         #else
            *Y += x0 * *A + x1 * A[1] + x2 * A[2] + x3 * A[3]
                 + x4 * A[4] + x5 * A[5] + x6 * A[6] + x7 * A[7];
         #endif
         A += lda;
      }
      while (++Y != stY);
      break;
   default:
      if (M)
      {
         do
         {
            #ifdef BETA0
               y0 = ATL_rzero;
            #elif defined(BETAX)
               y0 = *Y * beta;
            #else
               y0 = *Y;
            #endif
            for (i=0; i != N; i++) y0 += A[i] * X[i];
            *Y++ = y0;
            A += lda;
         }
         while (Y != stY);
      }
   }
}

@ROUT ATL_gemvT_4x8_1 ATL_gemvT_2x8_0 ATL_gemvT_4x16_1 ATL_gemvT_2x16_1
static void gemvT_Msmall(const int M, const int N, const TYPE *A, const int lda,
                         const TYPE *X, const SCALAR beta, TYPE *Y)
{
   const TYPE *stY = Y + M;
   #ifndef BETA0
      register TYPE y0;
   #endif

   do
   {
      #ifdef BETA0
         *Y = Mjoin(PATL,dot)(N, X, 1, A, 1);
      #else
         y0 = *Y;
         #ifdef BETAX
            y0 *= beta;
         #endif
         y0 += Mjoin(PATL,dot)(N, X, 1, A, 1);
         *Y = y0;
      #endif
      Y++;
      A += lda;
   }
   while (Y != stY);
}
@ROUT ATL_gemvT_4x8_1
static void gemvT4x4(const int M, const int N, const TYPE *A, const int lda,
                     const TYPE *X, const SCALAR beta, TYPE *Y)
{
   const int M4 = (M>>2)<<2, N4 = (N>>2)<<2; 
   const int nr = N-N4, incAm = (lda<<2) - N4;
   const TYPE *stX = X + N4, *x; 
   const TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   TYPE *stY = Y + M4;
   register TYPE a00, a10, a20, a30, a01, a11, a21, a31;
   register TYPE a02, a12, a22, a32, a03, a13, a23, a33;
   register TYPE y0, y1, y2, y3, yy0, yy1, yy2, yy3;
   register TYPE x0, x1, x2, x3;

   if (N4 > 4)
   {
      if (M4)
      {
         do
         {
            a00 = *A0;   a01 = *A1;   a02 = *A2;   a03 = *A3;
            a10 = A0[1]; a11 = A1[1]; a12 = A2[1]; a13 = A3[1];
            a20 = A0[2]; a21 = A1[2]; a22 = A2[2]; a23 = A3[2];
            a30 = A0[3]; a31 = A1[3]; a32 = A2[3]; a33 = A3[3];
            A0 += 4;     A1 += 4;     A2 += 4;     A3 += 4;
            #ifdef BETA0
               y0 = y1 = y2 = y3 = yy0 = yy1 = yy2 = yy3 = ATL_rzero;
            #elif defined(BETAX)
               y0 = beta;
               yy0 = *Y; yy1 = Y[1]; yy2 = Y[2];  yy3 = Y[3];
               yy0 *= y0; yy1 *= y0; yy2 *= y0; yy3 *= y0;
               y0 = y1 = y2 = y3 = ATL_rzero;
            #else
               yy0 = *Y; yy1 = Y[1]; yy2 = Y[2];  yy3 = Y[3];
               y0 = y1 = y2 = y3 = ATL_rzero;
            #endif
            x0 = *X; x1 = X[1]; x2 = X[2]; x3 = X[3]; x = X + 4;
            do
            {
               y0  += a00 * x0; a00 = *A0;
               y1  += a01 * x0; a01 = *A1;
               yy0 += a10 * x1; a10 = A0[1];
               yy1 += a11 * x1; a11 = A1[1];
               y2  += a02 * x0; a02 = *A2;
               y3  += a03 * x0; a03 = *A3; x0 = *x;
               yy2 += a12 * x1; a12 = A2[1];
               yy3 += a13 * x1; a13 = A3[1]; x1 = x[1];

               y0  += a20 * x2; a20 = A0[2];
               y1  += a21 * x2; a21 = A1[2];
               yy0 += a30 * x3; a30 = A0[3]; A0 += 4;
               yy1 += a31 * x3; a31 = A1[3]; A1 += 4;
               y2  += a22 * x2; a22 = A2[2];
               y3  += a23 * x2; a23 = A3[2]; x2 = x[2];
               yy2 += a32 * x3; a32 = A2[3]; A2 += 4;
               yy3 += a33 * x3; a33 = A3[3]; A3 += 4; x3 = x[3]; x += 4;
            }
            while (x != stX);
            y0  += a00 * x0;
            y1  += a01 * x0;
            yy0 += a10 * x1;
            yy1 += a11 * x1;
            y2  += a02 * x0;
            y3  += a03 * x0;
            yy2 += a12 * x1;
            yy3 += a13 * x1;

            y0  += a20 * x2;
            y1  += a21 * x2;
            yy0 += a30 * x3;
            yy1 += a31 * x3;
            y2  += a22 * x2;
            y3  += a23 * x2;
            yy2 += a32 * x3;
            yy3 += a33 * x3;
            switch(nr)
            {
            case 1:
               x0 = *x;
               y0 += *A0 * x0;
               y1 += *A1 * x0;
               y2 += *A2 * x0;
               y3 += *A3 * x0;
               break;
            case 2:
               x0 = *x;
               x1 = x[1];
               y0  += *A0 * x0;
               y1  += *A1 * x0;
               yy0 += A0[1] * x1;
               yy1 += A1[1] * x1;
               y2  += *A2 * x0;
               y3  += *A3 * x0;
               yy2 += A2[1] * x1;
               yy3 += A3[1] * x1;
               break;
            case 3:
               x0 = *x;
               x1 = x[1];
               x2 = x[2];
               y0  += *A0 * x0;
               y1  += *A1 * x0;
               yy0 += A0[1] * x1;
               yy1 += A1[1] * x1;
               y2  += *A2 * x0;
               y3  += *A3 * x0;
               yy2 += A2[1] * x1;
               yy3 += A3[1] * x1;
               y0  += A0[2] * x2;
               y1  += A1[2] * x2;
               y2  += A2[2] * x2;
               y3  += A3[2] * x2;
               break;
            default:;
            }
            A0 += incAm;
            y0 += yy0;
            A1 += incAm;
            y1 += yy1;
            A2 += incAm;
            y2 += yy2;
            A3 += incAm;
            y3 += yy3;
            *Y = y0;
            Y[1] = y1;
            Y[2] = y2;
            Y[3] = y3;
            Y += 4;
         }
         while (Y != stY);
      }
      if (M-M4) gemvT_Msmall(M-M4, N, A0, lda, X, beta, Y);
   }
   else if (M) gemvT_Nsmall(M, N, A, lda, X, beta, Y);
}
@ROUT ATL_gemvT_2x16_1
static void gemvT2x16(const int M, const int N, const TYPE *A, const int lda,
                      const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int i;
   const int M2 = (M>>1)<<1, N16 = (N>>4)<<4; 
   const int incAm = (N16 ? (lda<<1) - N16 + 16 : (lda<<1));
   const int nr = (N16 ? N-N16+16 : N);
   TYPE *stY = Y + M2;
   const TYPE *stX = X + N16-16, *x; 
   const TYPE *A0 = A, *A1 = A + lda;
   register TYPE y0, y1, x0, x1;
   #ifndef ATL_PFD 
      #define ATL_PFD 12
   #endif

   if (M2)
   {
      do
      {
         #ifdef BETA0
            y0 = y1 = ATL_rzero;
         #elif defined(BETAX)
            y0 = *Y * beta; y1 = beta * Y[1];
         #else
            y0 = *Y; y1 = Y[1];
         #endif
         x = X;
         if (N16 > 16)
         {
            x0 = *x; x1 = x[1];
            do
            {
               y0 += x0 * *A0; ATL_pfl1R(A0+ATL_PFD); ATL_pfl1R(A1+ATL_PFD); 
                               ATL_pfl1R(A0+ATL_PFD+8); ATL_pfl1R(A1+ATL_PFD+8);
               y1 += x0 * *A1; x0 = x[2];
               y0 += x1 * A0[1];
               y1 += x1 * A1[1]; x1 = x[3];
               y0 += x0 * A0[2];
               y1 += x0 * A1[2]; x0 = x[4];
               y0 += x1 * A0[3];
               y1 += x1 * A1[3]; x1 = x[5];
               y0 += x0 * A0[4];
               y1 += x0 * A1[4]; x0 = x[6];
               y0 += x1 * A0[5];
               y1 += x1 * A1[5]; x1 = x[7];
               y0 += x0 * A0[6];
               y1 += x0 * A1[6]; x0 = x[8];
               y0 += x1 * A0[7];
               y1 += x1 * A1[7]; x1 = x[9];
               y0 += x0 * A0[8];  
                  ATL_pfl1R(A0+ATL_PFD+4); ATL_pfl1R(A1+ATL_PFD+4);
                  ATL_pfl1R(A0+ATL_PFD+12); ATL_pfl1R(A1+ATL_PFD+12);
               y1 += x0 * A1[8]; x0 = x[10];
               y0 += x1 * A0[9];
               y1 += x1 * A1[9]; x1 = x[11];
               y0 += x0 * A0[10];
               y1 += x0 * A1[10]; x0 = x[12];
               y0 += x1 * A0[11];
               y1 += x1 * A1[11]; x1 = x[13];
               y0 += x0 * A0[12];
               y1 += x0 * A1[12]; x0 = x[14];
               y0 += x1 * A0[13];
               y1 += x1 * A1[13]; x1 = x[15];
               y0 += x0 * A0[14]; x += 16;
               y1 += x0 * A1[14]; x0 = *x;
               y0 += x1 * A0[15]; A0 += 16;
               y1 += x1 * A1[15]; x1 = x[1]; A1 += 16;
            }
            while(x != stX);
         }
         for (i=0; i != nr; i++)
         {
            x0 = x[i];
            y0 += x0 * A0[i];
            y1 += x0 * A1[i];
         }
         A0 += incAm;
         *Y = y0;
         A1 += incAm;
         Y[1] = y1;
         Y += 2;
      }
      while (Y != stY);
   }
   if (M-M2) gemvT_Msmall(M-M2, N, A0, lda, X, beta, Y);
}
@ROUT ATL_gemvT_4x16_1
static void gemvT4x16(const int M, const int N, const TYPE *A, const int lda,
                      const TYPE *X, const SCALAR beta, TYPE *Y)
{
   int j;
   const int M4 = (M>>2)<<2, N16 = (N>>4)<<4, incAm = (lda<<2) - N; 
   const int nr = ( N16 ? N-N16+16 : N );
   const TYPE *stX = X + N16-16, *x; 
   const TYPE *A0 = A, *A1 = A + lda, *A2 = A1 + lda, *A3 = A2 + lda;
   TYPE *stY = Y + M4;
   register TYPE a00, a01, a02, a03, a10, a11, a12, a13;
   register TYPE b00, b01, b02, b03, b10, b11, b12, b13;
   register TYPE y0, y1, y2, y3, z0, z1, z2, z3;
   register TYPE x0, x1, x2, x3;
   #ifdef ATL_AltiVec
      int cwrd = ATL_MulBySize(N)>>4;     
      if (cwrd >= 64) cwrd = ATL_GetCtrl(512, (cwrd+31)>>5, 0);
      else cwrd = ATL_GetCtrl(64, (cwrd+3)>>2, 4); 
   #endif  


   if (N >= 10)
   {
      if (M4)
      {
         do
         {
            #ifdef ATL_AltiVec
               ATL_pfavR(A0, cwrd, 0);
               ATL_pfavR(A1, cwrd, 1);
               ATL_pfavR(A2, cwrd, 2);
               ATL_pfavR(A3, cwrd, 3);
            #endif

            a00 = *A0;   a01 = *A1;   a02 = *A2;   a03 = *A3;
            a10 = A0[1]; a11 = A1[1]; a12 = A2[1]; a13 = A3[1];
            b00 = A0[8]; b01 = A1[8]; b02 = A2[8]; b03 = A3[8];
            b10 = A0[9]; b11 = A1[9]; b12 = A2[9]; b13 = A3[9];
            #ifdef BETA0
               y0 = y1 = y2 = y3 = z0 = z1 = z2 = z3 = ATL_rzero;
            #elif defined(BETAX)
               y0 = beta;
               z0 = *Y; z1 = Y[1]; z2 = Y[2];  z3 = Y[3];
               z0 *= y0; z1 *= y0; z2 *= y0; z3 *= y0;
               y0 = y1 = y2 = y3 = ATL_rzero;
            #else
               z0 = *Y; z1 = Y[1]; z2 = Y[2];  z3 = Y[3];
               y0 = y1 = y2 = y3 = ATL_rzero;
            #endif
            x0 = *X; x1 = X[1]; x2 = X[8]; x3 = X[9]; x = X;
            if (N16 > 16)
            {
               do
               {
                  y0  += a00 * x0; a00 = A0[2];
                  y1  += a01 * x0; a01 = A1[2];
                  y2  += a02 * x0; a02 = A2[2];
                  y3  += a03 * x0; a03 = A3[2]; x0 = x[2];
                  z0  += b00 * x2; b00 = A0[10];
                  z1  += b01 * x2; b01 = A1[10];
                  z2  += b02 * x2; b02 = A2[10];
                  z3  += b03 * x2; b03 = A3[10]; x2 = x[10];
   
                  y0  += a10 * x1; a10 = A0[3];
                  y1  += a11 * x1; a11 = A1[3];
                  y2  += a12 * x1; a12 = A2[3];
                  y3  += a13 * x1; a13 = A3[3]; x1 = x[3];
                  z0  += b10 * x3; b10 = A0[11];
                  z1  += b11 * x3; b11 = A1[11];
                  z2  += b12 * x3; b12 = A2[11];
                  z3  += b13 * x3; b13 = A3[11]; x3 = x[11];
   
                  y0  += a00 * x0; a00 = A0[4];
                  y1  += a01 * x0; a01 = A1[4];
                  y2  += a02 * x0; a02 = A2[4];
                  y3  += a03 * x0; a03 = A3[4]; x0 = x[4];
                  z0  += b00 * x2; b00 = A0[12];
                  z1  += b01 * x2; b01 = A1[12];
                  z2  += b02 * x2; b02 = A2[12];
                  z3  += b03 * x2; b03 = A3[12]; x2 = x[12];
   
                  y0  += a10 * x1; a10 = A0[5];
                  y1  += a11 * x1; a11 = A1[5];
                  y2  += a12 * x1; a12 = A2[5];
                  y3  += a13 * x1; a13 = A3[5]; x1 = x[5];
                  z0  += b10 * x3; b10 = A0[13];
                  z1  += b11 * x3; b11 = A1[13];
                  z2  += b12 * x3; b12 = A2[13];
                  z3  += b13 * x3; b13 = A3[13]; x3 = x[13];
   
                  y0  += a00 * x0; a00 = A0[6];
                  y1  += a01 * x0; a01 = A1[6];
                  y2  += a02 * x0; a02 = A2[6];
                  y3  += a03 * x0; a03 = A3[6]; x0 = x[6];
                  z0  += b00 * x2; b00 = A0[14];
                  z1  += b01 * x2; b01 = A1[14];
                  z2  += b02 * x2; b02 = A2[14];
                  z3  += b03 * x2; b03 = A3[14]; x2 = x[14];
   
                  y0  += a10 * x1; a10 = A0[7];
                  y1  += a11 * x1; a11 = A1[7];
                  y2  += a12 * x1; a12 = A2[7];
                  y3  += a13 * x1; a13 = A3[7]; x1 = x[7];
                  z0  += b10 * x3; b10 = A0[15]; A0 += 16;
                  z1  += b11 * x3; b11 = A1[15]; A1 += 16;
                  z2  += b12 * x3; b12 = A2[15]; A2 += 16;
                  z3  += b13 * x3; b13 = A3[15]; x3 = x[15]; x += 16; A3 += 16;
   
                  y0  += a00 * x0; a00 = *A0;
                  y1  += a01 * x0; a01 = *A1;
                  y2  += a02 * x0; a02 = *A2;
                  y3  += a03 * x0; a03 = *A3; x0 = *x;
                  z0  += b00 * x2; b00 = A0[8];
                  z1  += b01 * x2; b01 = A1[8];
                  z2  += b02 * x2; b02 = A2[8];
                  z3  += b03 * x2; b03 = A3[8]; x2 = x[8];
   
                  y0  += a10 * x1; a10 = A0[1];
                  y1  += a11 * x1; a11 = A1[1];
                  y2  += a12 * x1; a12 = A2[1];
                  y3  += a13 * x1; a13 = A3[1]; x1 = x[1];
                  z0  += b10 * x3; b10 = A0[9];
                  z1  += b11 * x3; b11 = A1[9];
                  z2  += b12 * x3; b12 = A2[9];
                  z3  += b13 * x3; b13 = A3[9]; x3 = x[9];
               }
               while (x != stX);
            }
            for (j=(nr>>1); j; j--, A0 += 2, A1 += 2, A2 += 2, A3 += 2, x += 2)
            {
               x0 = *x; x1 = x[1];
               y0 += *A0 * x0;
               y1 += *A1 * x0;
               y2 += *A2 * x0;
               y3 += *A3 * x0;
               z0 += A0[1] * x1;
               z1 += A1[1] * x1;
               z2 += A2[1] * x1;
               z3 += A3[1] * x1;
            }
            if (nr != (nr>>1)<<1)
            {
               x0 = *x;
               z0 += *A0++ * x0;
               z1 += *A1++ * x0;
               z2 += *A2++ * x0;
               z3 += *A3++ * x0;
            }
            A0 += incAm;
            y0 += z0;
            A1 += incAm;
            y1 += z1;
            A2 += incAm;
            y2 += z2;
            A3 += incAm;
            y3 += z3;
            *Y = y0;
            Y[1] = y1;
            Y[2] = y2;
            Y[3] = y3;
            Y += 4;
         }
         while (Y != stY);
      }
      if (M-M4) gemvT_Msmall(M-M4, N, A0, lda, X, beta, Y);
   }
   else if (M) gemvT_Nsmall(M, N, A, lda, X, beta, Y);
}

@ROUT ATL_gemvT_4x8_1 ATL_gemvT_2x8_0 ATL_gemvT_mm ATL_gemvT_4x16_1 ATL_gemvT_2x16_1 ATL_gemvT_1x1_1
#define gemv0 Mjoin(Mjoin(Mjoin(Mjoin(gemvT,NM),_x1),BNM),_y1)
void Mjoin(PATL,gemv0)
   (const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY)
{
@ROUT ATL_gemvT_1x1_1
   int i, j;
   for (j=0; j != M; j++)
   {
      #ifdef BETA0
         Y[j] = ATL_rzero;
      #elif defined(BETAX)
         Y[j] *= beta;
      #endif
      for (i=0; i != N; i++) Y[j] += A[i+j*lda] * X[i];
   }
}
@ROUT ATL_gemvT_2x16_1
   gemvT2x16(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvT_4x16_1
   gemvT4x16(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvT_4x8_1
   gemvT4x4(M, N, A, lda, X, beta, Y);
@ROUT ATL_gemvT_2x8_0

   const int M2 = (M>>1)<<1, n4 = (N>>2)<<2; 
   const int nr = N-n4, incAm = (lda<<1) - n4;
   const TYPE *stX = X + n4 - 4, *x, *A0 = A, *A1 = A + lda;
   TYPE *stY = Y + M2;
   register TYPE y0, y1, yy0, yy1, x0, x1, x2, x3, m0, m1, m2, m3;
   register TYPE a00, a10, a20, a30, a01, a11, a21, a31;

   if (N >= 8)
   {
      if (M2)
      {
         do
         {
            x = X + 4;
            #ifdef BETA0
               y0 = y1 = yy0 = yy1 = ATL_rzero;
            #elif defined(BETAX)
               y0 = beta;
               yy0 = *Y * y0; yy1 = Y[1] * y0;
               y0 = y1 = ATL_rzero;
            #else
               yy0 = *Y; yy1 = Y[1];
               y0 = y1 = ATL_rzero;
            #endif
            a00 = *A0; a10 = A0[1]; a20 = A0[2]; a30 = A0[3]; A0 += 4;
            a01 = *A1; a11 = A1[1]; a21 = A1[2]; a31 = A1[3]; A1 += 4;
            x0 = *X; x1 = X[1]; x2 = X[2]; x3 = X[3];
            m0 = a00 * x0; a00 = *A0;
            m1 = a01 * x0; a01 = *A1; x0 = *x;
            m2 = a10 * x1; a10 = A0[1];
            m3 = a11 * x1; a11 = A1[1]; x1 = x[1];

            if (n4 != 8)
            {
               do
               {
                  y0  += m0; m0 = a20 * x2; a20 = A0[2];
                  y1  += m1; m1 = a21 * x2; a21 = A1[2]; x2 = x[2];
                  yy0 += m2; m2 = a30 * x3; a30 = A0[3]; A0 += 4;
                  yy1 += m3; m3 = a31 * x3; a31 = A1[3]; A1 += 4; 
                             x3 = x[3]; x += 4;
                  y0  += m0; m0 = a00 * x0; a00 = *A0;
                  y1  += m1; m1 = a01 * x0; a01 = *A1;   x0 = *x;
                  yy0 += m2; m2 = a10 * x1; a10 = A0[1];
                  yy1 += m3; m3 = a11 * x1; a11 = A1[1]; x1 = x[1];
               }
               while (x != stX);
            }
/*
 *          Drain pipes, then do cleanup
 */
            y0  += m0; m0 = a20 * x2; a20 = A0[2];
            y1  += m1; m1 = a21 * x2; a21 = A1[2]; x2 = x[2];
            yy0 += m2; m2 = a30 * x3; a30 = A0[3]; A0 += 4;
            yy1 += m3; m3 = a31 * x3; a31 = A1[3]; A1 += 4; x3 = x[3]; x += 4;
            y0  += m0; m0 = a00 * x0;
            y1  += m1; m1 = a01 * x0; 
            yy0 += m2; m2 = a10 * x1; 
            yy1 += m3; m3 = a11 * x1; 

            y0  += m0; m0 = a20 * x2;
            y1  += m1; m1 = a21 * x2;
            yy0 += m2; m2 = a30 * x3;
            yy1 += m3; m3 = a31 * x3;
            y0  += m0;
            y1  += m1;
            yy0 += m2;
            yy1 += m3;

            switch(nr)
            {
            case 1:
               x0 = *x;
               y0 += *A0 * x0;
               y1 += *A1 * x0;
               break;
            case 2:
               x0 = *x;
               x1 = x[1];
               y0  += *A0 * x0;
               y1  += *A1 * x0;
               yy0 += A0[1] * x1;
               yy1 += A1[1] * x1;
               break;
            case 3:
               x0 = *x;
               x1 = x[1];
               x2 = x[2];
               y0  += *A0 * x0;
               y1  += *A1 * x0;
               yy0 += A0[1] * x1;
               yy1 += A1[1] * x1;
               y0  += A0[2] * x2;
               y1  += A1[2] * x2;
               break;
            default:;
            }
            A0 += incAm;
            y0 += yy0;
            A1 += incAm;
            y1 += yy1;
            *Y = y0;
            Y[1] = y1;
            Y += 2;
         }
         while (Y != stY);
      }
      if (M-M2)
      {
         #ifdef BETA0
            *Y = Mjoin(PATL,dot)(N, X, 1, A0, 1);
         #else
            y0 = *Y;
            #ifdef BETAX
               y0 *= beta;
            #endif
            y0 += Mjoin(PATL,dot)(N, X, 1, A0, 1);
            *Y = y0;
         #endif
      }
   }
   else if (M) gemvT_Nsmall(M, N, A, lda, X, beta, Y);

@ROUT ATL_gemvT_mm

   Mjoin(PATL,NCmmJIK)(AtlasTrans, AtlasNoTrans, M, 1, N, ATL_rone, A, lda,
                       X, N, beta, Y, M);

@ROUT ATL_gemvT_4x8_1 ATL_gemvT_2x8_0 ATL_gemvT_mm ATL_gemvT_4x16_1 ATL_gemvT_2x16_1
}
@ROUT ATL_gemvT_old
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#define ATL_NOMULADD
#define ATL_mmnreg 7

void Mjoin(Mjoin(Mjoin(Mjoin(Mjoin(PATL,gemvT),NM),_x1),BNM),_y1)
   (const int M, const int N, const SCALAR alpha, const TYPE *A, const int lda,
    const TYPE *X, const int incX, const SCALAR beta, TYPE *Y, const int incY)
{
#if defined(ATL_NOMULADD)
   const int M2 = (M>>1)<<1;
   int ib, n4, nr, incA, i;
   const TYPE *pA0=A, *pA1 = A + lda;
   const TYPE *x, *stX;
   TYPE *y=Y, *stY = Y + M2;
   #if ATL_mmnreg >= 18
      register TYPE m0, m1, m2, m3, x0, x1, y0, y1, yy0, yy1;
      register TYPE a00, a10, a20, a30, a01, a11, a21, a31;
   #else
      register TYPE m0, m1, m2, m3, y0, y1, x0;
   #endif

   ATL_FindPtrAdjust(A, ib);
   if (ib > N) ib = N;
   n4 = ((N-ib)>>2)<<2;
   nr = N - ib - n4;
   stX = X + ib + (n4 - 4);
   incA = lda + lda - (N-nr);
@skip fprintf(stderr, "line %d of %s: ib=%d, n4=%d, nr=%d\n", __LINE__,__FILE__,ib,n4,nr);

   if (M2)
   {
      do
      {
         x = X + (ib SHIFT);
         #if ATL_mmnreg >= 18
            #ifdef BETA0
               yy0 = yy1 = ATL_rzero;
            #elif defined(BETA1)
               yy0 = *y; yy1 = y[1];
            #else
               yy0 = *y; yy1 = y[1];
               yy0 *= beta;  yy1 *= beta;
            #endif
         #elif !defined(BETA0)
            m0 = *y;
            m1 = y[1];
            #ifndef BETA1
               m0 *= beta;
               m1 *= beta;
            #endif
         #endif
         if (ib)  /* partial first block to get alignment on cache boundary */
         {
            switch(ib)
            {
            case 1:
               y0 = *pA0++ * *X;
               y1 = *pA1++ * *X;
               break;
            case 2:
               y0 = *pA0 * *X + pA0[1] * X[1];
               y1 = *pA1 * *X + pA1[1] * X[1];
               pA0 += 2;
               pA1 += 2;
               break;
            case 3:
               y0 = *pA0 * *X + pA0[1] * X[1] + pA0[2] * X[2];
               y1 = *pA1 * *X + pA1[1] * X[1] + pA1[2] * X[2];
               pA0 += 3;
               pA1 += 3;
               break;
            case 4:
               y0 = *pA0 * *X + pA0[1] * X[1] + pA0[2] * X[2] + pA0[3] * X[3];
               y1 = *pA1 * *X + pA1[1] * X[1] + pA1[2] * X[2] + pA1[3] * X[3];
               pA0 += 4;
               pA1 += 4;
               break;
            case 5:
               y0 = *pA0 * *X + pA0[1] * X[1] + pA0[2] * X[2] + pA0[3] * X[3] + 
                    pA0[4] * X[4];
               y1 = *pA1 * *X + pA1[1] * X[1] + pA1[2] * X[2] + pA1[3] * X[3] + 
                    pA1[4] * X[4];
               pA0 += 5;
               pA1 += 5;
               break;
            case 6:
               y0 = *pA0 * *X + pA0[1] * X[1] + pA0[2] * X[2] + pA0[3] * X[3] + 
                    pA0[4] * X[4] + pA0[5] * X[5];
               y1 = *pA1 * *X + pA1[1] * X[1] + pA1[2] * X[2] + pA1[3] * X[3] + 
                    pA1[4] * X[4] + pA1[5] * X[5];
               pA0 += 6;
               pA1 += 6;
               break;
            case 7:
               y0 = *pA0 * *X + pA0[1] * X[1] + pA0[2] * X[2] + pA0[3] * X[3] + 
                    pA0[4] * X[4] + pA0[5] * X[5] + pA0[6] * X[6];
               y1 = *pA1 * *X + pA1[1] * X[1] + pA1[2] * X[2] + pA1[3] * X[3] + 
                    pA1[4] * X[4] + pA1[5] * X[5] + pA1[6] * X[6];
               pA0 += 7;
               pA1 += 7;
               break;
            default:
               for (i=0; i != ib; i++)
               {
                  y0 += pA0[i] * X[i];
                  y1 += pA1[i] * X[i];
               }
               pA0 += ib;
               pA1 += ib;
            }
         }
         else y0 = y1 = ATL_rzero;
/*
 *       Perform 4x2 unrolling, 4-cycle fp latency hiding, with prefetch
 */
   #if ATL_mmnreg >= 18
         if (n4)  /* can do 4 unrolling */
         {
            a00 = *pA0, a01 = *pA1;
            x0 = *x; x1 = x[1];
            a10 = pA0[1]; a11 = pA1[1];
            a20 = pA0[2]; a21 = pA1[2];
            a30 = pA0[3]; a31 = pA1[3];
            pA0 += 4; pA1 += 4;
            m0 = x0 * a00;  a00 = *pA0;
            m1 = x0 * a01;  a01 = *pA1;
            x0 = x[2];
            m2 = x1 * a10;  a10 = pA0[1];
            m3 = x1 * a11;  a11 = pA1[1];
            x1 = x[3];
            x += 4;
            if (x != stX)
            {
               do
               {
                  y0 += m0;
                  m0 = x0 * a20;
                  a20 = pA0[2];
                  y1 += m1;
                  m1 = x0 * a21;
                  x0 = *x;
                  a21 = pA1[2];
                  yy0 += m2;
                  m2 = a30 * x1;
                  a30 = pA0[3];
                  pA0 += 4;
                  yy1 += m3;
                  m3 = a31 * x1;
                  a31 = pA1[3];
                  x1 = X[1];
                  pA1 += 4;
                  y0 += m0;
                  m0 = x0 * a00;
                  a00 = *pA0;
                  y1 += m1;
                  m1 = x0 * a01;
                  a01 = *pA1;
                  x0 = x[2];
                  yy0 += m2;
                  m2 = x1 * a10;
                  a10 = pA0[1];
                  yy1 += m3;
                  m3 = x1 * a11;
                  a11 = pA1[1];
                  x1 = x[3];
                  x += 4;
               }
               while (x != stX);
            }
            y0 += m0;
            m0 = x0 * a20;
            y1 += m1;
            m1 = x0 * a21;
            yy0 += m2;
            m2 = a30 * x1;
            yy1 += m3;
            m3 = a31 * x1;
            y0 += m0;
            pA0 += 4;
            y1 += m1;
            pA1 += 4;
            yy0 += m2;
            x += 4;
            yy1 += m3;
         }
   #else  /* low register code (i.e., x86) */
         #ifndef BETA0
            y0 += m0;
            y1 += m1;
         #endif
         if (n4)  /* can do 4 unrolling */
         {
            m0 = *pA0;
            m1 = *pA1;
            x0 = *x;
            m2 = pA0[1];
            m3 = pA1[1];
            m0 *= x0;
            m1 *= x0;
            x0 = x[1];
            m2 *= x0;
            m3 *= x0;
            x0 = x[2];
            if (n4 != 4)
            {
               do
               {
                  y0 += m0;
                  m0 = pA0[2] * x0;
                  y1 += m1;
                  m1 = pA1[2] * x0;
                  x0 = x[3];
                  x += 4;
                  y0 += m2;
                  m2 = pA0[3] * x0;
                  pA0 += 4;
                  y1 += m3;
                  m3 = pA1[3] * x0;
                  x0 = *x;
                  pA1 += 4;
                  y0 += m0;
                  m0 = *pA0 * x0;
                  y1 += m1;
                  m1 = *pA1 * x0;
                  x0 = x[1];
                  y0 += m2;
                  m2 = pA0[1] * x0;
                  y1 += m3;
                  m3 = pA1[1] * x0;
                  x0 = x[2];
               }
               while (x != stX);
            }
            y0 += m0;
            m0 = pA0[2] * x0;
            y1 += m1;
            m1 = pA1[2] * x0;
            x0 = x[3];
            y0 += m2;
            m2 = pA0[3] * x0;
            y1 += m3;
            m3 = pA1[3] * x0;
            y0 += m0;
            pA0 += 4;
            y1 += m1;
            pA1 += 4;
            y0 += m2;
            x += 4;
            y1 += m3;
         }
   #endif
   
         switch(nr)  /* cleanup last part of loop */
         {
         case 1:
            y0 += *pA0 * *x;
            y1 += *pA1 * *x;
            break;
         case 2:
            y0 += *pA0 * *x + pA0[1] * x[1];
            y1 += *pA1 * *x + pA1[1] * x[1];
            break;
         case 3:
            y0 += *pA0 * *x + pA0[1] * x[1] + pA0[2] * x[2];
            y1 += *pA1 * *x + pA1[1] * x[1] + pA1[2] * x[2];
            break;
         case 0 : ;
         }
         #if ATL_mmnreg >= 18
            y0 += yy0;
            y1 += yy1;
         #endif
         *y = y0;
         y[1] = y1;
         y += 2;
         pA0 += incA;
         pA1 += incA;
      }
      while(y != stY);
   }
   #ifdef BETA0
      if (M != M2) *y = Mjoin(PATL,dot)(N, X, 1, pA0, 1);
   #elif defined BETA1
      if (M != M2) *y += Mjoin(PATL,dot)(N, X, 1, pA0, 1);
   #else
      if (M != M2) *y = beta * *y + Mjoin(PATL,dot)(N, X, 1, pA0, 1);
   #endif
#else
   void Mjoin(PATL,refgemv)
   (const enum ATLAS_TRANS TA, const int M, const int N, const SCALAR alpha,
    const TYPE *A, const int lda, const TYPE *X, const int incX,
    const SCALAR beta, TYPE *Y, const int incY);

   Mjoin(PATL,refgemv)(TransA, M, N, alpha, A, lda, X, incX, beta, Y, incY);
#endif
}
@ROUT ATL_trmvUT
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_level2.h"
#include "atlas_mv.h"

#ifndef Conj_
   #define gemv0 Mjoin(PATL,gemvT_a1_x1_b0_y1)
   #define gemv Mjoin(PATL,gemvT_a1_x1_b1_y1)
   #define trmv Mjoin(PATL,trmvUT)
   #define ktrmvN Mjoin(PATL,ktrmvUTN)
   #define ktrmvU Mjoin(PATL,ktrmvUTU)
#else
   #define gemv0 Mjoin(PATL,gemvC_a1_x1_b0_y1)
   #define gemv Mjoin(PATL,gemvC_a1_x1_b1_y1)
   #define trmv Mjoin(PATL,trmvUC)
   #define ktrmvN Mjoin(PATL,ktrmvUCN)
   #define ktrmvU Mjoin(PATL,ktrmvUCU)
#endif
void trmv(const enum ATLAS_DIAG Diag, const int N, const TYPE *A, const int lda,
          const TYPE *X, TYPE *Y)
{
   int i, mb;
   int incA;
   #ifdef TCPLX
      TYPE one[3] = {ATL_rone, ATL_rzero, ATL_rzero}, *zero = one + 1;
      int incmb;
   #else
      #define one ATL_rone
      #define zero ATL_rzero
      #define incmb mb
   #endif
   void (*ktrmv)(const int N, const TYPE *A, const int lda, 
                 const TYPE *X, const int BetaIsOne, TYPE *Y);

   if (Diag == AtlasNonUnit) ktrmv = ktrmvN;
   else ktrmv = ktrmvU;

   ATL_GetPartMVT(A, lda, &mb, &i);
   mb = Mmin(mb, N);
   #ifdef TCPLX
      incmb = mb SHIFT;
   #endif
   incA = lda * incmb;

   ktrmv(mb, A, lda, X, 0, Y);
   if (mb != N)
   {
      A += incA; Y += incmb;
      gemv0(N-mb, mb, one, A, lda, X, 1, zero, Y, 1);
      X += incmb; A += incmb;
   
      for (i=mb; i < N; i += mb)
      {
         mb = Mmin(mb, N-i);
         ktrmv(mb, A, lda, X, 1, Y);
         A += incA; Y += incmb;
         gemv(N-i-mb, mb, one, A, lda, X, 1, one, Y, 1);
         X += incmb; A += incmb;
      }
   }
}
@ROUT ATL_trmvUN
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_level2.h"
#include "atlas_mv.h"

#ifndef Conj_
   #define gemv Mjoin(PATL,gemvN_a1_x1_b1_y1)
   #define trmv Mjoin(PATL,trmvUN)
   #define ktrmvN Mjoin(PATL,ktrmvUNN)
   #define ktrmvU Mjoin(PATL,ktrmvUNU)
#else
   #define gemv Mjoin(PATL,gemvNc_a1_x1_b1_y1)
   #define trmv Mjoin(PATL,trmvUNc)
   #define ktrmvN Mjoin(PATL,ktrmvUNcN)
   #define ktrmvU Mjoin(PATL,ktrmvUNcU)
#endif
void trmv(const enum ATLAS_DIAG Diag, const int N, const TYPE *A, const int lda,
          const TYPE *X, TYPE *Y)
{
   int j, kb, mb, nb;
   int incA;
   #ifdef TCPLX
      TYPE one[2] = {1.0, 0.0};
      const int lda2 = lda << 1;
   #else
      #define one ATL_rone
      #define lda2 lda
   #endif
   void (*ktrmv)(const int N, const TYPE *A, const int lda, 
                 const TYPE *X, const int BetaIsOne, TYPE *Y);

   if (Diag == AtlasNonUnit) ktrmv = ktrmvN;
   else ktrmv = ktrmvU;

   ATL_GetPartMVN(A, lda, &mb, &nb);
   if (mb > N) mb = nb = N;
   if (nb > N) nb = nb = N;

   ktrmv(mb, A, lda, X, 0, Y);
   if (mb != N)
   {
      incA = nb * lda2;
      A += mb*lda2;
      X += mb SHIFT;
@skip      Mjoin(PATL,zero)(N-mb, Y+(mb SHIFT), 1);
      for (j=mb; j < N; j += nb)
      {
         kb = Mmin(nb,N-j);
         gemv(j, kb, one, A, lda, X, 1, one, Y, 1);
         ktrmv(kb, A+(j SHIFT), lda, X, 0, Y+(j SHIFT));
         A += incA;
         X += nb SHIFT;
      }
   }
}
@ROUT ATL_trmvLN
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_level2.h"
#include "atlas_mv.h"

#ifndef Conj_
   #define gemv0 Mjoin(PATL,gemvN_a1_x1_b0_y1)
   #define gemv Mjoin(PATL,gemvN_a1_x1_b1_y1)
   #define trmv Mjoin(PATL,trmvLN)
   #define ktrmvN Mjoin(PATL,ktrmvLNN)
   #define ktrmvU Mjoin(PATL,ktrmvLNU)
#else
   #define gemv0 Mjoin(PATL,gemvNc_a1_x1_b0_y1)
   #define gemv Mjoin(PATL,gemvNc_a1_x1_b1_y1)
   #define trmv Mjoin(PATL,trmvLNc)
   #define ktrmvN Mjoin(PATL,ktrmvLNcN)
   #define ktrmvU Mjoin(PATL,ktrmvLNcU)
#endif
void trmv(const enum ATLAS_DIAG Diag, const int N, const TYPE *A, const int lda,
          const TYPE *X, TYPE *Y)
{
   int j, nb;
   int incA;
   #ifdef TCPLX
      int incnb;
      TYPE one[3] = {1.0, 0.0, 0.0}, *zero = one + 1;
   #else
      #define one  ATL_rone
      #define zero ATL_rzero
      #define incnb nb
   #endif
   void (*ktrmv)(const int N, const TYPE *A, const int lda, 
                 const TYPE *X, const int BetaIsOne, TYPE *Y);

   if (Diag == AtlasNonUnit) ktrmv = ktrmvN;
   else ktrmv = ktrmvU;

   ATL_GetPartMVN(A, lda, &j, &nb);
   if (nb > N) nb = N;

   ktrmv(nb, A, lda, X, 0, Y);
   if (nb != N)
   {
      #ifdef TCPLX
         incnb = nb SHIFT;
      #endif
      Y += incnb;
      incA = incnb * (lda + 1);
      gemv0(N-nb, nb, one, A+incnb, lda, X, 1, zero, Y, 1);
      for (j=nb; j < N; j += nb)
      {
         X += incnb;
         A += incA;
         nb = Mmin(nb,N-j);
         ktrmv(nb, A, lda, X, 1, Y);
         Y += incnb;
         gemv(N-nb-j, nb, one, A+incnb, lda, X, 1, one, Y, 1);
      }
   }
}
@ROUT ATL_trmvLT
#include "atlas_misc.h"
#include "atlas_lvl2.h"
#include "atlas_level2.h"
#include "atlas_mv.h"

#ifndef Conj_
   #define gemv Mjoin(PATL,gemvT_a1_x1_b1_y1)
   #define trmv Mjoin(PATL,trmvLT)
   #define ktrmvN Mjoin(PATL,ktrmvLTN)
   #define ktrmvU Mjoin(PATL,ktrmvLTU)
#else
   #define gemv Mjoin(PATL,gemvC_a1_x1_b1_y1)
   #define trmv Mjoin(PATL,trmvLC)
   #define ktrmvN Mjoin(PATL,ktrmvLCN)
   #define ktrmvU Mjoin(PATL,ktrmvLCU)
#endif
void trmv(const enum ATLAS_DIAG Diag, const int N, const TYPE *A, const int lda,
          const TYPE *X, TYPE *Y)
{
   int i, mb, nb;
   int incA;
   #ifdef TCPLX
      const int lda2 = lda<<1;
      int incmb;
      TYPE one[2] = {1.0, 0.0};
   #else
      #define one  ATL_rone
      #define incmb mb
      #define lda2 lda
   #endif
   void (*ktrmv)(const int N, const TYPE *A, const int lda, 
                 const TYPE *X, const int BetaIsOne, TYPE *Y);

   if (Diag == AtlasNonUnit) ktrmv = ktrmvN;
   else ktrmv = ktrmvU;

   ATL_GetPartMVT(A, lda, &mb, &nb);
   if (mb > N) mb = nb = N;
   else if (nb > N) nb = mb = N;

   ktrmv(nb, A, lda, X, 0, Y);
   if (nb != N)
   {
      #ifdef TCPLX
         incmb = mb SHIFT;
      #endif
      X += nb SHIFT;
      A += nb SHIFT;
      for (i=nb; i < N; i += mb)
      {
         mb = Mmin(mb,N-i);
         gemv(i, mb, one, A, lda, X, 1, one, Y, 1);
         ktrmv(mb, A+i*lda2, lda, X, 0, Y+(i SHIFT));
         X += incmb;
         A += incmb;
      }
   }
}
@ROUT ATL_trmv
#include "atlas_misc.h"
#include "atlas_level2.h"
#include "atlas_lvl2.h"
void Mjoin(PATL,trmv)(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TA,
                      const enum ATLAS_DIAG Diag, const int N,
                      const TYPE *A, const int lda, TYPE *X, const int incX)
{
   void *vy=NULL, *vx;
   TYPE *x, *y, *tptr;

   vx = malloc(ATL_Cachelen + ATL_MulBySize(N));
   ATL_assert(vx);
   x = ATL_AlignPtr(vx);
   if (incX == 1) y = X;
   else
   {
      vy = malloc(ATL_Cachelen + ATL_MulBySize(N));
      ATL_assert(vy);
      y = ATL_AlignPtr(vy);
   }
   Mjoin(PATL,copy)(N, X, incX, x, 1);
   if (N)
   {
      if (Uplo == AtlasUpper)
      {
#ifndef ATL_RecurOnly
         if (TA == AtlasNoTrans) Mjoin(PATL,trmvUN)(Diag, N, A, lda, x, y);
         #ifdef TCPLX
            else if (TA == AtlasConjTrans) 
               Mjoin(PATL,trmvUC)(Diag, N, A, lda, x, y);
            else if (TA == AtlasConj)
               Mjoin(PATL,trmvUNc)(Diag, N, A, lda, x, y);
         #endif
         else Mjoin(PATL,trmvUT)(Diag, N, A, lda, x, y);
#else
         if (Diag == AtlasNonUnit)
         {
            if (TA == AtlasNoTrans) Mjoin(PATL,ktrmvUNN)(N, A, lda, x, 0, y);
            #ifdef TCPLX
               else if (TA == AtlasConjTrans) 
                  Mjoin(PATL,ktrmvUCN)(N, A, lda, x, 0, y);
               else if (TA == AtlasConj)
                  Mjoin(PATL,ktrmvUNcN)(N, A, lda, x, 0, y);
            #endif
            else Mjoin(PATL,ktrmvUTN)(N, A, lda, x, 0, y);
         }
         else
         {
            if (TA == AtlasNoTrans) Mjoin(PATL,ktrmvUNU)(N, A, lda, x, 0, y);
            #ifdef TCPLX
               else if (TA == AtlasConjTrans) 
                  Mjoin(PATL,ktrmvUCU)(N, A, lda, x, 0, y);
               else if (TA == AtlasConj)
                  Mjoin(PATL,ktrmvUNcU)(N, A, lda, x, 0, y);
            #endif
            else Mjoin(PATL,ktrmvUTU)(N, A, lda, x, 0, y);
         }
#endif
      }
      else
      {
#ifndef ATL_RecurOnly
         if (TA == AtlasNoTrans) Mjoin(PATL,trmvLN)(Diag, N, A, lda, x, y);
         #ifdef TCPLX
            else if (TA == AtlasConjTrans) 
               Mjoin(PATL,trmvLC)(Diag, N, A, lda, x, y);
            else if (TA == AtlasConj)
               Mjoin(PATL,trmvLNc)(Diag, N, A, lda, x, y);
         #endif
         else Mjoin(PATL,trmvLT)(Diag, N, A, lda, x, y);
#else
         if (Diag == AtlasNonUnit)
         {
            if (TA == AtlasNoTrans) Mjoin(PATL,ktrmvLNN)(N, A, lda, x, 0, y);
            #ifdef TCPLX
               else if (TA == AtlasConjTrans) 
                  Mjoin(PATL,ktrmvLCN)(N, A, lda, x, 0, y);
               else if (TA == AtlasConj)
                  Mjoin(PATL,ktrmvLNcN)(N, A, lda, x, 0, y);
            #endif
            else Mjoin(PATL,ktrmvLTN)(N, A, lda, x, 0, y);
         }
         else
         {
            if (TA == AtlasNoTrans) Mjoin(PATL,ktrmvLNU)(N, A, lda, x, 0, y);
            #ifdef TCPLX
               else if (TA == AtlasConjTrans) 
                  Mjoin(PATL,ktrmvLCU)(N, A, lda, x, 0, y);
               else if (TA == AtlasConj)
                  Mjoin(PATL,ktrmvLNcU)(N, A, lda, x, 0, y);
            #endif
            else Mjoin(PATL,ktrmvLTU)(N, A, lda, x, 0, y);
         }
#endif
      }
   }
   free(vx);
   if (vy)
   {
      Mjoin(PATL,copy)(N, y, 1, X, incX);
      free(vy);
   }
}
@ROUT symv
void Mjoin(PATL,symvL)(const int N, const SCALAR alpha, const TYPE *A,
                       const int lda, const TYPE *X, const int incX,
                       const SCALAR beta, TYPE *Y, const int incY)
{
/*
 * Figure partioning for A
 */
   ATL_GetPartMVN(A, lda, &mb, &i);
   ATL_GetPartMVT(A, lda, &i, &nb);
   if (ATL_pagesize > lda) maxNB = (ATL_pagesize / lda) * ATL_ntlb;
   else maxNB = ATL_ntlb;
   nb = ATL_lcm(mb, nb);
   size = (3*ATL_L1elts)>>3;
   while (nb*(2+nb) < size) nb >>= 1;
   nb <<= 1;

/*
 * Figure mb & nb partitioning for A
 */
   size = (3*ATL_L1elts)>>3;
   while (mb+nb+mb*nb < size)
   {
      if (mb<<1 <= maxNB) mb <<= 1;
      nb <<= 1;
      if (mb+nb+mb*nb > size)
      {
         nb >>= 1;
         break;
      }
   }
   if (mb+nb+mb*nb > size) mb >>= 1;
   ksymv(AtlasLower, nb
}
@ROUT mvtest
#include "atlas_misc.h"
#include "atlas_tst.h"
#include "atlas_lvl2.h"
int FAx=0, MAx=0, FAy=0, MAy=0, FAa=0, MAa=0;
@extract -b @(topd)/FAmalloc.inc

int CheckAns(int M, int N, SCALAR beta, TYPE *Y, TYPE *Y0)
{
   TYPE eps, diff;
   #ifdef TCPLX
      const int M2 = M<<1, mul=8;
   #else
      const int M2 = M, mul=4;
   #endif
   int i, ierr=0;

   eps = Mjoin(PATL,epsilon)();
   for (i=0; i < M2; i++)
   {
      diff = Y0[i] - Y[i];
      if (diff < 0.0) diff = -diff;
      if (diff > N*mul*eps + 2.0*eps)
      {
         ierr = i+1;
         fprintf(stderr, "Y[%d] = %f, expected %f\n", i, Y[i], Y0[i]);
      }
   }
   return(ierr);
}

#ifdef TREAL
static void dumb_gemv(enum ATLAS_TRANS TA, int M, int N, SCALAR alpha, 
                      TYPE *A, int lda, TYPE *X, SCALAR beta, TYPE *Y)
{
   register TYPE y0;
   int i, j;

   ATL_assert(alpha == ATL_rone);
   if (beta == ATL_rzero) Mjoin(PATL,zero)(M, Y, 1);
   else if (beta != ATL_rone) Mjoin(PATL,scal)(M, beta, Y, 1);

   if (TA == AtlasNoTrans)
   {
      for (j=0; j < N; j++) Mjoin(PATL,axpy)(M, X[j], A+j*lda, 1, Y, 1);
   }
   else
   {
      for (i=0; i < M; i++)
      {
         y0 = Y[i];
         for (j=0; j < N; j++) y0 += A[i*lda+j] * X[j];
         Y[i] = y0;
      }
   }
}
#else
static void dumb_gemv(enum ATLAS_TRANS TA, int M, int N, SCALAR alpha, 
                      TYPE *A, int lda, TYPE *X, SCALAR beta, TYPE *Y)
{
   register TYPE ry, iy, rx, ix, ra, ia;
   int i, j;
   const int M2 = M<<1, N2 = N<<1;

   ATL_assert(SCALAR_IS_ONE(alpha));
   if ( SCALAR_IS_ZERO(beta) ) Mjoin(PATL,zero)(M, Y, 1);
   else if ( !SCALAR_IS_ONE(beta) ) Mjoin(PATL,scal)(M, beta, Y, 1);

   if (TA == AtlasNoTrans)
      for (j=0; j < N; j++) Mjoin(PATL,axpy)(M, X+2*j, A+j*2*lda, 1, Y, 1);
   else if (TA == AtlasConj)
      for (j=0; j < N; j++) Mjoin(PATL,axpyConj)(M, X+2*j, A+j*2*lda, 1, Y, 1);
   else if (TA == AtlasTrans)
   {
      for (i=0; i < M2; i += 2)
      {
         ry = Y[i];
         iy = Y[i+1];
         for (j=0; j < N2; j += 2)
         {
            ra = A[i*lda+j]; ia = A[i*lda+j+1];
            rx = X[j];       ix = X[j+1];
            ry += rx * ra - ix * ia;
            iy += rx * ia + ix * ra;
         }
         Y[i] = ry;
         Y[i+1] = iy;
      }
   }
   else if (TA == AtlasConjTrans)
   {
      for (i=0; i < M2; i += 2)
      {
         ry = Y[i];
         iy = Y[i+1];
         for (j=0; j < N2; j += 2)
         {
            ra = A[i*lda+j]; ia = -A[i*lda+j+1];
            rx = X[j];       ix = X[j+1];
            ry += rx * ra - ix * ia;
            iy += rx * ia + ix * ra;
         }
         Y[i] = ry;
         Y[i+1] = iy;
      }
   }
}
#endif

int RunTest(enum ATLAS_TRANS TA, int M, int N, int lda, TYPE *beta0)
{
   #ifdef TCPLX
      TYPE alpha[2] = {ATL_rone, ATL_rzero};
      #define beta beta0
   #else
      TYPE alpha= ATL_rone;
      TYPE beta = *beta0;
   #endif
   TYPE *A, *X, *Y, *Y0;
   int mA, nA, ierr;
   char cta, ln[32];

   if (TA == AtlasNoTrans) cta = 'N';
   else if (TA == AtlasTrans) cta = 'T';
   else if (TA == AtlasConjTrans) cta = 'C';
   else cta = '-';
   if (TA == AtlasNoTrans || TA == AtlasConj) { mA = M; nA = N; }
   else { mA = N; nA = M; }

   #ifdef TREAL
      fprintf(stdout, "   TEST TA=%c, M=%d, N=%d, lda=%d, beta=%f STARTED\n",
              cta, M, N, lda, beta);
   #else
      fprintf(stdout, 
              "   TEST TA=%c, M=%d, N=%d, lda=%d, beta=(%f,%f) STARTED\n",
              cta, M, N, lda, *beta, beta[1]);
   #endif
   A = FA_malloc(lda * ATL_MulBySize(nA), FAa, MAa);
   X = FA_malloc(ATL_MulBySize(N), FAx, MAx);
   Y = FA_malloc(ATL_MulBySize(M), FAy, MAy);
   Y0 = FA_malloc(ATL_MulBySize(M), FAy, MAy);
   ATL_assert(A && X && Y && Y0);
   Mjoin(PATL,gegen)(mA, nA, A, lda, M*N+lda);
   Mjoin(PATL,gegen)(N, 1, X, N, N*1139+52);
   if ( !SCALAR_IS_ZERO(beta) )
   {
      Mjoin(PATL,gegen)(M, 1, Y, M, M*8897+112);
      Mjoin(PATL,gegen)(M, 1, Y0, M, M*8897+112);
   }

   if (TA == AtlasNoTrans)
   {
      if ( SCALAR_IS_ZERO(beta) )
         Mjoin(PATL,gemvN_a1_x1_b0_y1)(M, N, alpha, A, lda, X, 1, 
                                       beta, Y, 1);
      else if ( SCALAR_IS_ONE(beta) )
         Mjoin(PATL,gemvN_a1_x1_b1_y1)(M, N, alpha, A, lda, X, 1, 
                                       beta, Y, 1);
      #ifdef TCPLX
         else if (beta[1] == ATL_rzero)
            Mjoin(PATL,gemvN_a1_x1_bXi0_y1)(M, N, alpha, A, lda, X, 1, 
                                            beta, Y, 1);
      #endif
      else
         Mjoin(PATL,gemvN_a1_x1_bX_y1)(M, N, alpha, A, lda, X, 1, 
                                       beta, Y, 1);
   }
   else if (TA == AtlasTrans)
   {
      if ( SCALAR_IS_ZERO(beta) )
         Mjoin(PATL,gemvT_a1_x1_b0_y1)(M, N, alpha, A, lda, X, 1, 
                                       beta, Y, 1);
      else if ( SCALAR_IS_ONE(beta) )
         Mjoin(PATL,gemvT_a1_x1_b1_y1)(M, N, alpha, A, lda, X, 1, 
                                       beta, Y, 1);
      #ifdef TCPLX
         else if (beta[1] == ATL_rzero)
            Mjoin(PATL,gemvT_a1_x1_bXi0_y1)(M, N, alpha, A, lda, X, 1, 
                                            beta, Y, 1);
      #endif
      else
         Mjoin(PATL,gemvT_a1_x1_bX_y1)(M, N, alpha, A, lda, X, 1, 
                                       beta, Y, 1);
   }
   #ifdef TCPLX
      else if (TA == AtlasConj)
      {
         if (beta[1] == ATL_rzero)
         {
            if (*beta == ATL_rzero)
               Mjoin(PATL,gemvNc_a1_x1_b0_y1)(M, N, alpha, A, lda, X, 1, 
                                              beta, Y, 1);
            else if (*beta == ATL_rone)
               Mjoin(PATL,gemvNc_a1_x1_b1_y1)(M, N, alpha, A, lda, X, 1, 
                                              beta, Y, 1);
            else
               Mjoin(PATL,gemvNc_a1_x1_bXi0_y1)(M, N, alpha, A, lda, X, 1, 
                                                beta, Y, 1);
         }
         else Mjoin(PATL,gemvNc_a1_x1_bX_y1)(M, N, alpha, A, lda, X, 1, 
                                             beta, Y, 1);
      }
      else if (TA == AtlasConjTrans)
      {
         if (beta[1] == ATL_rzero)
         {
            if (*beta == ATL_rzero)
               Mjoin(PATL,gemvC_a1_x1_b0_y1)(M, N, alpha, A, lda, X, 1, 
                                             beta, Y, 1);
            else if (*beta == ATL_rone)
               Mjoin(PATL,gemvC_a1_x1_b1_y1)(M, N, alpha, A, lda, X, 1, 
                                             beta, Y, 1);
            else
               Mjoin(PATL,gemvC_a1_x1_bXi0_y1)(M, N, alpha, A, lda, X, 1, 
                                               beta, Y, 1);
         }
         else Mjoin(PATL,gemvC_a1_x1_bX_y1)(M, N, alpha, A, lda, X, 1, 
                                            beta, Y, 1);
      }
   #endif
   dumb_gemv(TA, M, N, alpha, A, lda, X, beta, Y0);

   FA_free(A, FAa, MAa);
   FA_free(X, FAx, MAx);

   ierr = CheckAns(M, N, beta, Y, Y0);

   FA_free(Y, FAy, MAy);
   FA_free(Y0, FAy, MAy);

   if (ierr) sprintf(ln, "FAILED");
   else sprintf(ln, "PASSED");
   #ifdef TREAL
      fprintf(stdout, "   TEST TA=%c, M=%d, N=%d, lda=%d, beta=%f %s\n",
              cta, M, N, lda, beta, ln);
   #else
      fprintf(stdout, "   TEST TA=%c, M=%d, N=%d, lda=%d, beta=(%f,%f) %s\n",
              cta, M, N, lda, *beta, beta[1], ln);
   #endif
@skip   A = malloc(lda * ATL_MulBySize(nA));
   return(ierr);
}

int RunTests(enum ATLAS_TRANS TA, int M, int N, int lda, SCALAR beta)
{
   int ierr = 0, i;
   #ifdef TREAL
      int nbeta = 3, incb = 1;
      TYPE betas[3];
   #else
      int nbeta = 8, incb = 2;
      TYPE betas[8];
   #endif

   #ifdef TREAL
      betas[0] = ATL_rzero;
      betas[1] = ATL_rone;
      betas[2] = beta;
   #else
      betas[0] = betas[1] = betas[3] = betas[5] = ATL_rzero;
      betas[2] = ATL_rone;
      betas[4] = betas[6] = *beta;
      betas[7] = beta[1];
   #endif
   for (i=0; i < nbeta; i += incb)
   {
      if (TA == AtlasNoTrans)
      {
         ierr = RunTest(AtlasNoTrans, M, N, lda, &betas[i]);
         if (ierr) break;
         #ifdef TCPLX
            ierr = RunTest(AtlasConj, M, N, lda, &betas[i]);
            if (ierr) break;
         #endif
      }
      else
      {
         ierr = RunTest(AtlasTrans, M, N, lda, &betas[i]);
         if (ierr) break;
         #ifdef TCPLX
            ierr = RunTest(AtlasConjTrans, M, N, lda, &betas[i]);
            if (ierr) break;
         #endif
      }
   }
   return(ierr);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "usage: %s -A t/n -m <M> -n <N> -l <lda> -b <betaX>\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, enum ATLAS_TRANS *TA, 
              int *M0, int *MN, int *incM, int *N0, int *NN, int *incN,
              int *lda, TYPE *beta)
{
   int i, k;
   char ch;

   *TA = AtlasNoTrans;
   *M0 = *MN = *incM = 997;
   *N0 = *NN = *incN = 177;
   *lda = 0;
   *beta = 0.8;
   #ifdef TCPLX
      beta[1] = 0.3;
   #endif
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'F':
         ch = args[i][2];
         k = atoi(args[++i]);
         if (ch == 'a')
         {
            if (k < 0)
              MAa = -k;
            else 
              FAa = k;
         }
         else if (args[i][2] == 'y')
         {
            if (k < 0)
              MAy = -k;
            else 
              FAy = k;
         }
         else
         {
            if (k < 0)
              MAx = -k;
            else 
              FAx = k;
         }
         break;
      case 'A':
         i++;
         if (args[i][0] == 'N' || args[i][0] == 'n') *TA = AtlasNoTrans;
         else if (args[i][0] == 'T' || args[i][0] == 't') *TA = AtlasTrans;
         else if (args[i][0] == 'C' || args[i][0] == 'c') *TA = AtlasConjTrans;
         else PrintUsage(args[0]);
         break;
      case 'm':
         *M0 = *MN = atoi(args[++i]);
         break;
      case 'n':
         *N0 = *NN = atoi(args[++i]);
         break;
      case 'M':
         *M0 = atoi(args[++i]);
         *MN = atoi(args[++i]);
         *incM = atoi(args[++i]);
         break;
      case 'N':
         *N0 = atoi(args[++i]);
         *NN = atoi(args[++i]);
         *incN = atoi(args[++i]);
         break;
      case 'l':
         *lda = atoi(args[++i]);
         break;
      case 'b':
         *beta = atof(args[++i]);
         #ifdef TCPLX
            beta[1] = atof(args[++i]);
         #endif
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   if (*lda == 0)
   {
      if (*TA == AtlasNoTrans  || *TA == AtlasConj) *lda = -(*M0 + 7);
      else *lda = -(*N0 + 7);
   }
}

main(int nargs, char **args)
/*
 * Test the GEMV primitives
 */
{
   #ifdef TREAL
      TYPE beta;
      #define bet &beta
   #else
      TYPE beta[2];
      #define bet beta
   #endif
   enum ATLAS_TRANS TA;
   int M0, MN, incM, N0, NN, incN, m, n, lda, ldagap=0, ierr=0;

   GetFlags(nargs, args, &TA, &M0, &MN, &incM,  &N0, &NN, &incN, &lda, bet);
   if (lda < 0)
   {
      lda = -lda;
      if (TA == AtlasNoTrans || TA == AtlasConj) ldagap = lda - M0;
      else ldagap = lda - N0;
      lda -= ldagap;
   }
   fprintf(stdout, "\n\nBEGINNING GEMV PRIMITIVE TESTING:\n\n");
   for (n=N0; n <= NN; n += incN)
   {
      for (m=M0; m <= MN; m += incM)
      {
         if (ldagap)
         {
            if (TA == AtlasNoTrans || TA == AtlasConj) lda = m + ldagap;
            else lda = n + ldagap;
         }
         ierr += RunTests(TA, m, n, lda, beta);
      }
   }
/*   ierr = RunTests(TA, M, N, lda, beta); */
   if (ierr == 0) fprintf(stdout, "\n\nGEMV PRIMITIVE PASSED ALL TESTS\n\n");
   else fprintf(stdout, "\n\nGEMV PRIMITIVE FAILED SOME TESTS\n\n");
   return(ierr);
}
@ROUT l2blastst
#include "atlas_misc.h"
#include "atlas_tst.h"
#include "atlas_level2.h"
#include <string.h>

#define DEBUG
#define THRESH 50.0
static TYPE eps;
enum LVL2_ROUT {GEMV=0, GBMV, HEMV, HBMV, HPMV, SYMV, SBMV, SPMV, TRMV, TBMV,
                TPMV, TRSV, TBSV, TPSV, GER, GERU, GERC, HER, HPR, HER2, HPR2, 
                SYR, SPR, SYR2, SPR2, ALLROUTS};

#if 1
   #define trusted_gemv(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY) \
      Mjoin(PATL,f77gemv)(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY)
   #define trusted_trmv(UP, TA, DI, N, A, lda, X, incX) \
      Mjoin(PATL,f77trmv)(UP, TA, DI, N, A, lda, X, incX)
   #define trusted_ger(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,f77ger)(M, N, alpha, X, incX, Y, incY, A, lda)
   #define trusted_geru(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,f77geru)(M, N, alpha, X, incX, Y, incY, A, lda)
   #define trusted_gerc(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,f77gerc)(M, N, alpha, X, incX, Y, incY, A, lda)
#else
   #define trusted_gemv(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY) \
      Mjoin(PATL,refgemv)(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY)
   #define trusted_trmv(UP, TA, DI, N, A, lda, X, incX) \
      Mjoin(PATL,reftrmv)(UP, TA, DI, N, A, lda, X, incX)
   #define trusted_ger(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,refger)(M, N, alpha, X, incX, Y, incY, A, lda)
   #define trusted_geru(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,refgeru)(M, N, alpha, X, incX, Y, incY, A, lda)
   #define trusted_gerc(M, N, alpha, X, incX, Y, incY, A, lda) \
      Mjoin(PATL,refgerc)(M, N, alpha, X, incX, Y, incY, A, lda)
#endif

#define test_gemv(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY) \
   Mjoin(PATL,gemv)(TA, M, N, alpha, A, lda, X, incX, beta, Y, incY)
#define test_trmv(UP, TA, DI, N, A, lda, X, incX) \
   Mjoin(PATL,trmv)(UP, TA, DI, N, A, lda, X, incX)
#define test_ger(M, N, alpha, X, incX, Y, incY, A, lda) \
   Mjoin(PATL,ger)(M, N, alpha, X, incX, Y, incY, A, lda)
#define test_gerc(M, N, alpha, X, incX, Y, incY, A, lda) \
   Mjoin(PATL,gerc)(M, N, alpha, X, incX, Y, incY, A, lda)
#define test_geru(M, N, alpha, X, incX, Y, incY, A, lda) \
   Mjoin(PATL,geru)(M, N, alpha, X, incX, Y, incY, A, lda)


TYPE gertst(const enum ATLAS_TRANS TY, const int M, const int N,
            const SCALAR alpha, const int incX, const int incY, const int lda,
            double *ttrust0, double *ttest0, double *mftrust0, double *mftest0)
{
   const int aincX = Mabs(incX), aincY = Mabs(incY);
   const int FlushSize=L2SIZE/sizeof(double);
   int i;
   TYPE normA, normD, normY, normX, resid;
   TYPE *X, *x, *Y, *y, *A, *Y0, *A0;
   double *flush;
   double t0, ttest, ttrust;
   #ifdef TREAL
      const double ops = 2.0 * M * N;
   #else
      const double ops = 8.0 * M * N;
   #endif
   extern TYPE eps;

   eps = EPS;

   *ttrust0 = *ttest0 = *mftest0 = *mftrust0 = -1.0;
   flush = malloc(sizeof(double)*(FlushSize));
   if (flush == NULL) return(-1);
   A = malloc(ATL_MulBySize(lda) * N);
   if (A == NULL)
   {
      free(flush);
      return(-1);
   }

   x = X = malloc(ATL_MulBySize(M) * aincX);
   if (X == NULL)
   {
      free(flush);
      free(A);
      return(-1);
   }

   y = Y = malloc(ATL_MulBySize(N) * aincY);
   if (Y == NULL)
   {
      free(flush);
      free(A);
      free(X);
      return(-1);
   }
   A0 = malloc(ATL_MulBySize(lda)*N);
   if (A0 == NULL)
   {
      free(flush);
      free(A);
      free(X);
      free(Y);
      return(-1);
   }
/*
 * Generate operands, figure starting norms, and then flush cache
 */
   Mjoin(PATL,gegen)(M, N, A, lda, M*N+lda);
   Mjoin(PATL,gegen)(M, N, A0, lda, M*N+lda);
   Mjoin(PATL,gegen)(1, M, X, aincX, N*incX*27+213);
   Mjoin(PATL,gegen)(1, N, Y, aincY, M*incY);
   #if defined(DEBUG) && 0
      Mjoin(PATL,geprint)("A", M, N, A, lda);
      Mjoin(PATL,geprint)("A0", M, N, A0, lda);
      Mjoin(PATL,geprint)("X", 1, M, X, aincX);
      Mjoin(PATL,geprint)("Y", 1, N, Y, aincY);
   #endif
   normA = Mjoin(PATL,genrm1)(M, N, A, lda);
   normX = Mjoin(PATL,infnrm)(M, X, aincX);
   normY = Mjoin(PATL,infnrm)(N, Y, aincY);
   #ifdef TREAL
      if (Mabs(alpha) > ATL_rone) normA *= Mabs(alpha);
   #else
      if (Mabs(*alpha)+Mabs(alpha[1]) > ATL_rone) 
         normA *= (Mabs(*alpha) + Mabs(alpha[1]));
   #endif

   if (incX < 0) x += (1-M)*incX SHIFT;
   if (incY < 0) y += (1-N)*incY SHIFT;

   ATL_dset(FlushSize, 0.0, flush, 1);
   for (i=0; i < FlushSize; i++) if (flush[i] != 0.0) exit(-1);

   t0 = time00();
   #ifdef TREAL
      trusted_ger(M, N, alpha, x, incX, y, incY, A0, lda);
   #else
      if (TY != AtlasConjTrans)
         trusted_geru(M, N, alpha, x, incX, y, incY, A0, lda);
      else trusted_gerc(M, N, alpha, x, incX, y, incY, A0, lda);
   #endif
   ttrust = time00() - t0;

   ATL_dset(FlushSize, 0.0, flush, 1);
   for (i=0; i < FlushSize; i++) if (flush[i] != 0.0) exit(-1);

   t0 = time00();
   #ifdef TREAL
      test_ger(M, N, alpha, x, incX, y, incY, A, lda);
   #else
      if (TY != AtlasConjTrans)
         test_geru(M, N, alpha, x, incX, y, incY, A, lda);
      else test_gerc(M, N, alpha, x, incX, y, incY, A, lda);
   #endif
   ttest = time00() - t0;

   *ttrust0 = *ttest0 = *mftest0 = *mftrust0 = 0.0;
   if (ttrust > 0.0)
   {
      *ttrust0 = ttrust;
      *mftrust0 = ops / (ttrust * 1000000.0);
   }
   if (ttest > 0.0)
   {
      *ttest0 = ttest;
      *mftest0 = ops / (ttest * 1000000.0);
   }
/*
 * Perform error check
 */
   normD = Mjoin(PATL,gediffnrm1)(M, N, A, lda, A0, lda);
   resid = normD / (normA * normX * normY * eps * Mmax(M,N));
   #ifdef DEBUG
      if (resid > THRESH || resid != resid)
      {
         fprintf(stderr, 
            "   resid=%f, normD=%f, normA=%f, normX=%f, normY=%f, eps=%e\n",
                 resid, normD, normA, normX, normY, eps);
         Mjoin(PATL,geprint)("A0", M, N, A0, lda);
         Mjoin(PATL,geprint)("A?", M, N, A, lda);
      }
   #endif
   free(flush);
   free(A);
   free(X);
   free(Y);
   free(A0);
   return(resid);
}

TYPE gemvtst(const enum ATLAS_TRANS TA, const int M, const int N, 
             const SCALAR alpha, const int lda, const int incX, 
             const SCALAR beta, const int incY, double *ttrust0,
             double *ttest0, double *mftrust0, double *mftest0)
{
   const int aincX = Mabs(incX), aincY = Mabs(incY);
   const int FlushSize=L2SIZE/sizeof(double);
   int i, mA, nA;
   TYPE normA, normD, normY, normX, resid;
   TYPE *X, *x, *Y, *y, *A, *Y0, *YD;
   double *flush;
   double t0, ttest, ttrust;
   #ifdef TREAL
      const double ops = 2.0 * M * N;
   #else
      const double ops = 8.0 * M * N;
   #endif
   extern TYPE eps;

   eps = EPS;
   if (TA == AtlasNoTrans)
   {
      mA = M;
      nA = N;
   }
   else
   {
      mA = N;
      nA = M;
   }

   *ttrust0 = *ttest0 = *mftest0 = *mftrust0 = -1.0;
   flush = malloc(sizeof(double)*(FlushSize));
   if (flush == NULL) return(-1);
   A = malloc(ATL_MulBySize(lda) * nA);
   if (A == NULL)
   {
      free(flush);
      return(-1);
   }

   x = X = malloc(ATL_MulBySize(N) * aincX);
   if (X == NULL)
   {
      free(flush);
      free(A);
      return(-1);
   }

   y = Y = malloc(2*ATL_MulBySize(M) * aincY);
   if (Y == NULL)
   {
      free(flush);
      free(A);
      free(X);
      return(-1);
   }
   Y0 = Y + M*(aincY SHIFT);
   YD = malloc(ATL_MulBySize(M));
   if (YD == NULL)
   {
      free(flush);
      free(A);
      free(X);
      free(Y);
      return(-1);
   }
/*
 * Generate operands, figure starting norms, and then flush cache
 */
   Mjoin(PATL,gegen)(mA, nA, A, lda, mA*nA+lda);
   Mjoin(PATL,gegen)(1, N, X, aincX, N*incX*27+213);
   Mjoin(PATL,gegen)(1, M, Y, aincY, M*incY);
   Mjoin(PATL,gegen)(1, M, Y0, aincY, M*incY);
   #if defined(DEBUG) && 0
      Mjoin(PATL,geprint)("A", mA, nA, A, lda);
      Mjoin(PATL,geprint)("X", 1, N, X, aincX);
      Mjoin(PATL,geprint)("Y0", 1, M, Y0, aincY);
      Mjoin(PATL,geprint)("Y", 1, M, Y, aincY);
   #endif
   normA = Mjoin(PATL,genrm1)(mA, nA, A, lda);
   normX = Mjoin(PATL,infnrm)(N, X, aincX);
   normY = Mjoin(PATL,infnrm)(M, Y, aincY);
   #ifdef TREAL
      if (beta == ATL_rzero) normY = 1.0;
      else if (Mabs(beta) > ATL_rone) normY *= Mabs(beta);
      if (Mabs(alpha) > ATL_rone) normX *= Mabs(alpha);
   #else
      if ( SCALAR_IS_ZERO(beta) ) normY = 1.0;
      else if (Mabs(*beta)+Mabs(beta[1]) > ATL_rone) 
         normY *= (Mabs(*beta)+Mabs(beta[1]));
      if (Mabs(*alpha)+Mabs(alpha[1]) > ATL_rone) 
         normX *= (Mabs(*alpha) + Mabs(alpha[1]));
   #endif

   if (incX < 0) x += (1-N)*incX SHIFT;
   if (incY < 0) y = Y0 + ((1-M)*incY SHIFT);
   else y = Y0;

   ATL_dset(FlushSize, 0.0, flush, 1);
   for (i=0; i < FlushSize; i++) if (flush[i] != 0.0) exit(-1);

   t0 = time00();
   trusted_gemv(TA, M, N, alpha, A, lda, x, incX, beta, y, incY);
   ttrust = time00() - t0;

   if (incY < 0) y = Y + ((1-M)*incY SHIFT);
   else y = Y;
   ATL_dset(FlushSize, 0.0, flush, 1);
   for (i=0; i < FlushSize; i++) if (flush[i] != 0.0) exit(-1);

   t0 = time00();
   test_gemv(TA, M, N, alpha, A, lda, x, incX, beta, y, incY);
   ttest = time00() - t0;

   *ttrust0 = *ttest0 = *mftest0 = *mftrust0 = 0.0;
   if (ttrust > 0.0)
   {
      *ttrust0 = ttrust;
      *mftrust0 = ops / (ttrust * 1000000.0);
   }
   if (ttest > 0.0)
   {
      *ttest0 = ttest;
      *mftest0 = ops / (ttest * 1000000.0);
   }
/*
 * Perform error check
 */
   Mjoin(PATL,vdiff)(M, Y, aincY, Y0, aincY, YD, 1);
   normD = Mjoin(PATL,infnrm)(M, YD, 1);
   resid = normD / (normA * normX * normY * eps * Mmax(M,N));
   #ifdef DEBUG
      if (resid > THRESH || resid != resid)
      {
         fprintf(stderr, 
            "   resid=%f, normD=%f, normA=%f, normX=%f, normY=%f, eps=%e\n",
                 resid, normD, normA, normX, normY, eps);
         Mjoin(PATL,geprint)("Y0", 1, M, Y0, aincY);
         Mjoin(PATL,geprint)("Y?", 1, M, Y, aincY);
      }
   #endif
   free(flush);
   free(A);
   free(X);
   free(Y);
   free(YD);
   return(resid);
}
TYPE trmvtst(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TA, 
             const enum ATLAS_DIAG Diag, const int N, const int lda,
             const int incX, double *ttrust0, double *ttest0, 
             double *mftrust0, double *mftest0)
{
   const int aincX = Mabs(incX);
   const int FlushSize=L2SIZE/sizeof(double);
   int i;
   TYPE normA, normD, normX, resid;
   TYPE *X, *x, *A, *X0, *XD;
   double *flush;
   double t0, ttest, ttrust;
   #ifdef TREAL
      const double ops = 2.0 * N * ((N+1)/2);
   #else
      const double ops = 8.0 * N * ((N+1)/2);
   #endif
   extern TYPE eps;

   eps = EPS;

   *ttrust0 = *ttest0 = *mftest0 = *mftrust0 = -1.0;
   flush = malloc(sizeof(double)*(FlushSize));
   if (flush == NULL) return(-1);
   A = malloc(ATL_MulBySize(lda) * N);
   if (A == NULL)
   {
      free(flush);
      return(-1);
   }

   x = X0 = malloc(2*ATL_MulBySize(N) * aincX);
   if (X0 == NULL)
   {
      free(flush);
      free(A);
      return(-1);
   }
   X = X0 + N*(aincX SHIFT);

   XD = malloc(ATL_MulBySize(N));
   if (XD == NULL)
   {
      free(flush);
      free(A);
      free(X0);
      return(-1);
   }
/*
 * Generate operands, figure starting norms, and then flush cache
 */
   Mjoin(PATL,trgen)(Uplo, Diag, N, A, lda, N+lda);
   Mjoin(PATL,gegen)(1, N, X, aincX, N*incX*27+213);
   Mjoin(PATL,gegen)(1, N, X0, aincX, N*incX*27+213);
   #if defined(DEBUG) && 0
      Mjoin(PATL,geprint)("A", N, N, A, lda);
      Mjoin(PATL,geprint)("X", 1, N, X, aincX);
      Mjoin(PATL,geprint)("X0", 1, N, X, aincX);
   #endif
   normA = Mjoin(PATL,trnrm1)(Uplo, Diag, N, A, lda);
   normX = Mjoin(PATL,infnrm)(N, X, aincX);

   if (incX < 0) x += (1-N)*incX SHIFT;

   ATL_dset(FlushSize, 0.0, flush, 1);
   for (i=0; i < FlushSize; i++) if (flush[i] != 0.0) exit(-1);

   t0 = time00();
   trusted_trmv(Uplo, TA, Diag, N, A, lda, x, incX);
   ttrust = time00() - t0;

   if (incX < 0) x = X + ((1-N)*incX SHIFT);
   else x = X;
   ATL_dset(FlushSize, 0.0, flush, 1);
   for (i=0; i < FlushSize; i++) if (flush[i] != 0.0) exit(-1);

   t0 = time00();
   test_trmv(Uplo, TA, Diag, N, A, lda, x, incX);
   ttest = time00() - t0;

   *ttrust0 = *ttest0 = *mftest0 = *mftrust0 = 0.0;
   if (ttrust > 0.0)
   {
      *ttrust0 = ttrust;
      *mftrust0 = ops / (ttrust * 1000000.0);
   }
   if (ttest > 0.0)
   {
      *ttest0 = ttest;
      *mftest0 = ops / (ttest * 1000000.0);
   }
/*
 * Perform error check
 */
   Mjoin(PATL,vdiff)(N, X, aincX, X0, aincX, XD, 1);
   normD = Mjoin(PATL,infnrm)(N, XD, 1);
   resid = normD / (normA * normX * eps * N);
   #ifdef DEBUG
      if (resid > THRESH || resid != resid)
      {
         fprintf(stderr, 
            "   resid=%f, normD=%f, normA=%f, normX=%f, eps=%e\n",
                 resid, normD, normA, normX, eps);
         Mjoin(PATL,geprint)("X0", 1, N, X0, aincX);
         Mjoin(PATL,geprint)("X?", 1, N, X, aincX);
      }
   #endif
   free(flush);
   free(A);
   free(X0);
   free(XD);
   return(resid);
}

int trmvcase(int MFLOP, int TEST, const enum ATLAS_UPLO Uplo, 
             const enum ATLAS_TRANS TA, const enum ATLAS_DIAG Diag, 
             const int N, const int lda, const int incX, 
             double *ttrust0, double *ttest0, 
             double *mftrust0, double *mftest0)
{
   const int aincX = Mabs(incX), inca = lda * N SHIFT, incx = N*incX SHIFT;
   int i, lx, la, PASSED;
   TYPE *A0, *A, *a, *stA, *X0, *X, *x, *stX;
   double ttrust, ttest, mftrust, mftest, t0, resid;
   #ifdef TREAL
      const double flops = 2.0 * N * ((N+1)/2);
   #else
      const double flops= 8.0 * N * ((N+1)/2);
   #endif
   const int reps = Mmax((MFLOP * 1000000.0) / flops, 1);

   if (MFLOP*1000000.0 <= flops || TEST)
   {
      resid = trmvtst(Uplo, TA, Diag, N, lda, incX, ttrust0, ttest0,
                      mftrust0, mftest0);
      if (resid > THRESH) fprintf(stderr, "   resid=%e\n", resid);
   }
   if (resid < 0.0) PASSED = -1;
   else PASSED = resid <= THRESH;
   if (MFLOP*1000000.0 <= flops) return(PASSED);

   i = (ATL_DivBySize(L2SIZE)+N-1)/N;
   lx = i * N * aincX;
   X0 = X = x = malloc(ATL_MulBySize(lx));
   if (x == NULL) return(-1);

   i = (ATL_DivBySize(L2SIZE)+N*N)/(N*N);
   la = i * inca;
   A0 = A = a = malloc(ATL_MulBySize(la));
   if (a == NULL)
   {
      free(x);
      return(-1);
   }

   if (incX < 1)
   {
      stX = x;
      x = X = x + (lx SHIFT);
   }
   else stX = x + (lx SHIFT);
   stA = a + (la SHIFT);

   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incX+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      trusted_trmv(Uplo, TA, Diag, N, a, lda, x, incX);
      x += incx;
      a += inca;
      if (x == stX) x = X;
      if (a == stA) a = A;
   }
   ttrust = time00() - t0;

   x = X; a = A;
   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incX+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      test_trmv(Uplo, TA, Diag, N, a, lda, x, incX);
      x += incx;
      a += inca;
      if (x == stX) x = X;
      if (a == stA) a = A;
   }
   ttest = time00() - t0;

   if (ttrust > 0.0) mftrust = (reps * flops) / (1000000.0 * ttrust);
   else mftrust = 0.0;
   if (ttest > 0.0) mftest = (reps * flops) / (1000000.0 * ttest);
   else mftest = 0.0;
   ttrust /= reps;
   ttest  /= reps;
   *ttrust0 = ttrust;
   *ttest0  = ttest;
   *mftrust0 = mftrust;
   *mftest0 = mftest;

   free(A0);
   free(X0);
   return(PASSED);
}

int gercase(int MFLOP, int TEST, const enum ATLAS_TRANS TY, const int M, 
            const int N, const SCALAR alpha, const int incX, const int incY,
            const int lda, double *ttrust0, double *ttest0,
            double *mftrust0, double *mftest0)
{
   unsigned long reps;
   int i, lx, ly, la;
   #ifdef TREAL
      const double flops = 2.0 * M * N;
   #else
      const double flops = 8.0 * M * N;
   #endif
   double ttrust, ttest, mftrust, mftest, t0;
   const int aincY = Mabs(incY), aincX = Mabs(incX);
   const int inca = lda*N SHIFT, incx = M*incX SHIFT, incy = N*incY SHIFT;
   TYPE *a, *A, *stA, *A0, *x, *X, *X0, *stX, *y, *Y, *Y0, *stY;
   TYPE resid=0.0;
   int PASSED;
   #ifdef TREAL
      const TYPE nalpha = -alpha;
      TYPE alp = alpha;
   #else
      const TYPE *alp = alpha;
      TYPE nalpha[2];
      nalpha[0] = -alpha[0]; nalpha[1] = -alpha[1];
   #endif

   if (MFLOP*1000000.0 <= flops || TEST)
   {
      resid = gertst(TY, M, N, alpha, incX, incY, lda, ttrust0, ttest0, 
                     mftrust0, mftest0);
      if (resid > THRESH) fprintf(stderr, "   resid=%e\n", resid);
   }
   if (resid < 0.0) PASSED = -1;
   else PASSED = resid <= THRESH;
   if (MFLOP*1000000.0 <= flops) return(PASSED);

   i = (ATL_DivBySize(L2SIZE)+M-1)/M;
   lx = i * M * aincX;
   X0 = X = x = malloc(ATL_MulBySize(lx));
   if (x == NULL) return(-1);

   i = (ATL_DivBySize(L2SIZE)+N-1)/N;
   ly = i * N * aincY;
   Y0 = Y = y = malloc(ATL_MulBySize(ly));
   if (y == NULL)
   {
      free(x);
      return(-1);
   }
   i = (ATL_DivBySize(L2SIZE)+M*N)/(M*N);
   la = i * lda*N;
   A0 = A = a = malloc(ATL_MulBySize(la));
   if (a == NULL)
   {
      free(x);
      free(y);
      return(-1);
   }
   if (incX < 1)
   {
      stX = x;
      x = X = x + (lx SHIFT);
   }
   else stX = x + (lx SHIFT);
   if (incY < 1)
   {
      stY = y;
      y = Y = y + (ly SHIFT);
   }
   else stY = y + (ly SHIFT);
   stA = a + (la SHIFT);

   reps = (MFLOP * 1000000.0) / flops;
   if (reps < 1) reps = 1;
   Mjoin(PATL,gegen)(ly, 1, Y0, ly, M*incY);
   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incY+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N*M+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      #ifdef TREAL
         trusted_ger(M, N, alpha, x, incX, y, incY, A0, lda);
      #else
         if (TY != AtlasConjTrans)
            trusted_geru(M, N, alpha, x, incX, y, incY, A0, lda);
         else trusted_gerc(M, N, alpha, x, incX, y, incY, A0, lda);
      #endif
      x += incx;
      y += incy;
      a += inca;
      if (x == stX) x = X;
      if (y == stY) y = Y;
      if (a == stA)
      {
         a = A;
         if (alp == alpha) alp = nalpha;
         else alp = alpha;
      }
   }
   ttrust = time00() - t0;

   alp = alpha;
   x = X; y = Y; a = A;
   Mjoin(PATL,gegen)(ly, 1, Y0, ly, M*incY);
   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incY+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N*M+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      #ifdef TREAL
         test_ger(M, N, alpha, x, incX, y, incY, A0, lda);
      #else
         if (TY != AtlasConjTrans)
            test_geru(M, N, alpha, x, incX, y, incY, A0, lda);
         else test_gerc(M, N, alpha, x, incX, y, incY, A0, lda);
      #endif
      x += incx;
      y += incy;
      a += inca;
      if (x == stX) x = X;
      if (y == stY) y = Y;
      if (a == stA)
      {
         a = A;
         if (alp == alpha) alp = nalpha;
         else alp = alpha;
      }
   }
   ttest = time00() - t0;

   if (ttrust > 0.0) mftrust = (reps * flops) / (1000000.0 * ttrust);
   else mftrust = 0.0;
   if (ttest > 0.0) mftest = (reps * flops) / (1000000.0 * ttest);
   else mftest = 0.0;
   ttrust /= reps;
   ttest  /= reps;
   *ttrust0 = ttrust;
   *ttest0  = ttest;
   *mftrust0 = mftrust;
   *mftest0 = mftest;

   free(A0);
   free(X0);
   free(Y0);
   return (PASSED);
}

int gemvcase(int MFLOP, int TEST, const enum ATLAS_TRANS TA, const int M,
             const int N, const SCALAR alpha, const int lda, const int incX, 
             const SCALAR beta, const int incY, double *ttrust0, 
             double *ttest0, double *mftrust0, double *mftest0)
{
   unsigned long reps;
   int i, lx, ly, la;
   #ifdef TREAL
      const double flops = 2.0 * M * N;
   #else
      const double flops = 8.0 * M * N;
   #endif
   double ttrust, ttest, mftrust, mftest, t0;
   const int aincY = Mabs(incY), aincX = Mabs(incX);
   const int inca = (TA == AtlasNoTrans) ? lda * (N SHIFT) : lda * (M SHIFT);
   const int incx = N*incX SHIFT, incy = M*incY SHIFT;
   TYPE *a, *A, *stA, *A0, *x, *X, *X0, *stX, *y, *Y, *Y0, *stY;
   TYPE resid=0.0;
   int PASSED;
   #ifdef TREAL
      const TYPE nbeta = -beta;
      TYPE bet = beta;
   #else
      const TYPE *bet = beta;
      TYPE nbeta[2];
      nbeta[0] = -beta[0]; nbeta[1] = -beta[1];
   #endif

   if (MFLOP*1000000.0 <= flops || TEST)
   {
      resid = gemvtst(TA, M, N, alpha, lda, incX, beta, incY, 
                      ttrust0, ttest0, mftrust0, mftest0);
      if (resid > THRESH) fprintf(stderr, "   resid=%f\n", resid);
   }
   if (resid < 0.0) PASSED = -1;
   else PASSED = (resid <= THRESH);
   if (MFLOP * 1000000.0 <= flops) return(PASSED);

   i = (ATL_DivBySize(L2SIZE)+N-1)/N;
   lx = i * N * aincX;
   X0 = X = x = malloc(ATL_MulBySize(lx));
   if (x == NULL) return(-1);

   i = (ATL_DivBySize(L2SIZE)+M-1)/M;
   ly = i * M * aincY;
   Y0 = Y = y = malloc(ATL_MulBySize(ly));
   if (y == NULL)
   {
      free(x);
      return(-1);
   }
   i = (ATL_DivBySize(L2SIZE)+M*N)/(M*N);
   la = i * inca;
   A0 = A = a = malloc(ATL_MulBySize(la));
   if (a == NULL)
   {
      free(x);
      free(y);
      return(-1);
   }
   if (incX < 1)
   {
      stX = x;
      x = X = x + (lx SHIFT);
   }
   else stX = x + (lx SHIFT);
   if (incY < 1)
   {
      stY = y;
      y = Y = y + (ly SHIFT);
   }
   else stY = y + (ly SHIFT);
   stA = a + (la SHIFT);

   reps = (MFLOP * 1000000.0) / flops;
   if (reps < 1) reps = 1;
   Mjoin(PATL,gegen)(ly, 1, Y0, ly, M*incY);
   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incY+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N*M+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      trusted_gemv(TA, M, N, alpha, a, lda, x, incX, beta, y, incY);
      x += incx;
      y += incy;
      a += inca;
      if (x == stX) x = X;
      if (y == stY)
      {
         y = Y;
         if (bet == beta) bet = nbeta;
         else bet = beta;
      }
      if (a == stA) a = A;
   }
   ttrust = time00() - t0;

   bet = beta;
   x = X; y = Y; a = A;
   Mjoin(PATL,gegen)(ly, 1, Y0, ly, M*incY);
   Mjoin(PATL,gegen)(lx, 1, X0, lx, N*incY+127*50+77);
   Mjoin(PATL,gegen)(la, 1, A0, la, N*M+513*7+90);

   t0 = time00();
   for (i=reps; i; i--)
   {
      test_gemv(TA, M, N, alpha, a, lda, x, incX, beta, y, incY);
      x += incx;
      y += incy;
      a += inca;
      if (x == stX) x = X;
      if (y == stY)
      {
         y = Y;
         if (bet == beta) bet = nbeta;
         else bet = beta;
      }
      if (a == stA) a = A;
   }
   ttest = time00() - t0;

   if (ttrust > 0.0) mftrust = (reps * flops) / (1000000.0 * ttrust);
   else mftrust = 0.0;
   if (ttest > 0.0) mftest = (reps * flops) / (1000000.0 * ttest);
   else mftest = 0.0;
   ttrust /= reps;
   ttest  /= reps;
   *ttrust0 = ttrust;
   *ttest0  = ttest;
   *mftrust0 = mftrust;
   *mftest0 = mftest;

   free(A0);
   free(X0);
   free(Y0);
   return(PASSED);
}

void RunCases(int TEST, int LDA_IS_M, int MFLOP, int nside,
              enum ATLAS_SIDE *Side, int nuplo, enum ATLAS_UPLO *Uplo, 
              int nta, enum ATLAS_TRANS *TA, int ndiag, enum ATLAS_DIAG *Diag,
              int M0, int MN, int incM, int N0, int NN, int incN,
              int K0, int KN, int incK, int nalphas, TYPE *alphas, int nbetas,
              TYPE *betas, int nincX, int *incX, int nincY, int *incY,
              int nrouts, enum LVL2_ROUT *Rout)
{
   enum ATLAS_TRANS TY;
   char cTA, cdiag, cuplo;
   char *pass, *form;
   int ro, mm, nn, kk, si, up, ta, di, iy, ix, al, be;
   int i, m, n, k, lda;
   int itst=0, np=0;
   int MSAME=0, KSAME=0;
   double t0, mftrust, mftest, ttrust, ttest;

   if (M0 == -1)
   {
      M0 = MN = incM = NN;
      MSAME = 1;
   }
   if (K0 == -1)
   {
      K0 = KN = incK = NN;
      KSAME = 1;
   }
   for (ro=0; ro < nrouts; ro++)
   {
      switch(Rout[ro])
      {
      case GER:
         fprintf(stdout, 
"\n------------------------------- GER ---------------------------------\n");
         fprintf(stdout, 
"TST#     M     N ALPHA INCX INCY   LDA   TIME  MFLOP  SpUp  TEST\n");
         fprintf(stdout, 
"==== ===== ===== ===== ==== ==== ===== ====== ====== ===== =====\n");
         form =
"%4d  %5d %5d %5.1f %4d %4d %5d %6.2f %6.1f %5.2f %5s\n";
         break;
      case GERU:
      case GERC:
         if (Rout[ro] == GERU)
            fprintf(stdout, 
"\n------------------------------- GERU --------------------------------\n");
         else fprintf(stdout, 
"\n------------------------------- GERC --------------------------------\n");
         fprintf(stdout, 
"TST#     M     N       ALPHA INCX INCY   LDA   TIME  MFLOP  SpUp  TEST\n");
         fprintf(stdout, 
"==== ===== ===== ===== ===== ==== ==== ===== ====== ====== ===== =====\n");
         form =
"%4d  %5d %5d %5.1f %5.1f %4d %4d %5d %6.2f %6.1f %5.2f %5s\n";
         break;
      case TRMV:
            fprintf(stdout, 
"\n------------------------------- TRMV --------------------------------\n");
            fprintf(stdout, 
"TST# UPLO TRAN DIAG    N  LDA INCX   TIME MFLOP  SpUp  TEST\n");
            fprintf(stdout, 
"==== ==== ==== ==== ==== ==== ==== ====== ====== ===== =====\n");
            form = 
"%4d    %c    %c    %c %4d %4d %4d %6.2f %6.1f %5.2f %5s\n";
         break;
      case GEMV:
#ifdef TREAL
            fprintf(stdout, 
"\n------------------------------- GEMV --------------------------------\n");
            fprintf(stdout, 
"TST# TR    M    N ALPHA  LDA INCX  BETA INCY   TIME MFLOP  SpUp  TEST\n");
            fprintf(stdout, 
"==== == ==== ==== ===== ==== ==== ===== ==== ====== ===== ===== =====\n");
            form =
"%4d  %c %4d %4d %5.1f %4d %4d %5.1f %4d %6.2f %5.1f %5.2f %5s\n";
#else
            fprintf(stdout, 
"\n----------------------------------- GEMV -----------------------------------\n");
            fprintf(stdout, 
"TST# TR    M    N     ALPHA  LDA INCX      BETA INCY   TIME MFLOP  SpUp  TEST\n");
            fprintf(stdout, 
"==== == ==== ==== ==== ==== ==== ==== ==== ==== ==== ====== ===== ===== =====\n");
            form =
"%4d  %c %4d %4d %4.1f %4.1f %4d %4d %4.1f %4.1f %4d %6.2f %5.1f %5.2f %5s\n";
#endif
            break;
         default:
           exit(-1);
      }
      for (mm=M0; mm <= MN; mm += incM)
      {
         for (nn=N0; nn <= NN; nn += incN)
         {
            n = nn;
            if (MSAME) m = n;
            else m = mm;
            for (kk=K0; kk <= KN; kk += incK)
            {
               if (KSAME) k = n;
               else k = kk;
               for (si=0; si < nside; si++)
               {
                  for (up=0; up < nuplo; up++)
                  {
                     if (Uplo[up] == AtlasUpper) cuplo = 'U';
                     else cuplo = 'L';
                     for (ta=0; ta < nta; ta++)
                     {
                        if (TA[ta] == AtlasNoTrans) cTA = 'N';
                        else if (TA[ta] == AtlasTrans) cTA = 'T';
                        else if (TA[ta] == AtlasConjTrans) cTA = 'C';
                        for (di=0; di < ndiag; di++)
                        {
                           if (Diag[di] == AtlasUnit) cdiag = 'U';
                           else cdiag = 'N';
                           for (iy=0; iy < nincY; iy++)
                           {
                              for (ix=0; ix < nincX; ix++)
                              {
                                 for (al=0; al < nalphas; al++)
                                 {
                                    for (be=0; be < nbetas; be++)
                                    {
   switch(Rout[ro])
   {
   case GEMV:
      if (TA[ta] == AtlasNoTrans)
      {
         if (LDA_IS_M) lda = m;
         else lda = MN;
         cTA = 'N';
      }
      else
      {
         if (LDA_IS_M) lda = n;
         else lda = NN;
         if (TA[ta] == AtlasTrans) cTA = 'T';
         else if (TA[ta] == AtlasConjTrans) cTA = 'C';
         else exit(-1);
      }
      #ifdef TREAL
         i = gemvcase(MFLOP, TEST, TA[ta], m, n, alphas[al], lda,
                      incX[ix], betas[be], incY[iy], 
                      &ttrust, &ttest, &mftrust, &mftest);
      #else
         i = gemvcase(MFLOP, TEST, TA[ta], m, n, alphas+(al<<1), lda,
                      incX[ix], betas+(be<<1), incY[iy], 
                      &ttrust, &ttest, &mftrust, &mftest);
      #endif
      if (!TEST) pass = "SKIP ";
      else if (i < 0) pass = "NoMEM";
      else if (i) pass = "PASS ";
      else pass = "FAIL ";
      if (i > 0) np++;
      if (mftrust > 0.0 && mftest > 0.0) t0 = mftest / mftrust;
      else t0 = 0.0;
      #ifdef TREAL
         fprintf(stdout, form, itst, cTA, m, n, alphas[al], lda, incX[ix],
                 betas[be], incY[iy], ttrust, mftrust, 1.0, "-----");
         fprintf(stdout, form, itst, cTA, m, n, alphas[al], lda, incX[ix],
                 betas[be], incY[iy], ttest, mftest, t0, pass);
      #else
         fprintf(stdout, form, itst, cTA, m, n, alphas[2*al], alphas[2*al+1],
                 lda, incX[ix], betas[2*be], betas[2*be+1], incY[iy], 
                 ttrust, mftrust, 1.0, "-----");
         fprintf(stdout, form, itst, cTA, m, n, alphas[al<<1], alphas[2*al+1],
                 lda, incX[ix], betas[2*be], betas[2*be+1], incY[iy], 
                 ttest, mftest, t0, pass);
      #endif
      break;
   case TRMV:
      if (LDA_IS_M) lda = n; 
      else lda = NN;
      i = trmvcase(MFLOP, TEST, Uplo[up], TA[ta], Diag[di], n, lda, incX[ix], 
                   &ttrust, &ttest, &mftrust, &mftest);
      if (!TEST) pass = "SKIP ";
      else if (i < 0) pass = "NoMEM";
      else if (i) pass = "PASS ";
      else pass = "FAIL ";
      if (i > 0) np++;
      if (mftrust > 0.0 && mftest > 0.0) t0 = mftest / mftrust;
      else t0 = 0.0;
      fprintf(stdout, form, itst, cuplo, cTA, cdiag, n, lda, incX[ix], 
              ttrust, mftrust, 1.0, "-----");
      fprintf(stdout, form, itst, cuplo, cTA, cdiag, n, lda, incX[ix], 
              ttest, mftest, t0, pass);
      break;
   case GER:
   case GERU:
   case GERC:
      if (Rout[ro] != GERC) TY = AtlasTrans;
      else TY = AtlasConjTrans;
      if (LDA_IS_M) lda = m;
      else lda = MN;
      #ifdef TREAL
         i = gercase(MFLOP, TEST, TY, m, n, alphas[al], incX[ix], incY[iy],
                     lda, &ttrust, &ttest, &mftrust, &mftest);
      #else
         i = gercase(MFLOP, TEST, TY, m, n, alphas+2*al, incX[ix], incY[iy],
                     lda, &ttrust, &ttest, &mftrust, &mftest);
      #endif
      if (!TEST) pass = "SKIP ";
      else if (i < 0) pass = "NoMEM";
      else if (i) pass = "PASS ";
      else pass = "FAIL ";
      if (i > 0) np++;
      if (mftrust > 0.0 && mftest > 0.0) t0 = mftest / mftrust;
      else t0 = 0.0;
      #ifdef TREAL
         fprintf(stdout, form, itst, m, n, alphas[al],
                 incX[ix], incY[iy], lda, ttrust, mftrust, 1.0, "-----");
         fprintf(stdout, form, itst, m, n, alphas[al],
                 incX[ix], incY[iy], lda, ttest, mftest, t0, pass);
      #else
         fprintf(stdout, form, itst, m, n, alphas[2*al], alphas[2*al+1],
                 incX[ix], incY[iy], lda, ttrust, mftrust, 1.0, "-----");
         fprintf(stdout, form, itst, m, n, alphas[2*al], alphas[2*al+1],
                 incX[ix], incY[iy], lda, ttest, mftest, t0, pass);
      #endif
      break;
   default:
      exit(-1);
   }
                                       itst++;
                                    }
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   if (TEST) fprintf(stdout, "\n%d tests run, %d passed\n\n", itst, np);
}

void PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -R <rout> -Side <nsides> L/R -Uplo <nuplo> L/U -Atrans <ntrans> n/t/c -Diag <ndiags> N/U -M <m1> <mN> <minc> -N <n1> <nN> <ninc> -K <k1> <kN> <kinc> -n <n> -m <m> -k <k> -a <nalphas> <alpha1> ... <alphaN> -b <nbetas> <beta1> ... <betaN> -Test <0/1> -F <mflops> -X <nincXs> <incX0> ... <incX1> -Y <nincYs> <incY0> ... <incYN>\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char *args[], int *TEST, int *nside,
              enum ATLAS_SIDE **Side, int *nuplo, enum ATLAS_UPLO **Uplo, 
              int *nta, enum ATLAS_TRANS **TransA, 
              int *ndiag, enum ATLAS_DIAG **Diag, 
              int *M0, int *MN, int *Minc, int *N0, int *NN, int *Ninc, 
              int *K0, int *KN, int *Kinc, int *nalphas, TYPE **alphas, 
              int *nbetas, TYPE **betas, int *nincX, int **incXs,
              int *nincY, int **incYs, int *nrouts, enum LVL2_ROUT **Routs, 
              int *LDA_IS_M, int *mflop)
{
   char ch;
   int i=1, j, k,l=0;
/*
 * Set up defaults
 */
   *TEST = 1;
   *nincX = *nincY = *M0 = *N0 = *K0 = -1;
   *nrouts = *nuplo = *nta = *nside = *ndiag = *nalphas = *nbetas = -1;
   *mflop = *LDA_IS_M = 0;

   for (i=1; i < nargs ; )
   {
      if ( args[i][0] != '-' ) PrintUsage(args[0]);
      switch(args[i++][1])
      {
      case 'F':
         if (args[i] == NULL) PrintUsage(args[0]);
         *mflop = atoi(args[i++]);
         break;
      case 'X':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nincX = atoi(args[i++]);
         if (*nincX <= 0) PrintUsage(args[0]);
         *incXs = malloc(*nincX * sizeof(int));
         ATL_assert(*incXs);
         for (j=0; j < *nincX; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            (*incXs)[j] = atoi(args[i++]);
         }
         break;
      case 'Y':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nincY = atoi(args[i++]);
         if (*nincY <= 0) PrintUsage(args[0]);
         *incYs = malloc(*nincY * sizeof(int));
         ATL_assert(*incYs);
         for (j=0; j < *nincY; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            (*incYs)[j] = atoi(args[i++]);
         }
         break;
      case 'S':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nside = atoi(args[i++]);
         if (*nside <= 0) PrintUsage(args[0]);
         *Side = malloc(*nside * sizeof(int));
         ATL_assert(*Side);
         for (j=0; j != *nside; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'r' || ch == 'R') (*Side)[j] = AtlasRight;
            else if (ch == 'l' || ch == 'L') (*Side)[j] = AtlasLeft;
            else PrintUsage(args[0]);
         }
         break;
      case 'U':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nuplo = atoi(args[i++]);
         if (*nuplo <= 0) PrintUsage(args[0]);
         *Uplo = malloc(*nuplo * sizeof(int));
         ATL_assert(*Uplo);
         for (j=0; j != *nuplo; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'u' || ch == 'U') (*Uplo)[j] = AtlasUpper;
            else if (ch == 'l' || ch == 'L') (*Uplo)[j] = AtlasLower;
            else PrintUsage(args[0]);
         }
         break;
      case 'D':
         if (args[i] == NULL) PrintUsage(args[0]);
         *ndiag = atoi(args[i++]);
         if (*ndiag <= 0) PrintUsage(args[0]);
         *Diag = malloc(*ndiag * sizeof(int));
         ATL_assert(*Diag);
         for (j=0; j != *ndiag; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'u' || ch == 'U') (*Diag)[j] = AtlasUnit;
            else if (ch == 'n' || ch == 'N') (*Diag)[j] = AtlasNonUnit;
            else PrintUsage(args[0]);
         }
         break;
      case 'A':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nta   = atoi(args[i++]);
         if (*nta <= 0) PrintUsage(args[0]);
         *TransA = malloc(*nta * sizeof(int));
         ATL_assert(*TransA);
         for (j=0; j != *nta; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            ch = *args[i++];
            if (ch == 'n' || ch == 'N') (*TransA)[j] = AtlasNoTrans;
            else if (ch == 't' || ch == 'T') (*TransA)[j] = AtlasTrans;
            else if (ch == 'c' || ch == 'C') (*TransA)[j] = AtlasConjTrans;
            else PrintUsage(args[0]);
         }
         break;
      case 'M':
         if (args[i] == NULL) PrintUsage(args[0]);
         *M0 = atoi(args[i++]);
         if (*M0 < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *MN = atoi(args[i++]);
         if (*MN < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *Minc = atoi(args[i++]);
         if (*Minc <= 0) PrintUsage(args[0]);
         break;
      case 'N':
         if (args[i] == NULL) PrintUsage(args[0]);
         *N0 = atoi(args[i++]);
         if (*N0 < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *NN = atoi(args[i++]);
         if (*NN < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *Ninc = atoi(args[i++]);
         if (*Ninc <= 0) PrintUsage(args[0]);
         break;
      case 'K':
         if (args[i] == NULL) PrintUsage(args[0]);
         *K0 = atoi(args[i++]);
         if (*K0 < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *KN = atoi(args[i++]);
         if (*KN < 0) PrintUsage(args[0]);
         if (args[i] == NULL) PrintUsage(args[0]);
         *Kinc = atoi(args[i++]);
         if (*Kinc <= 0) PrintUsage(args[0]);
         break;
      case 'T':
         if (args[i] == NULL) PrintUsage(args[0]);
         *TEST = atoi(args[i++]);
         break;
      case 'R':
         if (args[i] == NULL) PrintUsage(args[0]);
         if (isdigit(*args[i]))
         {
            *nrouts = atoi(args[i++]);
            *Routs = malloc( (*nrouts) * sizeof(enum LVL2_ROUT) );
            ATL_assert(*Routs);
         }
         else
         {
            *nrouts = 1;
            *Routs = malloc( sizeof(enum LVL2_ROUT) );
            ATL_assert(*Routs);
         }
         for (j=0; j < *nrouts; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            if ( !strcmp(args[i], "GEMV") || !strcmp(args[i], "gemv") )
               *(Routs)[j] = GEMV;
            else if ( !strcmp(args[i], "TRMV") || !strcmp(args[i], "trmv") )
               *(Routs)[j] = TRMV;
            #ifdef TREAL
               else if ( !strcmp(args[i], "GER") || !strcmp(args[i], "ger") )
                  *(Routs)[j] = GER;
            #else
               else if ( !strcmp(args[i], "GERU") || !strcmp(args[i], "geru") )
                  *(Routs)[j] = GERU;
               else if ( !strcmp(args[i], "GERC") || !strcmp(args[i], "gerc") )
                  *(Routs)[j] = GERC;
            #endif
            else if ( !strcmp(args[i], "ALL") || !strcmp(args[i], "all") )
            {
               if (*nrouts != 1) PrintUsage(args[0]);
               free(*Routs);
               *nrouts = 25;
               *Routs = malloc( *nrouts * sizeof(enum LVL2_ROUT) );
               ATL_assert(*Routs);
               for (j=0; j < *nrouts; j++) (*Routs)[j] = j;
            }
            else PrintUsage(args[0]);
            i++;
         } 
         break;
      case 'm':
         if (args[i] == NULL) PrintUsage(args[0]);
         *M0 = *MN = atoi(args[i++]);
         *Minc = 1;
         if (*M0 <= 0) PrintUsage(args[0]);
         break;
      case 'n':
         if (args[i] == NULL) PrintUsage(args[0]);
         *N0 = *NN = atoi(args[i++]);
         *Ninc = 1;
         if (*N0 < 0) PrintUsage(args[0]);
         break;
      case 'k':
         if (args[i] == NULL) PrintUsage(args[0]);
         *K0 = *KN = atoi(args[i++]);
         *Kinc = 1;
         if (*K0 <= 0) PrintUsage(args[0]);
         break;
      case 'a':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nalphas = atoi(args[i++]);
         if (*nalphas <= 0)  PrintUsage(args[0]);
         *alphas = malloc(ATL_MulBySize(*nalphas ));
         ATL_assert(*alphas);
         for (j=0; j < *nalphas SHIFT; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            (*alphas)[j] = atof(args[i++]);
         }
         break;
      case 'b':
         if (args[i] == NULL) PrintUsage(args[0]);
         *nbetas  = atoi(args[i++]);
         if (*nbetas <= 0)  PrintUsage(args[0]);
         *betas  = malloc(ATL_MulBySize(*nbetas ));
         ATL_assert(*betas );
         for (j=0; j < *nbetas SHIFT; j++)
         {
            if (args[i] == NULL) PrintUsage(args[0]);
            (*betas)[j] = atof(args[i++]);
         }
         break;
      case 'd':
         *LDA_IS_M  = atoi(args[i++]);
         break;
      default:
         PrintUsage(args[0]);
         break;
      }
   }
/*
 * Finish setting up defaults if the user has not selected
 */
   if (*N0 == -1)
   {
      *N0 = 100;
      *NN = 1000;
      *Ninc = 100;
   }
   if (*nside == -1)
   {
      *nside = 1;
      *Side = malloc(sizeof(int));
      ATL_assert(*Side);
      **Side = AtlasLeft;
   }
   if (*nuplo == -1)
   {
      *nuplo = 1;
      *Uplo = malloc(sizeof(int));
      ATL_assert(*Uplo);
      **Uplo = AtlasLower;
   }
   if (*nta == -1)
   {
      *nta = 1;
      *TransA = malloc(sizeof(int));
      ATL_assert(*TransA);
      **TransA = AtlasNoTrans;
   }
   if (*ndiag == -1)
   {
      *ndiag = 1;
      *Diag = malloc(sizeof(int));
      ATL_assert(*Diag);
      **Diag = AtlasNonUnit;
   }
   if (*nalphas == -1)
   {
      *nalphas = 1;
      *alphas = malloc(ATL_MulBySize(1));
      ATL_assert(*alphas);
      #ifdef TREAL
         **alphas = 1.0;
      #else
         **alphas = 1.0;
         (*alphas)[1] = 0.0;
      #endif
   }
   if (*nbetas  == -1)
   {
      *nbetas  = 1;
      *betas  = malloc(ATL_MulBySize(1));
      ATL_assert(*betas );
      #ifdef TREAL
         **betas  = 1.0;
      #else
         **betas  = 1.0;
         (*betas)[1] = 0.0;
      #endif
   }
   if (*nincX == -1)
   {
      *nincX = 1;
      *incXs = malloc(sizeof(int));
      **incXs = 1;
   }
   if (*nincY == -1)
   {
      *nincY = 1;
      *incYs = malloc(sizeof(int));
      **incYs = 1;
   }
   if (*nrouts == -1)
   {
      *nrouts = 1;
      *Routs = malloc( sizeof(enum LVL2_ROUT) );
      ATL_assert(*Routs);
      (*Routs)[0] = GEMV;
   }
}
main(int nargs, char **args)
{
   int LDA_IS_M, TEST, nside, nuplo, nta, ndiag, M0, MN, incM, N0, NN, incN;
   int K0, KN, incK, nalphas, nbetas, nincX, nincY, nrouts, MFLOP;
   int *incXs, *incYs;
   TYPE *alphas, *betas;
   enum LVL2_ROUT *Routs;
   enum ATLAS_SIDE *Side;
   enum ATLAS_UPLO *Uplo;
   enum ATLAS_TRANS *TA;
   enum ATLAS_DIAG *Diag;
   extern TYPE eps;

   GetFlags(nargs, args, &TEST, &nside, &Side, &nuplo, &Uplo, &nta, &TA, 
            &ndiag, &Diag, &M0, &MN, &incM, &N0, &NN, &incN, &K0, &KN, &incK,
            &nalphas, &alphas, &nbetas, &betas, &nincX, &incXs, &nincY, &incYs,
            &nrouts, &Routs, &LDA_IS_M, &MFLOP);
   eps = Mjoin(PATL,epsilon)();
   RunCases(TEST, LDA_IS_M, MFLOP, nside, Side, nuplo, Uplo, nta, TA,
            ndiag, Diag, M0, MN, incM, N0, NN, incN, K0, KN, incK, 
            nalphas, alphas, nbetas, betas, nincX, incXs, nincY, incYs, 
            nrouts, Routs);
   free(Side);
   free(Uplo);
   free(TA);
   free(Diag);
   free(alphas);
   free(incXs);
   free(incYs);
   free(betas);
   free(Routs);
}
@ROUT atlas_lvl2.h
#include "atlas_level2.h"
#include "atlas_kernel2.h"
#ifndef ATLAS_LVL2_H
#define ATLAS_LVL2_H

/*
 * Real kernels
 */
@multidef typ double float
@whiledef pre d s 
void ATL_@(pre)gerk_Mlt16
   (const int M, const int N, const @(typ) alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
void ATL_@(pre)gerk_axpy
   (const int M, const int N, const @(typ) alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
@beginskip
void ATL_@(pre)ger1_a1_x1_yX
   (const int M, const int N, const @(typ) alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
@endskip
   @whiledef al 1
      @whiledef be 0 1 X
         @whiledef ta N T S
void ATL_@(pre)gemv@(ta)_a@(al)_x1_b@(be)_y1
   (const int M, const int N, const @(typ) alpha, const @(typ) *A, 
    const int lda, const @(typ) *X, const int incX, const @(typ) beta,
    @(typ) *Y, const int incY);
         @endwhile
      @endwhile
   @endwhile
@beginskip
   @whiledef up L U
      @whiledef ta T N
         @whiledef di N U
void ATL_@(pre)trmv@(up)@(ta)
   (const enum ATLAS_DIAG Diag, const int N, const @(typ) *A, const int lda,
    const @(typ) *X, @(typ) *Y);
void ATL_@(pre)ktrmv@(up)@(ta)@(di)
   (const int N, const @(typ) *A, const int lda, const @(typ) *X, 
    const int BetaIsOne, @(typ) *Y);
         @endwhile
      @endwhile
   @endwhile
@endskip
   @undef typ
@endwhile

/*
 * Complex kernels
 */
@multidef typ double float
@whiledef pre z c 
void ATL_@(pre)gerk_Mlt16
   (const int M, const int N, const @(typ) *alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
void ATL_@(pre)gerk_axpy
   (const int M, const int N, const @(typ) *alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
@beginskip
void ATL_@(pre)ger1u_a1_x1_yX
   (const int M, const int N, const @(typ) *alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
void ATL_@(pre)ger1c_a1_x1_yX
   (const int M, const int N, const @(typ) *alpha, const @(typ) *X,
    const int incX, const @(typ) *Y, const int incY, @(typ) *A, const int lda);
@endskip
   @whiledef al 1
      @whiledef be 0 1 X Xi0
         @whiledef ta N T Nc C S
void ATL_@(pre)gemv@(ta)_a@(al)_x1_b@(be)_y1
   (const int M, const int N, const @(typ) *alpha, const @(typ) *A, 
    const int lda, const @(typ) *X, const int incX, const @(typ) *beta,
    @(typ) *Y, const int incY);
         @endwhile
      @endwhile
   @endwhile
@beginskip
   @whiledef up L U
      @whiledef ta Nc C T N
         @whiledef di N U
void ATL_@(pre)trmv@(up)@(ta)
   (const enum ATLAS_DIAG Diag, const int N, const @(typ) *A, const int lda,
    const @(typ) *X, @(typ) *Y);
void ATL_@(pre)ktrmv@(up)@(ta)@(di)
   (const int N, const @(typ) *A, const int lda, const @(typ) *X, 
    const int BetaIsOne, @(typ) *Y);
         @endwhile
      @endwhile
   @endwhile
@endskip
   @undef typ
@endwhile

#endif
@ROUT atlas_level2.h
/*
 * ===========================================================================
 * Prototypes for level 2 BLAS
 * ===========================================================================
 */
#ifndef ATLAS_LEVEL2_H
#define ATLAS_LEVEL2_H

/* 
 * Routines with standard 4 prefixes (S, D, C, Z)
 */
@multidef sty double@^* float@^* double@^ float@^
@multidef typ double float double float
@whiledef pre z c d s
void ATL_@(pre)gemv(const enum ATLAS_TRANS TransA, const int M, const int N,
               const @(sty)alpha, const @(typ) *A, const int lda,
               const @(typ) *X, const int incX, const @(sty)beta,
               @(typ) *Y, const int incY);
void ATL_@(pre)gbmv(const enum ATLAS_TRANS TransA, const int M, const int N,
               const int KL, const int KU, const @(sty)alpha,
               const @(typ) *A, const int lda, const @(typ) *X,
               const int incX, const @(sty)beta, @(typ) *Y, const int incY);
void ATL_@(pre)trmv(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TransA,
               const enum ATLAS_DIAG Diag, const int N,
               const @(typ) *A, const int lda, @(typ) *X, const int incX);
void ATL_@(pre)tbmv(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TransA,
               const enum ATLAS_DIAG Diag, const int N, const int K,
               const @(typ) *A, const int lda, @(typ) *X, const int incX);
void ATL_@(pre)tpmv(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TransA,
               const enum ATLAS_DIAG Diag, const int N, const @(typ) *Ap, 
               @(typ) *X, const int incX);
void ATL_@(pre)trsv(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TransA,
               const enum ATLAS_DIAG Diag, const int N,
               const @(typ) *A, const int lda, @(typ) *X, const int incX);
void ATL_@(pre)tbsv(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TransA,
               const enum ATLAS_DIAG Diag, const int N, const int K,
               const @(typ) *A, const int lda, @(typ) *X, const int incX);
void ATL_@(pre)tpsv(const enum ATLAS_UPLO Uplo, const enum ATLAS_TRANS TransA,
               const enum ATLAS_DIAG Diag, const int N,
               const @(typ) *Ap, @(typ) *X, const int incX);
   @undef typ
   @undef sty

@endwhile

/* 
 * Routines with S and D prefixes only
 */
@multidef typ double float
@whiledef pre d s
void ATL_@(pre)symv(const enum ATLAS_UPLO Uplo, const int N,
               const @(typ) alpha, const @(typ) *A, const int lda,
               const @(typ) *X, const int incX, const @(typ) beta,
               @(typ) *Y, const int incY);
void ATL_@(pre)sbmv(const enum ATLAS_UPLO Uplo, const int N, const int K,
               const @(typ) alpha, const @(typ) *A, const int lda,
               const @(typ) *X, const int incX, const @(typ) beta,
               @(typ) *Y, const int incY);
void ATL_@(pre)spmv(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
               const @(typ) *Ap, const @(typ) *X, const int incX,
               const @(typ) beta, @(typ) *Y, const int incY);
void ATL_@(pre)ger(const int M, const int N, const @(typ) alpha,
              const @(typ) *X, const int incX, const @(typ) *Y, const int incY,
              @(typ) *A, const int lda);
void ATL_@(pre)syr(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
              const @(typ) *X, const int incX, @(typ) *A, const int lda);
void ATL_@(pre)spr(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
              const @(typ) *X, const int incX, @(typ) *Ap);
void ATL_@(pre)syr2(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
               const @(typ) *X, const int incX, const @(typ) *Y, const int incY,
               @(typ) *A, const int lda);
void ATL_@(pre)spr2(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
               const @(typ) *X, const int incX, const @(typ) *Y, const int incY,
               @(typ) *A);
   @undef typ

@endwhile

/* 
 * Routines with C and Z prefixes only
 */
@multidef styp double@^* float@^*
@multidef typ double float
@whiledef pre z c
void ATL_@(pre)hemv(const enum ATLAS_UPLO Uplo, const int N,
               const @(styp)alpha, const @(typ) *A, const int lda,
               const @(typ) *X, const int incX, const @(typ) *beta,
               @(typ) *Y, const int incY);
void ATL_@(pre)hbmv(const enum ATLAS_UPLO Uplo, const int N, const int K,
               const @(styp)alpha, const @(typ) *A, const int lda,
               const @(typ) *X, const int incX, const @(styp)beta,
               @(typ) *Y, const int incY);
void ATL_@(pre)hpmv(const enum ATLAS_UPLO Uplo, const int N,
               const @(styp)alpha, const @(typ) *Ap,
               const @(typ) *X, const int incX, const @(typ) *beta,
               @(typ) *Y, const int incY);
void ATL_@(pre)geru(const int M, const int N, const @(styp)alpha,
               const @(typ) *X, const int incX, const @(typ) *Y, const int incY,
               @(typ) *A, const int lda);
void ATL_@(pre)gerc(const int M, const int N, const @(styp)alpha,
               const @(typ) *X, const int incX, const @(typ) *Y, const int incY,
               @(typ) *A, const int lda);
void ATL_@(pre)her(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
              const @(typ) *X, const int incX, @(typ) *A, const int lda);
void ATL_@(pre)hpr(const enum ATLAS_UPLO Uplo, const int N, const @(typ) alpha,
                   const @(typ) *X, const int incX, @(typ) *A);
void ATL_@(pre)her2(const enum ATLAS_UPLO Uplo, const int N,
               const @(styp)alpha, const @(typ) *X, const int incX,
               const @(typ) *Y, const int incY, @(typ) *A, const int lda);
void ATL_@(pre)hpr2(const enum ATLAS_UPLO Uplo, const int N,
               const @(styp)alpha, const @(typ) *X, const int incX,
               const @(typ) *Y, const int incY, @(typ) *Ap);
   @undef styp
   @undef typ

@endwhile

#endif
@ROUT mvscases.dsc mvdcases.dsc
10
  1  8  0  0 ATL_gemvN_mm.c     "R. Clint Whaley"
  2  0  1  1 ATL_gemvN_1x1_1.c  "R. Clint Whaley"
  3 16 32  1 ATL_gemvN_1x1_1a.c "R. Clint Whaley"
  4  0  4  2 ATL_gemvN_4x2_0.c  "R. Clint Whaley"
  5  0  4  4 ATL_gemvN_4x4_1.c  "R. Clint Whaley"
  6  0  8  4 ATL_gemvN_8x4_1.c  "R. Clint Whaley"
  7  0 16  2 ATL_gemvN_16x2_1.c "R. Clint Whaley"
  8  0 16  4 ATL_gemvN_16x4_1.c "R. Clint Whaley"
  9 16 32  4 ATL_gemvN_32x4_1.c "R. Clint Whaley"
 10 16 32  2 ATL_gemvN_SSE.c    "Camm Maguire" \
    gcc
    -fomit-frame-pointer -O2
 8
101 8  0  0 ATL_gemvT_mm.c      "R. Clint Whaley"
102 0  2  8 ATL_gemvT_2x8_0.c   "R. Clint Whaley"
103 0  4  8 ATL_gemvT_4x8_1.c   "R. Clint Whaley"
104 0  4 16 ATL_gemvT_4x16_1.c  "R. Clint Whaley"
105 0  2 16 ATL_gemvT_2x16_1.c  "R. Clint Whaley"
106 0  1  1 ATL_gemvT_1x1_1.c   "R. Clint Whaley"
107 0  2 32 ATL_gemvT_SSE.c     "Camm Maguire" \
    gcc
    -fomit-frame-pointer -O2
108 0  1 128 ATL_gemv_SSE.c     "Camm Maguire" \
    gcc
    -fomit-frame-pointer -O2

<flag> <Yunroll> <Xunroll> <filename> <author>
<flag> :  add to get all combinations of flags
          0: normal, ATLAS supplied
          8: GEMM-based primitive
         16: Outer-product or AXPY-based primitive (only valid for NoTrans)
         32: Do not block primitive for GEMV call
@ROUT mvccases.dsc
6
  1  8  0 0 ATL_cgemvN_mm.c      "R. Clint Whaley"
  2  0  1 1 ATL_cgemvN_1x1_1.c   "R. Clint Whaley"
  3 16 32 1 ATL_cgemvN_1x1_1a.c  "R. Clint Whaley"
  4  0  4 2 ATL_cgemvN_2x2_0.c   "R. Clint Whaley"
  5  0  4 4 ATL_cgemvN_4x2_1.c   "R. Clint Whaley"
  6 16 32 2 ATL_gemvN_SSE.c      "Camm Maguire" \
    gcc
    -fomit-frame-pointer -O2
6
101 8  0  0 ATL_cgemvT_mm.c      "R. Clint Whaley"
102 0  2  8 ATL_cgemvT_2x2_0.c   "R. Clint Whaley"
103 0  4  8 ATL_cgemvT_2x4_1.c   "R. Clint Whaley"
104 0  1  1 ATL_cgemvT_1x1_1.c   "R. Clint Whaley"
105 0  2 32 ATL_gemvT_SSE.c      "Camm Maguire" \
    gcc
    -fomit-frame-pointer -O2
106 0  1 128 ATL_gemv_SSE.c      "Camm Maguire" \
    gcc
    -fomit-frame-pointer -O2
@ROUT mvzcases.dsc
6
  1  8  0 0 ATL_cgemvN_mm.c      "R. Clint Whaley"
  2  0  1 1 ATL_cgemvN_1x1_1.c   "R. Clint Whaley"
  3 16 32 1 ATL_cgemvN_1x1_1a.c  "R. Clint Whaley"
  4  0  4 2 ATL_cgemvN_2x2_0.c   "R. Clint Whaley"
  5  0  4 4 ATL_cgemvN_4x2_1.c   "R. Clint Whaley"
  6 16 16 2 ATL_gemvN_SSE.c      "Camm Maguire" \
    gcc
    -fomit-frame-pointer -O2
6
101  8 0  0 ATL_cgemvT_mm.c      "R. Clint Whaley"
102  0 2  8 ATL_cgemvT_2x2_0.c   "R. Clint Whaley"
103  0 4  8 ATL_cgemvT_2x4_1.c   "R. Clint Whaley"
104  0 1  1 ATL_cgemvT_1x1_1.c   "R. Clint Whaley"
105  0 2 16 ATL_gemvT_SSE.c      "Camm Maguire" \
    gcc
    -fomit-frame-pointer -O2
106  0 1 128 ATL_gemv_SSE.c      "Camm Maguire" \
    gcc
    -fomit-frame-pointer -O2
@ROUT r1dcases.dsc r1scases.dsc
5
 1 0 16 1 ATL_ger1_axpy.c  "R. Clint Whaley"
 2 0  4 4 ATL_ger1_4x4_1.c "R. Clint Whaley"
 3 0  1 4 ATL_ger1_1x4_0.c "R. Clint Whaley"
 4 0  8 4 ATL_ger1_8x4_0.c "R. Clint Whaley"
 5 0 32 2 ATL_ger1_SSE.c   "Camm Maguire" 
@skip    gcc
@skip    -fomit-frame-pointer -O2
@ROUT r1ccases.dsc
3
 1 0 16 1 ATL_cger1_axpy.c  "R. Clint Whaley"
 2 16 32 2 ATL_ger1_SSE.c   "Camm Maguire" 
@skip    gcc
@skip    -fomit-frame-pointer -O2
 3 0  2 1 ATL_cger1_2x1p.c  "R. Clint Whaley"
@ROUT r1zcases.dsc
3
 1 0 16 1 ATL_cger1_axpy.c "R. Clint Whaley"
 2 0 16 1 ATL_ger1_SSE.c   "Camm Maguire" 
@skip    gcc
@skip    -fomit-frame-pointer -O2
 3 0  2 1 ATL_cger1_2x1p.c "R. Clint Whaley"
@ROUT mvktime mvksearch r1ktime
@extract -b @(topd)/gen.inc what=cw @(cw09)
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "atlas_misc.h"
#include Mstr(Mjoin(Mjoin(atlas_,PRE),sysinfo.h))

@ROUT mvktime r1ktime
static char *resfile=NULL;
static FILE *fpres=NULL;
@ROUT r1ktime
@extract -b @(topd)/FAmalloc.inc
#include "atlas_r1testtime.h"

#ifdef TIME_KERNEL
   void ATL_UGERK(ATL_CINT M, ATL_CINT N, const SCALAR alpha, 
                  const TYPE *X, ATL_CINT incX, const TYPE *Y, ATL_CINT incY, 
                  TYPE *A, ATL_CINT lda);
#else
   void Mjoin(PATL,ger)(ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT, 
                        const TYPE *, ATL_CINT, TYPE *, ATL_CINT);
   #ifdef TREAL
      #define test_ger(M, N, alpha, X, incX, Y, incY, A, lda) \
         Mjoin(PATL,ger)(M, N, *alpha, X, incX, Y, incY, A, lda)
   #else
      #define test_ger(M, N, alpha, X, incX, Y, incY, A, lda) \
         Mjoin(PATL,geru)(M, N, alpha, X, incX, Y, incY, A, lda)
   #endif
#endif

@extract -b @(basd)/atlas-parse.base rout=r1res
@beginskip
double SortDoubles(int N, double *d)
/* 
 * Sorts N-length array d from least to greatest using N^2 selection sort
 */
{
   double min;
   int imin, i, j;

   for (i=0; i < N-1; i++)
   {
      imin = i;
      min = d[i];
      for (j=i+1; j < N; j++)
      {
         if (d[j] < min)
         {
            imin = j;
            min = d[j];
         }
      }
      if (imin != i)
      {
         d[imin] = d[i];
         d[i] = min;
      }
   }
}
@endskip

double Time2Flop(ATL_INT M, ATL_INT N, double time)
{
@ROUT r1ktime
   #ifdef TREAL
      return(((1.0*M)*(2.0*N)+Mmin(M,N))/(time*1.0e6));
   #else
      return(((((6.0*M)*N+Mmin(M,N)) + (2.0*M)*N)*1.0e-6)/time);
   #endif
@ROUT mvktime
   #ifdef TREAL
      return(((1.0e-6 * M)*(2.0*N+1.0))/time);
   #else
      return((((6.0*M)*(N+1.0) + (2.0*M)*N)*1.0e-6)/time);
   #endif
@ROUT mvktime r1ktime
}

void Times2Flops(ATL_INT M, ATL_INT N, ATL_INT ntim, double *mf)
/*
 * Converts time to MFLOP
 */
{
   int i;

   for (i=0; i < ntim; i++)
      mf[i] = Time2Flop(M, N, mf[i]);
}

static double mysum(ATL_CINT N, double *d)
{
   int i;
   double sum;

   sum = d[0];
   for (i=1; i < N; i++)
      sum += d[i];
   return(sum);
}

@ROUT mvktime
#define ATL_UGEMV Mjoin(Mjoin(Mjoin(PATL,gemvT_a1_x1),_b0),_y1)
void ATL_UGEMV(ATL_CINT M, ATL_CINT N, const SCALAR alpha, const TYPE *A, 
               ATL_CINT lda, const TYPE *X, ATL_CINT incX,
               const SCALAR beta, TYPE *Y, ATL_CINT incY);
@multidef UR yu xu
@whiledef TA T N
static void mvsim@(TA)(
   size_t celts,    /* # of elts in cache size we are blocking for */
   size_t pgelts,   /* # of elts on a virtual mem page (best guess) */
   ATL_CINT xu,     /* unrolling on X's loop by this kernel */
   ATL_CINT yu,     /* unrolling on Y's loop by this kernel */
   enum ATLAS_TRANS TA, 
   ATL_CINT M, 
   ATL_CINT N, 
   const TYPE *A, 
   ATL_CINT lda, 
   const TYPE *X, 
   const TYPE *beta, 
   TYPE *Y)
/*
@mif TA = "T
 * This routine assumes the transpose case, where we write Y in the outer
 * loop, and apply X to each column of A in the inner loop, and we therefore
 * cut M in order encourage cache reuse of X
@endmif
@mif TA = "N
 * This routine assumes the Notranspose case, where we read X in the outer
 * loop, and do a axpy with each column of A into Y in the inner loop,
 * and we therefore cut M in order encourage cache reuse of Y
@endmif
 */
{
   ATL_INT Mp, m, i;
   #ifdef TREAL
      #define BETA *beta
      const TYPE alpha = ATL_rone;
   #else
      const TYPE alpha[2] = {ATL_rone, ATL_rzero};
      #define BETA beta
   #endif
/*
 * Compute where to cut M in order to get to reuse the vector in 
 * the celts-length cache
 */
   Mp = (celts - 2*@(UR)) / (2*@(UR)+1);
   if (Mp)
   {
/*
 *    Keep the M partition a multiple of the page size if that doesn't drastically
 *    change it.  This will tend to minimize the cost of moving row-wise by often
 *    avoiding an extra page load that isn't used much.
 */
      if (celts > pgelts+pgelts)
         celts = (celts/pgelts)*pgelts;
   }
   else Mp = M;
   for (i=0; i < M; i += Mp)
   {
      m = M - i;
      m = (m > Mp) ? Mp : m;
@mif TA = "T
//      ATL_UGEMV(m, N, alpha, A+(i SHIFT), lda, X+(i SHIFT), 1, BETA, Y, 1); 
      ATL_UGEMV(N, m, alpha, A+(i SHIFT), lda, X+(i SHIFT), 1, BETA, Y, 1); 
@endmif
@mif TA = "N
      ATL_UGEMV(m, N, alpha, A+(i SHIFT), lda, X, 1, BETA, Y+(i SHIFT), 1);
@endmif
   }
}

   @undef UR
@endwhile
@ROUT r1ktime
#ifdef TIME_KERNEL
double r1time(
   int verb,            /* verbosity */
   int nreps,           /* number of reps to do for one timing sample */
   ATL_INT flushelts,   /* size of area to flush to avoid cache reuse */
   ATL_INT M,           /* # of rows of array A */
   ATL_INT N,           /* # of cols of array A */
   TYPE *alpha,
   ATL_INT lda,         /* leading dim */
   int incX,            /* ignored, assumed 1 by definition */
   int incY,            /* increment on Y; can be non-1 */
   int FAa,             /* if (FA. = 0) enforce no alignment */
   int MAa,             /* else force op to be aligned to at least FA bytes */
   int FAx,             /* if MA. != 0, disallow op to be aligned to MA. bytes */
   int MAx,
   int FAy,
   int MAy)
/* 
 * This function directly calls the kernel routine on data that has been
 * preloaded (through initialization) to any cache large enough to hold it.
 */
{
   double t0, t1;
   TYPE *A, *X, *Y;
   ATL_INT i;

   A = FA_malloc(ATL_MulBySize(lda)*N, FAa, MAa);
   X = FA_malloc(ATL_MulBySize(M), FAx, MAx);
   Y = FA_malloc(ATL_MulBySize(N*incY), FAy, MAy);
   ATL_assert(A && X && Y);

   Mjoin(PATL,gegen)(1, N, Y, incY, M);
   Mjoin(PATL,gegen)(M, 1, X, M, N+127*50+77);
   Mjoin(PATL,gegen)(M, N, A, lda, N*M+513*7+90);
/*
 * NOTE: if nreps too high this could lead to under/overflow, since changing
 * alpha will only help for alpha=X kernels!
 */
   t0 = time00();
   for (i=nreps; i; i--)
   {
      ATL_UGERK(M, N, SVVAL alpha, X, incX, Y, incY, A, lda);
      *alpha = -(*alpha);
   }
   t1 = time00();
   t1 = (t1 - t0)/(1.0*nreps);
   if (verb)
      fprintf(stdout, "   M=%d, N=%d, lda=%d, nreps=%d, time=%e, mflop=%.2f\n",
              M, N, lda, nreps, t1, Time2Flop(M, N, t1));
   return(t1);
}
#else
@ROUT r1ktime
double r1time(
   int verb,            /* verbosity */
   int nreps,           /* number of reps to do for one timing sample */
   ATL_INT flushelts,   /* size of area to flush to avoid cache reuse */
   ATL_INT M,           /* # of rows of array A */
   ATL_INT N,           /* # of cols of array A */
   TYPE *alpha,
   ATL_INT lda,         /* leading dim */
   int xu,              /* unrolling on X */
   int yu,              /* unrolling on Y */
   int FAa,             /* if (FA. = 0) enforce no alignment */
   int MAa,             /* else force op to be aligned to at least FA bytes */
   int FAx,             /* if MA. != 0, disallow op to be aligned to MA. bytes */
   int MAx,
   int FAy,
   int MAy)
@ROUT mvktime
double mvtime_OC(
   int nreps,           /* number of reps to do for one timing sample */
   ATL_INT flushelts,   /* size of area to flush to avoid cache reuse */
   ATL_INT celts,       /* # of elts for cache blocking by MV driver */
   ATL_INT pgelts,      /* guess for virtual mem page size -- used by MV driver */
   enum ATLAS_TRANS TA, 
   ATL_INT M,           /* # of rows of array A */
   ATL_INT N,           /* # of cols of array A */
   ATL_INT lda,         /* leading dim */
   TYPE *beta,
   int xu,              /* unrolling on X */
   int yu,              /* unrolling on Y */
   int FAa,             /* if (FA. = 0) enforce no alignment */
   int MAa,             /* else force op to be aligned to at least FA bytes */
   int FAx,             /* if MA. != 0, disallow op to be aligned to MA. bytes */
   int MAx,
   int FAy,
   int MAy)
@ROUT mvktime r1ktime
/*
 * Times the kernel for out-of-cache (where flushelts sets the cache that it
 * is not allowed to be in) use.  
 * RETURNS: elapsed time in seconds to average repitition of indicated problem.
 */
{
   #ifdef TREAL
      TYPE NONE = -1.0;
   #else
      TYPE NONE[2] = {-1.0, 0.0};
   #endif
   double t0, t1;
   TYPE *A, *X, *Y, *a, *x, *y;
   void *vmem;
@ROUT mvktime
   void (*mvsim)(size_t celts, size_t pgelts, ATL_CINT xu, ATL_CINT yu,
                 enum ATLAS_TRANS TA, ATL_CINT M, ATL_CINT N, const TYPE *A, 
                 ATL_CINT lda, const TYPE *X, const TYPE *beta, TYPE *Y);
@ROUT mvktime r1ktime
   ATL_INT Aelts, Xelts, Yelts, setspan, ygap, xgap, agap, pregap, setsz, nsets;
   ATL_INT i, j;
   size_t ptr_st;
   int maxalign;

@ROUT mvktime `   mvsim = (TA == AtlasNoTrans || TA == AtlasConj) ? mvsimN : mvsimT;`
   if (MAx)
      assert(MAx != FAx);
   if (MAy)
      assert(MAy != FAy);
   if (MAa)
      assert(MAa != FAa);
/*
 * Find basic length of each operand in elements
 */
   Aelts = lda * N;
@ROUT r1ktime
   Xelts = M;
   Yelts = N;
@ROUT mvktime
   Xelts = (TA == AtlasNoTrans || TA == AtlasConj) ? N : M;
   Yelts = (TA == AtlasNoTrans || TA == AtlasConj) ? M : N;
@ROUT mvktime r1ktime
/*
 * Map memory so that we can enforce all required alignments while moving
 * through memory; mem starts with maxalign-aligned memory, so that we can
 * guarantee all further alignments
 */
   maxalign = (FAx >= FAa) ? FAx : FAa;
   maxalign = (maxalign >= FAy) ? maxalign : FAy;
   if (MAx | MAy | MAa)
   {
      maxalign = (MAx >= MAa) ? MAx : MAa;
      maxalign = (maxalign >= MAy) ? maxalign : MAy;
   }
   if (MAx)
   {
      j = (FAx) ? FAx : ATL_sizeof;
      for (i=0; (i % j != 0 || i%MAx == 0); i += ATL_sizeof);
      pregap = i;
   }
   else pregap = 0;
   xgap = ATL_MulBySize(Xelts);
   if (FAy || MAy)
   {
      j = (FAy) ? FAy : ATL_sizeof;
      if (MAy)
         for (i=pregap+xgap; (i%j != 0 || i%MAy == 0); i += ATL_sizeof);
      else
         for (i=pregap+xgap; (i%j != 0); i += ATL_sizeof);
      xgap = i - pregap;
   }
   ygap = ATL_MulBySize(Yelts);
   if (FAa || MAa)
   {
      j = (FAa) ? FAa : ATL_sizeof;
      if (MAa)
         for (i=pregap+xgap+ygap; (i%j != 0 || i%MAa == 0); i += ATL_sizeof);
      else
         for (i=pregap+xgap+ygap; (i%j != 0); i += ATL_sizeof);
      ygap = i - pregap - xgap;
   }
   agap = ATL_MulBySize(Aelts);

   if (maxalign)
   {
      j = pregap;
      for (i=pregap+xgap+ygap+agap; i%maxalign != 0; i++);
      agap = i-xgap-ygap;
   }
   setspan = xgap + ygap + agap;
   assert(setspan%ATL_sizeof == 0);
   setsz = ATL_MulBySize(M+N+M*N);
   nsets = (ATL_MulBySize(flushelts)+setsz-1)/setsz;
   if (!nsets)
      nsets = 1;
   vmem = malloc(maxalign + nsets*setspan);
   assert(vmem);
   if (maxalign)   /* start maxaligned to guarantee all alignments */
      for (ptr_st = (size_t)vmem; ptr_st%maxalign; ptr_st++);
   else ptr_st = (size_t) vmem;
   X = (TYPE*) (ptr_st + pregap);
   Y = (TYPE*) (ptr_st + pregap + xgap);
   A = (TYPE*) (ptr_st + pregap + xgap + ygap);
/*
 * Set ptrs to last set in memory
 */
   setspan /= ATL_sizeof;
   a = A += (nsets-1) * setspan;
   x = X += (nsets-1) * setspan;
   y = Y += (nsets-1) * setspan;
   for (i=nsets; i; i--)
   {
      #define DEBUG_FA
      #ifdef DEBUG_FA
         if (FAa)
            assert(((size_t)a)%FAa == 0);
         if (FAx)
            assert(((size_t)x)%FAx == 0);
         if (FAy)
            assert(((size_t)y)%FAy == 0);
         if (MAa)
            assert(((size_t)a)%MAa != 0);
         if (MAx)
            assert(((size_t)x)%MAx != 0);
         if (MAy)
            assert(((size_t)y)%MAy != 0);
      #endif
      Mjoin(PATL,gegen)(Yelts, 1, y, Yelts, M);
      Mjoin(PATL,gegen)(Xelts, 1, x, Xelts, N+127*50+77);
      if (i&1)
         Mjoin(PATL,scal)(Xelts, NONE, x, 1);
      Mjoin(PATL,gegen)(M, N, A, lda, N*M+513*7+90);
      a -= setspan; x -= setspan; y -= setspan;
   }
   a = A; x = X; y = Y;

   j=0;
   t0 = time00();
   for (i=nreps; i; i--)
   {
@ROUT mvktime `      mvsim(celts, pgelts, xu, yu, TA, M, N, a, lda, x, beta, y);`
@ROUT r1ktime `      test_ger(M, N, alpha, x, 1, y, 1, A, lda);`
      if (++j < nsets) { a -= setspan; x -= setspan; y -= setspan; }
      else  { a = A; x = X; y = Y; j=0; }
   }
   t1 = time00();
   free(vmem);
   t1 = (t1-t0) / (1.0*nreps);
   if (verb)
      fprintf(stdout, "   M=%d, N=%d, lda=%d, nreps=%d, time=%e, mflop=%.2f\n",
              M, N, lda, nreps, t1, Time2Flop(M, N, t1));
   return(t1);
}
@ROUT r1ktime `#endif`

@ROUT mvktime
void DoTimes(int verb, ATL_INT flshelts, ATL_INT celts, ATL_INT pgelts, 
             ATL_INT ntim, ATL_INT nrep, ATL_INT xu, ATL_INT yu, 
             enum ATLAS_TRANS TA, ATL_INT M, ATL_INT N, ATL_INT lda, TYPE *beta,
             int FAa, int MAa, int FAx, int MAx, int FAy, int MAy)
@ROUT r1ktime
void DoTimes(int verb, ATL_INT flshelts, ATL_INT ntim, ATL_INT nrep, 
             ATL_INT xu, ATL_INT yu, ATL_INT M, ATL_INT N, TYPE *alpha, 
             ATL_INT lda, int FAa, int MAa, int FAx, int MAx, int FAy, int MAy)
@ROUT mvktime r1ktime
{
   double *times;
   int i;

   times = malloc(ntim * sizeof(double));
   assert(times);
   
@ROUT r1ktime
#ifdef TREAL
   fprintf(stdout, 
           "GER1: M=%d, N=%d, lda=%d, AF=[%d,%d,%d], AM=[%d,%d,%d], alpha=%e:\n",
           M, N, lda, FAa, FAx, FAy, MAa, MAx, MAy, *alpha);
#else
   fprintf(stdout, 
      "GER1: M=%d, N=%d, lda=%d, AF=[%d,%d,%d], AM=[%d,%d,%d], alpha=[%e,%e]:\n",
           M, N, lda, FAa, FAx, FAy, MAa, MAx, MAy, *alpha, alpha[1]);
#endif
   for (i=0; i < ntim; i++)
      times[i] = r1time(verb, nrep, flshelts, M, N, alpha, lda,
                        xu, yu, FAa, MAa, FAx, MAx, FAy, MAy);
@ROUT mvktime
#ifdef TREAL
   fprintf(stdout, 
           "GEMV: M=%d, N=%d, lda=%d, AF=[%d,%d,%d], AM=[%d,%d,%d], beta=%e:\n",
           M, N, lda, FAa, FAx, FAy, MAa, MAx, MAy, *beta);
#else
   fprintf(stdout, 
      "GEMV: M=%d, N=%d, lda=%d, AF=[%d,%d,%d], AM=[%d,%d,%d], beta=[%e,%e]:\n",
           M, N, lda, FAa, FAx, FAy, MAa, MAx, MAy, *beta, beta[1]);
#endif
   for (i=0; i < ntim; i++)
      times[i] = mvtime_OC(nrep, flshelts, celts, pgelts, TA, M, N, lda, beta,
                           xu, yu, FAa, MAa, FAx, MAx, FAy, MAy);
@ROUT mvktime r1ktime
   SortDoubles(ntim, times);
   Times2Flops(M, N, ntim, times);
   if (fpres)
   {
      #if defined(PentiumCPS) || defined(WALL)
         fprintf(fpres, "%d 1\n", ntim);
      #else
         fprintf(fpres, "%d 0\n", ntim);
      #endif
      for (i=0; i < ntim; i++)
         fprintf(fpres, "%le\n", times[i]);
      fclose(fpres);
   }
   fprintf(stdout, "NSAMPLES=%d, MAX=%.2f, MIN=%.2f, AVG=%.2f, MED=%.2f\n", 
           ntim, times[0], times[ntim-1], mysum(ntim, times)/ntim,
           times[ntim>>1]);
   free(times);
}

void PrintUsage(char *name, char *arg, int i)
{
   if (i > 0)
      fprintf(stderr, "BAD ARG '%s' on %dth FLAG\n", arg, i);
   fprintf(stderr, "USAGE: %s [flags], where flags are:\n", name);
   fprintf(stderr, "   -v <#> : set verbosity level\n");
   fprintf(stderr, "   -C <#> : set flushsz = # (kbytes)\n");
@ROUT mvktime
   fprintf(stderr, "   -p <#> : set pagesz = # (kbytes)\n");
   fprintf(stderr, 
       "   -G <#> : set GEMV cache size (for blocking) to # (kbytes)\n");
@ROUT mvktime r1ktime
   fprintf(stderr, "   -x <#> : unrolling for X in kernel is #\n");
   fprintf(stderr, "   -y <#> : unrolling for Y in kernel is #\n");
   fprintf(stderr, "   -m <#> : set # of rows of matrix to #\n");
   fprintf(stderr, "   -n <#> : set # of cols of matrix to #\n");
   fprintf(stderr, "   -l <#> : set leading dimension of array A to #\n");
   fprintf(stderr, "   -F <#> : do at least # MFLOPS for each timing interval\n");
   fprintf(stderr, "   -f <file> : output timing summary in <file>; if file exists read & report\n");
@ROUT mvktime
   fprintf(stderr, "   -A n/t/c/z : set transpose (z = Conj, NoTrans)\n");
@ROUT mvktime r1ktime
   fprintf(stderr, 
           "   -r <#> : do # repetitions of the call for each timing interval\n");
   fprintf(stderr, 
      "   -# <#> : report # timings (each interval may have multiple calls)\n");
   fprintf(stderr, 
"   -F[x,y,a] <#> : if(# > 0) -> force op to be aligned to at least # bytes\n");
   fprintf(stderr, 
"                   if(# < 0) -> force op to be aligned to < # bytes.\n");
   fprintf(stderr, "   -b <beta> : 2 floats for complex, one for real.\n");
   exit(i ? i : -1);
}

void GetFlags(int nargs, char **args, int *verb,
              ATL_INT *flushelts, ATL_INT *celts, ATL_INT *pgelts, 
              ATL_INT *xu, ATL_INT *yu, ATL_INT *ntim, ATL_INT *nrep, 
              enum ATLAS_TRANS *TA, ATL_INT *m, ATL_INT *n, ATL_INT *lda, 
              TYPE *beta,
              int *FAa, int *MAa, int *FAx, int *MAx, int *FAy, int *MAy)
{
   double mfF=ATL_nkflop/1000.0, flops;
   ATL_INT j, h;
   int i;
   char ch;

   *verb = 1;
   #ifdef ATL_PAGESZ
      *pgelts = ATL_DivBySize(ATL_PAGESZ);
   #else
      *pgelts = 4*ATL_DivBySize(1024);
   #endif
   *celts = 0.75*ATL_L1elts;
   *flushelts = 8*1024*ATL_DivBySize(1024);
   *xu = *yu = 1;
   *m = 800;
   *n = 200;
   *nrep = *lda = 0;
   *ntim = 3;
   *FAa = *MAa = *FAx = *MAx = *FAy = *MAy = 0;
   *beta = 1.0;
   #ifdef TCPLX
      beta[1] = 0.0;
   #endif

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], "No '-' preceeding flag!", i);
      switch(args[i][1])
      {
      case 'f' :  /* set resfile output */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -f ", i-1);
         resfile = args[i];
         break;
      case 'v' :  /* set verbosity */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -v ", i-1);
         *verb = atoi(args[i]);
         break;
      case 'G' :  /* set GEMV blocking cache size in KB */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -G ", i-1);
         j = atoi(args[i]);
         *celts = j*ATL_DivBySize(1024);
         break;
      case 'A' :  /* set transpose */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -A ", i-1);
         ch = args[i][0];
         if (ch == 't' || ch == 'T')
            *TA = AtlasTrans;
         else if (ch == 'c' || ch == 'C')
            *TA = AtlasConjTrans;
         else if (ch == 'z' || ch == 'Z')
            *TA = AtlasConj;
         else
            *TA = AtlasNoTrans;
         break;
      case 'C' :  /* set flushsz in KB */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -C ", i-1);
         j = atoi(args[i]);
         *flushelts = j*ATL_DivBySize(1024);
         break;
      case 'p' :  /* set pagesz in KB */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -p ", i-1);
         j = atoi(args[i]);
         *pgelts = j*ATL_DivBySize(1024);
         break;
      case 'x' :  /* set xu */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -x ", i-1);
         *xu = atoi(args[i]);
         break;
      case 'y' :  /* set yu */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -y ", i-1);
         *yu = atoi(args[i]);
         break;
      case 'm' :  /* set M */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -m ", i-1);
         *m = atoi(args[i]);
         break;
      case 'n' :  /* set N */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -n ", i-1);
         *n = atoi(args[i]);
         break;
      case 'l' :  /* set lda */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -l ", i-1);
         *lda = atoi(args[i]);
         break;
      case 'a' : /* alias for setting alpha in r1ktime */
      case 'b' : /* set beta */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -b ", i-1);
         *beta = atof(args[i]);
         #ifdef TCPLX
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -b ", i-1);
            beta[1] = atof(args[i]);
         #endif
         break;
      case 'F' :  /* set nrep by specifying MFLOPS, or force alignment */
         ch = args[i][2];
         if (!ch)   /* specifying MFLOPS */
         {
            if (++i >= nargs)
               PrintUsage(args[0], "out of flags in -F ", i-1);
            j = atoi(args[i]);
            mfF = j;
         }
         else
         {
            if (ch != 'a' && ch != 'y' && ch != 'x')
               PrintUsage(args[0], args[i], i);
            if (++i >= nargs)
               PrintUsage(args[0], args[i-1], i-1);
            j = atoi(args[i]);
            if (j < 0)
            {
               if (ch == 'a')
                  *MAa = -j;
               else if (ch == 'y')
                  *MAy = -j;
               else if (ch == 'x')
                  *MAx = -j;
            }
            else
            {
               if (ch == 'a')
                  *FAa = j;
               else if (ch == 'y')
                  *FAy = j;
               else if (ch == 'x')
                  *FAx = j;
            }
         }
         break;
      case 'r' :  /* set nrep directly as integer */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -r ", i-1);
         *nrep = atoi(args[i]);
         break;
      case '#' :  /* set number of timings to report */
         if (++i >= nargs)
            PrintUsage(args[0], "out of flags in -# ", i-1);
         *ntim = atoi(args[i]);
         break;
      default:
         PrintUsage(args[0], args[i], i);
      }
   }
   if (!(*nrep))
   { 
      flops = Time2Flop(*m, *n, 1.0) * 1000.0;  /* Get kiloFLOPS in GEMV */
      *nrep = (mfF+flops-1)/flops;
      if (*nrep < 1) *nrep = 1;
   }
   if (!(*lda))
      *lda = *m + 8;
}
int main(int nargs, char **args)
{
   ATL_INT flushelts, celts, pgelts, xu, yu, ntim, nrep, m, n, lda;
   int FAa, MAa, FAx, MAx, FAy, MAy;    /* Force & Max align for ops */
   int verb;
   enum ATLAS_TRANS TA;
   double *dres;
   #ifdef TREAL
      TYPE beta;
   #else
      TYPE beta[2];
   #endif

   GetFlags(nargs, args, &verb, &flushelts, &celts, &pgelts, &xu, &yu, &ntim, 
            &nrep, &TA, &m, &n, &lda, SADD beta, 
            &FAa, &MAa, &FAx, &MAx, &FAy, &MAy);
   if (resfile)
   {
      dres = ReadResultsFile(1, resfile);
      if (dres)
      {
         fprintf(stdout, "TIMINGS READ IN FROM '%s':\n", resfile);
         PrintResultsFromFile(stdout, dres);
         free(dres);
         exit(0);
      }
      fpres = fopen(resfile, "w");
      assert(fpres);
   }
@ROUT r1ktime
   DoTimes(verb, flushelts, ntim, nrep, xu, yu, m, n, SADD beta, lda, 
           FAa, MAa, FAx, MAx, FAy, MAy);
@ROUT mvktime
   DoTimes(verb, flushelts, celts, pgelts, ntim, nrep, xu, yu, TA, m, n, lda, 
           SADD beta, FAa, MAa, FAx, MAx, FAy, MAy);
@ROUT mvktime r1ktime
   exit(0);
}
@ROUT sr1cases.idx dr1cases.idx cr1cases.idx zr1cases.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
# The file has the following format:
# ROUT='routine name' AUTH='author names' COMP='compiler name' FLAGS='flags'
# ID=<id> YU=<yu> XU=<xu> minY=<#> minX=<#> alignX=<#> alignY=<#> alignA=<#>,
# SSE=[0,1,2,3] X87=[0,1] PREF[a,x,y]=[DIST,INSTDIST, INST] LDAMUL=<#>
# ALLALIGNXY=[0,1] GEMMBASED=[0,1] CONJDEF=[0,1] FYU=[0,1]
# ASM=[asmlist], eg., asmlist is "GAS_x8664,GAS_x8632" or "GAS_SPARC"
# ASM defaults to no assembly dialect required.
# If YU/XU is negative, then the routine can only handle multiples of YU/XU.
#
# Assuming M is the length of X, and N is the length of Y, all routines
# are assumed to handle any runtime value of N >= minY, M >= minX.
# They must respect the compile-time macros BETA0, BETA1, & BETAX.
# Some less-obvious keywords:
# LDAMUL    : Kernel will only work if lda is a multiple of # (in bytes)
# PFTUNEx   : Kernel uses pref_x(mem) macro for each op=x (A,y,x).  prefetch
#             inst can be varied wt this macro, as can fetch distance.
#             If set to INSTDIST, tune both distance and instruction type;
#             If set to INST, tune instruction type only
#             If set to DIST, tune distance only
# FYU       : if set, kernel can only handle N where N%YU == 0
@ROUT sr1cases.idx dr1cases.idx
ID=1 XU=16 YU=1  AUTH='R. Clint Whaley' ROUT='ATL_ger1_axpy.c'
ID=2 XU=4  YU=4  AUTH='R. Clint Whaley' ROUT='ATL_ger1_4x4_1.c'
ID=3 XU=1  YU=4  AUTH='R. Clint Whaley' ROUT='ATL_ger1_1x4_0.c'
ID=4 XU=8  YU=4  AUTH='R. Clint Whaley' ROUT='ATL_ger1_8x4_0.c'
ID=5 XU=32 YU=2  SSE=2 ASM=GAS_x8632 AUTH='Camm Maquire' ROUT='ATL_ger1_SSE.c'
@ROUT cr1cases.idx zr1cases.idx
ID=1  XU=16 YU=1  AUTH='R. Clint Whaley' ROUT='ATL_cger1_axpy.c'
ID=2  XU=32 YU=2  AUTH='Camm Maguire'    ROUT='ATL_ger1_SSE.c'
ID=3  XU=2  YU=1  AUTH='R. Clint Whaley' ROUT='ATL_cger1_2x1p.c'
@ROUT r1ksearch
@define rt @r1@
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
@skip @extract -b @(basd)/atlconf.base rout=asmconf.h
#include "atlas_misc.h"
#include "atlas_r1parse.h"
#include "atlas_r1testtime.h"

@skip @extract -b @(basd)/atlas-parse.base rout=r1read

ATL_r1node_t *TimeAllKernels
(
   int L1CacheElts,             /* size of L1 cache in elements */
   int imf,                     /* index into bp->mflop  */
   char pre,                    /* type/precision prefix */
   int  M, int N, int lda,      /* problem dimensions */
   int Fflops,                  /* what to set Force flops to (see below) */
   ATL_r1node_t *kq             /* queue of kernels */
)
/* 
 * This routine times all kernels in kq, putting results in kq->mflop[imf]
 * Fflops: for very large problems, set to 0, else the # of flops to force
 * RETURNS: ptr to fastest kernel
 */
{
   ATL_r1node_t *kp, *bestp=NULL;
   int percL1;
   double mf, mfmax=0.0;

   for (kp=kq; kp; kp = kp->next)
   {
      mf = ((double)kp->CacheElts) / ((double)L1CacheElts)*100.0;
      percL1 = mf;
      mf = Time@up@(rt)Kernel(1, 0, kp, pre, M, N, lda, percL1, Fflops, -1);
      kp->mflop[imf] = mf;
      if (mf > mfmax)
      {
         bestp = kp;
         mfmax = mf;
      }
   }
   return(bestp);
}

ATL_r1node_t *TimeAllKernelsForContext
(
   int L1CacheElts,     /* size of L1 cache in elements */
   int imf,             /* index into mflop & see below */
   char pre,            /* type/precision prefix */
   ATL_r1node_t *bp     /* queue of kernels */
)
/* 
 * This routine naively assumes that 4*L1CacheSize is a decent marker for
 * the L2 size to use in initial L2-timings.
 *
 * imf: parameter describing type of timings to perform:
 *    0: large out-of-cache, blocked for 85% of L1CacheSize
 *    1: large out-of-cache, blocked for MIN(128K,4*L1CacheSize) (L2-blocked)
 *    2: large out-of-cache, no blocking
 *    3: in-L2 problem, no blocking
 *    4: in-L1 problem, no blocking
 * RETURNS: best-performing kernel in context
 */
{
   ATL_r1node_t *r1p, *r1max=NULL;
   double mf, mfmax=0.0;
   int M, N, lda, percL1, cflush=(-1);

   if (imf == 0 || imf == 1 || imf == 2)
   {
      M = (pre == 's') ? 2000 : 1000;
      N = (pre == 'z') ? 500 : 1000;
      cflush = -1;
      percL1 = imf ? 400 : 85;
      percL1 = (imf == 2) ? 0 : percL1;
   }
   else   /* Time in-cache data with no blocking */
      cflush = percL1 = 0;
   for (r1p=bp; r1p; r1p = r1p->next)
   {
      if (imf == 3)  /* L2-contained data */
      {
         N = ((16+r1p->YU-1)/r1p->YU)*r1p->YU;
         M = 128*1024/pre2size(pre);
         if (M > 4*L1CacheElts)
            M = 4*L1CacheElts;
         M /= N;
      }
      else if (imf == 4)  /* L1-contained data */
      {
         N = ((8+r1p->YU-1)/r1p->YU)*r1p->YU;
         M = (85*L1CacheElts)/(N*100);
      }
      lda = M+8;
      mf = Time@up@(rt)Kernel(0, 0, r1p, pre, M, N, lda, percL1, -1, cflush);
      if (mf > mfmax)
      {
         mfmax = mf;
         r1max = r1p;
      }
      r1p->mflop[imf] = mf;
   }
   return(r1max);
}

static ATL_r1node_t *DelBadTestKernels(char pre, ATL_r1node_t *bp)
/*
 * Deletes all kernels that can't pass basic usage test
 */
{
   int die;
   ATL_r1node_t *p, *prev;
   int m, n, lda, i, j;
   fprintf(stdout, "\nBEGIN BASIC KERNEL TESTS:\n");

   prev = p = bp;
   while(p)
   {
      m = n = lda = 1000;
      if (FLAG_IS_SET(p->flag, R1F_FYU))
      {
         i = p->YU;
         n = ((n+i-1)/i)*i;
      }
      if (p->ldamul)
      {
         j = pre2size(pre);
         i = p->ldamul / j;
         assert(p->ldamul == i*j);
         lda = ((lda+i-1)/i)*i;
      }
      if (@up@(rt)KernelFailsTest(0, pre, m, n, lda, p))
      {
         fprintf(stdout, "   NUKING bad kernel %s(%d)\n", p->rout, p->ID);
         if (p == bp)
            bp = p = KillR1Node(p);
         else
            prev->next = p = KillR1Node(p);
      }
      else
      {
         fprintf(stdout, "   Kernel %s(%d) passes basic test\n", 
                 p->rout, p->ID);
         prev = p;
         p = p->next;
      }
   }
   fprintf(stdout, "DONE BASIC KERNEL TESTS:\n\n");
   return(bp);
}

ATL_r1node_t *ChooseKernelBlocking
(ATL_r1node_t *L1,      /* L1 blocked kernel, scope imf=0 */
 ATL_r1node_t *L2,      /* L2 blocked kernel, scope imf=1 */
 ATL_r1node_t *NOB      /* no-blocking kernel, scope imf=2 */
)
/*
 * This routine compares 3 different blocking strategy using 1-3 kernels
 * (i.e., they may all be the same kernel).
 * It is possible that the data we use may stay in a very large L3 cache,
 * so only accept no-blocking if it is significantly faster than doing
 * blocking.  L1-blocking will tend to minimize the number of kernels required,
 * so stress it very slightly more than L2 blocking.
 * RETURNS: cloned node of best blocking/kernel
 */
{
   ATL_r1node_t *best;
   double mf1, mf2, mf3;

   mf1 = L1->mflop[0] * 1.05;  /* give small adv to safest option, L1 blk */
   mf2 = L2->mflop[1] * 1.03;  /* give small adv to blocking over not */
   mf3 = NOB->mflop[2];        /* no blocking loss may vary by size, penalize */
   if (mf1 > mf2 && mf1 > mf3)
      best = L1;
   else if (mf2 > mf1 && mf2 > mf3)
      best = L2;
   else
      best = NOB;
   return(best);
}

double ExhCESrch
/*
 * RETURNS: best mflop found 
 */
(
   ATL_r1node_t *r1p,           /* kernel to search with */
   char pre,                    /* type/precision prefix */
   int M, int N, int lda,
   int stride,                  /* stride to search with, real pL = pL*stride */
   int pLL,                     /* lower percL1 (mul by stride for real val) */
   int pLH,                     /* higher percL1 */
   double mfL,                  /* mflops achieved by lower */
   double mfH,                  /* mflops achieved by higher */
   int *pLB                     /* the best percL1 found */
)
{
   int plm, plb;
   double mf;

   plm = (pLH-pLL)>>1;
   if (plm < 1)
   {
      if (mfL < mfH)
      {
         *pLB = pLH;
         return(mfH);
      }
      *pLB = pLL;
      return(mfL);
   }
   plm += pLL;
   mf = Time@up@(rt)Kernel(0, 0, r1p, pre, M, N, lda, plm*stride, 0, -1);
   fprintf(stdout, "%6d  %6d  %6d  %6d  %9.2f\n", M, N, lda, plm*stride, mf);
   mfL = ExhCESrch(r1p, pre, M, N, lda, stride, pLL, plm, mfL, mf, pLB);
   mfH = ExhCESrch(r1p, pre, M, N, lda, stride, plm, pLH, mf, mfH, &plb);
   if (mfH > mfL)
   {
      mfL = mfH;
      *pLB = plb;
   }
   return(mfL);
}

@beginskip
int LineCEsrch
/*
 * Performs an line search, searching npts equally spaced points between
 * pLL and pLH (npts excludes these end points).
 * RETURNS: best performing of (lower,higher) point around best found.
 * Modifies r1p->CacheElts to be best % of L1 size found.
 */
(
   ATL_r1node_t *r1p,           /* kernel to search with */
   int imf,                     /* set r1p->mflop[imf] to best perf */
   char pre,                    /* type/precision prefix */
   int M, int N, int lda,       /* prob size to tune with */
   int npts,                    /* number of points to search */
   int pLL,                     /* lower percL1 (mul by stride for real val) */
   int pLH                      /* higher percL1 */
)
{
   int inc, bestL1p;
   double mfmax, mf;

   bestL1p = pLL;
   mfmax = Time@up@(rt)Kernel(0, 0, r1p, pre, M, N, lda, pLL, 0, -1);
   inc = (pLH-pLL)/npts;
   if (inc)
   {
      for (i=pLL+inc; i <= pLH; i += inc)
      {
         mf = Time@up@(rt)Kernel(0, 0, r1p, pre, M, N, lda, i, 0, -1);
         if (mf > mfmax*1.01)
         {
            mfmax = mf;
            bestL1p = i;
         }
      }
   }
   mf = Time@up@(rt)Kernel(0, 0, r1p, pre, M, N, lda, pLH, 0, -1);
   if (mf > mfmax*1.01)
   {
      mfmax = mf;
      bestL1p = pLH;
   }
   r1p->CacheElts = bestL1p;
   if (bestL1p == pLL)
      iret = Mmin(pLH,
}
@endskip

void ExhaustiveCESrch
/*
 * Performs an exhaustive search on entire range using recursive halving
 * And modifies CE to be best % of L1 size found.
 */
(
   ATL_r1node_t *r1p,           /* kernel to search with */
   int imf,                     /* set r1p->mflop[imf] to best perf */
   char pre,                    /* type/precision prefix */
   int M, int N, int lda,       /* prob size to tune with */
   int stride,                  /* stride to search with, real pL = pL*stride */
   int pLL,                     /* lower percL1 (mul by stride for real val) */
   int pLH                      /* higher percL1 */
)
{
   double mfH, mfL;
   int percL1;
   fprintf(stdout, "     M       N     lda  percL1       mflop\n");
   fprintf(stdout, "======  ======  ======  ======  ==========\n");
   
   mfL = Time@up@(rt)Kernel(0, 0, r1p, pre, M, N, lda, pLL*stride, 0, -1);
   fprintf(stdout, "%6d  %6d  %6d  %6d  %9.2f\n", M, N, lda, pLL*stride, mfL);
   mfH = Time@up@(rt)Kernel(0, 0, r1p, pre, M, N, lda, pLH*stride, 0, -1);
   fprintf(stdout, "%6d  %6d  %6d  %6d  %9.2f\n", M, N, lda, pLH*stride, mfH);
   mfL = ExhCESrch(r1p, pre, M, N, lda, stride, pLL, pLH, mfL, mfH, &percL1);
   fprintf(stdout, "\nBEST CASE %d percent of L1, MFLOP=%.2f\n\n", 
           percL1*stride, mfL);
   r1p->mflop[imf] = mfL;
   r1p->CacheElts = percL1*stride;
}

static int GetMaxID(ATL_r1node_t *r1b)
{
   ATL_r1node_t *r1p;
   int maxID=0;

   for (r1p=r1b; r1p; r1p = r1p->next)
      maxID = Mmax(maxID, r1p->ID);

   return(maxID);
}
#ifdef ATL_SSE3
void FillInGenNode
(
   ATL_r1node_t *r1p,   /* data structure to fill in */
   int nmu,             /* unrolling on mu unrolled inner (X) loop */
   int mu,              /* register blk to apply to X */
                        /* total X unrolling is nmu*mu! */
   int nu,              /* unroll&jam on outer (Y) loop */
   int evenlda,         /* assume X&Y have same (mis)align, lda is even */
   int allalign16,      /* assume X,Y,A all aligned to 16 bytes */
   int aptrs            /* use ptrs rather than lda for column indexing */
)
{
   char ln[2048];
   r1p->NXU = nmu;
//   HERE HERE HERE
}
ATL_r1node_t *SrchSSEGen
(
   char pre,  /* precision prefix indicating type */
   int maxID  /* IDs > maxID are safe to use in generation */
)
/*
 * This search finds the best kernel provided by the ATLAS SSE GER generator
 * RETURNS: a list of kernels to be added to the multiple implementation srch
 */
{
   return(NULL);
}
#endif

ATL_r1node_t *SortRestricted
/*
 * Sorts queue of kernels into a queue of unrestricted kernels (can be
 * always be used) and restricted (only used under certain conditions,
 * such as lda*size a multiple 16).  Destroys R1B in process.
 */
(
   ATL_r1node_t *R1B,   /* original queue containing restricted & unrest */
   ATL_r1node_t **R1R   /* queue of only restricted kernels */
)
{
   ATL_r1node_t *r1B=NULL, *r1R=NULL, *r1b=NULL, *r1r=NULL, *r1p;

   for (r1p=R1B; r1p; r1p = r1p->next)
   {
      if (FLAG_IS_SET(r1p->flag, R1F_ALGLDA))
      {
         if (r1R)
            r1r->next = r1p;
         else
            r1R = r1p;
         r1r = r1p;
      }
      else
      {
         if (r1B)
            r1b->next = r1p;
         else
            r1B = r1p;
         r1b = r1p;
      }
   }
   if (r1R)
      r1r->next = NULL;
   assert(r1B);
   r1b->next = NULL;
   *R1R = r1R;
   return(r1B);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n",
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set precision prefix \n");
   exit(ierr ? ierr : -1);
}

void GetFlags(int nargs, char **args, char *pre)
{
   int i;
   char ch;

   *pre = 'd';
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'p':  /* -p <pre> */
         if (++i >= nargs)
            PrintUsage(args[0], i, NULL);

         ch = tolower(args[i][0]);
         assert(ch == 's' || ch == 'd' || ch == 'c' || ch == 'z');
         *pre = ch;
         break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
}

void WriteR1SummFile(char pre, ATL_r1node_t *r1b)
{
   char ln[256];
   FILE *fpout;

   sprintf(ln, "res/%cR1SUMM", pre);
   fpout = fopen(ln, "w");
   assert(fpout);
   fprintf(fpout, "#\n#MFLOP array has following meaning by index:\n");
   fprintf(fpout, "#   0 : Out-of-cache, L1 blocked\n");
   fprintf(fpout, "#   1 : Out-of-cache, L2 blocked\n");
   fprintf(fpout, "#   2 : Out-of-cache, no blocking\n");
   fprintf(fpout, "#   3 : Problem preloaded to L2, no blocking\n");
   fprintf(fpout, "#   4 : Problem preloaded to L1, no blocking\n#\n");
   fprintf(fpout, "#\n#Each kernel context has two kernels:\n");
   fprintf(fpout, 
           "#   1st has a restriction and so can't be called all the time\n");
   fprintf(fpout, "#   2nd is used whenever restricted kernel can't be\n");
   fprintf(fpout, "#   -> If kernels are same, no restricted kernel needed\n");
   fprintf(fpout, "#\n");
   fprintf(fpout, 
   "# --------------------------------------------------------------\n");
   fprintf(fpout, 
   "# Next two lines are GER kernels to use for out-of-cache timings\n");
   fprintf(fpout, 
   "# --------------------------------------------------------------\n");
   PrintR1Line(fpout, r1b);
   PrintR1Line(fpout, r1b->next);
   r1b = r1b->next->next;
   fprintf(fpout, "# ---------------------------------------------------------------------------\n");
   fprintf(fpout, "# The next two GER kernels are for use when ops are preloaded to the L2 cache\n");
   fprintf(fpout, "# ---------------------------------------------------------------------------\n");
   PrintR1Line(fpout, r1b);
   PrintR1Line(fpout, r1b->next);
   r1b = r1b->next->next;
   fprintf(fpout, "# ---------------------------------------------------------------------------\n");
   fprintf(fpout, "# The next two GER kernels are for use when ops are preloaded to the L1 cache\n");
   fprintf(fpout, "# ---------------------------------------------------------------------------\n");
   PrintR1Line(fpout, r1b);
   PrintR1Line(fpout, r1b->next);
   r1b = r1b->next->next;
   fprintf(fpout, 
           "# -----------------------------------------------------------\n");
   fprintf(fpout, 
           "# Last two lines are L1-blocked kernels for building SYR/SYR2\n");
   fprintf(fpout, 
           "# -----------------------------------------------------------\n");
   PrintR1Line(fpout, r1b);
   PrintR1Line(fpout, r1b->next);
   fclose(fpout);
}

main(int nargs, char **args)
{
   ATL_r1node_t *r1b, *r1p, *r1r, *r1bestL2b; 
   ATL_r1node_t *r1bestOC, *r1bestOCr, *r1bestL1b, *r1bestL1br;
   ATL_r1node_t *r1bestL1, *r1bestL1r, *r1bestL2, *r1bestL2r;
   FILE *fpin, *fpout;
   double mf, percL1;
   int i, L1CacheElts, CE1, CE2, maxID, bigN;
   char ln[128];
   char pre;

   GetFlags(nargs, args, &pre);
   if (pre == 'd' || pre == 'c')
      bigN = 2048;
   else if (pre == 's')
      bigN = 2896;
   else
      bigN = 1448;
   sprintf(ln, "res/%cR1SUMM", pre);
   L1CacheElts = (GetL1CacheSize()*1024) / pre2size(pre);
   r1b = ReadR1File(ln);
   maxID = GetMaxID(r1b);
   if (r1b)
   {
      if (r1b->next->next->mflop[3] <= 0.0)
      {
/*
 *       Retime out-of-cache kernel
 */
         r1p = r1b;
         r1p = r1b->next->next;
         r1b->next->next = NULL;
         if (r1p->next->ID == r1p->ID)
         {
            TimeAllKernels(L1CacheElts, 0, pre, bigN, bigN, bigN, 0, r1p->next);
            r1p->mflop[0] = r1p->next->mflop[0];
         }
         else
            TimeAllKernels(L1CacheElts, 0, pre, bigN, bigN, bigN, 0, r1p);
         r1b->next->next = r1p;
/* 
 *       Retime in-L2 timings
 */
         r1p = r1b->next->next;
         r1r = r1p->next->next;
         r1p->next->next = NULL;
         if (r1p->ID == r1p->next->ID)
         {
            TimeAllKernelsForContext(L1CacheElts, 3, pre, r1p->next);
            r1p->mflop[3] = r1p->next->mflop[3];
         }
         else
            TimeAllKernelsForContext(L1CacheElts, 3, pre, r1p);
         r1p->next->next = r1r;
/* 
 *       Retime in-L1 timings
 */
         r1p = r1p->next->next;
         r1r = r1p->next->next;
         r1p->next->next = NULL;
         if (r1p->ID == r1p->next->ID)
         {
            TimeAllKernelsForContext(L1CacheElts, 4, pre, r1p->next);
            r1p->mflop[4] = r1p->next->mflop[4];
         }
         else
            TimeAllKernelsForContext(L1CacheElts, 4, pre, r1p);
         r1p->next->next = r1r;
/*
 *       Retime L1-blocked out-of-cache timings
 */
         r1p = r1p->next->next;
         if (r1p->next->ID == r1p->ID)
         {
            TimeAllKernels(L1CacheElts, 0, pre, bigN, bigN, bigN, 0, r1p->next);
            r1p->mflop[0] = r1p->next->mflop[0];
         }
         else
            TimeAllKernels(L1CacheElts, 0, pre, bigN, bigN, bigN, 0, r1p);
         WriteR1SummFile(pre, r1b);
      }
      PrintR1Nodes(stdout, r1b);
      KillAllR1Nodes(r1b);
      exit(0);
   }
   sprintf(ln, "CASES/%cr1cases.idx", pre);
   r1b = ReadR1File(ln);
   fprintf(stdout, "\nCases read in:\n");
   WriteR1File("stdout", r1b);
   r1b = DelBadArchKernels(r1b);
@skip   fprintf(stdout, "\nCases after weeding:\n");
@skip   WriteR1File("stdout", r1b);
   r1b = DelBadTestKernels(pre, r1b);
   fprintf(stdout, "\nSurviving cases:\n");
   WriteR1File("stdout", r1b);

   #ifdef ATL_SSE3   /* current generator requires SSE3 */
      r1p = SrchSSEGen(pre, maxID);
      if (r1p)
      {
         while (r1p->next) 
            r1p = r1p->next;
         r1p->next = r1b;
         r1b = r1p;
      }
   #endif
   r1b = SortRestricted(r1b, &r1r);     /* sort into general & rest kernels */
/*
 * Find best general kernel for L1-blocked out-of-cache behavior; use
 * cache elements of 85% of L1 size
 */
   for (r1p=r1b; r1p; r1p = r1p->next)
      r1p->CacheElts = 0.85 * L1CacheElts;
   fprintf(stdout, "\nBEGIN L1-BLOCKED TUNING\n");
   r1p = TimeAllKernels(L1CacheElts, 0, pre, bigN, bigN, bigN, 0, r1b);
   r1bestL1b = Clone@up@(rt)Node(r1p);
   r1bestL1b->next = NULL;
   fprintf(stdout, "DONE L1-BLOCKED TUNING, CHOSE '%s' (%.2f)\n",
           r1bestL1b->rout, r1bestL1b->mflop[0]);
/* 
 * Find best L1 blocking % of cache, convert back to Elts
 */
   ExhaustiveCESrch(r1bestL1b, 0, pre, bigN, bigN, bigN, 2, 25, 50);
   r1bestL1b->CacheElts = L1CacheElts*0.01*r1bestL1b->CacheElts;
/*
 * Find best kernel for L2-blocked out-of-cache context; use min of 4*L1 
 * and 128K as good effective L2 estimate, convert back to elts
 */
   CE1 = 4 * L1CacheElts;
   CE1 = Mmin(CE1, 128*1024/pre2size(pre));
   for (r1p=r1b; r1p; r1p = r1p->next)
      r1p->CacheElts = CE1;
   fprintf(stdout, "\nBEGIN L2-BLOCKED TUNING\n");
   r1p = TimeAllKernels(L1CacheElts, 1, pre, bigN, bigN, bigN, 0, r1b);
   r1bestL2b = Clone@up@(rt)Node(r1p);
   r1bestL2b->next = NULL;
   fprintf(stdout, "DONE L2-BLOCKED TUNING, CHOSE '%s' (%.2f)\n",
           r1bestL2b->rout, r1bestL2b->mflop[1]);
   ExhaustiveCESrch(r1bestL2b, 0, pre, bigN, bigN, bigN, 
                    50, 3, 16);
   r1bestL2b->CacheElts = L1CacheElts*0.01*r1bestL2b->CacheElts;

   printf("BEST L1-blocked kernel:\n");
   WriteR1File("stdout", r1bestL1b);
   printf("BEST L2-blocked kernel:\n");
   WriteR1File("stdout", r1bestL2b);
/*
 * Find best kernel for in-L2 and in-L1 usage 
 */
   r1bestL1 = TimeAllKernelsForContext(L1CacheElts, 4, pre, r1b);
   r1bestL2 = TimeAllKernelsForContext(L1CacheElts, 3, pre, r1b);
   r1bestOC = TimeAllKernelsForContext(L1CacheElts, 2, pre, r1b);
   r1bestL1 = Clone@up@(rt)Node(r1bestL1);
   r1bestL2 = Clone@up@(rt)Node(r1bestL2);
   r1bestOC = Clone@up@(rt)Node(r1bestOC);
   r1bestOC->CacheElts = 0;
   r1bestL1->next = r1bestL2->next = r1bestOC->next = NULL;
/*
 * Figure out what type of blocking to use for out-of-cache context
 */
   r1p = ChooseKernelBlocking(r1bestL1, r1bestL2, r1bestOC);
   if (r1p != r1bestOC)
   {
      Kill@up@(rt)Node(r1bestOC);
      r1bestOC = Clone@up@(rt)Node(r1p);
   }
/*
 * When timing restricted kernels, we will use best CE found by unresticted,
 * and we can tune only the contexts we use: r1bestOC, r1bestL1[b], r1bestL2.
 */
   if (r1r)
   {
/*
 *    Find best restricted out-of-cache, L1blocked, in-L1 & in-L2 kernels
 */
      fprintf(stdout, "\nBEGIN RESTRICTED OUT-OF-CACHE TUNING\n");
      for (r1p=r1r; r1p; r1p = r1p->next)
         r1p->CacheElts = r1bestOC->CacheElts;
      r1p = TimeAllKernels(L1CacheElts, 1, pre, bigN, bigN, bigN, 0, r1r);
      r1bestOCr = Clone@up@(rt)Node(r1p);
      fprintf(stdout, "\nBEGIN RESTRICTED L1-BLOCKED TUNING TUNING\n");
      for (r1p=r1r; r1p; r1p = r1p->next)
         r1p->CacheElts = r1bestL1b->CacheElts;
      r1p = TimeAllKernels(L1CacheElts, 1, pre, bigN, bigN, bigN, 0, r1r);
      r1bestL1br = Clone@up@(rt)Node(r1p);
      fprintf(stdout, "\nBEGIN RESTRICTED in-L1 TUNING TUNING\n");
      r1bestL1r = TimeAllKernelsForContext(L1CacheElts, 4, pre, r1r);
      fprintf(stdout, "\nBEGIN RESTRICTED in-L2 TUNING TUNING\n");
      r1bestL2r = TimeAllKernelsForContext(L1CacheElts, 3, pre, r1r);
      r1bestL1r = Clone@up@(rt)Node(r1bestL1r);
      r1bestL2r = Clone@up@(rt)Node(r1bestL2r);
/*
 *    If restricted kern not 5% better than unrestricted, nuke it
 */
      r1bestL1br->next = r1bestL1r->next = r1bestL2r->next = 
                         r1bestOCr->next = NULL;
      if (r1bestL2r->mflop[3] < r1bestL2->mflop[3]*1.05)
      {
         Kill@up@(rt)Node(r1bestL2r);
         r1bestL2r = NULL;
      }
      if (r1bestL1r->mflop[4] < r1bestL1->mflop[4]*1.05)
      {
         Kill@up@(rt)Node(r1bestL1r);
         r1bestL1r = NULL;
      }
      if (r1bestL1br->mflop[0] < r1bestL1b->mflop[0]*1.05)
      {
         Kill@up@(rt)Node(r1bestL1br);
         r1bestL1br = NULL;
      }
      if (r1bestOC->CacheElts > L1CacheElts)
         i = 1;
      else if (r1bestOC->CacheElts > 0)
         i = 0;
      else
         i = 2;
      if (r1bestOCr->mflop[i] < r1bestOC->mflop[i]*1.05)
         r1bestOCr = NULL;
   }
   else
      r1bestOCr = r1bestL1r = r1bestL2r = r1bestL1br = NULL;
/*
 * Link restricted with unrestricted, duping unrest if rest NULL
 */
   KillAllR1Nodes(r1b);
   KillAllR1Nodes(r1r);
   r1b = (r1bestOCr) ? r1bestOCr : Clone@up@(rt)Node(r1bestOC);
   r1p = r1b->next = r1bestOC;
   r1p->next = (r1bestL2r) ? r1bestL2r : Clone@up@(rt)Node(r1bestL2);
   r1p = r1p->next->next = r1bestL2;
   r1p->next = (r1bestL1r) ? r1bestL1r : Clone@up@(rt)Node(r1bestL1);
   r1p = r1p->next->next = r1bestL1;
   r1p->next = (r1bestL1br) ? r1bestL1br : Clone@up@(rt)Node(r1bestL1b);
   r1p = r1p->next->next = r1bestL1b;
   r1p->next = NULL;
   WriteR1SummFile(pre, r1b);
   KillAllR1Nodes(r1b);
@beginskip
   for (i=0; i < 5; i++)
      TimeAllKernelsForContext(L1CacheElts, i, pre, r1b);
   fprintf(stdout, "\nPerformance numbers:\n");
   WriteR1File("stdout", r1b);
/*
 * ========================================================================
 * We have to find two things here: the best GER kernels for building GER,
 * and the best GER kernels for building SYR/SYR2 (HER/HER2).  For building
 * GER, we want the best kernel of L1-, L2-, or no-blocking.  This routine
 * becomes our ATL_gerk.  We also need to build the in-L1 and in L2 routines,
 * which become ATL_gerk_L1 and ATL_gerk_L2.  Finally, we need to find the
 * kernels to use to build SYR and SYR2, and for these guys we force
 * L1-blocking so that the GER kernel time dominates (if we choose a 
 * large block relative to N, then the SYR kernel time will dominate, not GER).
 * Also, *most* of the time the in-cache L1 will be faster than in-cache L2 
 * for SYR2.  The L1-blocked kernel becomes ATL_gerk_L1blk, and SYR2's second
 * call is made to ATL_gerk_L1 (in-L1 call).
 * ========================================================================
 */
/*
 * Find whether blocking for L1 or L2 or no blocking gives best perf
 */
   r1restB1 = FindFastestKernel(pre, r1b, 0, 1);
   r1bestB1 = FindFastestKernel(pre, r1b, 0, 0);
   r1restB2 = FindFastestKernel(pre, r1b, 1, 1);
   r1bestB2 = FindFastestKernel(pre, r1b, 1, 0);
   r1restOC = FindFastestKernel(pre, r1b, 2, 1);
   r1bestOC = FindFastestKernel(pre, r1b, 2, 0);
   r1restOC = ChooseKernelBlocking(r1restB1, CE1, r1restB2, CE2, r1restOC);
   r1bestOC = ChooseKernelBlocking(r1bestB1, CE1, r1bestB2, CE2, r1bestOC);
/*
 * Restricted kernel must be significantly better in perf to be worth the hassle
 */
   if (r1restOC->ID != r1bestOC->ID && 
       r1restOC->mflop[0] < 1.03*r1bestOC->mflop[0])
   {
      Kill@up@(rt)Node(r1restOC);
      r1restOC = Clone@up@(rt)Node(r1bestOC);
   }
/*
 * Now, find best in-L2 GER kernels
 */
   r1restL2 = FindFastestKernel(pre, r1b, 3, 1);
   r1bestL2 = FindFastestKernel(pre, r1b, 3, 0);
   if (r1restL2->mflop[3] < 1.03*r1bestL2->mflop[3])
      r1restL2 = r1bestL2;
/*
 * Use prior-selected kernels if they are almost as fast as new kernels
 * (this will save on code size and hence inst load)
 */
   if (r1restOC->mflop[3]*1.02 >= r1restL2->mflop[3])
      r1restL2 = r1restOC;
   if (r1bestOC->mflop[3]*1.02 >= r1bestL2->mflop[3])
      r1bestL2 = r1bestOC;
   r1restL2 = Clone@up@(rt)Node(r1restL2);
   r1bestL2 = Clone@up@(rt)Node(r1bestL2);
   r1restL2->CacheElts = r1bestL2->CacheElts = 0;
/*
 * Now, find best in-L1 GER kernels 
 */
   r1restL1 = FindFastestKernel(pre, r1b, 4, 1);
   r1bestL1 = FindFastestKernel(pre, r1b, 4, 0);
   if (r1restL1->mflop[4] < 1.03*r1bestL1->mflop[4])
      r1restL1 = r1bestL1;
/*
 * Use prior-selected kernels if they are almost as fast as new kernels
 */
   if (r1restOC->mflop[4]*1.02 >= r1restL1->mflop[4])
      r1restL1 = r1restOC;
   if (r1bestOC->mflop[4]*1.02 >= r1bestL1->mflop[4])
      r1bestL1 = r1bestOC;
   if (r1restL2->mflop[4]*1.02 >= r1restL1->mflop[4])
      r1restL1 = r1restL2;
   if (r1bestL2->mflop[4]*1.02 >= r1bestL1->mflop[4])
      r1bestL1 = r1bestL2;
   r1restL1 = Clone@up@(rt)Node(r1restL1);
   r1bestL1 = Clone@up@(rt)Node(r1bestL1);
   r1restL1->CacheElts = r1bestL1->CacheElts = 0;
/*
 * Finally, find best L1-blocked kernels for use in SYR and SYR2
 */
   if (r1restB1->mflop[0] < 1.03*r1bestB1->mflop[0])
      r1restB1 = r1bestB1;
   r1restB1 = Clone@up@(rt)Node(r1restB1);
   r1bestB1 = Clone@up@(rt)Node(r1bestB1);
   r1restB1->CacheElts = r1bestB1->CacheElts = CE1;
/*
 * Link up best kernels and free original queue
 */
   KillAllR1Nodes(r1b);
   r1restOC->next = r1bestOC;
   r1bestOC->next = r1restL2;
   r1restL2->next = r1bestL2;
   r1bestL2->next = r1restL1;
   r1restL1->next = r1bestL1;
   r1bestL1->next = r1restB1;
   r1restB1->next = r1bestB1;
   r1bestB1->next = NULL;
/*
 * Remember that we really need to refine the blocking cache sizes in the
 * final version (since we assumed 85% of L1 for L1, and 4*L1 for L2)
 */
   ExhaustiveCESrch(r1bestL1, 0, pre, bigN, bigN, bigN, 1, 50, 100);
   r1bestL1->CacheElts = r1bestL1->CacheElts*.01*L1CacheElts;
    /* ..... */
   WriteR1SummFile(pre, r1restOC);
   KillAllR1Nodes(r1restOC);
@endskip
   return(0);
}

@ROUT r1hgen
@extract -b @(topd)/gen.inc what=cw @(cw09)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "atlas_misc.h"
#include "atlas_r1parse.h"
@skip @extract -b @(basd)/atlconf.base rout=asmconf.h
@skip @extract -b @(basd)/atlas-parse.base rout=r1read
/*
 * For SYR and SYR2, generate a macro called HandleDiag, which does
 * a small NUxNU triangular matrix so that GER kernel can be called
 * on rest of NU-wide column panel.
 */
void PrintPrototype(FILE *fpout, char pre, char *rout, char *type, char *styp)
{
   fprintf(fpout, "void %s(ATL_CINT, ATL_CINT, const %s, const %s*, ATL_CINT, const %s*, ATL_CINT, %s*, ATL_CINT);\n", 
           rout, styp, type, type, type);
}

@extract -b @(basd)/atlas-gen.base rout=GetMul

void GenKernFiles(char pre, char *path, ATL_r1node_t *r1b)
/*
 * r1b is a list of rank-1 kernels that must be compiled (including those
 * needed to form SYR and SYR2).  This list should be unique (same kernel
 * not compiled twice).  r1b->str will have the routine name to give the
 * kernel during compilation.
 */
{
   ATL_r1node_t *r1p;
   char ln[2048];
   for (r1p = r1b; r1p; r1p = r1p->next)
   {
      if (r1p->genstr)   /* generate kernel if necessary */
      {
         assert(!system(r1p->genstr));
         sprintf(ln, "cp %s %s/%s\n", r1p->rout, path, r1p->str);
      }
      else
         sprintf(ln, "cp CASES/%s %s/%s.c\n", r1p->rout, path, r1p->str);
      if (system(ln))
      {
         fprintf(stderr, "FAILED: %s\n", ln);
         exit(-1);
      }
   }
}

void EmitMakefile(char pre, char *path, ATL_r1node_t *r1b)
/*
 * r1b is a list of rank-1 kernels that must be compiled (including those
 * needed to form SYR and SYR2).  This list should be unique (same kernel
 * not compiled twice).  r1b->str will have the routine name to give the
 * kernel during compilation.
 */
{
   ATL_r1node_t *r1p, *r1k;
   char *kern, *outf, *typD;
   FILE *fpout;
   int i, ialias=0;
   const char UPRE = (pre == 'z' || pre == 'd') ? 'D' : 'S';
   static char *aliased[16];

   assert(path);
   kern = (pre == 'z' || pre == 'c') ? "geru" : "ger";
   if (pre == 'd')
      typD = "DREAL";
   else if (pre == 's')
      typD = "SREAL";
   else if (pre == 'c')
      typD = "SCPLX";
   else if (pre == 'z')
      typD = "DCPLX";
   else 
      assert(0);

   i = strlen(path);
   outf = malloc((i+10)*sizeof(char));
   assert(outf);
   strcpy(outf, path);
   strcpy(outf+i, "/Make_");   /* Make_<pre>r1 */
   outf[i+6] = pre;
   outf[i+7] = 'r';
   outf[i+8] = '1';
   outf[i+9] = '\0';
   fpout = fopen(outf, "w");
   assert(fpout);

   fprintf(fpout, "#\n#  This file generated at line %d of %s\n#\n",
           __LINE__, __FILE__);
   fprintf(fpout, "include Make.inc\n\n");
   fprintf(fpout, "R1CC = $(%cKC)\nR1FLAGS = $(CDEFS) $(%cKCFLAGS)",
            UPRE, UPRE);
   fprintf(fpout, " -D%s\n\n", typD);
   fprintf(fpout, "obj =");
   for (r1p=r1b; r1p; r1p = r1p->next)
      fprintf(fpout, " %s.o", r1p->str);
   fprintf(fpout, "\n");

   fprintf(fpout, "lib : %clib\n%clib : %cr1k.grd\n", pre, pre, pre);
   fprintf(fpout, "%cr1k.grd : $(obj)\n", pre);
   fprintf(fpout, "\t$(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(obj)\n");
   fprintf(fpout, "\t$(RANLIB) $(ATLASlib)\n");
   fprintf(fpout, "\ttouch %cr1k.grd\n", pre);

   fprintf(fpout, "%cclean : clean\n", pre);
   fprintf(fpout, "clean :\n\trm -f $(obj) %cr1k.grd\n\n", pre);

   fprintf(fpout, "%ckilllib : killlib\n", pre);
   fprintf(fpout, "killlib : \n");
   fprintf(fpout, "\t$(ARCHIVER) d $(ATLASlib) $(obj)\n");
   fprintf(fpout, "\t$(RANLIB) $(ATLASlib)\n");
   fprintf(fpout, "killall : killlib clean\n");
   fprintf(fpout, "\t rm -f");
   for (r1p=r1b; r1p; r1p = r1p->next)
      fprintf(fpout, " %s.c", r1p->str);
   fprintf(fpout, "\n\n");
/*
 * Spit out build command for all surviving kernels
 */
   for (r1p=r1b; r1p; r1p = r1p->next)
   {
      fprintf(fpout, "%s.o : %s.c\n", r1p->str, r1p->str);
      if (r1p->comp)
         fprintf(fpout, "\t %s", r1p->comp);
      else
         fprintf(fpout, "\t $(R1CC)");
      fprintf(fpout, " -o %s.o -c -DATL_UGERK=%s", r1p->str, r1p->str);
      if (r1p->cflags)
         fprintf(fpout, " %s -D%s", r1p->cflags, typD);
      else
         fprintf(fpout, " $(R1FLAGS)");
      fprintf(fpout, " %s.c\n", r1p->str);
   }
   free(outf);
}

void r1khgen(char pre, char *path, ATL_r1node_t *r1b, char **aliases)
{
   char *ln;
   int i;
   FILE *fpout;
   ATL_r1node_t *r1p;
   char *styp, *type = (pre == 'd' || pre == 'z') ? "double" : "float";
   char PRE;
   
   PRE = toupper(pre);
   if (pre == 'd')
      styp = "double";
   else if (pre == 's')
      styp = "float";
   else if (pre == 'c')
      styp = "float*";
   else
      styp = "double*";

   i = strlen(path);
   ln = malloc(i+32*sizeof(char));
   sprintf(ln, "%s/atlas_%cr1kernels.h", path, pre);

   fpout = fopen(ln, "w");
   fprintf(fpout, 
           "#ifndef ATLAS_%cR1KERNELS_H\n   #define ATLAS_%cR1KERNELS_H\n\n", 
           PRE, PRE);

   for (r1p=r1b; r1p; r1p = r1p->next)
      PrintPrototype(fpout, pre, r1p->str, type, styp);
   if (aliases)
   {
      fprintf(fpout, "\n");
      for (i=0; aliases[i]; i += 2)
         fprintf(fpout, "#define %-24s %s\n", aliases[i], aliases[i+1]);

   }
   fprintf(fpout, "\n#endif /* end guard around atlas_%cr1kernels.h */\n", pre);

   fclose(fpout);
   free(ln);
}

void r1hgen(char pre, char *path, int LVL, ATL_r1node_t *kp, ATL_r1node_t *kpR)
{
   FILE *fpout;
   char PRE = toupper(pre);
   char *type = (pre == 'd' || pre == 'z') ? "double" : "float";
   char *styp, *sp;
   char gerk[32];
   int mb, DOPROTO=0;
   int irest=12, iconj=8;

   if (kpR && kpR->ID == kp->ID)   /* nuke restricted if same as normal */
      kpR = NULL;
   if (LVL < 0)
   {
      DOPROTO = 1;
      LVL = 0;
   }
/*
 * Name the kernel according to cache block level and data type
 */
   assert(LVL >= 0 && LVL <= 9);
   sprintf(gerk, "ATL_%cgerk_L%d_restrict", pre, LVL);
   gerk[irest] = '\0';
   sp = malloc(strlen(path) + 16);
   assert(sp);
   if (!LVL)
      sprintf(sp, "%s/atlas_%cr1.h", path, pre);
   else
      sprintf(sp, "%s/atlas_%cr1_L%d.h", path, pre, LVL);
   fpout = fopen(sp, "w");
   free(sp);
   if (pre == 'd')
      styp = "double";
   else if (pre == 's')
      styp = "float";
   else if (pre == 'c')
      styp = "float*";
   else
      styp = "double*";
   fprintf(fpout, "#ifndef ATLAS_%cR1_L%d_H\n#define ATLAS_%cR1_L%d_H\n\n", 
           PRE, LVL, PRE, LVL);
   fprintf(fpout, "#include \"atlas_type.h\"\n\n");
   fprintf(fpout, "#define ATL_r1CacheElts %d\n", kp->CacheElts);
   fprintf(fpout, "#define ATL_r1MU %d\n", kp->XU);
   fprintf(fpout, "#define ATL_r1NU %d\n", kp->YU);
   if (kp->CacheElts == 0)
      fprintf(fpout, "#define ATL_r1NOBLOCK\n");
   if (kp->CacheElts > 0)
   {
      mb = (kp->CacheElts - 2*kp->YU) / (2*kp->YU+1);   /* elts in cache */
      mb = (mb>>2)<<2;                                  /* multiple of 4 */
      mb = (mb >= kp->XU) ? (mb/kp->XU)*kp->XU : kp->XU; /* mul of XU */
   }
   else
      mb = 0;
   if (DOPROTO)
   {
      fprintf(fpout, "#define %s ATL_UGERK\n", gerk);
      PrintPrototype(fpout, pre, gerk, type, styp);
   }
@beginskip
   {
      PrintPrototype(fpout, pre, gerk, type, styp);
      if (pre == 'z' || pre == 'c')
      {
         gerk[iconj] = 'c';
         PrintPrototype(fpout, pre, gerk, type, styp);
         gerk[iconj] = 'u';
      }
   }
@endskip
   else
      fprintf(fpout, "#include \"atlas_%cr1kernels.h\"\n", pre);
/*
 * Print handles for kernel names for use by fixed code
 */
   fprintf(fpout, "#define ATL_GERK ATL_%cgerk_L%d\n", pre, LVL);
   fprintf(fpout, "#define ATL_GERKr ATL_%cgerk_L%d_restrict\n\n", pre, LVL);

   fprintf(fpout, "#define ATL_GetPartR1(A_, lda_, mb_, nb_) { (mb_) = %d; (nb_) = ATL_r1NU; }\n", mb);
   if (kpR)
   {
      fprintf(fpout, "#define ATL_r1USERESTRICTK 1\n");
      fprintf(fpout, "#define ATL_r1CacheEltsr %d\n", kpR->CacheElts);
      fprintf(fpout, "#define ATL_r1MUr %d\n", kpR->XU);
      fprintf(fpout, "#define ATL_r1NUr %d\n", kpR->YU);
      if (kpR->CacheElts == 0)
         fprintf(fpout, "#define ATL_r1NOBLOCKr\n");
      gerk[irest] = '_';
      if (DOPROTO)
         PrintPrototype(fpout, pre, gerk, type, styp);
@beginskip
      if (pre == 'z' || pre == 'c')
      {
         gerk[iconj] = 'c';
         PrintPrototype(fpout, pre, gerk, type, styp);
         gerk[iconj] = 'u';
      }
@endskip
      mb = (kpR->CacheElts - 2*kpR->YU) / (2*kpR->YU+1);
      mb = (mb >= kpR->XU) ? (mb/kpR->XU)*kpR->XU : kpR->XU;
      fprintf(fpout, "#define ATL_GetPartR1r(A_, lda_, mb_, nb_) { (mb_) = %d; (nb_) = ATL_r1NUr; }\n");
      fprintf(fpout, "#define ATL_r1UseRestrictK(M_, N_, A_, lda_) \\\n");
      assert(kpR->ldamul > 1);  /* only allowed restriction right now! */
      if (kpR->ldamul > 1)
         fprintf(fpout, "   (%s == ATL_sizeof*(lda_))", 
                 GetMul(kpR->ldamul, GetDiv(kpR->ldamul, "ATL_sizeof*(lda_)")));
   }
   fprintf(fpout, 
           "\n#endif  /* end protection around header file contents */\n");
   fclose(fpout);
}

void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n",
              ierr, flag ? flag : "Not enough arguments");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix \n");
   fprintf(stderr, "   -d <dir> : output files using path <dir>\n");
   fprintf(stderr, "   -F <file> : read kernel file & gen headers\n");
   fprintf(stderr, "    The following flags can be used if -F is not:\n");
   fprintf(stderr, "      -l <l1mul> : use l1mul*L1CacheSize for blocking\n");
   fprintf(stderr, "      -x <xu> : xu elements of X are accessed at once\n");
   fprintf(stderr, "      -y <yu> : yu elements of Y are accessed at once\n");
   fprintf(stderr, "      -f <iflag> : set the flag bitfield to iflag\n");
   exit(ierr ? ierr : -1);
}

void GetFlags(int nargs, char **args, char *PRE, char **FNAM, char **DIR,
              int *XU, int *YU, int *L1MUL, int *IFLAG)
{
   int i, k;
   char pre='d';

   *DIR = "./";
   *IFLAG = *XU = *YU = *L1MUL = 0;
   *FNAM = NULL;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      switch(args[i][1])
      {
      case 'x':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *XU = atoi(args[i]);
         break;
      case 'y':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *YU = atoi(args[i]);
         break;
      case 'l':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *L1MUL = atoi(args[i]);
         break;
      case 'f':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *IFLAG = atoi(args[i]);
         break;
      case 'd':
         if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *DIR = args[i];
         break;
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 'F':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *FNAM = args[i];
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *PRE = pre;
   if (*FNAM == NULL && (*XU == 0 || *YU == 0))
   {
      *FNAM = malloc(16*sizeof(char));
      sprintf(*FNAM, "res/%cR1SUMM", pre);
   }
}

main(int nargs, char **args)
{
   char *fnam, *path, *aliases[16];
   ATL_r1node_t *r1b, *r1p, *r1B;
   int i, xu, yu, l1mul, iflag;
   char pre;

   GetFlags(nargs, args, &pre, &fnam, &path, &xu, &yu, &l1mul, &iflag);
   
/*
 * If we just want simple tuning header, no need to read file for details
 */
   if (!fnam)
   {
      r1b = GetR1Node();
      r1b->next = NULL;
      r1b->XU = xu;
      r1b->YU = yu;
      r1b->flag = iflag;
      r1b->CacheElts = l1mul * GetL1CacheElts(pre);
      r1hgen(pre, path, -1, r1b, NULL);
      exit(0);
   }
/*
 * Otherwise, we should be doing a full-blown install; read in summary file
 */
   r1b = ReadR1File(fnam);
/*
 * Find out which are geniune kernels, and which are aliased
 */
   r1B = GetSortedUniqueR1Kerns(pre, r1b, aliases);
/*
 * Generate prototype file for all routines
 */
   r1khgen(pre, path, r1B, aliases);
/*
 * For each cache level, generate a header file which provides macros
 * describing the best GER kernels
 */
   r1p = r1b;
   for (i=0; i < 3; i++)
   {
      r1hgen(pre, path, i, r1p->next, r1p);
      r1p = r1p->next->next;
   }
/*
 * Generate Makefiles to compile all GER kernels (including those used by
 * SYR and SYR2).  These Makefiles & kernels will wind up in 
 *   BLDdir/src/blas/ger/
 */
   EmitMakefile(pre, path, r1B);
/*
 * Get required .c kernel files
 */
   GenKernFiles(pre, path, r1B);
/*
 * Generate headers for SYR & SYR2
 */
// s1hgen(...); s2hgen(...);
   return(0);
}
@ROUT mvksearch
@extract -b @(basd)/atlas-parse.base rout=mvread
@ROUT smvcases.idx dmvcases.idx cmvcases.idx zmvcases.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
# The file has the following format:
# ROUT='routine name' AUTH='author names' COMP='compiler name' FLAGS='flags'
# ID=<id> YU=<yu> XU=<xu> minY=<#> minX=<#> alignX=<#> alignY=<#> alignA=<#>,
# TA='[t,n,c]' TB='[t,n,c]' SSE=[0,1,2,3] X87=[0,1] 
# LDTOP=[0,1] ALLALIGNXY=[0,1] AXPYBASED=[0,1] GEMMBASED=[0,1] CONJDEF=[0,1]
# ASM=[asmlist], eg., asmlist is "GAS_x8664,GAS_x8632" or "GAS_SPARC"
# ASM defaults to no assembly dialect required.
# If YU/XU is negative, then the routine can only handle multiples of YU/XU.
#
# Assuming N is the length of X, and M is the length of Y, all routines
# are assumed to handle any runtime value of M >= minY, N >= minX.
# They must respect the compile-time macros BETA0, BETA1, & BETAX.
# Some less-obvious keywords:
# LDTOP     : set to 1 if load Y at top of MV loop (more error)
# CONJDEF   : Defining Conj_ will cause A to be conjugated before use
#             if 0, then can only be used for TA setting
# ALLALIGNXY: Create k copies of X and Y, where k is the number of times
#             the native alignment goes into the required alignment.  So,
#             if ALIGNX=16, and we are doing single precision, X will be
#             passed as float *X[4], and X[0] will be 16-byte aligned,
#             X[1]: 4-byte aligned, X[2]: 8-byte aligned, X[3]: 12 byte aligned
#             if ALIGN[X/Y] == native length, then this flag has no effect on
#             that vector.
# AXPYBASED : Routine employs the outer-product matvec (mainly for NoTrans)
# GEMMBASED : Kernel calls GEMM to do matvec
# PFTUNEx   : Kernel uses pref_x(mem) macro for each op=x (A,y,x).  prefetch
#             inst can be varied wt this macro, as can fetch distance.
#
@ROUT ATL_gemvN_tM
#include "atlas_mvN_Mdegen.h"

void Mjoin(PATL,gemvN_tM)
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha, const TYPE *A, ATL_CINT lda, 
    const TYPE *X, ATL_CINT incX, const SCALAR beta, TYPE *Y, ATL_CINT incY)
/* 
 * This routine is specialized for very small M dimension GEMV.
 */
{
   ATL_assert(M <= 16);
}
@ROUT ATL_gemv_new
void Mjoin(PATL,gemv)
   (const enum ATLAS_TRANS TA, ATL_CINT M, ATL_CINT N, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *X, ATL_CINT incX,
    const SCALAR beta, TYPE *Y, ATL_CINT incY)
{
   if (M <= 8)
   {
      if (M > 0)
      {
         if (TA == AtlasNoTrans || TA == AtlasConj)
            Mjoin(PATL,gemvN_degenM)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
         else
            Mjoin(PATL,gemvT_degenM)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      }
      return;
   }
   if (N <= 8)
   {
      if (N > 0)
      {
         if (TA == AtlasNoTrans || TA == AtlasConj)
            Mjoin(PATL,gemvN_degenN)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
         else
            Mjoin(PATL,gemvT_degenN)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      }
      return;
   }
}
@ROUT ATL_gemvT ATL_gemvN
typedef void (*mvkern_t)(ATL_CINT, ATL_CINT, const TYPE*, ATL_CINT, const TYPE*,
                         const SCALAR, TYPE*);

static void *ATL_AlignToX(void *v, int bytes)
{
   size_t sp = (size_t) v;
   if (bytes == 16)
      while (((sp>>4)<<4) != sp) sp++;
   else
      while ((sp/alignY)*alignY != sp) sp++;
   return((void*)sp);
}
#ifdef TREAL
void Mjoin(PATL,cpXs)(const int N, const SCALAR alpha, const TYPE *X,
                      const int incX, TYPE *Y, const int nYs)
{
   TYPE **Ys = (TYPE**) Y;
   TYPE *y0, *y1, *y2, *y3;
   ATL_int i;

   if (nYs == 2)        /* SSE2 kernels in double */
   {
      y0 = Ys[0]; y1 = Ys[1];
      for(i=0; i < N; i++, X += incX)
          y0[i] = y1[i] = *X * alpha;
   }
   else if (nYs == 4)    /* SSE kernels in single */
   {
      y0 = Ys[0]; y1 = Ys[1]; y2 = Ys[2]; y3 = Ys[3];
      for(i=0; i < N; i++, X += incX)
          y0[i] = y1[i] = y2[i] = y3[i] = *X * alpha;
   }
   else
   {
      Mjoin(PATL,cpsc)(N, alpha, X, incX, Ys[0], 1);
      for (i=1; i < nYs; i++)
         Mjoin(PATL,copy)(N, Ys[0], 1, Ys[i], 1);
   }
}
#else
void Mjoin(PATL,cpXs)(const int N, const SCALAR alpha, const TYPE *X,
                      const int incX, TYPE *Y, const int nYs)
{
   TYPE **Ys = (TYPE**) Y;
   TYPE *y0, *y1, *y2, *y3;
   ATL_CINT incx = incX+incX, N2=N+N;
   const register TYPE ra, ia;
   register TYPE rx, ix;
   ATL_INT i;

   if (nYs == 2)        /* SSE2 kernels in double */
   {
      y0 = Ys[0]; y1 = Ys[1];
      if (ix == ATL_rzero)
      {
         for (i=0; i < N2; i += 2, X += incx)
         {
             rx = *X;
             ix = X[1];
             y0[i] = y1[i] = ra*rx;
             y0[i+1] = y1[i+1] = ia*rx;
         }
      }
      else
      {
         for(i=0; i < N2; i += 2, X += incx)
         {
             rx = *X;
             ix = X[1];
             y0[i] = y1[i] = ra*rx - ia*ix;
             y0[i+1] = y1[i+1] = ra*ix + ia*rx;
         }
      }
   }
   else if (nYs == 4)    /* SSE kernels in single */
   {
      if (ix == ATL_rzero)
      {
         for (i=0; i < N2; i += 2, X += incx)
         {
             rx = *X;
             ix = X[1];
             y0[i] = y1[i] = ra*rx;
             y0[i+1] = y1[i+1] = ia*rx;
         }
      }
      else
      {
         y0 = Ys[0]; y1 = Ys[1]; y2 = Ys[2]; y3 = Ys[3];
         for(i=0; i < N2; i += 2, X += incx)
         {
             rx = *X;
             ix = X[1];
             y0[i] = y1[i] = y2[i] = y3[i] = ra*rx - ia*ix;
             y0[i+1] = y1[i+1] = y2[i+1] = y3[i+1] = ra*ix + ia*rx;
         }
      }
   }
}
#endif

@ROUT ATL_gemvT_L2
   @define suf @_L2@
@ROUT ATL_gemvT ATL_gemvT_L2
   @define TA @T@
   @define suf @@
@ROUT ATL_gemvT ATL_gemvT_L2
#define Nx M
#define Ny N
@ROUT ATL_gemvN
   @define TA @N@
#define Nx N
#define Ny M
@ROUT ATL_gemvT ATL_gemvN
void Mjoin(PATL,gemv@(TA)@(suf))
   (ATL_CINT M, ATL_CINT N, const SCALAR alpha,
    const TYPE *A, ATL_CINT lda, const TYPE *X, ATL_CINT incX,
    const SCALAR beta, TYPE *Y, ATL_CINT incY)
/*
@ROUT ATL_gemvN 
 *  y <- alpha * A * x + beta*y  .. or .. y <- alpha * conj(A) * x + beta*y
 *  A is MxN and X has length N and Y has length M
@ROUT ATL_gemvT ATL_gemvT_L2
 *  y <= alpha * A' * x + beta*y .. or .. y <- alpha * conj(A') * x + beta*y
 *  A is MxN and X has length M and Y has length N
@ROUT ATL_gemvT ATL_gemvN ATL_gemvT_L2
 */
{
   mvkern_t gemv0, gemv1, gemvX;  /* main gemv kernels */
   mvkern_t mvdN0, mvdN1, mvdNX;  /* small-N handling kernels */
   void (*getX)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, TYPE *Y, const int incY);
   void (*putY)(const int N, const SCALAR alpha, const TYPE *X,
                const int incX, const SCALAR beta, TYPE *Y, const int incY);
   TYPE **Xs;
   int allalign=0;                /* does kernel require X wt all alignments? */
   int COPYX=0, COPYY=0;
   int mu, nu;    /* M and N unrolling of kernel */
   int Fmu, Fnu;  /* if nonzero, kernel only handles multiples of this size */
@ROUT ATL_gemvT ATL_gemvT_L2
/*
 * Call special code if M is degenerate
 */
   if (M <= 8)
   {
      if (M > 0)
         Mjoin(PATL,gemvT_degenM)(M, N, alpha, A, lda, X, incX, 
                                  beta, Y, incY);
      return;
   }
/* 
 * =======================================
 * Select kernel to be used by this driver
 * =======================================
 */
/*
 * If we have a kernel that insists that A be alignable, use it.  Note that
 * transpose kernels must take any value of M, but are allowed to insist they
 * handle only certain multiples of N, which is stored in Fnu
 */
   gemv0 = gemv1 = gemvX = NULL;
   mu = nu = ku = 1;
   Fnu = 0;
   alignX = alignY = allalignX = 0;
   #if ATL_MVALIGNA > ATL_sizeof
      mvdN0 = mvdN1 = mvdNX = Mjoin(PATL,gemvT_degenN);
      i = ATL_MulBySize(lda);
      if (((i/ATL_MVALIGNA)*ATL_MVALIGNA) == i)
      {
         gemv0 = ATL_mvk_alignA_b0;
         gemv1 = ATL_mvk_alignA_b1;
         gemvX = ATL_mvk_alignA_bX;
         #ifdef ATL_MVA_ALLALIGNX
            allalignX = 1;
         #elif defined(ATL_MVA_ALIGNX)
            alignX = ATL_MVA_ALIGNX;
         #endif
         #if defined(ATL_MVA_ALIGNY)
            alignY = ATL_MVA_ALIGNY;
         #endif
         #if defined(ATL_MVA_FNU)
            Fnu = ATL_MVA_FNU;
            #ifndef ATL_MV_FNU
               mvdN0 = ATL_mvk_b0;
               mvdN1 = ATL_mvk_b1;
               mvdNX = ATL_mvk_bX;
            #endif
         #endif
         #ifdef ATL_MVA_INCY1
            COPYY = (incY != 1);
         #endif
         ATL_GetPartMVA@(TA)(A, lda, &mb, &nb);
      }
   if (!gemv0)
   #endif
   {
      gemv0 = ATL_mvk_b0;
      gemv1 = ATL_mvk_b1;
      gemvX = ATL_mvk_bX;
      #ifdef ATL_MV_ALLALIGNX
         allalignX = 1;
      #elif defined(ATL_MV_ALIGNX)
         alignX = ATL_MV_ALIGNX;
      #endif
      #if defined(ATL_MV_ALIGNY)
         alignY = ATL_MV_ALIGNY;
      #endif
      #if defined(ATL_MV_FNU)
         Fnu = ATL_MV_FNU;
      #endif
      #ifdef ATL_MV_INCY1
         COPYY = (incY != 1);
      #endif
      ATL_GetPartMV@(TA)(A, lda, &mb, &nb);
   }
/*
 * If N is not at least as large as the forced unroll of the selected kernel,
 * call the degenerate-N driver to handle the gemv
 */
   if (N < Fnu)
   {
      Mjoin(PATL,gemvT_degenN)(M, N, alpha, A, lda, X, incX, beta, Y, incY);
      return;
   }
/*
 * Compute if we need to copy the vectors.  We must always copy X to
 * contiguous storage for our kernels for Transpose.  We will apply alpha
 * during the X copy, and if we don't copy, we must see if it is cheaper
 * to apply alpha by copying X or Y
 */
   COPYX = (incX != 1 | (AlphaIsX & Nx <= Ny) | allalignX);
   if (!COPYX && alignX)
   {
      sz = (size_t) X;
      COPYX = ((sz/alignX)*alignX != sz);
   }
   COPYY = COPYY | (!COPYX && AlphaIsX);
   if (!COPYY && alignY)
   {
      sz = (size_t) Y;
      COPYY = (((sz/alignY)*alignY != sz) | (incY != 1));
   }
/*
 * Count the number of vectors, and allocate them with the required alignment
 */
   nxvec = ((allalignX) ? 4 : COPYX);
   nyvec = COPYY;
   if (nxvec|nyvec)
   {
      vp = malloc(ATL_MulBySize(nxvec*mb+nyvec*Ny)+
                  (nxvec+nyvec)*(ATL_Cachelen+ATL_Cachelen));
      ATL_assert(vp);
      sz = (size_t) vp;
      if (nyvec)
      {
         alignY = (alignY) ? alignY : 16;
         ATL_assert(alignY <= ATL_Cachelen);
         y = ATL_AlignToX(vp, alignY);
         sz = (size_t) (y+Ny);
      }
      if (nxvec)
      {
         if (!allalignX)
         {
            alignX = (alignX) ? alignX : 16;
            x = ATL_AlignToX((TYPE*)sz, alignX);
         }
/*
 *       allalign means I want all legal alignments between 0-alignX in steps
 *       of sizeof(TYPE)
 */
         else
         {
            nXptrs = ATL_DivBySize(alignX);
            ATL_assert(ATL_MulBySize(nXptrs) == alignX);
            Xs = malloc(nXptrs * sizeof(TYPE*));
            for (i=0; i < nXptrs; i++)
            {
               Xs[i] = ATL_AlignToX((TYPE*)sz, alignX));
               Xs[i] += i;
               sz = (size_t) (Xs[i] + mb);
            }
         }
      }
   }
/*
 * See where I'm going to apply BETA
 */
   if (COPYY || BetaIsZero)
      gemv0 = ATL_gemv@(TA)_b0;
   else if (BetaIsOne)
      gemv0 = ATL_gemv@(TA)_b1;
   else 
      gemv0 = ATL_gemv@(TA)_bX;
   gemv1 = ATL_gemv@(TA)_b1;
   putY = (COPYY) ? Mjoin(PATL,axpby) : NULL;
   getX = (COPYX) ? Mjoin(PATL,cpsc) : NULL;
}
@ROUT ATL_gerk_axpy
#include "atlas_misc.h"
#include "atlas_level1.h"

#ifdef Conj_
void Mjoin(PATL,gerck_axpy)
#else
void Mjoin(PATL,gerk_axpy)
#endif
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
/*
 * This routine typically called when N is very small, and so we can't afford
 * to copy the vectors even if M is large; in this case we simply loop over
 * the appropriate calls to the AXPY
 */
{
#ifdef TCPLX
   const int incy = incY+incY, lda2 = lda+lda;
   TYPE y[2];
   const TYPE ralp=(*alpha), ialp=alpha[1];
   TYPE ry, iy;
   int j;

   for (j=0; j < N; j++, A += lda2, Y += incy)
   {
      ry = *Y; iy = Y[1];
      #ifdef Conj_
         y[0] = ry*ralp + iy*ialp;
         y[1] = ry*ialp - iy*ralp;
      #else
         y[0] = ry*ralp - iy*ialp;
         y[1] = ry*ialp + iy*ralp;
      #endif
      Mjoin(PATL,axpy)(M, y, X, incX, A, 1);
   }
#else
   int j;
   for (j=0; j < N; j++, A += lda, Y += incY)
      Mjoin(PATL,axpy)(M, *Y*alpha, X, incX, A, 1);
#endif
}
@ROUT ATL_gerk_Mlt16
#include "atlas_misc.h"

typedef void (*gerk_t)
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda);

#ifdef TREAL
@BEGINPROC gerkN M
static void ATL_gerk_Meq@(M)
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
{
   register int j;
   @declare "   register TYPE " n n ";"
      y0
      @define i @0@
      @iwhile i < @(M)
         x@(i)
         @iexp i 1 @(i) +
      @endiwhile
      @undef i
   @enddeclare

   if (alpha == ATL_rone) goto ALPHA1;
   else if (alpha != ATL_rnone) goto ALPHAX;
@define i @0@
@iwhile i < @(M)
   x@(i) = -X[@(i)*incX];
   @iexp i 1 @(i) +
@endiwhile
@undef i
X_IS_LOADED:

   for (j=0; j < N; j++, A += lda)
   {
      y0 = Y[incY*j];
   @define i @0@
   @iwhile i < @(M)
      A[@(i)] += x@(i) * y0;
      @iexp i 1 @(i) +
   @endiwhile
   @undef i
   }
   return;

ALPHAX:
@define i @0@
@iwhile i < @(M)
   y0 = alpha;
   x@(i) = X[@(i)*incX] * y0;
   @iexp i 1 @(i) +
@endiwhile
@undef i
   goto X_IS_LOADED;
ALPHA1:
@define i @0@
@iwhile i < @(M)
   x@(i) = X[@(i)*incX];
   @iexp i 1 @(i) +
@endiwhile
@undef i
   goto X_IS_LOADED;
}
@ENDPROC

@define j @1@
@iwhile j < 16
   @callproc gerkN @(j)
   @iexp j 1 @(j) +
@endiwhile
@undef j

void Mjoin(PATL,gerk_Mlt16)
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
/*
 * ATLAS's normal GER kernels are optimized for long-M, and loop over rows in
 * the inner loop.  To avoid this killing us on short, wide matrices, have
 * special case code for M < 16.  This also allows kernels to assume M >= 16.
 */
{
   @declare "   static gerk_t gerks[15]={" y n "};"
      @define i @1@
      @iwhile i < 16
         ATL_gerk_Meq@(i)
         @iexp i 1 @(i) +
      @endiwhile
      @undef i
   @enddeclare
   ATL_assert(M < 16);
   gerks[M-1](M, N, alpha, X, incX, Y, incY, A, lda);
}

#else /* complex type */
#ifdef Conj_
void Mjoin(PATL,gerck_Mlt16)
#else
void Mjoin(PATL,gerk_Mlt16)
#endif
   (const int M, const int N, const SCALAR alpha, const TYPE *X, const int incX,
    const TYPE *Y, const int incY, TYPE *A, const int lda)
{
/*
 * For now, complex simply calls axpy-based routine.  Need to fix later
 */
#ifdef Conj_
   Mjoin(PATL,gerck_axpy)(M, N, alpha, X, incX, Y, incY, A, lda);
#else
   Mjoin(PATL,gerk_axpy)(M, N, alpha, X, incX, Y, incY, A, lda);
#endif
}
#endif
@ROUT gemvT_oc
@ROUT gensy2
void UnrolledSyr2(FILE *fpout, char pre, enum ATLAS_UPLO Uplo, int N)
/*
 * Assume regular files defines lda[2-nu]
 */
{
   char **ldas;
   ldas = malloc(N*sizeof(char*));
   assert(ldas);
   ldas[0] = "";
   ldas[1] = "+lda";
   for (j=2; j < N; j++)
   {
      ldas[j] = malloc(8*sizeof(char));
      sprintf(ldas[j], "+lda%d", j);
   }
   fprintf(fpout, "#define ATL_SYR2_Diag(A_, lda_, x_, y_) \\\n{ \\\n");
   fprintf(fpout, "   const %s x0=*(x_)", type);
   for (i=1; i < N; i++)
      fprintf(fpout, ", x%d=(x_)[%d]", i, i);
   fprintf(fpout, "; \\\n");
   fprintf(fpout, "   const %s y0=*(y_)", type);
   for (i=1; i < N; i++)
      fprintf(fpout, ", y%d=(y_)[%d]", i, i);
   fprintf(fpout, "; \\\n");
   for (j=0; j < N; j++)
   {
      for (i=j; i < N; i++)
         fprintf(fpout, "   A[%d%s] += x%d*y%d + x%d*y%d; \\\n",
	         i, ldas[j], i, j, j, i);
   }
   for (j=2; j < N; j++)
      free(ldas[j]);
   free(ldas);
}
@ROUT ATL_syr2K
#ifdef TCPLX
void Mjoin(PATL,syr2KL)
   (ATL_CINT N, const SCALAR alpha, const TYPE *X, ATL_CINT incX, 
    const TYPE *Y, ATL_CINT incY, TYPE *A, ATL_CINT lda0)
{
   int i, j;
   const int lda = lda0+lda0, N2=N+N, M2=M+M;
   TYPE rXj, iXj, rXi, iXi, rYi, iYi, rYj, iYj;
   for (j=0; j < N2; j += 2, A += lda)
   {
      rXj = X[j];
      iXj = X[j+1];
      rYj = Y[j];
      iYj = Y[j+1];
      for (i=j; i < M2; i += 2)
      {
         rXi = X[i];
         iXi = X[i+1];
         rYi = Y[i];
         iYi = Y[i+1];
	 A[i] += rXj*rYi - iXj*iYi + rXi*rYj - iXi*iYj;
	 A[i+1] += rXj*iYi + iXj*rYi + rXi*iYj + iXi*rYj;
      }
   }
}
#else
void Mjoin(PATL,syr2KL)
   (ATL_CINT N, const SCALAR alpha, const TYPE *X, ATL_CINT incX, 
    const TYPE *Y, ATL_CINT incY, TYPE *A, ATL_CINT lda)
{
   int i, j;
   TYPE xi, yi, xj, yj;

   for (j=0; j < N; j++, A += lda)
   {
      xj = X[j];
      yj = Y[j];
      for (i=j; i < N; i++)
      {
         xi = X[i];
	 yi = Y[i];
	 A[i] += xi*yj + xj*yi;
      }
   }
}
#endif
@ROUT ATL_syr
   @define rt @syr@
@ROUT ATL_her
   @define rt @her@
@ROUT ATL_her ATL_syr
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_reflvl2.h"
#include "atlas_reflevel2.h"

void Mjoin(PATL,@(rt))(const enum ATLAS_UPLO Uplo, ATL_CINT N, const TYPE alpha,
                     const TYPE *X, ATL_CINT incX, TYPE *A, ATL_CINT lda)
{
   Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, A, lda);
}
@ROUT ATL_syr2
   @define rt @syr2@
@ROUT ATL_her2
   @define rt @her2@
@ROUT ATL_her2 ATL_syr2
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_reflvl2.h"
#include "atlas_reflevel2.h"

void Mjoin(PATL,@(rt))(const enum ATLAS_UPLO Uplo, ATL_CINT N, 
                      const SCALAR alpha, const TYPE *X, ATL_CINT incX, 
                      const TYPE *Y, ATL_CINT incY, TYPE *A, ATL_CINT lda)
{
   Mjoin(PATL,ref@(rt))(Uplo, N, alpha, X, incX, Y, incY, A, lda);
}
