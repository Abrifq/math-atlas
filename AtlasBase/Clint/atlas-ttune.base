@ROUT test_count
#include "atlas_threads.h"
#include "atlas_misc.h"
#include "assert.h"

static volatile char *checkin;

void PrintUsage(char *name)
{
   fprintf(stderr, "USAGE: %s [-r <reps>] [-c <cnt>]\n", name);
   exit(-1);
}

int GetFlags(int nargs, char **args, int *nreps)
{
   int i, cnt=16384;

   *nreps = 20;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'r':
         if (++i == nargs)
            PrintUsage(args[0]);
         *nreps = atoi(args[i]);
         break;
      case 'c':
         if (++i == nargs)
            PrintUsage(args[0]);
         cnt = atoi(args[i]);
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   return(cnt);
}

void TestDoWork(ATL_LAUNCHSTRUCT_t *lp, void *vp)
{
   int i;
   do
   {
      i = ATL_DecAtomicCount(vp);
      if (i < 1) 
         break;
      checkin[i-1]++;
   }
   while(1);
}

int main(int nargs, char **args)
{
   int cnt, nreps, i, k;
   void *vp;
   if (nargs > 1)
      cnt = atoi(args[0]);
   cnt = GetFlags(nargs, args, &nreps);

   checkin = malloc(cnt*sizeof(char));
   assert(checkin);
   for (i=0; i < nreps; i++)
   {
      vp = ATL_SetAtomicCount(cnt);
      for (k=0; k < cnt; k++)
         checkin[k] = 0;
      ATL_thread_launch(vp, 0, NULL, TestDoWork, NULL);
      for (k=0; k < cnt; k++)
         assert(checkin[k] == 1);
      ATL_FreeAtomicCount(vp);
   }
   printf("TEST PASSED\n");
   return(0);
}
@ROUT probe_nthr
#include "atlas_taffinity.h"
#include "atlas_misc.h"
#include "assert.h"

void PrintUsage(char *nam)
{
   fprintf(stderr, "\nUSAGE: %s [-o <outfile>]\n", nam);
   exit(-1);
}

void GetFlags(int nargs, char **args, FILE **fpout)
{
   int i;

   *fpout=stdout;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'o':
         *fpout = fopen(args[++i], "w");
         assert(*fpout);
         break;
      default:
         PrintUsage(args[0]);
      }
   }
}

void getLaunchOrder(int P, int *lo)
{
   int i, j, k, stop, dest;

   for (i=0; (1<<i) < P; i++)
   lo[0] = 0;
   k = 1;
   for (i--; i >= 0; i--)
   {
      stop = k;
      for (j=0; j < stop; j++)
      {
         dest = lo[j] + (1<<i);
         if (dest < P)
            lo[k++] = dest;
         if (k == P)
            return;
      }
   }
}

int main(int nargs, char **args)
{
   FILE *fpout;
   int i, j, k, P;
   int *lo;
   GetFlags(nargs, args, &fpout);

   fprintf(fpout, "  /* This file generated by %s */\n", __FILE__);
   fprintf(fpout, "#ifndef ATLAS_NTHREADS_H\n   #define ATLAS_NTHREADS_H\n\n");
@beginskip
/*
 * I presently build Antoine's pthread implementation even on windows for
 * comparison purposes.  Need to get rid of 00 when this is no longer the
 * case.
 */
   fprintf(fpout, "/* Get rid of 00 if you don't want to build pthreads */\n");
@endskip
   fprintf(fpout,
      "   #ifndef ATL_WINTHREADS\n      #include \"pthread.h\"\n   #endif\n");
   #if ATL_NCPU != 0
      P = ATL_NCPU;
   #elif defined(ATL_AFF_NUMID)
      P = ATL_AFF_NUMID;
   #else
      P = 4;
   #endif
   #if defined(ATL_AFF_NUMID)
      #if ATL_NCPU > ATL_AFF_NUMID
         fprintf(fpout, 
         "/*\n * I should have tested if NTHREADS = %d(NCPU) or %d(NAFFIDs)\n");
         fprintf(fpout, " * is better.  For now, assuming %d\n */", ATL_NCPU);
      #endif
   #endif
   fprintf(fpout, "   #define ATL_NTHREADS %d\n", P);
   for (i=0; (1<<i) < P; i++);
   fprintf(fpout, "   #define ATL_NTHRPOW2 %d\n", i);
   lo = malloc(P*sizeof(int));
   getLaunchOrder(P, lo);
   fprintf(fpout, "   #ifdef ATL_LAUNCHORDER\n");
   fprintf(fpout, "       static int ATL_launchorder[%d] = {0", P);
   for (i=1; i < P; i++)
      fprintf(fpout, ",%d", lo[i]);
   fprintf(fpout, "};\n   #endif\n");
   #if defined(ATL_AFF_NUMID) && !defined(ATL_RANK_IS_PROCESSORID)
      fprintf(fpout, "   #if defined(ATL_RANK2ID)\n");
      fprintf(fpout, "       static int ATL_rank2ID[%d] = {%d", 
              P, ATL_affinityIDs[0]);
      for (i=1; i < P; i++)
         fprintf(fpout, ",%d", ATL_affinityIDs[i%ATL_AFF_NUMID]);
      fprintf(fpout, "};\n   #endif\n");
   #endif
   fprintf(fpout, "\n#endif\n");
   fclose(fpout);
   return(0);
}
@ROUT tune_count
#include "atlas_threads.h"
#include "atlas_misc.h"

static volatile int count=0;
static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
static void *acnt;

int ATL_DecAtomicCount_ser(void)
{
   int iret=0;
   if (count)
   {
      iret = count;
      count--;
   }
   return(iret);
}

int ATL_DecAtomicCount_mut(void)
{
   int iret=0;
   if (count)
   {
      pthread_mutex_lock(&mutex);
      if (count)
      {
         iret = count;
         count--;
      }
      pthread_mutex_unlock(&mutex);
   }
   return(iret);
}

void TuneDoWork_ser(ATL_LAUNCHSTRUCT_t *lp, void *vp)
{
   while (ATL_DecAtomicCount_ser());
}

void TuneDoWork_mut(ATL_LAUNCHSTRUCT_t *lp, void *vp)
{
   while (ATL_DecAtomicCount_mut());
}

void TuneDoWork(ATL_LAUNCHSTRUCT_t *lp, void *vp)
{
   while (ATL_DecAtomicCount(acnt));
}

int main(int nargs, char **args)
{
   double t0, tmut, tdec, tser; 
   int nreps=1000000;

   if (nargs > 1)
      nreps = atoi(args[1]);
   
   printf("FINDING SPEED OF COUNTER CHANGING USING %d REPS & %d PROC\n",
          nreps, ATL_NTHREADS);
   
   acnt = ATL_SetAtomicCount(nreps);
   t0 = ATL_walltime();
//   ATL_thread_launch(NULL, 0, NULL, TuneDoWork, NULL);
   TuneDoWork(NULL, NULL);
   tdec = ATL_walltime() - t0;
   printf("   dec time = %e\n", tdec);
   ATL_FreeAtomicCount(acnt);
   acnt = NULL;

   count = nreps;
   t0 = ATL_walltime();
//   ATL_thread_launch(NULL, 0, NULL, TuneDoWork_mut, NULL);
   TuneDoWork_mut(NULL, NULL);
   tmut = ATL_walltime() - t0;
   printf("   mut time = %e\n", tmut);

   count = nreps;
   t0 = ATL_walltime();
//   ATL_thread_launch(NULL, 0, NULL, TuneDoWork_mut, NULL);
   TuneDoWork_ser(NULL, NULL);
   tser = ATL_walltime() - t0;
   printf("   ser time = %e\n", tser);

   printf("\n   MICROSECONDS PER CALL: SER=%.2f DEC=%.2f, MUT=%.2f\n", 
          tser*1000000.0, tdec*1000000.0, tmut*1000000.0);
   #ifdef PentiumCPS
      t0 = 1000000.0*PentiumCPS;
      printf("   CYCLES: SER=%e, DEC=%e, MUT=%e\n", 
             t0*(tser/nreps), t0*(tdec/nreps), t0*(tmut/nreps));
   #endif
   printf("DEC TIME SPEEDUP OVER MUTEX   = %.2f\n", tmut / tdec);
   printf("SERIAL SPEEDUP OVER DEC = %.2f\n", tdec / tser);
   return(0);
}
@ROUT tune_spawn tune_spawn_fp
#include "atlas_threads.h"
#include "atlas_misc.h"

void ATL_tllin
   (void *opstruct, int opstructstride, void *OpStructIsInit, void *DoWork, 
    void *CombineOpStructs);
void ATL_tllg2
   (void *opstruct, int opstructstride, void *OpStructIsInit, void *DoWork, 
    void *CombineOpStructs);
void ATL_tldyn
   (void *opstruct, int opstructstride, void *OpStructIsInit, void *DoWork, 
    void *CombineOpStructs);
@ROUT tune_spawn_fp `void DoFlops(size_t nflops);`
typedef struct
{
@ROUT tune_spawn_fp `   size_t flops;`
   volatile int *donearr;   /* starts all zero */
   int rank, nthr;
} ATL_TUNE_T;

@skip int TuneIsInit(void *vp) { return(1); }  /* all structs init when tuning */

void TuneDoWork(ATL_LAUNCHSTRUCT_t *lp, void *vp)
/* 
 * Use volatile array to check in, and then quit (cache-speed barrier)
 */
{
   ATL_TUNE_T *tp = vp;
   const int nthr = tp->nthr;
   int i;

@ROUT tune_spawn_fp
   DoFlops(tp->flops);
@ROUT tune_spawn
   tp->donearr[tp->rank] = 1;
   for (i=0; i < nthr; i++)
      while(!tp->donearr[i]);
@ROUT tune_spawn tune_spawn_fp
}

void PrintUsage(char *exe)
{
@ROUT tune_spawn_fp
   fprintf(stderr, 
"USAGE: %s [-r <reps>] [-f flops] [-k <kflops>] [-m <mflops>] -W [which]\n", 
           exe);
@ROUT tune_spawn
   fprintf(stderr, "USAGE: %s [-r <reps>] -W [which]\n", exe);
@ROUT tune_spawn tune_spawn_fp
   fprintf(stderr, 
   "   which: bitfield, 1st bit is dyn, 2nd is lg2, 3rd is linear\n");
   exit(-1);
}

@ROUT tune_spawn_fp
int GetFlags(int nargs, char **args, int *which, size_t *flops)
@ROUT tune_spawn
int GetFlags(int nargs, char **args, int *which)
@ROUT tune_spawn tune_spawn_fp
{
   int i, reps=1;
@ROUT tune_spawn_fp `   int imul=1;`

@ROUT tune_spawn_fp `   *flops = 1000000;`
   *which = 7;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'r':
         if (++i >= nargs)
            PrintUsage(args[0]);
         reps = atoi(args[i]);
         break;
      case 'W':
         if (++i >= nargs)
            PrintUsage(args[0]);
         *which = atoi(args[i]);
         break;
@ROUT tune_spawn_fp
      case 'm':
         imul *= 1000;
      case 'k':
         imul *= 1000;
      case 'f':
         if (++i >= nargs)
            PrintUsage(args[0]);
         *flops = imul * atoi(args[i]);
         imul = 1;
         break;
@ROUT tune_spawn tune_spawn_fp
      default:
         PrintUsage(args[0]);
      }
   }
   return(reps);
}
int main(int nargs, char **args)
{
   int i, k, nreps = 200, opstride, which;
   double t0, tlin, tlg2, tdyn;
   ATL_TUNE_T ta[ATL_NTHREADS];
   volatile int done[ATL_NTHREADS];
@ROUT tune_spawn_fp `   size_t flops;`

   tlg2 = tdyn = tlin = 0.0;
@ROUT tune_spawn `   nreps = GetFlags(nargs, args, &which);`
@ROUT tune_spawn_fp `   nreps = GetFlags(nargs, args, &which, &flops);`

   for (i=0; i < ATL_NTHREADS; i++)
   {
      ta[i].donearr = done;
      ta[i].rank = i;
      ta[i].nthr = ATL_NTHREADS;
@ROUT tune_spawn_fp `      ta[i].flops = flops;`
   }
   opstride = (int) ( ((char*)(ta+1)) - (char*)(ta) );

   printf("FINDING SPEED OF CREATE/BARRIER/JOIN USING %d REPITITIONS:\n", 
          nreps);
   if (which & 1)
   {
      t0 = ATL_walltime();
      for (k=0; k < nreps; k++)
      {
         for (i=0; i < ATL_NTHREADS; i++)
            done[i] = 0;
         ATL_tldyn(ta, opstride, NULL, TuneDoWork, NULL);
      }
      tdyn = ATL_walltime() - t0;
      printf("   dyn time = %e\n", (float)tdyn);
   }

   if (which & 2)
   {
      t0 = ATL_walltime();
      for (k=0; k < nreps; k++)
      {
         for (i=0; i < ATL_NTHREADS; i++)
            done[i] = 0;
         ATL_tllg2(ta, opstride, NULL, TuneDoWork, NULL);
      }
      tlg2 = ATL_walltime() - t0;
      printf("   lg2 time = %e\n", (float)tlg2);
   }

   if (which & 4)
   {
      t0 = ATL_walltime();
      for (k=0; k < nreps; k++)
      {
         for (i=0; i < ATL_NTHREADS; i++)
            done[i] = 0;
         ATL_tllin(ta, opstride, NULL, TuneDoWork, NULL);
      }
      tlin = ATL_walltime() - t0;
      printf("   lin time = %e\n", (float)tlin);
   }
   if ((which | 7) == which)
      printf("DYNAMIC is %.2f%% of LINEAR and %.2f%% of LOG2 SPEED.\n", 
             (tdyn/tlin)*100.0, (tdyn/tlg2)*100.0);
   return(0);
}
@ROUT tune_aff
/*
 * Eventually, should figure out if setting affinity helps or hurts performance.
 * Will probably want to prove L3 & L2 seperately!
 */
int main(int nargs, char **args)
{
   return(0);
}
@ROUT DoFlops_amd64.S
#include "atlas_asm.h"
/* 
 * function is: void DoFlops(size_t nflops);
 */
#define nflops  %rdi
#define N       %rax
#define ZR  %xmm0
#define A0  %xmm1
#define B0  %xmm2
#define B1  %xmm3
#define B2  %xmm4
#define B3  %xmm5
#define B4  %xmm6
#define C0  %xmm7
#define C1  %xmm8
#define C2  %xmm9
#define C3  %xmm10
#define C4  %xmm11
#define C5  %xmm12
#define C6  %xmm13
#define C7  %xmm14

.text
.globl ATL_asmdecor(DoFlops)
ATL_asmdecor(DoFlops):
/*
 * Zero all xmm regs
 */
   xorps %xmm0, %xmm0
   xorps %xmm1, %xmm1
   xorps %xmm2, %xmm2
   xorps %xmm3, %xmm3
   xorps %xmm4, %xmm4
   xorps %xmm5, %xmm5
   xorps %xmm6, %xmm6
   xorps %xmm7, %xmm7
   xorps %xmm8, %xmm8
   xorps %xmm9, %xmm9
   xorps %xmm10, %xmm10
   xorps %xmm11, %xmm11
   xorps %xmm12, %xmm12
   xorps %xmm13, %xmm13
   xorps %xmm14, %xmm14
   xorps %xmm15, %xmm15
/* 
 * This loop adds into 8 different accumulators, after doing a chained
 * multiplication.  The number of flops is therefore:
 *   (veclen)*(vecflops)*(naccum) = 4 * 2 * 8 = 64 flops/iteration
 */
   movq nflops, N
   shr  $6, N      /* N = nflops / 64 */
   LOOPN:
/*
 *    On Intel chips, you need to write all read registers once every loop
 *    iteration, or you cannot achieve peak.
 */
      mulps A0, B0
      addps B0, C0
      mulps A0, B1
      addps B1, C1
      mulps A0, B2
      addps B2, C2
      mulps A0, B3
      addps B3, C3
      mulps A0, B0
      addps B0, C4
      mulps A0, B1
      addps B1, C5
      mulps A0, B2
      addps B2, C6
      mulps A0, B3
      addps B3, C7
      #ifdef Intel
         xorps A0, A0
      #endif
   sub $1, N
   jnz LOOPN

ret
