@skip
@skip Comments of the ATLAS LAPACK F77 interface                       AP99
@skip
@skip Last modification : 11/15/99
@skip
@skip      C      V                      D                             V12345678
@skip
@rout xerlin
@extract @(PURPOSE)
*
*  @(rname) is an error handler for the  ATLAS  linear solver routines. It
*  is called by an Fortran 77 ATLAS routine if an input parameter has an
*  invalid value.  A message is printed.  Installers  may consider modi-
*  fying this routine in order to call  system-specific  exception-hand-
*  ling facilities.
*
*  SRNAME  (input)                       CHARACTER*10
*          The name of the routine which called @(rname).
*
*  INFO    (input)                       INTEGER
*          The  position  of the invalid parameter in the parameter list
*          of the calling routine.
*
@extract @(LINE)
@rout gesv
@extract @(PURPOSE)
*
*  @(rname) computes the solution to a real system of linear equations
*
*     A * X = B,
*
*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
*
*  The  LU  decomposition  with partial pivoting and row interchanges is
*  used to factor A as
*
*     A = P * L * U,
*
*  where P is a permutation matrix, L is unit lower triangular, and U is
*  upper triangular.  The factored form of  A  is then used to solve the
*  system of equations A * X = B.
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies  the number  of linear equations, i.e.,
*          the order of the matrix A. N must be at least zero. Unchanged
*          on exit.
*
*  NRHS    (input)                       INTEGER
*          On entry, NRHS  specifies  the number of  right  hand  sides,
*          i.e., the number of columns of the matrix B.  NRHS must be at
*          least zero. Unchanged on exit.
*
*  A       (input/output)                @(type_comm) array
*          On entry,  A  is  an  array of  DIMENSION ( LDA, n ).  Before
*          entry, the leading  n by n  part of the array  A must contain
*          the coefficient matrix A. On exit, the array  A  is overwrit-
*          ten by the triangular factors L and U  from the factorization
*          A = P*L*U; the unit diagonal elements of L are not stored.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, N ). Unchanged on exit.
*
*  IPIV    (output)                      INTEGER array
*          On entry,  IPIV  is an array of DIMENSION (N).  On exit, IPIV
*          contains the pivot indices that define the permutation matrix
*          P; row i of the matrix was interchanged with row IPIV(i).
*
*  B       (input/output)                @(type_comm) array
*          On entry,  B is an array of DIMENSION (LDB, nrhs). Before en-
*          try, the leading n by nrhs  part of the array  B must contain
*          the matrix of right hand side matrix B. On exit, if INFO = 0,
*          the array  B  is overwritten by the n by nrhs solution matrix
*          X.
*
*  LDB     (input)                       INTEGER
*          On entry, LDB  specifies the leading dimension of the array B
*          as declared in the calling (sub)program. LDB must be at least
*          max( 1, N ). Unchanged on exit.
*
*  INFO    (output)                      INTEGER
*          = 0:  successful exit,
*          < 0:  if INFO = -i, the i-th argument had an illegal value,
*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
*                has been completed, but the factor  U is exactly singu-
*                lar, so the solution could not be computed.
*
@extract @(LINE)
@rout getrf
@extract @(PURPOSE)
*
*  @(rname)  computes an LU factorization of a general M-by-N matrix A
*  using partial pivoting with row interchanges.
*
*  The factorization has the form
*
*     A = P * L * U
*
*  where P is a permutation matrix, L is lower triangular with unit dia-
*  gonal elements (lower trapezoidal if m > n), and  U is upper triangu-
*  lar (upper trapezoidal if m < n).
*
*  This is the recursive version of the algorithm.
*
@extract @(ARGUMENTS)
*
*  M       (input)                       INTEGER
*          On entry,  M  specifies  the number  of rows of the matrix A.
*          M  must be at least zero. Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N  specifies the number of columns of the matrix A.
*          N must be at least zero. Unchanged on exit.
*
*  A       (input/output)                @(type_comm) array
*          On entry,  A  is  an  array of  DIMENSION ( LDA, n ).  Before
*          entry, the leading  m by n  part of the array  A must contain
*          the coefficient matrix A. On exit, the array  A  is overwrit-
*          ten by the triangular factors L and U  from the factorization
*          A = P*L*U; the unit diagonal elements of L are not stored.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, M ). Unchanged on exit.
*
*  IPIV    (output)                      INTEGER array
*          On entry,  IPIV is an array of DIMENSION (MIN(M,N)). On exit,
*          IPIV  contains the pivot  indices that define the permutation 
*          matrix P; for 1 <= i <= min(M,N), row i of the matrix was in-
*          terchanged with row IPIV(i).
*
*  INFO    (output)                      INTEGER
*          = 0:  successful exit,
*          < 0:  if INFO = -i, the i-th argument had an illegal value,
*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization
*                has been completed, but the factor  U is exactly singu-
*                lar, and  division by zero  will occur if it is used to
*                solve a system of equations.
*
@extract @(LINE)
@rout getrs
@extract @(PURPOSE)
*
*  @(rname) solves a system of linear equations
*
@type real dble
*     A * X = B  or  A' * X = B
@type cplx zplx
*     A * X = B,  A**T * X = B,  or  A**H * X = B
@type real dble cplx zplx
*
*  with a general N-by-N matrix A using the LU factorization computed by
*  ATL_@(pre)GETRF.
*
@extract @(ARGUMENTS)
*
*  TRANS   (input)                       CHARACTER*1
*          On entry,  TRANS  specifies the form of the  system of linear 
*          equations to be solved as follows:
*             = 'N':  A    * X = B  (No transpose)
*             = 'T':  A**T * X = B  (Transpose)
@type real dble
*             = 'C':  A**T * X = B  (Conjugate transpose = Transpose)
@type cplx zplx
*             = 'C':  A**H * X = B  (Conjugate transpose)
@type real dble cplx zplx
*
*  N       (input)                       INTEGER
*          On entry, N specifies the order of the matrix A. N must be at
*          least zero. Unchanged on exit.
*
*  NRHS    (input)                       INTEGER
*          On entry, NRHS  specifies  the number of  right  hand  sides,
*          i.e., the number of columns of the matrix B.  NRHS must be at
*          least zero. Unchanged on exit.
*
*  A       (input)                       @(type_comm) array
*          On entry,  A  is  an  array of DIMENSION (LDA, n),  such that
*          the  leading  n by n  part of this array  A  must contain the
*          triangular factors L and U  from the factorization  A = P*L*U
*          as computed by ATL_@(pre)GETRF.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, N ). Unchanged on exit.
*
*  IPIV    (input)                       INTEGER array
*          On entry,  IPIV  is an array of  DIMENSION (N) as returned by
*          ATL_DGETRF.  IPIV  contains the pivot indices that define the
*          permutation matrix  P;  for 1 <= i <= N, row i of the  matrix
*          was interchanged with row IPIV(i).
*
*  B       (input/output)                @(type_comm) array
*          On entry,  B is an array of DIMENSION (LDB, nrhs). Before en-
*          try, the leading n by nrhs  part of the array  B must contain
*          the matrix of right hand side matrix B. On exit, if INFO = 0,
*          the array  B  is overwritten by the n by nrhs solution matrix
*          X.
*
*  LDB     (input)                       INTEGER
*          On entry, LDB  specifies the leading dimension of the array B
*          as declared in the calling (sub)program. LDB must be at least
*          max( 1, N ). Unchanged on exit.
*
*  INFO    (output)                      INTEGER
*          = 0:  successful exit,
*          < 0:  if INFO = -i, the i-th argument had an illegal value.
*
@extract @(LINE)
@rout getri
@extract @(PURPOSE)
*
*  @(rname)  computes the inverse of a matrix using the LU  factoriza-
*  tion computed by ATL_@(pre)GETRF.
*
*  This method inverts U and then computes inv(A) by solving the system
*  inv(A)*L = inv(U) for inv(A).
*
*  This is the recursive version of the algorithm.
*
@extract @(ARGUMENTS)
*
*  N       (input)                       INTEGER
*          On entry, N specifies the order of the matrix A. N must be at
*          least zero. Unchanged on exit.
*
*  A       (input/output)                @(type_comm) array
*          On entry,  A  is  an  array of DIMENSION (LDA, n),  such that
*          the  leading  n by n  part of this array  A  must contain the
*          triangular factors L and U  from the factorization  A = P*L*U
*          as computed by ATL_@(pre)GETRF. On exit, if INFO = 0, the in-
*          verse of the original matrix A.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, N ). Unchanged on exit.
*
*  IPIV    (input)                       INTEGER array
*          On entry,  IPIV  is an array of  DIMENSION (N) as returned by
*          ATL_DGETRF.  IPIV  contains the pivot indices that define the
*          permutation matrix  P;  for 1 <= i <= N, row i of the  matrix
*          was interchanged with row IPIV(i).
*
*  INFO    (output) INTEGER
*             = 0: successful exit,
*             < 0: if INFO = -i, the i-th argument had an illegal value,
*             > 0: if INFO =  i, U(i,i) is exactly zero;  the matrix  is
*                  singular and its inverse could not be computed.
*
@extract @(LINE)
@rout posv
@extract @(PURPOSE)
*
*  @(rname) computes the solution to a real system of linear equations
*
*     A * X = B,
*
*  where  A  is an N-by-N @(syhe_comm) positive definite matrix and X and B
*  are N-by-NRHS matrices.
*
*  The Cholesky decomposition is used to factor A as
*
@type real dble
*     A = U**T * U,  if UPLO = 'U',   or   A = L * L**T,  if UPLO = 'L',
@type chex zhex
*     A = U**H * U,  if UPLO = 'U',   or   A = L * L**H,  if UPLO = 'L', 
@type real dble chex zhex
*
*  where U is an upper triangular matrix and L is a lower triangular ma-
*  trix.  The factored form of  A  is then used to solve the  system  of
*  equations A * X = B.
*
@extract @(ARGUMENTS)
*
*  UPLO    (input)                       CHARACTER*1
*          On entry, UPLO  specifies whether the upper or lower triangu-
*          lar part of the array A is to be referenced as follows:
*
*             UPLO = 'U' or 'u'   Only the upper triangular part of A is
*                                 to be referenced.
*
*             UPLO = 'L' or 'l'   Only the lower triangular part of A is
*                                 to be referenced.
*
*          Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry,  N  specifies the number of linear equations, i.e.,
*          the order of the matrix A. N must be at least zero. Unchanged
*          on exit.
*
*  NRHS    (input)                       INTEGER
*          On entry, NRHS  specifies  the number of  right  hand  sides,
*          i.e., the number of columns of the matrix B.  NRHS must be at
*          least zero. Unchanged on exit.
*
*  A       (input/output)                @(type_comm) array
*          On entry,  A  is  an  array of  DIMENSION ( LDA, n ).  Before
*          entry,  if UPLO = 'U',  the  leading  n by n upper triangular 
*          part of A contains the upper triangular part of the @(syhe_comm)
*          positive definite matrix A, and the strictly lower triangular
*          part of A  is not referenced. If UPLO = 'L', the leading n by
*          n lower triangular part of  A  contains  the lower triangular
*          part of the  @(syhe_comm) positive definite  matrix  A, and  the
*          strictly  upper  triangular part of  A  is not referenced. On
*          exit, if INFO = 0, the factor U or L from the Cholesky facto-
@type real dble
*          rization A = U**H * U or A = L * L**H.
@type chex zhex
*          rization A = U**T * U or A = L * L**T.
@type real dble chex zhex
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, N ). Unchanged on exit.
*
*  B       (input/output)                @(type_comm) array
*          On entry,  B is an array of DIMENSION (LDB, nrhs). Before en-
*          try, the leading n by nrhs  part of the array  B must contain
*          the matrix of right hand side matrix B. On exit, if INFO = 0,
*          the array  B  is overwritten by the n by nrhs solution matrix
*          X.
*
*  LDB     (input)                       INTEGER
*          On entry, LDB  specifies the leading dimension of the array B
*          as declared in the calling (sub)program. LDB must be at least
*          max( 1, N ). Unchanged on exit.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit,
*          < 0:  if INFO = -i, the i-th argument had an illegal value,
*          > 0:  if INFO =  i, the leading minor of order i of  A is not
*                positive definite,  so  the  factorization could not be
*                completed, and the solution has not been computed.
*
@extract @(LINE)
@rout potrf
@extract @(PURPOSE)
*
*  @(rname) computes the Cholesky factorization of a @(syhe_comm) positi-
*  ve definite matrix A.
*
*  The factorization has the form
*
@type real dble
*     A = U**T * U,  if UPLO = 'U',   or   A = L * L**T,  if UPLO = 'L',
@type chex zhex
*     A = U**H * U,  if UPLO = 'U',   or   A = L * L**H,  if UPLO = 'L', 
@type real dble chex zhex
*
*  where U is an upper triangular matrix and L is lower triangular.
*
*  This is the recursive version of the algorithm.
*
@extract @(ARGUMENTS)
*
*  UPLO    (input)                       CHARACTER*1
*          On entry, UPLO  specifies whether the upper or lower triangu-
*          lar part of the array A is to be referenced as follows:
*
*             UPLO = 'U' or 'u'   Only the upper triangular part of A is
*                                 to be referenced.
*
*             UPLO = 'L' or 'l'   Only the lower triangular part of A is
*                                 to be referenced.
*
*          Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N specifies the order of the matrix A. N must be at
*          least zero. Unchanged on exit.
*
*  A       (input/output)                @(type_comm) array
*          On entry,  A  is  an  array of  DIMENSION ( LDA, n ).  Before
*          entry,  if UPLO = 'U',  the  leading  n by n upper triangular
*          part of A contains the upper triangular part of the @(syhe_comm)
*          positive definite matrix A, and the strictly lower triangular
*          part of A  is not referenced. If UPLO = 'L', the leading n by
*          n lower triangular part of  A  contains  the lower triangular
*          part of the  @(syhe_comm) positive definite  matrix  A, and  the
*          strictly  upper  triangular part of  A  is not referenced. On
*          exit, if INFO = 0, the factor U or L from the Cholesky facto-
@type real dble
*          rization A = U**H * U or A = L * L**H.
@type chex zhex
*          rization A = U**T * U or A = L * L**T.
@type real dble chex zhex
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, N ). Unchanged on exit.
*
*  INFO    (output)                      INTEGER
*          = 0:  successful exit,
*          < 0:  if INFO = -i, the i-th argument had an illegal value,
*          > 0:  if INFO =  i, the leading minor of order i of  A is not
*                positive definite,  so  the  factorization could not be
*                completed.
*
@extract @(LINE)
@rout potrs
@extract @(PURPOSE)
*
*  @(rname) solves a system of linear equations
*
*     A * X = B
*
*  with a @(syhe_comm) positive definite matrix A using the Cholesky facto-
@type real dble
*  rization A = U**T * U or A = L * L**T computed by ATL_@(pre)POTRF.
@type chex zhex
*  rization A = U**H * U or A = L * L**H computed by ATL_@(pre)POTRF.
@type real dble chex zhex
*
@extract @(ARGUMENTS)
*
*  UPLO    (input)                       CHARACTER*1
*          On entry, UPLO  specifies whether the upper or lower triangu-
*          lar part of the array A is to be referenced as follows:
*
*             UPLO = 'U' or 'u'   Only the upper triangular part of A is
*                                 to be referenced.
*
*             UPLO = 'L' or 'l'   Only the lower triangular part of A is
*                                 to be referenced.
*
*          Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N specifies the order of the matrix A. N must be at
*          least zero. Unchanged on exit.
*
*  NRHS    (input)                       INTEGER
*          On entry, NRHS  specifies  the number of  right  hand  sides,
*          i.e., the number of columns of the matrix B.  NRHS must be at
*          least zero. Unchanged on exit.
*
*  A       (input)                       @(type_comm) array
*          On entry,  A  is  an  array of  DIMENSION ( LDA, n ).  Before
*          entry,  the leading n by n of the array  A  must  contain the
*          triangular  factor  U  or  L  from the Cholesky factorization
@type real dble
*          A = U**T * U or A = L * L**T, as computed by ATL_@(pre)POTRF.
@type chex zhex
*          A = U**H * U or A = L * L**H, as computed by ATL_@(pre)POTRF.
@type real dble chex zhex
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, N ). Unchanged on exit.
*
*  B       (input/output)                @(type_comm) array
*          On entry,  B is an array of DIMENSION (LDB, nrhs). Before en-
*          try, the leading n by nrhs  part of the array  B must contain
*          the matrix of right hand side matrix B. On exit, the array  B
*          is overwritten by the n by nrhs solution matrix X. 
*
*  LDB     (input)                       INTEGER
*          On entry, LDB  specifies the leading dimension of the array B
*          as declared in the calling (sub)program. LDB must be at least
*          max( 1, N ). Unchanged on exit.
*
*  INFO    (output)                      INTEGER
*          = 0:  successful exit,
*          < 0:  if INFO = -i, the i-th argument had an illegal value.
*
@extract @(LINE)
@rout potri
@extract @(PURPOSE)
*
*  @(rname)  computes the inverse of a symmetric positive definite ma-
@type real dble
*  trix A using the Cholesky factorization A = U**T * U  or A = L * L**T
@type chex zhex
*  trix A using the Cholesky factorization A = U**H * U  or A = L * L**H
@type real dble chex zhex
*  computed by ATL_@(pre)POTRF.
*
*  This is the recursive version of the algorithm.
*
@extract @(ARGUMENTS)
*
*  UPLO    (input)                       CHARACTER*1
*          On entry, UPLO  specifies whether the upper or lower triangu-
*          lar part of the array A is to be referenced as follows:
*
*             UPLO = 'U' or 'u'   Only the upper triangular part of A is
*                                 to be referenced.
*
*             UPLO = 'L' or 'l'   Only the lower triangular part of A is
*                                 to be referenced.
*
*          Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N specifies the order of the matrix A. N must be at
*          least zero. Unchanged on exit.
*
*  A       (input/output)                @(type_comm) array
*          On entry,  A  is  an  array of  DIMENSION ( LDA, n ).  Before
*          entry,  the leading n by n of the array  A  must  contain the
*          triangular  factor  U  or  L  from the Cholesky factorization
@type real dble
*          A = U**T * U or A = L * L**T, as computed by  ATL_@(pre)POTRF.  On
@type chex zhex
*          A = U**H * U or A = L * L**H, as computed by  ATL_@(pre)POTRF.  On
@type real dble chex zhex
*          exit,  the upper or lower triangle of the (@(suhe_comm)) inverse
*          of A, overwriting the input factor U or L.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, N ). Unchanged on exit.
*
*  INFO    (output)                      INTEGER
*          = 0:  successful exit,
*          < 0:  if INFO = -i, the i-th argument had an illegal value,
*          > 0:  if INFO =  i, the (i,i) element of the factor U or L is
*                zero, and the inverse could not be computed.
*
@extract @(LINE)
@rout gels
@extract @(PURPOSE)
*
*  @(rname)  solves  overdetermined  or  underdetermined linear systems
@type real dble
*  involving an m by n matrix A, or its transpose, using a QR or LQ fac-
*  torization of A. It is assumed that A has full rank.
@type cplx zplx
*  involving an m by n matrix A, or its conjugate-transpose, using a QR
*  or LQ factorization of A. It is assumed that A has full rank.
@type real dble cplx zplx
*
*  The following options are provided:
*
*  1. If TRANS = 'N' or 'n' and m >= n:  find the least squares solution
*     of an overdetermined system, i.e., solve the least squares problem
*                  minimize || B - A*X ||.
*
*  2. If TRANS = 'N' or 'n' and m < n:  find  the  minimum norm solution
*     of an underdetermined system A * X = B.
*
@type real dble
*  3. If TRANS = 'T' or 't' and m >= n:  find  the minimum norm solution
*     of an undetermined system A**T * X = B.
*
*  4. If TRANS = 'T' or 't' and m <  n:  find the least squares solution
*     of an an overdetermined system, i.e., solve the least squares pro-
*     blem
*                  minimize || B - A**T * X ||.
@type cplx zplx
*  3. If TRANS = 'C' or 'c' and m >= n:  find  the minimum norm solution
*     of an undetermined system A**H * X = B.
*
*  4. If TRANS = 'C' or 'c' and m <  n:  find the least squares solution
*     of an an overdetermined system, i.e., solve the least squares pro-
*     blem
*                  minimize || B - A**H * X ||.
@type real dble cplx zplx
*
*  Several  right hand side vectors  b  and solution vectors  x  can  be
*  handled in a single call; they are stored as the columns of the right
*  hand side M-by-NRHS matrix B and the N-by-NRHS solution matrix X.
*
@extract @(ARGUMENTS)
*
*  TRANS   (input)                       CHARACTER*1
@type real dble
*          On entry,  TRANS  specifies whether A or its transpose should
*          be involved as follows: 
*             = 'N' or 'n': the linear system involves A;
*             = 'T' or 't': the linear system involves A**T.
@type cplx zplx
*          On entry,  TRANS  specifies whether A or its transpose should
*          be involved as follows: 
*             = 'N' or 'n': the linear system involves A;
*             = 'C' or 'c': the linear system involves A**H.
@type real dble cplx zplx
*          Unchanged on exit.
*
*  M       (input)                       INTEGER
*          On entry,  M  specifies  the number  of rows of the matrix A.
*          M  must be at least zero. Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N  specifies the number of columns of the matrix A.
*          N must be at least zero. Unchanged on exit.
*
*  NRHS    (input)                       INTEGER
*          On entry, NRHS  specifies  the number of  right  hand  sides,
*          i.e., the number of columns of the matrix B and X.  NRHS must
*          be at least zero. Unchanged on exit.
*
*  A       (input/output)                @(type_comm) array
*          On entry, A is an array of DIMENSION ( LDA, N ). Before entry
*          the leading  m by n  part of the array A must contain the ma-
*          trix  A.  On exit, if M >= N,  A is overwritten by details of
*          its QR factorization as returned by ATL_@(pre)GEQRF; Otherwise, A
*          is overwritten by details of its LQ factorization as returned
*          by ATL_@(pre)GELQF.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, M ). Unchanged on exit.
*
*  B       (input/output)                @(type_comm) array
*          On entry, B is an array of DIMENSION (LDB,NRHS). Before entry
*          this array B must contain the matrix  of right hand side vec-
*          tors stored columnwise; B is M-by-NRHS if TRANS = 'N' or 'n',
*          and N-by-NRHS otherwise. On exit, B is overwritten by the so-
*          lution vectors, stored columnwise: if TRANS = 'N' and m >= n,
*          rows 1 to n of  B contain the least squares solution vectors;
*          the residual sum  of  squares for the solution in each column
*          is given  by the sum of squares of elements  N+1 to M in that
*          column;  if  TRANS = 'N' or 'n' and m < n,  rows  1 to N of B
@type real dble
*          contain  the minimum norm solution vectors; if TRANS = 'T' or
*          't' and m >= n, rows 1 to M of B contain the minimum norm so-
*          lution vectors;  if TRANS = 'T' or 't' and m < n, rows 1 to M
*          of B contain the least squares solution vectors; the residual
*          sum of  squares for  the  solution in each column is given by
*          the sum of squares of elements M+1 to N in that column.
@type cplx zplx
*          contain  the minimum norm solution vectors; if TRANS = 'C' or
*          'c' and m >= n, rows 1 to M of B contain the minimum norm so-
*          lution vectors;  if TRANS = 'C' or 'c' and m < n, rows 1 to M
*          of B contain the least squares solution vectors; the residual
*          sum of  squares for  the  solution in each column is given by
*          the sum of squares of elements M+1 to N in that column.
@type real dble cplx zplx
*
*  LDB     (input)                       INTEGER
*          On entry, LDB  specifies the leading dimension of the array B
*          as declared in the calling (sub)program. LDB must be at least
*          max( 1, M, N ). Unchanged on exit.
*
*  INFO    (output)                      INTEGER
*          = 0:  successful exit,
*          < 0:  if INFO = -i, the i-th argument had an illegal value.
*
@extract @(LINE)
@rout geqrf
@extract @(PURPOSE)
*
*  @(rname) computes a QR factorization of an m by n matrix A:
*
*     A = Q * R.
*
*  This is the hybrid recursive version of the algorithm.
*
@extract @(ARGUMENTS)
*
*  M       (input)                       INTEGER
*          On entry,  M  specifies  the number  of rows of the matrix A.
*          M  must be at least zero. Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N  specifies the number of columns of the matrix A.
*          N must be at least zero. Unchanged on exit.
*
*  A       (input/output)                @(type_comm) array
*          On entry, A is an array of DIMENSION ( LDA, N ). Before entry
*          the leading  m by n  part of the array A must contain the ma-
*          trix  A.  On exit,  the elements on and below the diagonal of
*          the array  A  contain the min(m,n)-by-n upper trapezoidal ma-
*          trix  R (R is upper triangular if m >= n); the elements below
@type real dble
*          the diagonal, with the array  TAU,  represent the  orthogonal
*          matrix  Q as a product of min(m,n) elementary reflectors (see
*          Further Details).
@type cplx zplx
*          the diagonal, with the array TAU,  represent the  unitary ma-
*          trix  Q  as a product of  min(m,n) elementary reflectors (see
*          Further Details).
@type real dble cplx zplx
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, M ). Unchanged on exit.
*
*  TAU     (output)                      @(type_comm) array
*          On entry, TAU is an array of DIMENSION (MIN(M,N)).  On  exit,
*          TAU(i)  contains the scalar factor of  the elementary reflec-
*          tor H(i) (see Further Details).
*
*  INFO    (output)                      INTEGER
*          = 0:  successful exit,
*          < 0:  if INFO = -i, the i-th argument had an illegal value.
*
@extract @(FURTHER_DETAILS)
*
*  The matrix Q is represented as a product of elementary reflectors
*
*     Q = H(1) H(2) . . . H(k), where k = min(m,n).
*
*  Each H(i) has the form
*
*     H(i) = I - tau * v * v'
*
*  where tau is a scalar, and  v is a vector with v(1:i-1)=0 and v(i)=1;
*  v(i+1:m) is stored on exit in  A(i+1:m,i), and tau in TAU(i).
*
@extract @(LINE)
@rout gelqf
@extract @(PURPOSE)
*
*  @(rname) computes a LQ factorization of an m by n matrix A:
*
*     A = L * Q.
*
*  This is the hybrid recursive version of the algorithm.
*
@extract @(ARGUMENTS)
*
*  M       (input)                       INTEGER
*          On entry,  M  specifies  the number  of rows of the matrix A.
*          M  must be at least zero. Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N  specifies the number of columns of the matrix A.
*          N must be at least zero. Unchanged on exit.
*
*  A       (input/output)                @(type_comm) array
*          On entry, A is an array of DIMENSION ( LDA, N ). Before entry
*          the leading  m by n  part of the array A must contain the ma-
*          trix  A.  On exit,  the elements on and below the diagonal of
*          the array  A  contain the m-by-min(m,n) lower trapezoidal ma-
*          trix  L (L is lower triangular if m <= n); the elements above
@type real dble
*          the diagonal, with the array  TAU,  represent the  orthogonal 
*          matrix Q  as a product of min(m,n) elementary reflectors (see
*          Further Details).
@type cplx zplx
*          the diagonal, with the array TAU,  represent the  unitary ma-
*          trix  Q  as a product of  min(m,n) elementary reflectors (see
*          Further Deails).
@type real dble cplx zplx
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, M ). Unchanged on exit.
*
*  TAU     (output)                      @(type_comm) array
*          On entry, TAU is an array of DIMENSION (MIN(M,N)).  On  exit,
*          TAU(i)  contains the scalar factor of  the elementary reflec-
*          tor H(i) (see Further Details).
*
*  INFO    (output)                      INTEGER
*          = 0:  successful exit,
*          < 0:  if INFO = -i, the i-th argument had an illegal value.
*
@extract @(FURTHER_DETAILS)
*
*  The matrix Q is represented as a product of elementary reflectors
*
@type real dble
*     Q = H(k) . . . H(2) H(1), where k = min(m,n).
@type cplx zplx
*     Q = H(k)' . . . H(2)' H(1)', where k = min(m,n).
@type real dble cplx zplx
*
*  Each H(i) has the form
*
*     H(i) = I - tau * v * v'
*
*  where tau is a scalar, and  v is a vector with v(1:i-1)=0 and v(i)=1;
@type real dble
*  v(i+1:n) is stored on exit in A(i,i+1:n), and tau in TAU(i).
@type cplx zplx
*  conjg(v(i+1:n)) is stored on exit in A(i,i+1:n), and tau in TAU(i). 
@type real dble cplx zplx
*
@extract @(LINE)
@rout ormqr
@extract @(PURPOSE)
*
*  @(rname) overwrites the general m by n matrix C with
*
*                           SIDE = 'L' or 'l'     SIDE = 'R' or 'r'
*     TRANS = 'N' or 'n':        Q    * C              C * Q
@type real dble
*     TRANS = 'T' or 't':        Q**T * C              C * Q**T
*
*  where  Q is a real orthogonal matrix defined as the product of k ele-
*  mentary reflectors
*
*        Q = H(k) . . . H(2) H(1)
@type cplx zplx
*     TRANS = 'C' or 'c':        Q**H * C              C * Q**H
*
*  where  Q is a complex unitary matrix defined as the product of k ele-
*  mentary reflectors
*
*        Q = H(k)' . . . H(2)' H(1)'
@type real dble cplx zplx
*
*  as returned by ATL_@(pre)GEQRF. Q is of order M  if SIDE = 'L' or 'l'  and
*  of order N if SIDE = 'R' or 'r'.
*
@extract @(ARGUMENTS)
*
*  SIDE    (input)                       CHARACTER*1
@type real dble
*          On entry,  SIDE  specifies where Q or its transpose should be
*          applied as follows:
*             = 'L' or 'l': apply Q or Q**T from the Left;
*             = 'R' or 'r': apply Q or Q**T from the Right.
@type cplx zplx
*          On entry,  SIDE  specifies where Q or its conjugate transpose
*          should be applied as follows:
*             = 'L' or 'l': apply Q or Q**H from the Left;
*             = 'R' or 'r': apply Q or Q**H from the Right.
@type real dble cplx zplx
*          Unchanged on exit.      
*
*  TRANS   (input)                       CHARACTER*1
@type real dble
*          On entry,  TRANS  specifies whether Q or its transpose should
*          be applied as follows:
*             = 'N' or 'n':  No transpose, apply Q;
*             = 'T' or 't':  Transpose,    apply Q**T.
@type cplx zplx
*          On entry,  TRANS  specifies whether Q or its conjugate trans-
*          pose should be applied as follows:
*             = 'N' or 'n':  No transpose,        apply Q;
*             = 'C' or 'c':  Conjugate transpose, apply Q**H.
@type real dble cplx zplx
*          Unchanged on exit.      
*
*  M       (input)                       INTEGER
*          On entry,  M  specifies  the number  of rows of the matrix C.
*          M  must be at least zero. Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N  specifies the number of columns of the matrix C.
*          N must be at least zero. Unchanged on exit.
*
*  K       (input)                       INTEGER
*          On entry,  K  specifies the number of  elementary  reflectors 
*          whose product defines the matrix Q:
*             If SIDE = 'L', M >= K >= 0; if SIDE = 'R', N >= K >= 0.
*          Unchanged on exit.
*
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of DIMENSION (LDA, K).  On entry, the
*          i-th column of this array  A  must  contain the vector  which
*          defines the elementary  reflector H(i),  for i = 1 ... k,  as
*          returned  by  ATL_@(pre)GEQRF  in the first k columns of its array 
*          argument  A.  A  is  modified by the routine but restored  on
*          exit.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, M )  if SIDE = 'L' or 'l', and MAX( 1, N ) otherwise.
*          Unchanged on exit.
*
*  TAU     (input)                       @(type_comm) array
*          On entry, TAU is an array of DIMENSION (K).  On entry, TAU(i)
*          must  contain  the scalar factor of  the elementary reflector 
*          H(i), as returned by ATL_@(pre)GEQRF. Unchanged on exit.
*
*  C       (input/output)                @(type_comm) array
*          On entry, C is an array of DIMENSION ( LDC, N ). Before entry
*          the leading  m by n  part of the array C must contain the ma-
@type real dble
*          trix C. On exit, C is overwritten by Q*C or Q**T*C or  C*Q**T
@type cplx zplx
*          trix C. On exit, C is overwritten by Q*C or Q**H*C or  C*Q**H
@type real dble cplx zplx
*          or C*Q.
*
*  LDC     (input)                       INTEGER
*          On entry, LDC  specifies the leading dimension of the array C
*          as declared in the calling (sub)program. LDC must be at least
*          max( 1, M ). Unchanged on exit.
*
*  INFO    (output)                      INTEGER
*          = 0:  successful exit,
*          < 0:  if INFO = -i, the i-th argument had an illegal value.
*
@extract @(LINE)
@rout ormlq
@extract @(PURPOSE)
*
*  @(rname) overwrites the general m by n matrix C with
*
*                           SIDE = 'L' or 'l'     SIDE = 'R' or 'r'
*     TRANS = 'N' or 'n':        Q    * C              C * Q
@type real dble
*     TRANS = 'T' or 't':        Q**T * C              C * Q**T
*
*  where  Q is a real orthogonal matrix defined as the product of k ele-
*  mentary reflectors
*
*        Q = H(k) . . . H(2) H(1)
@type cplx zplx
*     TRANS = 'C' or 'c':        Q**H * C              C * Q**H
*
*  where  Q is a complex unitary matrix defined as the product of k ele-
*  mentary reflectors
*
*        Q = H(k)' . . . H(2)' H(1)'
@type real dble cplx zplx
*
*  as returned by ATL_@(pre)GELQF. Q is of order M  if SIDE = 'L' or 'l'  and
*  of order N if SIDE = 'R' or 'r'.
*
@extract @(ARGUMENTS)
*
*  SIDE    (input)                       CHARACTER*1
@type real dble
*          On entry,  SIDE  specifies where Q or its transpose should be
*          applied as follows:
*             = 'L' or 'l': apply Q or Q**T from the Left;
*             = 'R' or 'r': apply Q or Q**T from the Right.
@type cplx zplx
*          On entry,  SIDE  specifies where Q or its conjugate transpose
*          should be applied as follows:
*             = 'L' or 'l': apply Q or Q**H from the Left;
*             = 'R' or 'r': apply Q or Q**H from the Right.
@type real dble cplx zplx
*          Unchanged on exit.      
*
*  TRANS   (input)                       CHARACTER*1
@type real dble
*          On entry,  TRANS  specifies whether Q or its transpose should
*          be applied as follows:
*             = 'N' or 'n':  No transpose, apply Q;
*             = 'T' or 't':  Transpose,    apply Q**T.
@type cplx zplx
*          On entry,  TRANS  specifies whether Q or its conjugate trans-
*          pose should be applied as follows:
*             = 'N' or 'n':  No transpose,        apply Q;
*             = 'C' or 'c':  Conjugate transpose, apply Q**H.
@type real dble cplx zplx
*          Unchanged on exit.      
*
*  M       (input)                       INTEGER
*          On entry,  M  specifies  the number  of rows of the matrix C.
*          M  must be at least zero. Unchanged on exit.
*
*  N       (input)                       INTEGER
*          On entry, N  specifies the number of columns of the matrix C.
*          N must be at least zero. Unchanged on exit.
*
*  K       (input)                       INTEGER
*          On entry,  K  specifies the number of  elementary  reflectors 
*          whose product defines the matrix Q:
*             If SIDE = 'L', M >= K >= 0; if SIDE = 'R', N >= K >= 0.
*          Unchanged on exit.
*
*  A       (input)                       @(type_comm) array
*          On entry, A is an array of DIMENSION ( LDA, ka ), where ka is
*          M  when  SIDE = 'L' or 'l', and is N otherwise.  The i-th row
*          of this array  A  must  contain the vector  which defines the
*          elementary  reflector H(i),  for i = 1 ... k,  as returned by
*          ATL_@(pre)GELQF in the first k rows of its array argument A.  A is
*          modified by the routine but restored on exit.
*
*  LDA     (input)                       INTEGER
*          On entry, LDA  specifies the leading dimension of the array A
*          as declared in the calling (sub)program. LDA must be at least
*          max( 1, K ). Unchanged on exit.
*
*  TAU     (input)                       @(type_comm) array
*          On entry, TAU is an array of DIMENSION (K).  On entry, TAU(i)
*          must  contain  the scalar factor of  the elementary reflector 
*          H(i), as returned by ATL_@(pre)GELQF. Unchanged on exit.
*
*  C       (input/output)                @(type_comm) array
*          On entry, C is an array of DIMENSION ( LDC, N ). Before entry
*          the leading  m by n  part of the array C must contain the ma-
@type real dble
*          trix C. On exit, C is overwritten by Q*C or Q**T*C or  C*Q**T
@type cplx zplx
*          trix C. On exit, C is overwritten by Q*C or Q**H*C or  C*Q**H
@type real dble cplx zplx
*          or C*Q.
*
*  LDC     (input)                       INTEGER
*          On entry, LDC  specifies the leading dimension of the array C
*          as declared in the calling (sub)program. LDC must be at least
*          max( 1, M ). Unchanged on exit.
*
*  INFO    (output)                      INTEGER
*          = 0:  successful exit,
*          < 0:  if INFO = -i, the i-th argument had an illegal value.
*
@extract @(LINE)
@rout !
