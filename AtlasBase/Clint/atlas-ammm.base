@ROUT damcases.idx samcases.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
# The file has the following format:
# ROUT='routine name' AUTH='author names' COMP='compiler name' CFLAGS='flags'
# ID=<id> NU=<nu> MU=<mu> KU=<ku> KBMAX=<kbmax> KBMIN=<kbmin>
# SSE=[0,1,2,3] X87=[0,1] BMABC=<0/1> BMAB=<0/1> JKMAB=<0/1> JKMABC=<0/1>
# AOUTER=<0/1> BETAN1=<0/1> KRUNTIME=<0/1> LDCTOP=<0/1> X87=<0/1>
# ASM=[asmlist], eg., asmlist is "GAS_x8664,GAS_x8632" or "GAS_SPARC"
# ASM defaults to no assembly dialect required.
# If NU/MU is negative, then the routine can only handle multiples of NU/MU.
#
@ROUT damcases.idx
ID=1 MU=4 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm2x4x1_sse2.S' \
     SSE=3 KRUNTIME=1 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=2 MU=4 NU=4 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm2x4x256_sse2.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=3 MU=6 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_dammm3x3x256_sse2.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=4 MU=4 NU=1 KU=4 AUTH="R. Clint Whaley" ROUT='ATL_dammm_nb4_sse2.S' \
     SSE=3 KBMIN=4 KBMAX=4 ASM=GAS_x8664 KUISKB=1 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=5 MU=2 NU=12 KU=2 AUTH="R. Clint Whaley" ROUT='ATL_damm2x12x2_sse2.S' \
     SSE=3 KBMIN=2 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=6 MU=2 NU=12 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm2x12x256_sse2.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -msse2'
ID=7 MU=12 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_damm12x3x256_avx.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
@ROUT samcases.idx
ID=7 MU=24 NU=3 KU=1 AUTH="R. Clint Whaley" ROUT='ATL_samm24x3x256_avx.S' \
     SSE=3 KBMAX=256 ASM=GAS_x8664 \
     COMP='gcc' CFLAGS='-x assembler-with-cpp -mavx'
@ROUT emit_amm
@ROUT emit_amm
@extract -b @(topd)/cw.inc lang=C -def cwdate 2012
#include "atlas_misc.h"
#define ATL_JKMDEF 1
#include "atlas_mmparse.h"
#include "atlas_sys.h"
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr, 
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags]:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -d <outdir>: directory to dump files to\n");
   fprintf(stderr, "   -i <infile> : can be repeated for multiple files\n");
   exit(ierr ? ierr : -1);
}

ATL_mmnode_t *GetFlags(int nargs, char **args, char *PRE, char **DOUT)
{
   int i, j=0, n, k;
   char pre='d';
   *DOUT = NULL;
   ATL_mmnode_t *mmb=NULL, *mmp, *mp;

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      
      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 'd':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *DOUT = DupString(args[i]);
        break;
      case 'i':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        mmp = ReadMMFile(args[i]);
        if (mmb)
        {
           ATL_mmnode_t *mp;
           for (mp=mmb; mp->next; mp = mp->next);
           mp->next = mmp;
        }
        else
           mmb = mmp;
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *PRE = pre;
   if (!(*DOUT))
   {
      *DOUT = DupString("dMake_amm");
      (*DOUT)[0] = pre;
   }
   return(mmb);
}

void GenMakefile(char pre, ATL_mmnode_t *mmb, char *outd)
{
   ATL_mmnode_t *mmp, *p;
   FILE *fp;
   char *comp, *cflags;
   char *ln;
   int i;
   char be[3] = {'1', 'n', '0'};
   char *bes[3] = {"1", "N1", "0"};
   char al[3] = {'1', 'n', 'X'};
   char dcomp[8] = {'$', '(', 'D', 'M', 'C', ')', '\0'};
   char dflags[12] = {'$', '(', 'D', 'M', 'C', 'F', 'L', 'A', 'G', 'S', 
                     ')', '\0'};
   char *styp = (pre == 'd') ? "-DDREAL" : "-DSREAL";

   ln = malloc((strlen(outd)+11)*sizeof(char));
   assert(ln);
   sprintf(ln, "%s/%cMake_amm", outd, pre);
   fp = fopen(ln, "w");
   assert(fp);
   fprintf(fp, "include ../Make.inc\n");
   fprintf(fp, "CDEFS2=$(CDEFS)\n\n");
/*
 * Spew out all filenames that must be compiled
 */
   fprintf(fp, "objs =");
/*
 * Copy2blk routines
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      const int mu=mmp->mu, nu=mmp->nu;
/*
 *    See if we've already made an entry for this unrolling
 */
      for (p=mmb; p != mmp && (p->mu != mu || p->nu != nu); p = p->next);
      if (p == mmp)  /* mu,nu not seen before */
      {
         int j;
         for (j=0; j < 3; j++)
         {
            fprintf(fp, " \\\n       ATL_%cablk2cmat_%dx%d_a%c_b1.o",
                    pre, mu, nu, al[j]);
            fprintf(fp, " ATL_%cablk2cmat_%dx%d_a%c_bX.o",
                    pre, mu, nu, al[j]);
            fprintf(fp, " \\\n       ATL_%cablk2cmat_%dx%d_a%c_b0.o",
                    pre, mu, nu, al[j]);
            fprintf(fp, " ATL_%cablk2cmat_%dx%d_a%c_bn.o",
                    pre, mu, nu, al[j]);
         }
      }
      for (i=(mu == nu); i < 2; i++)
      {
         const int u = (i) ? mu : nu;
         for (p=mmb; p != mmp && p->mu != u && p->nu != u; p = p->next);
         if (p == mmp)  /* u not seen before */
         {
            int j;
            for (j=0; j < 3; j++)
               fprintf(fp, 
               " \\\n       ATL_%crm2am_a%c_%d.o ATL_%ccm2am_a%c_%d.o",
                       pre, al[j], u, pre, al[j], u);
         }
      }
   }
/*
 * AMM kernel routines
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      int kb = mmp->kbB;
/*
 *    Kernels that take runtime K are only compiled once, so don't repeat them
 *    for every KB
 */
      if (FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
      {
         const int id = mmp->ID;
         for (p=mmb; p != mmp && p->ID != id; p = p->next);
         if (p != mmp)
            continue;
         kb = mmp->ku;
      }
/* 
 *    ATL_<pre>AMMM_<ID>_<kb/ku>_b<X>
 */
      for (i=0; i < 3; i++)
         fprintf(fp, " \\\n       ATL_%cAMMM_%d_%d_b%c.o", pre, mmp->ID, 
                 kb, be[i], mmp->rout);
   }
/*
 * library make targets
 */
   fprintf(fp, "\n\nlib : %clib.grd\nall : %clib.grd\n%clib : %clib.grd\n", 
           pre, pre, pre, pre);
   fprintf(fp, "%clib.grd : $(objs)\n", pre);
   fprintf(fp, "\t$(ARCHIVER) $(ARFLAGS) $(ATLASlib) $(objs)\n");
   fprintf(fp, "\t $(RANLIB) $(ATLASlib)\n");
   fprintf(fp, "\t touch %clib.grd\n", pre);

/*
 * Print out the individual rules for each needed copy function
 */
   dcomp[2] = dflags[2] = toupper(pre);
   dflags[3] = dcomp[3] = 'K';
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      const int mu=mmp->mu, nu = mmp->nu;
/*
 *    Print out 2-D ablk2Cmat targets
 */
      for (p=mmb; p != mmp && (p->mu != mu || p->nu != nu); p = p->next);
      if (p == mmp)  /* mu,nu not seen before */
      {
         char cbe[4] = {'0', '1', 'n', 'X'};
         int ibe[4] =  {0,    1,  -1,  2};
         int i, j;
         for (i=0; i < 4; i++)
         {
            for (j=0; j < 3; j++)
            {
               char rn[64];
               sprintf(rn, "ATL_%cablk2cmat_%dx%d_a%c_b%c",
                       pre, mu, nu, al[j], cbe[i]);
               fprintf(fp, "%s.o : %s.c\n", rn, rn);
               fprintf(fp, "\t%s %s $(CDEFS) %s -c %s.c\n", 
                       dcomp, dflags, styp, rn);
            }
         }
      }
      for (i=(mu == nu) ? 1:0; i < 2; i++)
      {
         const int u = (i) ? mu : nu;
/*
 *       See if we've already made a rule for this unrolling
 */
         for (p=mmb; p != mmp && p->mu != u && p->nu != u; p = p->next);
         if (p == mmp)  /* u not seen before */
         {
            int j;
            for (j=0; j < 3; j++)
            {
               fprintf(fp, "ATL_%crm2am_a%c_%d.o : ATL_%crm2am_a%c_%d.c\n",
                       pre, al[j], u, pre, al[j], u);
               fprintf(fp, "\t%s %s $(CDEFS) %s -c ATL_%crm2am_a%c_%d.c\n", 
                       dcomp, dflags, styp, pre, al[j], u, pre, al[j], u);
               fprintf(fp, "ATL_%ccm2am_a%c_%d.o : ATL_%ccm2am_a%c_%d.c\n",
                       pre, al[j], u, pre, al[j], u);
               fprintf(fp, "\t%s %s $(CDEFS) %s -c ATL_%ccm2am_a%c_%d.c\n", 
                       dcomp, dflags, styp, pre, al[j], u, pre, al[j], u);
            }
         }
      }
   }
/*
 * Print out the individual rules for each kernel compile
 */
   dflags[3] = dcomp[3] = 'M';
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
/*
 *    Kernels that take runtime K are only compiled once, so print rules on
 *    only the first encounter of that ID
 */
      if (FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
      {
         const int id = mmp->ID;
         for (p=mmb; p != mmp && p->ID != id; p = p->next);
         if (p != mmp)
            continue;
      }
      if (mmp->comp)
      {
         comp = (mmp->comp[0] == 'g' && mmp->comp[1] == 'c' && 
                 mmp->comp[2] == 'c' && 
                 (mmp->comp[3] == '\0' || mmp->comp[3] == ' ')) 
              ? "$(GOODGCC)" : mmp->comp;
         cflags = mmp->cflags;
      }
      else
      {
         comp = dcomp;
         cflags = dflags;
      }
/* 
 *    ATL_<pre>AMMM_<ID>_<kb/ku>_b<X>
 */
      for (i=0; i < 3; i++)
      {
         const int kb=FLAG_IS_SET(mmp->flag, MMF_KRUNTIME)?mmp->ku:mmp->kbB;
         fprintf(fp, "ATL_%cAMMM_%d_%d_b%c.o : %s\n", pre, mmp->ID, 
                 kb, be[i], mmp->rout);
         fprintf(fp, "\t%s $(CDEFS2) %s -DBETA%s=1", comp, styp, bes[i]);
         if (!FLAG_IS_SET(mmp->flag, MMF_KRUNTIME))
            fprintf(fp, " -DMB=%d -DNB=%d, -DKB=%d", 
                    mmp->mbB, mmp->nbB, mmp->kbB);
         fprintf(fp, " -DATL_USERMM=ATL_%cAMMM_%d_%d_b%c", pre, mmp->ID,
                 kb, be[i]);
         fprintf(fp, " %s -o ATL_%cAMMM_%d_%d_b%c.o -c %s\n", 
                 cflags, pre, mmp->ID, kb, be[i], mmp->rout);
      }
   }
   fclose(fp);
}

void GenUserFiles(char pre, ATL_mmnode_t *mmb, char *outd)
/*
 * Creates any files that can be copied from the AMMCASES directory
 */
{
   ATL_mmnode_t *mmp, *p;
   char *ln=NULL;
   int lnlen=0, dlen;
   char al[3] = {'1', 'n', 'X'};
   int ial[3] = {1,   -1,   2};

   dlen = strlen(outd);
/*
 * Extract every unique block-copy routine
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      int i;
      const int mu=mmp->mu, nu=mmp->nu;
      for (p=mmb; p != mmp && (p->mu != mu || p->nu != nu); p = p->next);
      if (p == mmp)  /* mu,nu not seen before */
      {
         char cbe[4] = {'0', '1', 'n', 'X'};
         int ibe[4] =  {0,    1,  -1,  2};
         int i, j;
         j = 64+8 + strlen(outd);
         j = (j > 128) ? j : 128;
         if (lnlen < j)
         {
            free(ln);
            lnlen = j;
            ln = malloc(j*sizeof(char));
            assert(ln);
         }
         for (i=0; i < 4; i++)
         {
            for (j=0; j < 3; j++)
            {
               char rn[64];
               int ierr;
               sprintf(rn, "ATL_%cablk2cmat_%dx%d_a%c_b%c.c",
                       pre, mu, nu, al[j], cbe[i]);
               sprintf(ln, 
                  "make %s pre=%c mu=%d nu=%d al=%c be=%c alpha=%d beta=%d", 
                       rn, pre, mu, nu, al[j], cbe[i], ial[j], ibe[i]);
               ierr = system(ln);
               if (ierr)
               {
                  fprintf(stderr, "FAILED CMND='%s'\n", ln);
                  exit(ierr);
               }
               sprintf(ln, "mv %s %s/.", rn, outd);
               ierr = system(ln);
               if (ierr)
               {
                  fprintf(stderr, "FAILED CMND='%s'\n", ln);
                  exit(ierr);
               }
            }
         }
      }
      for (i=0; i < 2; i++)
      {
         const int u = (i) ? mu : nu;
/*
 *       See if we've extracted for this unrolling
 */
         for (p=mmb; p != mmp && p->mu != u && p->nu != u; p = p->next);
         if (p == mmp)  /* u not seen before */
         {
            int j;
            j = 16 * 40 + (strlen(outd)<<1);
            j = (j > 90) ? j : 90;
            if (lnlen < j)
            {
               free(ln);
               lnlen = j;
               ln = malloc(j*sizeof(char));
               assert(ln);
            }
            for (j=0; j < 3; j++)
            {
               int ierr;
               sprintf(ln, 
"make ATL_%crm2am_a%c_%d.c ATL_%ccm2am_a%c_%d.c pre=%c UR=%d alpha=%d al=%c",
                       pre, al[j], u, pre, al[j], u, pre, u, ial[j], al[j]);
               ierr = system(ln);
               if (ierr)
               {
                  fprintf(stderr, "FAILED CMND='%s'\n", ln);
                  exit(ierr);
               }
               sprintf(ln, 
                  "mv ATL_%crm2am_a%c_%d.c %s/. ;mv ATL_%ccm2am_a%c_%d.c %s/.",
                       pre, al[j], u, outd, pre, al[j], u, outd);
               ierr = system(ln);
               if (ierr)
               {
                  fprintf(stderr, "FAILED CMND='%s'\n", ln);
                  exit(ierr);
               }
            }
         }
      }
   }
   
/*
 * Copy every unique user-supplied file, but only once
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      const int id=mmp->ID;
      assert(id > 0);   /* will need to extend to handle generation! */
/*
 *    File must still be physically copied
 */
      for (p=mmb; p != mmp && p->ID != id; p = p->next);
      if (p == mmp)
      {
         int i, ierr;
         i = strlen(mmp->rout) + dlen + 16;
         if (i > lnlen)
         {
            if (ln)
               free(ln);
            ln = malloc(i*sizeof(char));
            assert(ln);
         }
         sprintf(ln, "cp AMMCASES/%s %s/.", mmp->rout, outd);
         ierr = system(ln);
         if (ierr)
         {
            fprintf(stderr, "FAILED CMND='%s'\n", ln);
            exit(ierr);
         }
      }
   }
   if (ln)
      free(ln);
}
void GenHeaderFiles(char pre, ATL_mmnode_t *mmb, char *outd)
{
}
void GenAllFiles(char pre, ATL_mmnode_t *mmb, char *outd)
{
   GenUserFiles(pre, mmb, outd);
   GenMakefile(pre, mmb, outd);
   GenHeaderFiles(pre, mmb, outd);
}

int main(int nargs, char **args)
{
   char pre='d';
   int verb=1;
   int *nbs;
   char *outd;
   ATL_mmnode_t *mmb, *mmp;

   mmb = GetFlags(nargs, args, &pre, &outd);
   assert(mmb);
   GenAllFiles(pre, mmb, outd);
   KillAllMMNodes(mmb);
   exit(0);
}
@ROUT ammusearch ammgsearch
@extract -b @(topd)/cw.inc lang=C -def cwdate 2012
#include "atlas_misc.h"
#define ATL_JKMDEF 1
#include "atlas_mmtesttime.h"

@extract -b @(basd)/atlas.base rout=Mylcm

ATL_mmnode_t *BestForThisNB
(
   int verb, 
   char pre, 
   ATL_mmnode_t *mmb, 
   int nb, 
   int FORCE
)
/*
 * Times all kernels in mmb
 * RETURNS: ptr to best performing kernel, NULL if no kernel worked
 */
{
   ATL_mmnode_t *mmp, *mmB=NULL;
   double mf, mfB=0.0;

   printf("SCOPING FOR BEST PERFORMING KERNEL FOR NB=%d\n", nb);
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      int kb;
/*
 *    Choose kb, if forced only kb will do, so skip if kernel can't do it
 */
      if (FORCE || nb <= 16)
         kb = nb;
/*
 *    If this kernel can't do the exact block factor, allow leeway
 */
      else
      {
         int u;
         u = Mylcm(mmp->mu, mmp->nu);
         u = Mylcm(u, mmp->ku);
         kb = (nb/u)*u;
         if (kb != nb)
         {
            int kbB;
            kbB = ((nb+u-1)/u)*u;
            if (!kb || kbB-nb < nb-kb && kbB <= 4)
               kb = kbB;
         }
      }
      if ((mmp->kbmin && kb < mmp->kbmin) ||
          (mmp->kbmax && kb > mmp->kbmax) ||
          ((kb/mmp->mu)*mmp->mu != kb) || ((kb/mmp->nu)*mmp->nu != kb) ||
          ((kb/mmp->ku)*mmp->ku != kb))
      {
         
         printf("   %d. %s: SKIPPED, bad NB\n", mmp->ID, mmp->rout);
         continue;
      }
      mf = TimeMMKernel(verb, 0, mmp, pre, kb, kb, kb, kb, kb, kb, 1, 0, -1);
      if (mf > mfB)
      {
         mfB = mf;
         mmB = mmp;
         mmB->mbB = mmB->nbB = mmB->kbB = kb;
      }
      printf("   %d. %s: kb=%d, MFLOP=%.2f\n", mmp->ID, mmp->rout, kb, mf);
   }
   if (!mmB)
   {
      printf("NO KERNEL POSSIBLE FOR NB=%d\n", nb);
      mmB = GetMMNode();
   }
   else
   {
      int i, kb = mmB->kbB;
      i = MMKernelFailsTest(pre, kb, kb, kb, 0, mmB);
      if (!i)
         i = MMKernelFailsTest(pre, kb, kb, kb, 1, mmB);
      if (!i)
         i = MMKernelFailsTest(pre, kb, kb, kb, -1, mmB);
      if (i)
      {
         printf("BEST KERNEL FAILS TESTER FOR NB=%d\n", kb);
         exit(i);
      }
      printf("BEST KERNEL FOUND FOR NB=%d: ID#%d '%s' %.2f MFLOPS\n\n", 
             nb, mmB->ID, mmB->rout, mfB);
      mmB = CloneMMNode(mmB);
      mmB->mflop[0] = mfB;
      mmB->next = NULL;
   }
   return(mmB);
}

int DeleteBadBigNBs(ATL_mmnode_t *mmb, int *nbs)
{
   ATL_mmnode_t *best=NULL, *mmp;
   double mfB=0.0;
   int n=0;
/*
 * Find the best-performing kernel
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      double mf;
      mf = mmp->mflop[0];
      if (mf > mfB)
      {
         mfB = mf;
         best = mmp;
      }
   }
/*
 * Delete all NBs larger than best
 */
   while (best->next)
   {
      best->next = KillMMNode(best->next);
      n++;
   }
   if (n)
   {
      int N = *nbs;
      N = (N >= 0) ? N : -N;
      printf("Deleted %d large, slow kernels starting at NB=%d\n", 
             n, nbs[N-n+1]);
   }
   return(n);
}
ATL_mmnode_t *FindBestForEachNB(int verb, char pre, ATL_mmnode_t *mmb, int *nbs)
{
   int i, n, FORCE;
   ATL_mmnode_t *best, *bp;
/*
 * If # of nbs is negative, then each nb is required and that exact size
 * will be used, or no NB of that size if no kernel works.  The normal behavior
 * is the exact size of forced for all nb <= 16, and inexact for larger
 */
   n = nbs[0];
   if (n < 0)  /* negative # of nbs says force exact NB or nothing */
   {
      n = -n;
      FORCE = 1;
   }
   bp = best = BestForThisNB(verb, pre, mmb, nbs[1], FORCE);
   for (i=2; i <= n; i++)
   {
      bp->next = BestForThisNB(verb, pre, mmb, nbs[i], FORCE);
      bp = bp->next;
   }
   i = DeleteBadBigNBs(best, nbs);
   return(best);
}

void PrintUsage(char *name, int ierr, char *flag)
@ROUT ammusearch ammgsearch
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr, 
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -o <outfile>: output file (res/<pre>uAMMRES.sum)\n");
   fprintf(stderr, "   -n # nb1 ... nb# : NBs to try for\n");
   fprintf(stderr, "   -N # nb1 ... nb# : force exact NBs in search\n");
@ROUT ammgsearch
   fprintf(stderr, "   -r <nreg> : set max # of registers to try\n");
   fprintf(stderr, "   -b <nb>   : set initial block factor to try\n");
@ROUT ammusearch ammgsearch
   exit(ierr ? ierr : -1);
}

@ROUT ammgsearch
int *GetFlags(int nargs, char **args, char *PRE, char **FNOUT, 
              int *NREG, int *NB)
@ROUT ammusearch
int *GetFlags(int nargs, char **args, char *PRE, char **FNOUT)
@ROUT ammusearch ammgsearch
{
   int i, j=0, n, k;
   char pre='d';
   int *nbs=NULL;
   *FNOUT = NULL;
@ROUT ammgsearch
   *NB = 0;
   #ifdef ATL_GAS_x8664
      *NREG = 16;
   #elif defined(aTL_GAS_x8632)
      *NREG = 8;
   #else
      *NREG = 32;
   #endif
@ROUT ammusearch ammgsearch
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);
      
      switch(args[i][1])
      {
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      case 'o':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        *FNOUT = DupString(args[i]);
        break;
      case 'n':
         j = 1;
      case 'N':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         n = atoi(args[i]);
         nbs = malloc((n+1)*sizeof(int));
         assert(nbs);
         nbs[0] = (j) ? n : -n;
         for (k=1; k <= n; k++)
         {
           if (++i >= nargs)
               PrintUsage(args[0], i-1, NULL);
            nbs[k] = atoi(args[i]);
         }
         break;
@ROUT ammgsearch
      case 'r':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *NREG = atoi(args[i]);
         break;
      case 'b':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
         *NB = atoi(args[i]);
         break;
   fprintf(stderr, "   -b <nb>   : set initial block factor to try\n");
@ROUT ammusearch ammgsearch
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *PRE = pre;
@ROUT ammgsearch
   if (*NB == 0)
      *NB = (pre == 'd') ? 36 : 48;
@ROUT ammusearch ammgsearch
   if (!(*FNOUT))
   {
      *FNOUT = DupString("res/duAMMRES.sum");
      (*FNOUT)[4] = pre;
   }
   if (!nbs)
   {
      nbs = malloc(18*sizeof(int));
      assert(nbs);
      nbs[0] = 16; nbs[1] = 4; nbs[2] = 6; nbs[3] = 8; 
      nbs[4] = 12; nbs[5] = 16; nbs[6] = 18; nbs[7] = 24;
      nbs[8] = 32; nbs[9] = 48; nbs[10] = 56; nbs[11] = 60;
      nbs[12] = 72; nbs[13] = 80; nbs[14] = 120; nbs[15] = 180;
      nbs[16] = 240; nbs[17] = 480;
   }
   return(nbs);
}

@ROUT ammgsearch
char *GenString(char *vec, int lat, int mu, int nu, int ku)
{
   char *frm=make gen_amm_%s lat=%d mu=%d nu=%d ku=%d", *ln;
   int l;
   l = strlen(frm) + strlen(vec) + 5;
   ln = malloc(l*sizeof(char));
   assert(ln);
   sprintf(ln, frm, vec, lat, mu, nu, ku);
   return(ln);
}

ATL_mmnode_t GetNewGenNode(char *vec, int lat, int mu, int nu, int ku)
{
   ATL_mmnode_t *np;
   np = GetMMnode();
   np->mu = mu;
   np->nu = nu;
   np->ku = ku;
   np->muladd = (lat != 0);
   np->lat = lat;
   np->genstr = GenString(vec, lat, mu, nu, ku);
   return(np);
}
ATL_mmnode_t *FindDefMUNU(int verb, char *vec, char pre, int nreg, int nb, 
                          int ku);
{
   ATL_mmnode_t *mmp;
   double mf, mfB=0.0;
/*
 * Try all near-square cases
 */
   mmp = GetMMNode();
   mmp->ku = ku;
   np->muladd = (lat != 0);
   mmp->lat = lat;
   for (n=4; n < nreg; n++)
   {
      for (j=1; j*j < n; j++);
      i = n / j;
      if (mmp->genstr)
        free(mmp->genstr);
      mmp->genstr = GenString(vec, lat, i, j, ku);
      mf = TimeMMKernel(verb, 0, mmp, pre, kb, kb, kb, kb, kb, kb, 1, 0, -1);
   }
}
int main(int nargs, char **args)
{
   char pre='d';
   int verb=1, nb, nreg, mu, nu;
   int *nbs;
   char *fnout;
   ATL_mmnode_t *mmb, *mmp;

   nbs = GetFlags(nargs, args, &pre, &fnout, &nreg, &nb);
   FindDefMUNU(pre, nreg, nb, &mu, &nu);
   if (verb)
   {
      int i;
      const int n = nbs[0]+1;
      printf("NBs = %3d", nbs[1]);
      for (i=2; i < n; i++)
         printf(", %3d", nbs[i]);
      printf("\n");
   }
   return(0);
}
@ROUT ammusearch
int main(int nargs, char **args)
{
   char pre='d';
   int verb=1;
   int *nbs;
   char *fnout;
   ATL_mmnode_t *mmb, *mmp;

   nbs = GetFlags(nargs, args, &pre, &fnout);
   if (verb)
   {
      int i;
      const int n = nbs[0]+1;
      printf("NBs = %3d", nbs[1]);
      for (i=2; i < n; i++)
         printf(", %3d", nbs[i]);
      printf("\n");
   }
   mmb = ReadMMFileWithPath(pre, "AMMCASES", "amcases.idx");
   assert(mmb);
/*
 * Eliminate those kernels that can't work for any block size
 */
   for (mmp=mmb; mmp; mmp = mmp->next)
   {
      if (FLAG_IS_SET(mmp->flag, MMF_KUISKB))
         mmp->mbB = mmp->nbB = mmp->kbB = mmp->ku;
      else
      {
         int m = Mylcm(mmp->mu, mmp->nu);
         m = (60/m)*m;
         if (mmp->kbmin)
            m = Mmax(m, mmp->kbmin);
         if (mmp->kbmax)
            m = Mmin(m, mmp->kbmax);
         mmp->mbB = mmp->nbB = mmp->kbB = m;
      }
   }
   mmb = DelBadMMKernels(pre, verb, mmb);
   assert(mmb);
#if 0
   if (verb)
   {
      printf("\nSURVIVING KERNELS:\n");
      PrintMMNodes(stdout, mmb);
   }
#endif
   mmp = FindBestForEachNB(verb, pre, mmb, nbs);
   KillAllMMNodes(mmb);
   free(nbs);
   WriteMMFile(fnout, mmp);
   exit(0);
}
@ROUT ATL_ammmABC
#include "atlas_misc.h"
/*
 * This routine loops over calls to the access-major matmul kernel given
 * in the arguments, using the NMK loop pattern, using the given blocking
 * parameters.  
 * alpha & beta are both applied by ablk2cmat.
 * It allocates an K*NB workspace for B, and an Mc*K workspace for A,
 * and a NB*NB workspace for C.
 */

typedef void (*mat2am_t)
   (ATL_CINT, ATL_CINT, const SCALAR, const TYPE*, ATL_CINT, TYPE*);
typedef void (*ablk2cmat_t)
   (ATL_CINT M, ATL_CINT N, const SCALAR al, const TYPE*A, 
    const SCALAR beta, TYPE*C, ATL_CINT ldc);
typedef void (*ammm_t)
   (ATL_CINT M, ATL_CINT N, ATL_CINT K, TYPE *A, TYPE *B, TYPE *C);
int Mjoin(PATL,ammmABC)
(
   enum ATLAS_TRANS TA,
   enum ATLAS_TRANS TB,
   ATL_CINT M,
   ATL_CINT N,
   ATL_CINT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CINT lda,
   const TYPE *B,
   ATL_CINT ldb,
   const SCALAR beta,
   const TYPE *C,
   ATL_CINT ldc,
   ATL_CINT MB,                 /* chosen M blocking for this problem */
   ATL_CINT NB,                 /* chosen N blocking for this problem */
   ATL_CINT KB,                 /* chosen K blocking for this problem */
   ATL_CINT mu,                 /* M unrolling used by kernels */
   ATL_CINT nu,                 /* N unrolling used by kernels */
   ATL_CINT ku,                 /* K unrolling used by non-cleanup kernels */
   ammm_t ammmk_b0,             /* amm beta=0 kernel to use */
   ammm_t ammmk_b1,             /* amm beta=1 kernel to use */
   ammm_t ammmk_ku1,            /* amm beta=1 for K-cleanup */
   mat2am_t A2am,               /* routine to translate A into access-major */
   mat2am_t B2am,               /* routine to translate B into access-major */
   ablk2cmat_t ablk2cmat,       /* put ammmk's C back to user's C */
)
{
   ATL_CINT Mf = (M/mu)*mu, mr = M-Mf, Nf = (N/nu)*nu, nr = N-Nf;
   ATL_CINT Kf = (K/ku)*ku, kr = K-Kf;
   ATL_CINT Mc = (mr) ? Mf + mr : Mf;  /* compute CEIL from FLOOR */
   ATL_CINT Nc = (nr) ? Nf + nr : Nf;
   ATL_CINT Kc = (kr) ? Kf + kr : Kf;
   ATL_CINT incBn = (TB == AtlasNoTrans) ldb*NB-Kf : NB-Kf*ldb;
   ATL_CINT incAm = (TA == AtlasNoTrans) ? MB - Kf*ldb : MB*ldb - Kf;
   ATL_INT i, j, k;
   void *vp;
   TYPE *pA, *pB, *c;
   int COPYA=1;

   if (K <= KB) 
      return(1);   /* don't handle rank-K update with this routine */
   vp = malloc(3*ATL_Cacchelen + sizeof(TYPE)*(Mc*K+K*NB+NB*NB));
   if (!vp)
      return(2);
   pB = ATL_AlignPtr(vp);
   pA = pB + K*NB;
   pA = ATL_AlignPtr(pA);
   c = pA + Mc*K;
   c = ATL_AlignPtr(c);

   for (j=0; j != Nc; j += NB)
   {
      ATL_CINT n = Mmin(NB, Nc-j), incb = n*nu*KB, n0 = Mmin(NB, N-j);
      int COPYB=1;
      TYPE *b = pB, *a = pA;

      for (i=0; i != Mc; i += MB)
      {
         ATL_CINT m = Mmin(MB, Mc-i), inca = m*mu*KB, m0 = Mmin(NB,M-j);

/* 
 *       Handle first block, known to always have a full KB, using _b0
 *       case to initialize workspace c
 */
         if (COPYA)
            A2am(m, KB, ATL_rone, A, lda, a);
         if (COPYB)
            B2am(KB, n, ATL_rone, B, ldb, b);
         ammmk_b0(m, n, KB, a, b, c);
         a += inca; b += incb;
/*
 *       Loop over all remaining blocks that can use ammmk_b1
 */
         for (k=KB; k < Kf; k += KB, a += inca, b += incb)
         {
            ATL_CINT kk = Mmin(KB, Kf-i);
/*
 *          If necessary, copy both A & B blocks to access-major format
 */
            if (COPYA)
            {
               A2am(m, kk, ATL_rone, A, lda, a);
               A += (TA == AtlasNoTrans) ? kk*lda : kk;
            }
            if (COPYB)
            {
               B2am(kk, n, ATL_rone, B, ldb, b);
               B += (TB == AtlasNoTrans) ? kk : kk*ldb;
            }
            ammmk_b1(m, n, kk, a, b, c);
         }
/*
 *       Handle K cleanup using the provided kernel
 */
         if (kr)
         {
            if (COPYA)
               A2am(m, kr, ATL_rone, A, lda, a);
            if (COPYB)
               B2am(kr, n, ATL_rone, B, ldb, b);
            ammmk_ku1(m, n, kr, a, b, c);
            a += kr*m;
         }
         A += incAm;
/*
 *       Write answer back out to user's C 
 */
         ablk2cmat(m0, n0, alpha, c, beta, C, ldc);
         C += m0;
         COPYB = 0;
         b = pB;
      }
      B += incBn;
      COPYA = 0;
   }
   free(vp);
   return(0);
}
