@ROUT atlas_cbc.h
#ifndef ATLAS_CBC_H
#define ATLAS_CBC_H
#include "atlas_misc.h"
/*
 ******************************************************************************
 * This file prototypes cache-based communication (CBC) routines.  CBC
 * exploits cache coherence protocols for synchronization and communication
 * that runs at the speed of hardware, rather than the speed of software
 * that you potentially get when calling OS-provided functions like mutex, etc.
 * CBC requires strongly-ordred cache coherence to work correctly.  In
 * a strongly ordered cache, if a given core writes memory two memory
 * locations A and B in that sequence, the coherence protocal guarantees
 * that other cores only "see" the change in B *after* they can "see"
 * the change in A.  In weakly ordered caches, the core may "see" the
 * changes in any order (so seeing B change does not guarantee you won't
 * get a stale value if you then read A).  In general, x86 architectures
 * have strongly ordered caches, while non-x86 (eg., ARM and PowerPC) have
 * weakly-ordered caches.  Therefore, most CBC routines should not be used
 * on non-x86 platforms unless they are combined with memory fences of some
 * sort.  On x86 at least, CBC is critical to driving down communication costs
 * on extreme parallel architectures like the Xeon PHI.
 * For weakly-ordered systems, we must use a memory barrier in order to
 * force the fact that we've seen A change to imply that we can see the change
 * to B.  So, on weakly-ordered cache systems where we support CBC (eg. ARM64),
 * we will defined the macro ATL_membarrier to call a system-specific
 * memory barrier.  On Strongly-ordered caches, ATL_membarrier will be empty.
 * NOTE: for correctness, mutexes must be doing memory barriers on weakly-
 * ordered systems, so all CBC routines that are required for correct
 * operation must provide a mutex (very slow) version  that will work
 * for unknown systems.
 ******************************************************************************
 */
/*
 * All known x86 use strongly-ordered caches, so CBC is safe.  
 * There are some instructions on the PHI that seem to violate strong ordering,
 * but ATLAS does not presently use them.  If these inst become important,
 * we may need to define a barrier
 */
#if defined(ATL_GAS_x8664) || defined(ATL_GAS_x8632)
   #define ATL_CBC_HANDLED 1
   #define ATL_USE_CBC 1
   #define ATL_membarrier
/*
 * ARM64 has weakly-ordered cache, so CBC must use explicit membarrier to work.
 * This memory barrier code provided by David Nuechterlein, who has gotten
 * CBC-based codes to work based on it.
 */
#elif defined ATL_ARCH_ARM64
   #if __GNUC__
      #define ATL_CBC_HANDLED 1
      #define ATL_USE_CBC 1
      #define ATL_membarrier __asm__ __volatile__ ("dmb sy" : : : "memory")
   #endif
/*
 * CBC came about after Itanium was essentially dead, so it has never been
 * tested there, so don't enable it.  We have this code here in case Itanium
 * becomes important enough to test.
 */
#elif defined(ATL_ARCH_IA64Itan) || defined(ATL_ARCH_IA64Itan2)
   #ifdef __GNUC__
      #define ATL_membarrier __asm__ __volatile__ ("mf")
   #endif
/*
 * On PowerPC and POWER I've never succeeded in getting any memory barrier
 * to work correctly.  IBM docs I've seen essentially say "here's how it should
 * work, but it doesn't, and we aren't going to tell you how it does work".
 * So, this code is just as a starting point if we find some docs or want
 * to do some experimentation later.
 */
#elif defined(ATL_ARCH_PPCG4) || defined(ATL_ARCH_PPCG5)
   #ifdef __GNUC__
      #define ATL_membarrier __asm__ __volatile__ ("sync")
   #endif
#elif defined(ATL_ARCH_POWER3) || defined(ATL_ARCH_POWER4) || \
      defined(ATL_ARCH_POWER5) || defined(ATL_ARCH_POWER6) || \
      defined(ATL_ARCH_POWER7)
   #ifdef __GNUC__
      #define ATL_membarrier __asm__ __volatile__ ("dcs")
   #endif
#endif
#ifdef ATL_CBC_HANDLED
   #undef ATL_CBC_HANDLED
#else
   #ifdef ATL_USE_CBC
      #undef ATL_USE_CBC
   #endif
   #ifdef ATL_membarrier
      #undef ATL_membarrier
   #endif
   #define ATL_membarrier
#endif
@multidef pre d      s     i
@whiledef typ double float int
   @whiledef cmb min max sum
@(typ) ATL_@(pre)comb_@(cmb)(ATL_CUINT P, ATL_CUINT IAM, @(typ) val, void*);
   @endwhile

   @undef pre
@endwhile
@multidef pre z      c
@whiledef typ double float
   @whiledef cmb min max sum
void ATL_@(pre)comb_@(cmb)(ATL_CUINT P, ATL_CUINT IAM, @(typ) *val, void*);
   @endwhile
   @undef pre
@endwhile

@multidef pre      z     c      d    s
@whiledef typ double float double float
int ATL_@(pre)comb_iamax(ATL_CUINT P, ATL_CUINT iam, int idx, 
                    @(typ) *val, void *vchk);
int ATL_@(pre)comb_iamax_nopost0(ATL_CUINT P, ATL_CUINT iam, int *idx, 
                            @(typ) *val, void *vchk);
   @undef pre
@endwhile

char ATL_cbc_post(ATL_CUINT rank, void *vchk);
void ATL_cbc_wait(ATL_CUINT hisrank, const char val, void *vchk);
#endif /* end ifndef ATL_CBC_H */
@ROUT ATL_barrier
#include "atlas_threads.h"
#include "atlas_cbc.h"
#include "atlas_misc.h"
/*
 * Use cache-based communication to perform a barrier for P threads.
 * This code works on any system with coherent caches (weakly-ordered OK).
 * For weakly-ordered caches, if this barrier is protecting memory, it
 * should be followed by a memory fence to avoid OOE advancing loads.
 */
void ATL_barrier
(
   ATL_CUINT P,     /* # of threads to barrier */
   ATL_CUINT iam,   /* rank of calling thread in barrier */
   void *vchk
)
{
   volatile char *bchk = (vchk) ? (volatile char*)vchk : ATL_TP_PTR->bchkin;
   ATL_CUINT II = iam<<ATL_chksh;
   const char newv = !bchk[II];

   if (iam)
   {
      bchk[II] = newv;
      while (*bchk != newv);
   }
   else
   {
      int i;
      for (i=1; i < P; i++)
      {
         ATL_CUINT d = i<<ATL_chksh;
         while (bchk[d] != newv);
      }
      *bchk = newv;
   }
}
@ROUT ATL_comb1 ATL_comb_iamax ATL_comb_iamax_nopost0
#include "atlas_threads.h"
#include "atlas_misc.h"
@ROUT ATL_comb1
#if defined(TCPLX) && (defined(COMBMIN) || defined(COMBMAX))
   #include <math.h>  /* for fabs */
#endif
@ROUT ATL_comb_iamax ATL_comb_iamax_nopost0
#include <math.h>  /* for fabs */
@ROUT ATL_comb1 ATL_comb_iamax ATL_comb_iamax_nopost0
/*
 * Use cache-based comm to perform a scalar combine for P threads.
 * This code works on any system with coherent caches (weakly-ordered OK)
 * because the data and boolean sync variables are on the same cache line.
 * We guarantee this by separating each region by ATL_chkgap, which should
 * always be >= cache line size (default value 128).  Then, as long as
 * we can fit all data being combined into the same cache line, coherence
 * will guarantee we have the sync boolean and the data regardless of
 * weakly- or strongly-ordered caches.  At least on the ARM, however,
 * we must memory barrier to prevent OOE from advancing loads above the
 * sync.
 */
@ROUT ATL_comb1
#if defined(COMBMIN)
   #define COMB Mjoin(PATL,comb_min)
   #define combvals(v1_, v2_) ((v1_) <= (v2_)) ? (v1_) : (v2_)
#elif defined(COMBMAX)
   #define COMB Mjoin(PATL,comb_max)
   #define combvals(v1_, v2_) ((v1_) >= (v2_)) ? (v1_) : (v2_)
#elif defined(COMBSUM)
   #define COMB Mjoin(PATL,comb_sum)
   #define combvals(v1_, v2_) (v1_) + (v2_)
#else
   #error "Unknown combine!"
#endif
#ifdef TCPLX
   void COMB
   (
      ATL_CUINT P,     /* # of threads in combine */
      ATL_CUINT iam,   /* rank of calling thread in combine */
      TYPE *val,       /* local min */
      void *vchk
   )
#else
   TYPE COMB
   (
      ATL_CUINT P,     /* # of threads in combine */
      ATL_CUINT iam,   /* rank of calling thread in combine */
      TYPE val,        /* local min */
      void *vchk
   )
#endif
@ROUT ATL_comb1
{
   volatile char *bchk = vchk ? (volatile char*) vchk : ATL_TP_PTR->bchkin;
   volatile char *mybool = bchk + (iam<<ATL_chksh);
   volatile TYPE *myval = (volatile TYPE*)(mybool + ATL_sizeof);
   const char newv = !(*mybool);

   if (iam)
   {
      volatile TYPE *ans = (volatile TYPE*) (bchk + ATL_sizeof);
      #ifdef TCPLX
         *myval = *val;
         myval[1] = val[1];
      #else
         *myval = val;
      #endif
      *mybool = newv;
      while (*bchk != newv);
      #ifdef TCPLX
         *val = *ans;
         val[1] = ans[1];
      #else
         val = *ans;
      #endif
   }
   else
   {
      int i;
      #if defined(TCPLX) && !defined(COMBSUM)
         TYPE mv = fabs(*val) + fabs(val[1]);
      #endif
      for (i=1; i < P; i++)
      {
         ATL_CUINT d = i<<ATL_chksh;
         volatile TYPE *hisval = (volatile TYPE*)(bchk+d+ATL_sizeof);
         TYPE hv;

         while (bchk[d] != newv);  /* wait for his answer to appear */
         #ifdef TCPLX
            #if defined(COMBSUM)
               *val += *hisval;
               val[1] += hisval[1];
            #else
               hv = fabs(*hisval) + fabs(hisval[1]);
               #if defined(COMBMAX)
               if (hv > mv)
               #else /* COMBMIN */
               if (hv < mv)
               #endif
               {
                  mv = hv;
                  *val = *hisval;
                  val[1] = hisval[1];
               }
            #endif
         #else
            hv = *hisval;
            val = combvals(val, hv);
         #endif
      }
      #ifdef TCPLX
         *myval = *val;      /* provide global answer for real */
         myval[1] = val[1];  /* and for imaginary */
      #else
         *myval = val;       /* provide global answer */
      #endif
      *bchk = newv;          /* signal answer is ready */
   }
   #ifndef TCPLX
      return(val);
   #endif
}
@ROUT ATL_comb_iamax_nopost0
/*
 * This routine is used in LU, and it is different from comb_iamax in that
 * rank==0 does post its "we're done" to its sync array before exiting.
 * This means all threads except 0 remain blocked in this routine while 0
 * exits it with the global answer.  In this way we can keep other cores
 * waiting until after core 0 performs pivoting, which avoids doubling the
 * number of syncs required for unblkd LU.
 *
 * It is also different in that we return the global index using a pointer,
 * and the function return is the value to post to the sync array
 */
int Mjoin(PATL,comb_iamax_nopost0)  /* RETURNS: global sync post value */
(
   ATL_CUINT P,     /* # of threads in combine */
   ATL_CUINT iam,   /* rank of calling thread in combine */
   int *IDX,        /* INPUT: local index, OUTPUT: global idx */
   TYPE *val,       /* INPUT: local max, OUTPUT: global max */
   void *vchk
)
@ROUT ATL_comb_iamax
int Mjoin(PATL,comb_iamax)  /* RETURNS: global index */
(
   ATL_CUINT P,     /* # of threads in combine */
   ATL_CUINT iam,   /* rank of calling thread in combine */
   int idx,         /* index of max val */
   TYPE *val,       /* INPUT: local max, OUTPUT: global max */
   void *vchk
)
@ROUT ATL_comb_iamax ATL_comb_iamax_nopost0
{
   volatile char *bchk = vchk ? (volatile char*) vchk : ATL_TP_PTR->bchkin;
   volatile char *mybool = bchk + (iam<<ATL_chksh);
   const int mysize = Mmax(ATL_isize, ATL_sizeof);
   volatile TYPE *myval = (volatile TYPE*)(mybool + mysize);
   volatile int *myidx = (volatile int*)(mybool + mysize + (mysize SHIFT));
   const char newv = !(*mybool);
@ROUT ATL_comb_iamax_nopost0 `   int idx = *IDX;`

   if (iam)
   {
      volatile TYPE *ans = (volatile TYPE*) (bchk + mysize);
      volatile int *hisidx = (volatile int*) (bchk + mysize + (mysize SHIFT));
      *myidx = idx;
      #ifdef TCPLX
         myval[1] = val[1];
      #endif
      *myval = *val;
      *mybool = newv;
      while (*bchk != newv);
      *val = *ans;
      #ifdef TCPLX
         val[1] = ans[1];
      #endif
      idx = *hisidx;
   }
   else
   {
      int i;
      #if defined(TCPLX)
         TYPE mv = fabs(*val) + fabs(val[1]);
      #else
         TYPE mv = fabs(*val);
      #endif
      for (i=1; i < P; i++)
      {
         ATL_CUINT d = i<<ATL_chksh;
         volatile TYPE *hisval = (volatile TYPE*)(bchk+d+mysize);
         volatile int *hisidx = (volatile int*) (bchk+d+mysize+(mysize SHIFT));
         TYPE hv;
         int hidx;

         while (bchk[d] != newv);  /* wait for his answer to appear */
         hv = fabs(*hisval);
         hidx = *hisidx;
         #ifdef TCPLX
            hv += fabs(hisval[1]);
         #endif
         if (hv > mv || (hv == mv && hidx < idx))
         {
            idx = hidx;
            mv = hv;
            *val = *hisval;
            #ifdef TCPLX
               val[1] = hisval[1];
            #endif
         }
      }
      *myidx = idx;          /* provide global answer for index */
      *myval = *val;         /* and real value */
      #ifdef TCPLX
         myval[1] = val[1];  /* and for imaginary value */
      #endif
@ROUT ATL_comb_iamax
      *bchk = newv;          /* signal answer is ready */
   }
   return(idx);
@ROUT ATL_comb_iamax_nopost0
   }
   *IDX = idx;
   return(newv);
@ROUT ATL_comb_iamax ATL_comb_iamax_nopost0
}
@ROUT ATL_cbc_post
#include "atlas_cbc.h"
#include "atlas_threads.h"
/*
 * Used to post done to boolean sync array, by reversing present condition.
 * should only be called by the thread given by rank.
 * RETURNS: new value of post variable
 */
char ATL_cbc_post(ATL_CUINT rank, void *vchk)
{
   volatile char *bchk = (vchk) ? (volatile char*)vchk : ATL_TP_PTR->bchkin;
   ATL_CUINT II = rank<<ATL_chksh;
   const char newv = !bchk[II];
   bchk[II] = newv;
   return(newv);
}
@ROUT ATL_cbc_wait
#include "atlas_cbc.h"
#include "atlas_threads.h"
void ATL_cbc_wait
(
   ATL_CUINT hisrank,  /* rank to wait on */
   const char val,     /* value he will write to signal end of wait */
   void *vchk          /* optional boolean sync array */
)
{
   volatile char *bchk = (vchk) ? (volatile char*)vchk : ATL_TP_PTR->bchkin;
   ATL_CUINT ih = hisrank<<ATL_chksh;
   while (bchk[ih] != val);
}
