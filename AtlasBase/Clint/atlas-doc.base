@ROUT AtlasCredits.txt
********************************* ATLAS TEAM **********************************
ATLAS was originally developed at the Innovative Computing Laboratory (ICL),
at the University of Tennessee, though no team members remain there now.
ATLAS is presently developed and maintained by R. Clint Whaley at the
University of Texas at San Antonio.  The original ATLAS team was:

                                Antoine Petitet
                              petitet@cs.utk.edu
       ** Recursive Level 3 BLAS
       ** Codeveloped Level 2 gemv- & ger-based BLAS
       ** Codeveloped ATLAS level 2 blas tester
       ** Reference BLAS
       ** BLAS F77 interface
       ** Developed original pthreads implementation
       ** Level 2 packed and banded gemv- and ger-based BLAS
       ** Level 1 BLAS tester/timer

                                R. Clint Whaley
                              whaley@cs.utsa.edu
       ** General ATLAS design
       ** config, install & tuning routines
       ** Matrix multiply
       ** Code generators for real & complex matrix multiply
       ** Kernel routines used in the recursive Level 3 BLAS
       ** Codeveloped Level 2 gemv- & ger-based BLAS
       ** Codeveloped ATLAS level 2 blas tester
       ** GEMV & GER and associated files
       ** C interface to BLAS
       ** Recursive LU, Cholesky, xLAUUM and xGETRI routines and testers
       ** LAPACK interfaces
       ** ATLAS Level 1 BLAS routines
       ** Tools and docs necessary to allow user contribution of all kernels
       ** Quite a few GEMV, GER, and GEMM kernels
       ** New threading infrastructure (as of 3.9.5)
       ** Help with new QR design and some coding, some help with qr tester,
          and wrote the C/F77 interface files for all QR variants (see
          Siju Samuel for more details on QR)
       -> Pretty much anything not attributed to someone else :)

During the original development at UTK, Jeff and Peter also helped out:

                                  Jeff Horner
                              jhorner@cs.utk.edu
       ** Level 3 BLAS tester/timer
       ** Beta versions of
          ** Non-generated complex matrix multiply code
          ** C interface to the Level 3 BLAS

                              Peter Soendergaard
                              soender@cs.utk.edu
       ** Recursive xTRTRI and tester


ATLAS has been modified to allow for outside contribution, and the
following people have contributed to ATLAS (alphabetic order):

                                 Doug Aberdeen 
       ** Work on emmerald (an SSE-enabled SGEMM) was the starting point
          for a lot of the people doing SSE-enabled kernels.

                                 Matthew Brett
       ** Help with getting ATLAS to build dynamic libraries.
       ** Lots of help in switching from CVS/sourceforge to git/github
       ** Provided basis for ATLAS/git documentation by creating
          first version gitwash subdir now in AtlasBase/TexDoc/gitwash

                                 Tony Castaldo (2008, 2009)
       ** Figured out PowerPC970 required issuing 4 inst of same type in a row,
          and intermixing of M-loop iterations for full performance.  
       ** Discovered the importance of master-last, leading to full threading
          rewrite.
       ** Did main prototyping and helped with design of the of ATLAS 
          QR variants.  See Siju Samuel entry for more details.

                                 Nicholas Coult
       ** Initial version of AltiVec enabled SGEMM.

                                 Markus Dittrich
       ** Provided the trick needed to get configure to pass multiple words
          as a single flag in configure.

                                 Dean Gaudet
       ** CPUID for config (see ATLAS/CONFIG/archinfo_x86.c), Efficeon tuning
          information, and many informative atlas-devel discussions.

                                 Kazushige Goto 
       ** Assembly language GEMM for Compaq/DEC ev5x and ev6 machines. See
          ATLAS/src/blas/gemm/GOTO for details.  Code no longer in ATLAS 
          v > 3.7.12, as we have dropped support for alphas.

                                 Camm Maguire   
       ** SSE enabled [S,D,C,Z]GEMM, [S,D,C,Z]GEMV and [S,D,C,Z]GER kernels,
          see ATLAS/tune/blas/gemm/CASES, ATLAS/tune/blas/gemv/CASES 
          and ATLAS/tune/blas/ger/CASES for details.

                                 Ryan Moon (2009)
       ** Wrote the first version of the OpenMP Level 3 threaded BLAS
          based on the new threading framework while an undergrad at UTSA.
          See ATLAS/src/threads/blas/level3/omp for details.

     
                             Tim Mattox and Hank Dietz
       ** Extremely efficient 3DNow! kernel for Athlon, see
          ATLAS/tune/blas/gemm/CASES/ATL_smm_3dnow_90.c for details.

                       Viet Nguyen and Peter Strazdins
       ** UltraSparc-optimized [D,Z]GEMM kernels, see
          ATLAS/tune/blas/gemm/CASES for details.

                           Pearu Peterson
       ** A lot of 3.6 stable testing.
       ** Initial work on building ATLAS to dynamic libraries.

                              Julian Ruhe
       ** Excellent Athlon-optimized assembly kernels, see
          ATLAS/tune/blas/gemm/CASES/objs/ for details.

                              Siju Samuel (2009)
       ** Took prototype QR factorization written by Tony Castaldo
          (mostly based on the Elmroth & Gustavson recursive QR, see
          www.cs.utsa.edu/~whaley/papers/ppopp143-castaldo.pdf for details)
          and wrote native implementations of all required QR variants.
          See ATLAS/src/lapack for all the QR/RQ/QL/LQ related files,
          and ATLAS/bin/qrtst.c for their tester.

                              Peter Soendergaard
       ** SSE and 3DNow! GEMM routines.  See ATLAS/tune/blas/gemm/CASES
          for details.  Also, translation of Julian Ruhe's Athlon kernels
          from NASM to gnu assembler, and extension to all precisions.
          See ATLAS/tune/blas/gemm/CASES/ATL_dmm_julian_gas_30.c for details.

                              Carl Staelin       
       ** Initial work on parallelizing ATLAS make.

                              Yevgen Voronenko
       ** Provided code template for Core2Duo-friendly 2-D register block
          which allowed us to greatly increase our Core2Duo GEMM performance.
          See ATLAS/tune/blas/gemm/CASES/ATL_dmm4x2x128_sse2.c for details.
                            
                             Chad Zalkin (2009)
      ** Wrote code generator which uses gcc intrinsics to autovectorize and
         tune matrix multiply.  Contributed to the search over the same.
         See ATLAS/tune/blas/gemm/mmgen_sse.c and 
         ATLAS/tune/blas/gemm/mmksearch_sse.c for details.
@ROUT INDEX.txt
This is the README index file.  If you want install intructions, 
read ATLAS/INSTALL.txt.  Windows users should read 
ATLAS/doc/Windows.txt as well.  Note that all of this documentation is
probably out of date.  The website always contains the most current versions:
   http://math-atlas.sourceforge.net/faq.html#doc


A listing of the ATLAS documentation files is:

                                 in ATLAS/
INSTALL.txt       : Basic ATLAS installation instructions as text
README            : This file


                              in ATLAS/doc/
AtlasCredits.txt : The ATLAS team
atlas_install.pdf: Relatively complete guide to configuring, building,
                   installing and testing ATLAS.
BootSequence.txt : Rough outline of how the ATLAS install works, and what
                   files it creates.
ChangeLog.txt    : Brief summmary of changes from previous releases.
DirStruct.txt    : A graphic of the general organization of the ATLAS files
INDEX.txt        : This index file again
LibReadme.txt    : Information on generated libraries.
TestTime.txt     : Information on using the ATLAS testing and timing programs
TroubleShoot.txt : Help with troubleshooting your installation, including
                   where to find more help
Windows.txt      : Special information users of Microsoft Windows (95/98/NT/2K)
                   should read
atlas_contrib.pdf: Information on how users can speedup and contribute to
                   ATLAS by providing low-level kernel routines
altas_over.pdf   : Paper describing ideas and basic methods of ATLAS
cblas.pdf        : Extract of the BLAST standard document, describing the
                   standard C interface to the BLAS.
fblasqr.pdf      : Quick reference to the F77 interface to the BLAS.
@ROUT TestTime.txt
************************  TIMING AND TESTING ATLAS  ***************************

The ATLAS distribution has several different testing and timing methods.  For
testing, the most important testers are the standard API testers for the 
C and Fortran77 BLAS libraries, and the Fortran77 lapack tester.  Sections
1, 2, and 3 deal with performing these tests.

ATLAS also provides its own timer programs that do some rudimentary testing
as well as performing relatively sophisticated timings (involving cache
flushing, etc).  The remaining sections deal with using these timer/testers.

1. THE FORTRAN77 INTERFACE BLAS TESTERS

   The official BLAS testers for the Fortran77 interface to the legacy BLAS
   can be ran in BLDdir/interfaces/blas/F77/testing/.  Typing "make" with
   no arguments will compile all of the testers (all levels & precisions).
   The user may then run the testers by:

   ./xsblat1
   ./xdblat1
   ./xcblat1
   ./xzblat1

   ./xsblat2 < ../sblat2.dat
   ./xdblat2 < ../dblat2.dat
   ./xcblat2 < ../cblat2.dat
   ./xzblat2 < ../zblat2.dat

   ./xsblat3 < ../sblat3.dat
   ./xdblat3 < ../dblat3.dat
   ./xcblat3 < ../cblat3.dat
   ./xzblat3 < ../zblat3.dat

   The user may edit the input files to perform more or less comprehensive
   tests. For more information on the legacy BLAS testers, go to :

   www.netlib.org/blas/faq.html

2. THE ANSI/ISO C INTERFACE BLAS TESTERS

   The official BLAS testers for the ANSI/ISO C interface to the legacy BLAS
   can be ran in BLDdir/interfaces/blas/C/testing/.  Typing "make" with
   no arguments will compile all of the testers (all levels & precisions).
   The user may then run the testers by:

   ./xscblat1
   ./xdcblat1
   ./xccblat1
   ./xzcblat1

   ./xscblat2 < ../c_sblat2.dat
   ./xdcblat2 < ../c_dblat2.dat
   ./xccblat2 < ../c_cblat2.dat
   ./xzcblat2 < ../c_zblat2.dat

   ./xscblat3 < ../c_sblat3.dat
   ./xdcblat3 < ../c_dblat3.dat
   ./xccblat3 < ../c_cblat3.dat
   ./xzcblat3 < ../c_zblat3.dat

   The user may edit the input files to perform more or less comprehensive
   tests. For more information on the legacy BLAS testers, go to :

   www.netlib.org/blas/faq.html

3. TESTING THE FORTRAN77 INTERFACE TO LAPACK

   Because ATLAS does not provide a full replacement for LAPACK, the user must
   compile a full lapack library combining ATLAS and LAPACK from netlib, as
   discussed in ATLAS/doc/LAPACK.txt.  The user can then modify the LAPACK
   makefile to point at this mixed library, and run the lapack testers as
   described in the lapack documentation.

4. USING ATLAS BLAS TIMER/TESTERS WITH A SYSTEM BLAS LIBRARY

   If your system already has a BLAS library installed or you have your
   own BLAS library (for instance, a library built using the Fortran77
   reference BLAS from netlib), then you can build the ATLAS Level 1-3
   TIMER/TESTER programs with it. These programs compute the Mflop/s
   rate for each routine called. In addition, they check the result
   matrices computed by calls to the system BLAS and ATLAS library
   routines.  For more information about the testing implementation in
   the Level 3 programs, read section 6.1.

   To properly build the programs with your BLAS library, make sure to
   set the BLASlib variable in the BLDdir/Make.inc include file correctly:
   
   BLASlib = /path/to/library/libblas.a
   
   On some machines, the compiler will recognize certain flags that link
   in the vendor-optimized BLAS library. You can place these in the BLASlib
   variable as well.  There are too many of these to list in detail here, but
   here are a few examples of vendor-supplied BLAS:
   
   BLASlib = -xlic_lib=sunperf    # on sun machines using Sun workshop compiler
   
   BLASlib = -ldxml               # Using Dec/Compaq's compiler
   BLASlib = -lcxml               # Using Compaq/Dec's compiler

   BLASlib = -lessl               # IBM machines using IBM compiler
   BLASlib = -lesslp2             # IBM Power2 machines using IBM compiler
   BLASlib = -lesslp3             # IBM Power3 machines using IBM compiler

   BLASlib = -lblas               # IRIX using SGI's compiler

   After you're sure that the BLASlib variable is set properly, read section
   3 and 4 on the ATLAS LEVEL 3 TIMER/TESTER PROGRAMS to learn how to build
   and run them.

5. TESTING _WITHOUT_ A BLAS LIBRARY

   You may still build and run the ATLAS TESTER/TIMERs programs without a
   system BLAS library by testing against the ATLAS provided C reference BLAS.
   Just leave the BLASlib variable in the ATLAS/Make.<arch> makefile blank:

   BLASlib =                    
   
   Then, edit ATLAS/bin/l3blastst.c, and change line 87 from:
#define USE_F77_BLAS
   to:
#define USE_L3_REFERENCE

   Edit ATLAS/bin/l2blastst.c and change line 56 from:
#define USE_F77_BLAS
   to:
#define USE_L2_REFERENCE

6. THE ATLAS LEVEL 3 TIMER/TESTER PROGRAMS

   To make the single, double, single complex, and double complex
   programs, type:

   make xsl3blastst
   make xdl3blastst
   make xcl3blastst
   make xzl3blastst

   Running the programs without arguments will time _GEMM with square
   problem sizes from 100 to 1000 by 100,  alpha=1.0 and beta=1.0, and A
   and B are non-transpose:

   ./xdl3blastst

DGEMM
TEST  TA  TB    M    N    K  alpha   beta    Time  Mflop  SpUp  PASS
====  ==  ==  ===  ===  ===  =====  =====  ======  =====  ====  ====

   1   N   N  100  100  100    1.0    0.0    0.02  200.0  1.00   ---
   1   N   N  100  100  100    1.0    0.0    0.01  200.0  1.00   YES
   2   N   N  200  200  200    1.0    0.0    0.09  177.8  1.00   ---
   2   N   N  200  200  200    1.0    0.0    0.09  177.8  1.00   YES
   3   N   N  300  300  300    1.0    0.0    0.35  154.3  1.00   ---
   3   N   N  300  300  300    1.0    0.0    0.29  186.2  1.21   YES
   4   N   N  400  400  400    1.0    0.0    0.73  175.3  1.00   ---
   4   N   N  400  400  400    1.0    0.0    0.68  188.2  1.07   YES
   5   N   N  500  500  500    1.0    0.0    1.48  168.9  1.00   ---
   5   N   N  500  500  500    1.0    0.0    1.35  185.2  1.10   YES
   6   N   N  600  600  600    1.0    0.0    2.47  174.9  1.00   ---
   6   N   N  600  600  600    1.0    0.0    2.30  187.8  1.07   YES
   7   N   N  700  700  700    1.0    0.0    4.01  171.1  1.00   ---
   7   N   N  700  700  700    1.0    0.0    3.65  187.9  1.10   YES
   8   N   N  800  800  800    1.0    0.0    5.74  178.4  1.00   ---
   8   N   N  800  800  800    1.0    0.0    5.43  188.6  1.06   YES
   9   N   N  900  900  900    1.0    0.0    8.38  174.0  1.00   ---
   9   N   N  900  900  900    1.0    0.0    7.68  189.8  1.09   YES
  10   N   N 1000 1000 1000    1.0    0.0   11.25  177.8  1.00   ---
  10   N   N 1000 1000 1000    1.0    0.0   10.58  189.0  1.06   YES

NTEST=10, NUMBER PASSED=10, NUMBER FAILURES=0


   Notice that there are two entries for each run. The first entry
   corresponds to a call to the library that you supply, and the second
   entry corresponds to a call to the ATLAS library.

   An explanation of each argument follows:

   ./xd3blastst -help
   USAGE: ./xd3blastst -R <rout> -Side <nsides> L/R -Uplo <nuplo> L/U 
   -Atrans <ntrans> n/t/c -Btrans <ntrans> n/t/c -Diag <ndiags> N/U 
   -M <m1> <mN> <minc> -N <n1> <nN> <ninc> -K <k1> <kN> <kinc> 
   -n <n> -m <m> -k <k> -a <nalphas> <alpha1> ... <alphaN> 
   -b <nbetas> <beta1> ... <betaN> -Test <0/1>

   -R <rout>    Specifies the routines which you would like to
                test/time. The routines for the single and double
                precision programs are gemm, symm, syrk, syr2k, trmm,
                and trsm (note the omission of the prefix s and d). The
                additional routines for the single complex and double 
                complex programs are hemm, herk, and her2k. You can
                also specify the argument like this:
                
                ./xd3blastst -R all
                
                which will time all the routines. Or you can specify
                some of the routines like this:
                
                ./xd3blastst -R 1 symm
                ./xd3blastst -R 4 syrk trsm symm gemm
                
                but NOT like this:
                
                ./xd3blastst -R 2 syr2k all
                
   -Side <nsides> L/R   
                Specifies the number of Side parameters you would like
                to test for the appropriate routines. If a routine does
                not take the side parameter, then the argument is ignored. 
                You can specify the argument like this:
                
                ./xd3blastst -R symm -Side 1 L
                ./xd3blastst -R symm -Side 2 L R
                ./xd3blastst -R symm -Side 3 R R L
                
                The <nsides> argument is not optional; it must be present.

   -Uplo <nuplo> L/U
                Specifies the number of Uplo parameters you would like to
                test. It's use follows the same behavior as -Side, like this:
                
                ./xd3blastst -R 2 syrk syr2k -Uplo 1 U
                ./xd3blastst -R 2 syrk syr2k -Uplo 2 U L
                ./xd3blastst -R 2 syrk syr2k -Uplo 4 U U U U

   -Diag <ndiag> N/U
                Specifies the number of Diag parameters you would like to
                test. It's use follows the same behavior as -Side, like this:
                
                ./xd3blastst -R trmm -Diag 1 N
                ./xd3blastst -R trmm -Diag 2 U N
                ./xd3blastst -R trmm -Diag 4 U N U U

   -Btrans <ntrans> N/T/C
                Specifies the number of Btrans parameters you would like to
                test (only used with gemm). It's use follows the same 
                behavior as -Side, like this:
                
                ./xd3blastst -R gemm -Btrans 1 N
                ./xd3blastst -R gemm -Btrans 2 T N
                ./xd3blastst -R gemm -Btrans 4 T N T T

   -Atrans <ntrans> N/T/C
                Specifies the number of Atrans parameters you would like to
                test. It's use follows the same behavior as -Side, like this:
                
                ./xd3blastst -R gemm -Atrans 1 N
                ./xd3blastst -R gemm -Atrans 2 T N
                ./xd3blastst -R gemm -Atrans 4 T N N T
                
                Also, use -Atrans for routines which only take one TRANS 
                argument:

                ./xd3blastst -R trmm -Atrans 2 T N
                
   -M <m1> <mN> <mInc>
   -N <n1> <nM> <nInc>
   -K <k1> <kK> <kInc>
                Specifies the combination of problem sizes to run.
                To specify square problem sizes, use -N:
                
                ./xd3blastst -R gemm -N 1 10 1
                
                will time all square matrices from dimension 1 to 10.
                
                ./xd3blastst -R gemm -M 10 100 10 -N 10 100 10 -K 10 100 10
                
                will time every single problem size imaginable between
                10 and 100 incrementing by 10.
                
   -m <m>
   -n <n>
   -k <k>
                Fixes the dimension in question to one value:
                
                ./xd3blastst -R gemm -K 1 100 1 -m 100 -n 100
                
   -a <nalphas> <alpha1> ... <alphan>
   -b <nbetas> <beta1> ... <betan>
                Specifies the number and the value of alphas/betas to try.
                
                ./xd3blastst -R gemm -a 4 -1.0 0.0 1.0 2.0 -b 1 0.0

                For the complex precision programs, you must specify both
                the real and imaginary parts for alpha and beta.

                ./xz3blastst -R gemm -a 2 -1.0 0.0 1.0 0.0 -b 1 0.0 0.0

               For those complex routines that take a real scalar
               alpha/beta instead of a complex scalar alpha/beta, the
               imaginary part must still be specified, but is
               ignored.

                ./xz3blastst -R her2k -a 1 2.0 3.0
                
                will time her2k with alpha=2.0.
                
   -Test 0/1
                Specifies whether or not to test the results of each run.
                A brief explanation of testing is provided below.
                 
6.1 TESTING IMPLEMENTATION

   The LEVEL 3 TESTER/TIMER programs were created to make performance
   analysis easier, not as a validation tool, thus the testing
   implementation is modest. For a complete test of ATLAS's LEVEL 3
   BLAS implementation, run the CBLAS TESTER described in section 5.

   For all routines, except _TRSM, we compute:
   
      
                          ||C-D||
      x = -----------------------------------------
         ||A|| * ||B|| * |alpha| * eps * max(M,N,K)

   where A, B, and alpha are arguments to the routine, C is the result
   matrix from the call to a trusted BLAS library, D is the result matrix from
   the call to ATLAS, eps is the epsilon value for the machine, and
   max(M,N,K) is the largest value of M, N, K which describe the
   dimensions for the argument and result matrices to the routine. The
   operation ||N|| is the column norm of matrix N, and x <= O(1).

   For _TRSM, we compute:
   
                           ||B-A*X||
       x =  ----------------------------------------
            ||A|| * ||X|| * |alpha| * eps * max(M,N)
   
   where A, B, and alpha are arguments to the routine, X is the result
   matrix from the ATLAS _TRSM call, and max(M,N) is the larger
   value of M an K.

   The data for the argument matrices are generated internally, using the
   ANSI C rand() function, and are distributed over the interval (-.5,+.5). 
   In any case, if x > 1 then an error will be output:

   DGEMM
   TEST  TA  TB    M    N    K  alpha   beta    Time  Mflop  SpUp  PASS
   ====  ==  ==  ===  ===  ===  =====  =====  ======  =====  ====  ====
   
      1   N   N  100  100  100    1.0    0.0    0.01  259.7  1.00   ---
   ERROR: ferr is 4860974538.606986
      1   N   N  100  100  100    1.0    0.0    0.01  227.9  0.88    NO
      2   N   N  200  200  200    1.0    0.0    0.05  291.6  1.00   ---
   ERROR: ferr is 8411267408.031064
      2   N   N  200  200  200    1.0    0.0    0.06  274.5  0.94    NO
      3   N   N  300  300  300    1.0    0.0    0.17  327.2  1.00   ---
   ERROR: ferr is 2895940442.476244
      3   N   N  300  300  300    1.0    0.0    0.20  272.5  0.83    NO

   Ferr is the value of x.  

   What can we infer from the error?  Not much. If the two result
   matrices are 'roughly the same', then no error is
   produced. Otherwise, the result matrices are 'not roughly the same'.

   However, if you see this error message it's best to test both
   libraries (if ATLAS doesn't fail, test your ``trusted'' BLAS)
   with the BLAS testers from netlib:
   
   www.netlib.org/blas/sblat3
   www.netlib.org/blas/dblat3
   www.netlib.org/blas/cblat3
   www.netlib.org/blas/zblat3

7. Timing the Level 2 BLAS
   
   The level 2 timer/tester is very similar in action to the level 3 timer.
   to make, in BLDdir/bin/, type:

   make xsl2blastst
   make xdl2blastst
   make xcl2blastst
   make xzl2blastst

   The flags are very similar to those accepted by the level 3 BLAS timer.
   For usage help, type 
   ./xdl2blastst -h

8. Timing the Level 1 BLAS
   The level 1 timer/tester is very similar in action to the level 2 timer.
   to make, in BLDdir/bin/, type:

   make xsl1blastst
   make xdl1blastst
   make xcl1blastst
   make xzl1blastst

   The flags are very similar to those accepted by the level 2 BLAS timer.
   For usage help, type 
   ./xdl1blastst -h

9. Timing ATLAS LU and Cholesky

   The LU and Choleksy timers may be built in ATLAS/bin/<arch> by:

   make xslutst
   make xdlutst
   make xclutst
   make xzlutst

   make xsllttst
   make xdllttst
   make xcllttst
   make xzllttst

   These timers time ATLAS's LU and Cholesky.  If you wish to time LAPACK or
   some other library's LU and Cholesky for comparison purposes, set your
   Make.inc macro FLAPACKlib to point to the appropriate library, and then

   make xslutstF
   make xdlutstF
   make xclutstF
   make xzlutstF

   make xsllttstF
   make xdllttstF
   make xcllttstF
   make xzllttstF

   Both LU and Cholesky testers will run default cases between 100 and 1000
   if no arguments are supplied.  Both will supply terse usage information
   if the -h flag is thrown.  These testers are similar to the level 3 tester
   in the flags they accept (i.e., -m, -M, -n -N, etc. all work the same).  In
   addition, the user may pass:
   -O <norders> <order1>...<orderN> :
      Whether Row-Major or Column-major storage LU/LLt is to be tested 
      (i.e., R and C are the only legal values for orderX).  Note that
      non-ATLAS implementations (such as provided by x<pre>lutstF) can only
      test Column-major arrays (the default).
   -T <thresh> : 
      supply a floating point threshhold the residual must pass.  If set to
      negative, no testing is done (saving time and space).  If set to zero,
      all tests will be flagged as failed.

10. Other timers/testers, including threading.
   ATLAS provides other timer/testers.  In particular, note that the timers
   in the bin directory have versions to test the threaded interface.  To
   build these, one simply adds the "_pt" suffix to the timer/tester name
   (eg., "make xdlutst_pt" rather than "make xdlutst").  Many of these
   timers also have a "_dyn" suffix, which allows you to test against
   the dynamically-linked ATLAS libs, assuming you have build them.
   In addition to the lu and llt tests mentioned above, we also have
   an inversion tester ("make xdinvtst"), an U*U' tester ("make xduumtst").
   and a solver tester ("make xdslvtst").  These work similarly to the
   LU and LLt testers covered above.  The solve tester allows for testing
   LU, Cholesky, and for some cases, QR solves.
@ROUT BootSequence.txt
This file documents the order in which files are generated in ATLAS.  If you
are crazy enough, it can be used as a starting point for building ATLAS
by hand, rather than letting install do it.  This document was out of date
before it was stored to disk, so don't bust a vein if it seems to be wrong.

Stage 1 : System discovery/aux compile
  (1) cd BLDdir/src/auxil/ ; make lib
      HEADERS                       RESULTS
      atlas_type.h                  res/[s,d]MULADD
      atlas_[s,d,c,z]sysinfo.h      res/[s,d]nreg
                                    res/L1CacheSize
Stage 2 : Type-dependent tuning (pre = d, s, z, c)
  NOTE: right now, the Level 3 are tuned first, followed by Level 2
        because the Level 2 can call the Level 3 for gemv.  It should be
        the other way around, but it ain't :)
  (1) Run ATLAS/tune/blas/gemm/<arch>/xmmsearch -p <pre>, creating
      BLDdir/include/<pre>mm.h & ATL_<pre>NCmm.h, and 
      res/:
         dgMMRES : generated NBmm kernel results
         dMMRES  : generated & user NBmm kernel results
         dClean[M,N,K] : generated cleanup results
         duMMRES : User-supplied kernel NBmm results
         duClean[M,N,K]: Best user-supplied cleanups
         duClean[M,N,K]F : User supplied cleanups that beat generated cases
         dbest[N,T][N,T]_0x0x0: best no-copy case with no fixed loop dimension
         dbest[N,T][N,T]_0x0x<nb>: best no-copy case with M and N loop 
            parameters variable, but K-loop fixed at <nb>
         dbest[N,T][N,T]_<nb>x<nb>x<nb>: best no-copy case with all loop
            dimensions fixed to <nb>
  (2) if first precision, run BLDdir/tune/blas/gemm/x<pre>findCE,
      creating BLDdir/include/atlas_cacheedge.h
  (3) Run BLDdir/tune/blas/gemm/x<pre>Run_tfc, creating
      BLDdir/include/<pre>Xover.h
  (4) GEMV tune, creating BLDdir/include/atlas_<pre>mv.h,
      atlas_<pre>mv[N,T].h
  (5) GER tune, creating BLDdir/include/atlas_<pre>r1.h

Stage 3: General library build
  (1) Finish all compilation
@ROUT TroubleShoot.txt
This file is rudementary and out of date.  See ATLAS/doc/atlas_install.pdf
for more accurate information.

You should always first check the ATLAS errata file at:
   http://math-atlas.sourceforge.net/errata.html
This file contains info about any known bugs and their fixes, compiler errors
that effect ATLAS, etc.


********************************* CONFIG **************************************
If your configure command fails because it can't compile config.c, you may
need to point configure at your ANSI C compiler (usually gcc).  Add the flags 
   --cc=<ANSI C Compiler> --cflags='<flags>'
If you need to throw a flag to cause your compiler to assume ANSI C, include
this as well.  For instance, on an old HP systems I would pass:
   --cc=cc --cflags='-Aa'
This assumes you understand configure and what it is doing, as explained in 
   ATLAS/doc/atlas_install.pdf

******************************** INSTALL **************************************
Most problems occur during installation.  If you have built the library as
recommended in atlas_install.pdf, a complete log of the installation process
will have been kept in BLDdir/bin/INSTALL_LOG.  If an error occurred which
prevented installation from completing, this directory should contain a file
ERROR.LOG, which provides some information, and perhaps points to another log
file where more details are available.  Typical problems would be invalid
compilers, compile flags, out of disk space, etc.

The user should examine the indicated log files for error messages.  If install
does not point the user at a specific log file, do an ls -l, and examine
the newest file aside from ERROR.LOG & SUMMARY.LOG.

Under Unix, you may want to do
   fgrep -i error *
in your INSTALL_LOG directory to look for problems (though some errors occur
naturally in an ATLAS install, since ATLAS tests things that are only legal
on some platforms).

If you are able to correct the problem (or it was a one-time thing, for
instance filesystem problems), you can restart the install.  To restart where
you left off, first edit your Make.inc file, and if the INSTFLAG macro contains
the flags '-a 1' change that to '-a 0' (this will prevent ATLAS from
overwriting your intermediate results with the architectural defaults again),
and then issue make in your BLDdir, and the ATLAS build will continue
where it left off before.  If you wish to restart the install from scratch, the
easiest method is to simply do a 'rm -rf BLDdir', and reconfigure in a new
BLDdir.

If the problem is inadequate performance, the file 
   BLDdir/bin/INSTALL_LOG/SUMMARY.LOG
should be examined in detail.  Make sure that ATLAS detected the correct
level 1 cache size, number of registers, etc. 

If after these steps you are unable to fix the problem, you can submit a
support request as discussed here:
   http://math-atlas.sourceforge.net/faq.html#help

Include a thorough description of your system, what problem you are
encountering, what you were doing when it happened, etc.  All questions and
bug reports should minimally include the Make.inc file you were using, and
the contents of your INSTALL_LOG directory.  If ATLAS's install detected the
error, and was not killed, it will have created a file containing all this
information in BLDdir/error_<arch>.tgz.  If it has not, you can create it
from your BLDdir directory with:
   make error_report

MAKE SURE TO ATTATCH THIS ERROR REPORT WHEN REPORTING PROBLEMS!!!

******************************  LINKING  **************************************
If you have missing symbols on link make sure you are linking in all of the
libraries you need.  For instance, a code calling the Fortran77 interface
to the BLAS would need:
   -L$(MY_HOME)/ATLAS/lib/$(MY_ARCH)/ -lf77blas -latlas

The full LAPACK library created by merging ATLAS and netlib LAPACK requires
both C and Fortran77 interfaces, and thus that link line would be:
   -L$(MY_HOME)/ATLAS/lib/$(MY_ARCH)/ -llapack -lf77blas -lcblas -latlas

REMEMBER: Order *is* important, so -latlas -lcblas will *not* work.
@ROUT ChangeLog.txt
This is ATLAS version 3.2, released December 2000.  The highlights of
changes from v3.0Beta are:
  ** SMP support via posix threads for Level 3 BLAS
  ** Addition of infrastructure for contribution of kernels, thus allowing:
     ** SSE support
     ** 3DNow! support
     ** Speedups on ev6x, ev5x, UltraSparcs, IA64, PowerPC archs
  ** Level 1 BLAS tester/timer added
  ** Additional OS and architectural support
  ** Bug fixes and misc. speedups

ATLAS version 3.0Beta, released December 1999.  The highlights of
changes from v2.0 are:
  ** ATLAS now supplies complete BLAS, although some level 1 and 2 BLAS not
     fully optimized on all architectures
  ** Some LAPACK routines explicitly supported (LU, Cholesky and related 
     routines)
  ** Standard C and Fortran77 APIs for all BLAS and provided LAPACK routines;
     C routines support both row- & column-major access
  ** Improved small-case GEMM performance made possible by code generator that
     can generate all transpose cases (and thus avoid data copy), with
     associated speed boost in many Level 3 BLAS routines.
  ** Support for complex matrix multiplication without copying user data
  ** Support for additional looping structures for complex GEMM, providing
     better performance and reducing memory usage for many cases

ATLAS version 2.0, released February 1999.  The highlights of changes
from 1.1 are:
  ** Support for all 4 types/precisions
  ** All Level 3 BLAS routines now supported
  ** Fortran77 is not required for installation
  ** Install & configure steps are now automated & logged
  ** Timer/tester for all Level 3 BLAS now included
  ** C interface to BLAS supported, and tester provided
  ** Improved small-case matrix multiply performance

ATLAS version 1.0, released September 1998.  The highlights of changes
from version 0.1 are:
  ** Support for entire real Level 3 BLAS via the Superscalar gemm-based
     BLAS (written in Fortran77)
  ** Improved matmul generator, including support for explicit
     register blocking in GEMM

First ATLAS release, version 0.1, released December 1997.  Provided:
  ** Optimized, real matrix multiplication
  ** Real GEMM tester/timer
@ROUT LAPACK.txt
ATLAS now includes replacements for the following LAPACK routines:
   ?gesv ?getrf ?getrs
   ?posv ?potrf ?potrs
   ?getri ?trtri
   ?potri ?lauum 
Where ? is replaced with the appropriate data type prefix, d, s, c, or z.

These routines are provided with both C and Fortran77 interfaces.  ATLAS's
LAPACK C interface, like the C interface to the BLAS, accepts both row- and
column-major arrays.  For details on the C interface API, consult the interface
code in
   ATLAS/interfaces/lapack/C/src/

The Fortran77 API is exactly that of LAPACK, and thus ATLAS's LU and Cholesky
routines can simply replace those provided by LAPACK.

************************** COMPILING A FULL LAPACK LIBRARY ********************
ATLAS does not provide a full lapack library.  However, there is a simple way
to get ATLAS to provide its faster LU and Cholesky to the LAPACK library.
This is described in detail in ATLAS/doc/atlas_install.pdf.

If you have already built ATLAS, you can still easily build one monolithic
LAPACK library.  First, obtain the LAPACK src from netlib and build the LAPACK
library as normal.  Then, go to your BLDdir/lib/ directory, and issue the
following commands:
  mkdir tmp
  cd tmp
  ar x ../liblapack.a
  mv <your LAPACK lib & path> ../liblapack.a
  ar r ../liblapack.a *.o
  cd ..
  rm -rf tmp
@ROUT Windows.txt

                               IMPORTANT: 
Windows 95/98/ME does a remarkably poor job of process load balance.  If you
change the focus from the cygnus window, performance will immediately drop by
at least 1/3, and the timings will be inaccurate.  It is recommended that you
leave the focus on the install window throughout the entire install procedure.
This is not necessary for Windows NT/2K/XP.

ATLAS requires unix-style make and /bin/sh commands in order to install on a 
windows system.  A fairly complete unix-style environment is available free of
charge at:
   http://www.cygwin.com/

From this website, you can download the package, get installation instructions,
etc.  You will want to download the "full" version of cygwin, which includes
compilers, shells, make, etc.  Be sure you get all the compilers you are
interested in (ATLAS requires gcc, and you will probably want g77 or gfortran
as well).

The cygwin installation is quite simple, involving downloading an executable
and installing with Windows' usual install procedure (you can remove it from
your machine with Windows' ADD/REMOVE if you later decide you don't want it).

After this is done, simply follow the instructions given in atlas_install.pdf,
running all command in a cygnus window.  By default, ATLAS will be compiled
with the gnu gcc compiler that comes with cygnus.  Gnu gcc provides better
ATLAS performance than does MSVC++, Watcom C, or Intel icl, so we recommend
that you leave gcc as the compiler the main compiler.  If you compile the
interface routines (described below) with the appropriate compiler, you
should be able to link the resulting libraries using any of these native
compilers (eg., icl, MSVC++).
to be linked in using MSVC++, if that is your programming environment of choice.
Windows developers using gnu fortran and C as their linkers can just install
ATLAS as normal with no special options.  Users wanting to link to their
ATLAS libs with Windows-style compilers such as MSVC++, CVF, or the Intel
compilers should scope the errata entry:
   http://math-atlas.sourceforge.net/errata.html#WinBuild
for full details on how to tell configure what compilers you are interested in.

@beginskip
Because people often miss them in the install instructions, I repeat two
very important pieces of information about the cygnus install here:

                              (1)
If, after installing cygnus, you get the message:
    Out of environment space
add the line 
    shell=C:\command.com /e:4096 /p
to your c:\config.sys

                              (2)
After installation, ATLAS needs to find /bin/sh, so you should (assuming you
don't already have this directory made):
   mkdir -p /bin
Then, you should copy sh.exe from the cygwin bin directory to this one.
The location of the cygwin bin directory changes depending on where you
did the install, what type of machine you have, and the version of cygnus.
Here is an example:
    /cygnus/cygwin-b20/H-i586-cygwin32/bin
the cygwin-b20 is a version number, so you might see cygwin-b21, if you have
a newer release, for instance.  The i586 refers to your processor, you might
expect to see i386, i486, i586 or i686, for instance.
@endskip

@ROUT DirStruct.txt
***************************** DIRECTORY STRUCTURE ******************************
NOTE: This graphic is *way* out of date (for instance, the pthreads directory is
      not shown), but still gives the general idea, so I leave it in.

The directory structure of ATLAS can be summarized by the following graphic:
      ---------------------------------------------------------
      |       |        |                |          |          |
     bin  interfaces  tune             lib      include      src
              |        |                                      |
              |   -----------------------       ----------------------------
              |   |                     |       |       |     |            |
              |   |                    blas   auxil  testing  |          lapack
              |   |                     |                     |
              |   |      ------------------------------     blas
              |sysinfo   |           |        |       |       |
              |          gemm       gemv     ger     level3   |
              |                                               |
        ----------------------           -----------------------------------
        |                    |           |       |       |      |     |    |
      blas                 lapack      level1  level2  level3  gemm  ger  gemv
        |                    |
    ---------            ---------
    |       |            |       |
   src    testing       src    testing

This directory structure is duplicated in the SRCdir and BLDdir directories,
with SRCdir containing the original source files (obtained from the ATLAS
tarfile) and BLDdir (created by the configure step) containing the generated
libraries, headers, objects, and executables.

A summary of each of the main directories is given below:

** interfaces : The official C and Fortran77 interfaces that ATLAS supplies.
                Users needing to examine the API can go to the appropriate
                src subdirectory.  If it exists, the official API tester is
                available in the appropriate testing subdirectory.
** bin        : ATLAS's user-runnable testers & timers are built here
** lib        : Libraries are compiled by default into this directory
** tune       : The code generators and timing programs that allow ATLAS to
                tune itself to specific architectures are here
** include    : All of atlas's include files.  Architecture-dependent include
                files appear in the appropriate <arch> subdirectory.
** src        : Stores the routines supported by atlas; once optimal cases have
                been found, this is also where the generated code is stored.

In addition to those shown above, the user should be aware of the directories:
   ATLAS/doc                    : ATLAS documentation
   BLDdir/bin/INSTALL_LOG : Log of the build step for each architecture
@ROUT INSTALL.txt
This file is outdated and not very comprehensive.  ATLAS installation is
covered in detail in ATLAS/doc/atlas_install.pdf.

Before doing anything, scope the ATLAS errata file for known errors/problems:
   http://math-atlas.sourceforge.net/errata.html
and apply any bug fixes/workarounds you find there.

Note that the documentation on the website will repeat most of this
information, and will be much more current.  The docs in this tarfile
are here mainly for convenience and for users not connected to the net.
Others should scope the website for the most current documentation:
   http://math-atlas.sourceforge.net/faq.html#doc

If you are a Windows user please read ATLAS/doc/Windows.txt before proceeding.

If you are used to the old build process, note that ATLAS's build mechanism
changed significantly starting with ATLAS3.7.12, to make it more like gnu
configure.

There are two mandatory steps to ATLAS installation (config & build), as
well as three optional steps (test, time, install) and these steps are
described in detail below.  For the impatient, here is the basic outline:
**************************************************
   mkdir my_build_dir ; cd my_build_dir
   /path/to/ATLAS/configure [flags]
   make              ! tune and compile library
   make check        ! perform sanity tests
   make ptcheck      ! checks of threaded code for multiprocessor systems
   make time         ! provide performance summary as % of clock rate
   make install      ! Copy library and include files to other directories
**************************************************

If you want to build a dynamic/shared library, see below at header:
                       BUILDING DYNAMIC/SHARED LIBRARIES
If you want to build a full LAPACK library (i.e. all of the lapack library,
including those lapack routines not natively provided by ATLAS), see:
                   NOTE ON BUILDING A FULL LAPACK LIBRARY

********** Important Install Information: CPU THROTTLING ***********
Most OSes (including Linux) now turn on CPU throttling for power management
**even if you are using a desktop**.  CPU throttling makes pretty much all
timings completely random, and so any ATLAS install will be junk.  Therefore,
before installing ATLAS, turn off CPU throttling.  For most PCs, you can
switch it off in the BIOS (eg., on my Athlon-64 machine, I can say "No" to 
"Cool and Quiet" under "Power Management").  Most OSes also provide a way
to do switch off CPU throttling, but that varies from OS to OS.  Under Fedora,
at any rate, the following command seemed to work:
     /usr/bin/cpufreq-selector -g performance
On my Core2Duo, cpufreq-selector only changes the parameters of the first CPU,
regardless if which cpu you specify.  I suspect this is a bug, because on
earlier systems, the remaining CPUs were controlled via a logical link to
/sys/devices/system/cpu/cpu0/.  In this case, the only way I found to force
the second processor to also run at its peak frequency was to issue the
following as root after setting CPU0 to performance:
   cp /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor \
      /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor

For non-broken systems, you instead issue the above command with -c <#> appended
to change the performance of each core in turn.  For example, to speedup both
processors of a dual system you would issue:
     /usr/bin/cpufreq-selector -g performance -c 0
     /usr/bin/cpufreq-selector -g performance -c 1

On Kubuntu, I had problems with this not working because scaling_max_freq
was set to the minimal speed.  To fix, I had to first increase the max scaling
frequency, which you can do (as root) by (where <#> below is replaced by each processor
number eg., 0 and 1 for dual processor system):
   cd /sys/devices/system/cpu/cpu<#>/cpufreq
   cp cpuinfo_max_freq scaling_max_freq

In Kubuntu 9.10, the only fix I found was to issue:
   sudo echo "performance" > \
        /sys/devices/system/cpu/cpuX/cpufreq/scaling_governor
Where 'X' is replaced by each of your cpu numbers in turn (eg., if you have
a quad processor, you would issue this command four times, using X=[0,1,2,3]).

Under MacOS or Windows, you may be able to change this under the power settings.
I have reports that issuing "powercfg /q" in cmd.exe under windows will tell
you whether windows is throttling or not.

ATLAS config tries to detect if CPU throttling is enabled, but it may not
always detect it, and sometimes may detect it after you have disabled it.
In the latter case, to force the configure to continue regardless of the
results of the CPU throttling probe, pass this flag to configure:
   -Si cputhrchk 0

********************************** CONFIG *************************************
First, create a directory where you will build ATLAS.  It can be anywhere in
your filesystem, and does not need to be under the ATLAS/ subdirectory 
(though it can be if you like).  In general, giving it a descriptive name
is good, for instance:
   mkdir ATLAS_Linux_P4E ; cd ATLAS_Linux_P4E

From this directory, configure the new directory to build atlas with the
command:
   /path/to/ATLAS/configure [flags]
Obviously, "/path/to/ATLAS" is the full or relative path from where you are
to the directory created by the ATLAS tarfile.  To see a list of available
flags to configure type "path/to/ATLAS/configure --help".  In general, no
flags are required, but there are many useful flags for helping with various
problems, in particular changing compilers, setting 32 or 64 bit libraries,
etc.  To ensure building 32 bit libraries, add the flag -b 32, and -b 64
to force 64 bit libraries (must be using a 64 bit-capable compiler on a
64-bit Operating System).

************ Important Compiler Advice **************
For most systems, ATLAS defaults to using the Gnu compiler collection for
its ATLAS install.  This means configure will automatically search for
either g77/gcc or gfortran/gcc.  If it can't find them, it will typically
stop with an error message.  For some platforms, ATLAS knows good flags
to use for multiple compilers, and so you may get good flags by simply
changing the compiler name.  If this doesn't work, you'll need to specify
both the compiler name and the flags to use.  For the fortran compiler,
you can switch the fortran compiler without performance or install penalty
on all platforms.  To do so, simply add the flags:
  -C if <fortran compiler with path> -F if 'fortran flags'
to the configure command.  If you need to install ATLAS on a platform that
doesn't have a working fortran compiler, you can do so by adding the flag:
   --nof77
instead.  Note that the fortran interface to BLAS and LAPACK cannot be built
without a fortran compiler.

You typically must build ATLAS's interface routines with the compiler that
you use to do the linking, so that the proper libraries can be found.  We
just discussed how to override the fortran choice; if you use a C compiler 
that does not seamlessly interoperate with gcc, you may need to override
the C compiler as well.  Overriding all of ATLAS's C compilers will typically
mean you can't use the architectural defaults, which will greatly increase
your install time and will potentially decrease your performance by a large
amount.  Therefore, it is usually advised to only override the C interface
compiler, leaving the kernel routines to be compiled by the default C compiler
(usually gnu gcc).  To override the C interface compiler, simply add these
flags to your configure invocation:
   -C ic <C compiler with path>  -F ic 'C compiler flags'

Note that all compilers used in an ATLAS install must be able to interoperate.
For more compiler-controlling flags, add --help to the configure command.

*********** Important x86 Compiler Advice ***********
If you are on an x86 and are using gcc 4.1, you should be aware that gcc 4.1
produces x87 code that gets performance of between 56-75% of the code produced
by gcc 3 (i.e. gcc3-produced code is almost twice as fast as gcc4's) depending
on the architecture.  From our own timings, gcc 4.2 is superior to either
4.1 or 3.  Gcc 4.1 produces adequate performance only on Intel Core
machines.  See ATLAS/doc/atlas_install.pdf for further details.

********************************** BUILD **************************************
If config finishes without error, start the build/tuning process by:
   make build
(or just "make")

Install times vary widely, depending on whether ATLAS has architectural 
defaults for your platform, and the speed of your compiler and computer.
Under gcc/linux, an install may take as little as 15 minutes for all four
types/precisions.  Under IRIX using SGI's rather slow (but high performance)
compilers, the install might take as long as four hours.  1-2 hours is probably
fairly typical.  However, the user is not required to enter any input during
the install phase, and all operations are logged, so it is safe to start the
install and ignore it until completion.

If you experience problems, read the TROUBLESHOOTING section in 
ATLAS/doc/TroubleShoot.txt.  ATLAS/README provides an index of all
included ATLAS documentation files.

You should then read ATLAS/doc/TestTime.txt for instructions on testing 
and timing your installation.

******************************* SANITY TEST ***********************************
This optional step merely verifies that the built ATLAS libraries are able
to pass basic correctness tests.  The standard BLAS testers (i.e. those
that go with the API, as opposed to those written by the ATLAS group) are
written in Fortran77, and so you will need a Fortran compiler installed to
run them.  If you have no Fortran77, you can amend the directions below by
prepending "C_" to all target names (eg., "make C_test") to run only those
testers that require a C compiler, but note that in so doing you will get
a less rigorously tested library.

you can run all the sequential sanity tests by:
   make check

If you have elected to build the threaded library, you can run the same tests
with the threaded library with:
   make ptcheck

A successful sanity test will dump a lot of compilation to the window, followed
with something like:

===========================================================================
DONE BUILDING TESTERS, RUNNING:
SCOPING FOR FAILURES IN BIN TESTS:
fgrep -e fault -e FAULT -e error -e ERROR -e fail -e FAIL \
        bin/Linux_PIIISSE1/sanity.out
8 cases: 8 passed, 0 skipped, 0 failed
4 cases: 4 passed, 0 skipped, 0 failed
8 cases: 8 passed, 0 skipped, 0 failed
4 cases: 4 passed, 0 skipped, 0 failed
8 cases: 8 passed, 0 skipped, 0 failed
4 cases: 4 passed, 0 skipped, 0 failed
8 cases: 8 passed, 0 skipped, 0 failed
4 cases: 4 passed, 0 skipped, 0 failed
DONE
SCOPING FOR FAILURES IN CBLAS TESTS:
fgrep -e fault -e FAULT -e error -e ERROR -e fail -e FAIL \
        interfaces/blas/C/testing/Linux_PIIISSE1/sanity.out | \
                fgrep -v PASSED
make[1]: [sanity_test] Error 1 (ignored)
DONE
SCOPING FOR FAILURES IN F77BLAS TESTS:
fgrep -e fault -e FAULT -e error -e ERROR -e fail -e FAIL \
        interfaces/blas/F77/testing/Linux_PIIISSE1/sanity.out | \
                fgrep -v PASSED
make[1]: [sanity_test] Error 1 (ignored)
DONE
make[1]: Leaving directory `/home/rwhaley/TEST/TEST/ATLAS3.3.15'
===========================================================================

Note that the "Error 1 (ignored)" is coming from grepping for failure, and
grep is saying it doesn't find any . . .

Assuming you have a fortran compiler, you can also run the full ATLAS
testing scripts, which may take over a day to run.  If you have
installed a full LAPACK library, you can also run the standard LAPACK
testers.  Please see "EXTENDED ATLAS TESTING" below for more information.

******************* INSTALLING ATLAS FOR MULTIPLE ARCHITECTURES ***************
You can install ATLAS from the same source tree on multiple machines at once
by simply creating different build directories for each architecture.

********************** BUILDING DYNAMIC/SHARED LIBRARIES **********************
ATLAS natively builds to a static library (i.e. libs that usually end in
".a" under unix and ".lib" under windows).  ATLAS always builds such a library,
but it can also optionally be requested to build a dynamic/shared library
(typically ending in .so for unix or .dll windows).  In order to do so, you
must tell ATLAS up front to compile with the proper flags  (the same is
true when building netlib's LAPACK, see the LAPACK note below).  Assuming
you are using the gnu C and Fortran compilers, you can add the following
commands to your configure command:
   -Fa alg -fPIC
to force ATLAS to be built using position independent code (required for a
dynamic lib).  If you use non-gnu compilers, you'll need to use -Fa to
pass the correct flag(s) to append to force position independent code for
each compiler (don't forget the gcc compiler used in the index files).
NOTE: Since gcc uses one less int register when compiling with this flag, this
      could potentially impact performance of the architectural defaults,
      but we have not seen it so far.

After you build is complete, you can cd to the OBJdir/lib directory, and
ask ATLAS to build the .so you want.  If you want all libraries, including
the Fortran77 routines, the target choices are :
   shared    : Create shared versions of ATLAS's sequential libs
   ptshared  : Create shared versions of ATLAS's threaded libs
If you want only the C routines (eg. you don't have a fortran compiler):
   cshared   : Create shared versions of ATLAS's sequential libs
   cptshared : Create shared versions of ATLAS's threaded libs

****************** NOTE ON BUILDING A FULL LAPACK LIBRARY *********************
In order to build a full LAPACK library, you must first obtain and untar
netlib lapack.  This can be accomplished on many systems with (the directions
below are for LAPACK version 3.1.1; some modification may be required for later
versions):
   cd /some/lapack/dir/ 
   wget http://netlib.org/lapack/lapack-lite-3.1.1.tgz
   gunzip -c lapack-lite-3.1.1.tgz | tar xvf -

Then, pass the flag
   -Ss lasrc /some/lapack/dir/lapack-3.1.1/SRC
to your ATLAS configure, and ATLAS will build the full LAPACK library for you.
You can speed up the various QR factorization routines significantly by
also adding the flat:
   -Si latune 1
to your configure command; this will lengthen your ATLAS install substantially
if you don't have architectural defaults with pretuned LAPACK headers
(lapack tuning typically adds 3-4 hours of install time on a fast machine).

***************************** EXTENDED ATLAS TESTING **************************
ATLAS has two extended testers beyond the sanity checks that can be
automatically invoked from the BLDdir.  These tests are longer running and
more complex to interpret than the sanity tests, and so not every user will
want to run them.  They are particularly recommended for installers who wish
to use a developer release for production code.

--------------------------------- full_test -----------------------------------
The first is a set of testing scripts written by Antoine Petitet, that
randomly generate testcases for a host of ATLAS's testers.  This testing
phase may take as long as two days to complete (and almost always takes
at least 4 hours).  To perform this long-running test, simply issue:
   make full_test
If you are logged into the host machine remotely, chances are good your
connection will go down before the install completes.  Therefore, there is
a second command that runs these scripts in the background with a no hangup
command (so the tests will continue even if your network connection dies):
   make full_test_nh
At the completion of the tests, the extensive output files will be searched
for errors (much as with the sanity tests), and the output sent to the screen.
If you have lost this screen of data, you can regenerate it with the command:
   make scope_full_test

Running these tests will create a directory BLDdir/bin/AtlasTest where the
tester resides, and your output files will be stored a $(ARCH) subdir.
If you want to rerun the testers from scratch (rather than just searching
old output), you can simply delete the entire BLDdir/bin/AtlasTest
directory tree, and do "make full_test" again.

----------------------------- lapack_test -------------------------------------
If you have installed the full LAPACK library, then you can run the standard
lapack testers as well.  The command you give is:
   make lapack_test_[a,s,f]l_[ab,sb,fb,pt]
The first choice (choose one of three) controls which LAPACK library macro is
used in the link for testing:

   _l    LINK FOR LAPACK       Make.inc MACRO
   ==    ===================   ==============
   a     ATLAS's LAPACK        $(LAPACKlib)
   s     system LAPACK         $(SLAPACKlib)
   f     F77 reference LAPACK  $(FLAPACKlib)

The second choice (choose one of three) controls which BLAS macros are
used in the link for testing:
  _b/pt  LINK FOR BLAS           Make.inc MACRO
  ====   =====================   =========================================
  ab     ATLAS BLAS              $(F77BLASlib) $(CBLASlib) $(ATLASlib)
  sb     system BLAS             $(BLASlib)
  fb     F77 reference BLAS      $(FBLASlib)
  pt     ATLAS' threaded BLAS    $(PTF77BLASlib) $(PTCBLASlib) $(ATLASlib)

Not all of these combinations will work without user modification of Make.inc.
You will need to fill in values for
   $(BLASlib)
   $(SLAPACKlib)
   $(FLAPACKlib)
if you want to run the lapack tester against these libraries.

Usually, you will want to test your newly install ATLAS LAPACK & BLAS:
   make lapack_test_al_ab

As before, once the testing is complete, you will get the output of a search
for errors though all output files, and you can search them again with:
   make scope_lapack_test_al_ab

Unfortunately, the lapack testers always show errors on almost all platforms.
So, how do you know if you have a real error?  Real errors will usually
have residuals in the 10^6 range, rather than O(1) (smaller residuals mean
less error).  If you are unsure, the best way is to contrast ATLAS with an
all-F77 install:
   make lapack_test_fl_fb
(To run this test, you will have to build a stock netlib LAPACK library,
and fill out Make.inc's FLAPACKlib macro appropriately.)  You can then see
how the errors reported by ATLAS stack up against the all-F77 version:
if they  are roughly the same, then you are usually OK.

All the lapack testers create a directory BLDdir/bin/LAPACK_TEST.  For
each test you run there will be a subdirectory
   LAOUT_[A,S,F]L_[AB,SB,FB,PT]
where all your output files will be located.  Additionally, the results
of the scope (search for error) will be stored in 
   BLDdir/bin/LAPACK_TEST/SUMMARY_<lapack>_<blas>

Therefore, a typical round of testing might be:
   make lapack_test_al_ab
   make lapack_test_fl_fb
   # compare SUMMARY_al_ab with SUMMARY_fl_fb to check for error
   make lapack_test_al_pt
   # compare SUMMARY_al_pt with SUMMARY_fl_fb to check for error in parallel lib

If you had an error, you might want to be sure the error was in ATLAS's BLAS
and not lapack, so you could do "make lapack_test_fl_ab", and see if the
error went away.  If you filled in the GotoBLAS for the SLAPACKlib & BLASlib
macros, you could scope the error properties of Goto's BLAS and LAPACK.
Many system/vendor LAPACK/BLAS do not provide all of the routines required
to run the LAPACK testers, and some ATLAS testers call ATLAS internal
routines.  Therefore, the safest thing if you have missing symbol errors
when building system/vendor tests, is to use ATLAS to pick up any missing
symbols.  For instance, here is an example Make.inc output that makes all of
ATLAS testers work with the GotoBLAS on my Athlon-64 workstation:
   BLASlib = /opt/lib/libgoto_opteronp-r1.26.a \
             $(F77BLASlib) $(CBLASlib) $(ATLASlib)
   SLAPACKlib = /opt/lib/libgoto_opteronp-r1.26.a $(FLAPACKlib)


@ROUT LibReadme.txt
***************************** FILE DESCRIPTIONS *******************************
The files in this archive are:

Make.inc      : The Make include file used to build these libs
SUMMARY.LOG   : The SUMMARY.LOG created by atlas_install.  Provides further
                information about the installation machine.
cblas.h       : The C header file for the C interface to the BLAS.
clapack.h     : The C header file for the C interface to LAPACK.
liblapack.a   : The LAPACK routines provided by ATLAS.  If you want a full
                lapack library, the .o in this lib can be archived into the
                f77 lapack lib without error.
libcblas.a    : The ANSI C interface to the BLAS.
libf77blas.a  : The Fortran77 interface to the BLAS.
libatlas.a    : The main ATLAS library, providing low-level routines for all
                interface libs.

Your archive may also contain additional libraries, if it has posix thread
support.  These optional libs are:

libptcblas.a    : The ANSI C interface to the threaded (SMP) BLAS.
libptf77blas.a  : The Fortran77 interface to the threaded (SMP) BLAS.

********************************* LINKING *************************************
When linking, remember that order is important.  So, if you want uniprocessor
libs, your link line would contain IN THIS ORDER:
   -LLIBDIR -llapack -lcblas -lf77blas -latlas 
And if you want to utilize an SMP version, it would be:
   -LLIBDIR -llapack -lptcblas -lptf77blas -latlas 

NOTE: On Apple's OS X, the above won't work, since system directories are
searched before the -L directories.  OS X includes ATLAS internally, so
the above link line will always get you OS X's libs instead of the ones
that you have built.  The easiest solution is to explicitly link to each
library using the full path, rather than using the -L/-l combo.

************************** GETTING A FULL LAPACK LIB **************************
ATLAS does not provide a full lapack library.  However, there is a simple way
to get ATLAS to provide its faster LAPACK routines to a full LAPACK library.
ATLAS's internal routines are distinct from LAPACK's, so it is safe to compile
ATLAS's LAPACK routines directly into a netlib-style LAPACK library.
If you install LAPACK before ATLAS, this can be automated as described in
ATLAS/INSTALL.txt.  The following describes adding netlib LAPACK to an
already built ATLAS library:

First, obtain the LAPACK src from netlib and build the LAPACK library as
normal.  Then, in the lib/ subdirectory of your ATLAS build directory 
(where you should have a liblapack.a), issue the following commands:
  mkdir tmp
  cd tmp
  ar x ../liblapack.a
  cp <your LAPACK path & lib> ../liblapack.a
  ar d ../liblapack.a lsame.o xerbla.o csrot.o zdrot.o
  ar r ../liblapack.a *.o
  cd ..
  rm -rf tmp

Just linking in ATLAS's liblapack.a first will not get you the best LAPACK
performance, mainly because LAPACK's untuned ILAENV will be used instead
of ATLAS's slightly tuned one.
@ROUT !
