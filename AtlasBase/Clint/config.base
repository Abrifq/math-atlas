@ifdef ! incd
   @define incd @/home/rwhaley/Base/ATLAS@
@endifdef
@extract -b @(topd)/gen.inc what=crsetup
@ROUT wincc winar winf77
@extract -b @(topd)/gen.inc what=cw @(cw99)
@ROUT archinfo_hpux.c archinfo_aix.c atlar
@extract -b @(topd)/gen.inc what=cw @(cw00)
@ROUT atlar

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <assert.h>
#include <string.h>

#define Mstr2(m) # m
#define Mstr(m) Mstr2(m)

#ifndef TMPDIR
   #define TMPDIR /tmp
#endif
#ifndef MAXLEN  /* maximum name length supported by atlar */
   #define MAXLEN 47
#endif
#ifndef SYSLEN  /* maximum name length supported by system ar */
   #define SYSLEN 15
#endif
#ifndef LNLNLEN
   #define LNLNLEN 2048
#endif
typedef struct wOrDs WORDS;
struct wOrDs
{
   char *word;
   WORDS *next;
};

typedef struct aDdTrEe ADDTREE;
struct aDdTrEe
{
   ADDTREE *lt, *gt;
   WORDS *eq;
   int sum;
};
enum ARACTION {Replace, Delete, Print, Extract, Ranlib};

static int maxlen=MAXLEN, syslen=SYSLEN;
static int nambig=0, nunamb=0;
static int unilen=SYSLEN-3;  /* unique length : use three digits for repeats */
static int totlen=MAXLEN+SYSLEN+2;
static char *tmpdir, *ardir;
static char *indxfile;
static char indxfp[128];
static char lnln[2048];
static ADDTREE *ambig=NULL, *unamb=NULL;
static WORDS *aliasedp=NULL, *unaliasp=NULL, *renamep=NULL;
@ROUT !

@ROUT wincc winar winf77
#include <stdio.h>
#include <stdlib.h>
@ROUT wincc winf77
#include <string.h>
#include <assert.h>
@ROUT wincc
@skip #include "defdf.h"
#ifndef DEFDF
/*   #define DEFDF "c:/Program Files/Microsoft Visual Studio/VC/BIN/CL.EXE" */
   #define DEFDF "CL.EXE"
#endif
@ROUT winf77
@skip #include "defdf.h"
#ifndef DEFDF
/* #define DEFDF "c:/Program Files/Microsoft Visual Studio/DF/BIN/DF.EXE" */
   #define DEFDF "DF.EXE"
#endif
@ROUT wincc winar winf77

int slashdrivesub(char *ln)
/*
 * replaces \\c\ with c:\, returns change in string length
 * this version required for older cygwins
 */
{
   char *sp, *lp=ln, ctmp;
   int nrep=0;
   do
   {
      sp = strstr(lp, "\\\\");
      if (sp && strlen(sp) > 3)
      {
         if (sp[2] == 'a' || sp[2] == 'b' || sp[2] == 'c' || sp[2] == 'd' ||
             sp[2] == 'e' || sp[2] == 'f' || sp[2] == 'g' || sp[2] == 'h')
         {
            if (sp[3] == '\\')
            {
               ctmp = sp[2];
               sp[0] = sp[2];
               sp[1] = ':';
               sp[2] = '\\';
               for (lp=sp+3; *lp = lp[1]; lp++);
               lp = sp + 3;
               nrep++;
            }
            else lp = sp + 2;
         }
         else lp = sp + 2;
      }
      else lp = sp + 2;
   }
   while (sp);
   return(-nrep);
}

int cygdrivesub(char *ln)
/*
 * replaces \cygdrive\c\ with c:\, returns change in string length
 * this version works cygnus version 1.1.0
 */
{
   char *sp;
   int i=0;

   while(sp = strstr(ln, "\\cygdrive\\"))
   {
      i++;
      sp[0] = sp[10];
      sp[1] = ':';
      sp[2] = '\\';
      sp += 3;
      while (*sp = sp[9]) sp++;
   }
   return( slashdrivesub(ln) - (i*9) );
}

void slashsub(char *ln)
/* 
 * changes forward slash of unix to backslash of windoze
 */
{
   int i;
   for (i=0; ln[i]; i++) if (ln[i] == '/') ln[i] = '\\';
}

void doto2dotobj(char *ln)
/*
 * changes all occurences of unix's .o extension to windoze-friendly obj
 */
{
   char ln2[4096];
   int i, j=0;
   for (i=0; ln[i]; i++)
   {
      ln2[j++] = ln[i];
      if (ln[i] == '.' && ln[i+1] == 'o' && isspace(ln[i+2]))
      {
         ln2[j] = 'o';
         ln2[j+1] = 'b';
         ln2[j+2] = 'j';
         ln2[j+3] = ln[i+2];
         j += 4;
         i += 2;
      }
   }
   ln2[j] = '\0';
   sprintf(ln, "%s", ln2);
}

@ROUT wincc winf77
#ifdef DEBUG

#define system SYSTEM
int system(char *ln)
{
   fprintf(stdout, "%s\n", ln);
   return(0);
}

#endif

typedef struct wOrDs WORDS;
struct wOrDs
{
   char *word;
   WORDS *next;
};

void KillWords(WORDS *wp)
{
   WORDS *wpn;

   while (wp)
   {
      free(wp->word);
      wpn = wp->next;
      free(wp);
      wp = wpn;
   }
}

WORDS *AddWord(WORDS *wbas, char *wrd, int wlen)
{
   WORDS *wp;
   int i;

   wp = malloc(sizeof(WORDS));
   assert(wp);
   wp->word = malloc( (wlen+1) * sizeof(char) );
   for (i=0; i != wlen; i++) wp->word[i] = wrd[i];
   wp->word[i] = '\0';
   wp->next = wbas;
   return(wp);
}

WORDS *AddFile(WORDS *wbase, char *fnam)
{
   int i, len;
   len = strlen(fnam);
   assert(len > 2);
@ROUT wincc
   if (fnam[len-1] = 'c' && fnam[len-2] == '.');
@ROUT winf77
   if (fnam[len-1] = 'f' && fnam[len-2] == '.');
@ROUT wincc winf77
   {
      for (i=len-3; i > 0; i--)
      {
         if (fnam[i] == ' ' || fnam[i] == '/' || fnam[i] == '\\')
         {
            i++;
            break;
         }
      }
      wbase = AddWord(wbase, fnam+i, len-i-2);
   }
   return(wbase);
}

int RenameFiles(WORDS *wbase)
{
   WORDS *wp;
   char ln[4096];

   for (wp=wbase; wp; wp = wp->next)
   {
      sprintf(ln, "MOVE %s.obj %s.o\n", wp->word, wp->word);
      fprintf(stdout, "%s", ln);
      if (system(ln)) return(1);
   }
   return(0);
}

main(int nargs, char **args)
{
   char ln[4096], *cptr=NULL;
   int i, j, k, ierr, ic;
   int COMP=0, RENAME=0;
   WORDS *wbase=NULL;

@skip   ic = sprintf(ln, "\"%s\" /iface:cref ", DEFDF);
   ic = sprintf(ln, "\"%s\" ", DEFDF);
@skip   assert(ln[2] == ':');
@skip   ln[2] == ln[1];
@skip   ln[1] = '/';
   slashsub(ln);
@ROUT
@ROUT winf77
   ic += sprintf(ln+ic, "/iface:cref ");
@ROUT wincc winar winf77

@skip   ic = sprintf(ln, "\"c:\\Program Files\\DevStudio\\DF\\BIN\\DF.EXE\" /iface:cref ");
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] == '-')  /* compiler flag */
      {
         if (args[i][1] == 'o') /* handle renaming, guess exe not .obj */
         {
            RENAME = 1;
            k = strlen(args[++i]);
            j = sprintf(ln+ic, "/Fe%s.exe ", args[i]);
            cptr = ln+ic;
            slashsub(ln+ic+3);
         }
         else if (args[i][1] == 'l') /* library to link against */
         {
            j = sprintf(ln+ic, "/link:DEFAULTLIB:%s", &args[i][2]);
            slashsub(ln+ic+17);
         }
         else
         {
            if (args[i][1] == 'c') COMP=1;
            j = sprintf(ln+ic, "/%s ", &args[i][1]);
            slashsub(ln+ic+1);
         }
      }
      else  /* must be files, not flags */
      {
         j = sprintf(ln+ic, "%s ", args[i]);
@ROUT wincc
         if (j > 3 && ln[ic+j-2] == 'c' && ln[ic+j-3] == '.')
@ROUT winf77
         if (j > 3 && ln[ic+j-2] == 'f' && ln[ic+j-3] == '.')
@ROUT wincc winf77
         { /* add this file to list of files to be moved to .o */
            wbase = AddFile(wbase, args[i]);
         }
         slashsub(ln+ic);
      }
      ic += j;
   }
   sprintf(ln+ic, "\n");
   cygdrivesub(ln);
   if (RENAME && COMP) /* gotta use different rename command if not exe */
   {
      cptr = strstr(ln, "/Fe");
      assert(cptr);
      cptr[2] = 'o';
      cptr = strstr(cptr, ".exe");
      assert(cptr);
      cptr[0] = cptr[1] = cptr[2] = cptr[3] = ' ';
   }
   fprintf(stdout, "%s", ln);
   ierr = system(ln);
   if (!ierr && COMP && !RENAME) /* rename the .obj to .o */
      ierr = RenameFiles(wbase);
   KillWords(wbase);
   exit(ierr);
}
@ROUT wincc_bad
main(int nargs, char **args)
{
   char ln[1024], ln2[1024], *cptr=NULL;
   int i, j, k, ic, ic2;

   ic = sprintf(ln, "cl ");
   ic2 = sprintf(ln2, "touch ");
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] == '-')
      {
         if (args[i][1] == 'o') /* handle renaming, guess exe not .obj */
         {
            k = strlen(args[++i]);
            if (args[i][k-1] == 'o' && args[i][k-2] == '.')
            { /* this is entire touch list */
               sprintf(ln2, "touch %s\n", args[i]);
               ic2 = 0;
            }
            j = sprintf(ln+ic, "/Fe%s ", args[i]);
            cptr = ln+ic;
            slashsub(ln+ic+3);
         }
         else
         {
            j = sprintf(ln+ic, "/%s ", &args[i][1]);
            slashsub(ln+ic+1);
         }
      }
      else  /* must be files, not flags */
      {
         j = sprintf(ln+ic, "%s ", args[i]);
         if (ic2 && j > 3 && ln[ic+j-2] == 'c' && ln[ic+j-3] == '.')
         { /* need to use touch to create .o to keep make happy */
            sprintf(ln2+ic2, "%s ", args[i]);
            ic2 += j;
            ln2[ic2-2] = 'o';
         }
         slashsub(ln+ic);
      }
      ic += j;
   }
   sprintf(ln+ic, "\n");
   if (strstr(ln, "/c "))  /* gotta use different rename command if not exe */
   {
      if (ic2) sprintf(ln2+ic2, "\n");
      fprintf(stderr, "%s", ln2);
      assert(system(ln2) == 0);
      if (cptr) cptr[2] = 'o';
   }
   doto2dotobj(ln);
   fprintf(stderr, "%s", ln);
   exit(system(ln));
}
@ROUT winar
#include <stdio.h>
#include <stdlib.h>
main(int nargs, char **args)
{
   char ln[1024];
   int i, j, ic;

   ic = sprintf(ln, "lib /OUT:%s ", args[1]);
   for (i=2; i < nargs; i++)
   {
      j = sprintf(ln+ic, "%s ", args[i]);
      slashsub(ln+ic);
      ic += j;
   }
   sprintf(ln+ic, "\n");
   doto2dotobj(ln);
   fprintf(stderr, "%s", ln);
   exit(system(ln));
}
@ROUT config findgcc
@extract -b @(topd)/gen.inc what=cw @(cw98)

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <ctype.h>
#include <string.h>

#define MAXL2SIZE 4194304
#define Mciswspace(C) ( (((C) > 8) && ((C) < 14)) || ((C) == 32) )
#define Mlowcase(C) ( ((C) > 64 && (C) < 91) ? (C) | 32 : (C) )


@ROUT config findgcc machenum
char *machnam[46] = {"21264", "21164", "21064", "HPPA20", "HP9735", 
                     "POWER", "POWER2Thin", "POWER2Wide", "POWER3", "POWER4",
                     "P5", "P5MMX", "PPRO", "PII", "PIII", "PM", "CoreSolo",
                     "CoreDuo", "P4", "P4E", "P4E64", "Efficeon", "K7",
                     "HAMMER32", "HAMMER64", "IA64Itan", "IA64Itan2",
                     "SGIIP28", "SGIIP27", "SGIIP32", "SGIIP22", "SGIIP30",
                     "SunMS", "SunSS", "SunUS1", "SunUS2", "SunUS4",
                     "SunUS5", "SunUSIII","SunUSX", "PPC604e", "PPC604",
                     "PPCG4", "PPCG5", "UNKNOWN"};
enum MACHTYPE {Dec21264, Dec21164, Dec21064, HPPA20, HP9K735,
               IbmPwr,  IbmTPwr2, IbmWPwr2, IbmPwr3, IbmPwr4,
               IntP5, IntP5MMX, IntPPRO, IntPII, IntPIII, IntPM, IntCoreS,
               IntCoreDuo, IntP4, IntP4E, IntP4E64, TMEff, AmdAthlon, 
               AmdHammer32, AmdHammer64, IA64Itan, IA64Itan2,
               SgiIP28, SgiIP27, SgiIP32, SgiIP22, SgiIP30, 
               SunMS, SunSS, SunUS1, SunUS2, SunUS4, SunUS5, SunUSIII, SunUSX, 
               PPC604e, PPC604, PPCG4, PPCG5, MACHOther};
@ROUT machenum
   @endextract
@ROUT config findgcc

char *osnam[12] = {"Linux", "SunOS", "SunOS4", "OSF1", "IRIX", "AIX", 
                  "Win9x", "WinNT", "HPUX", "FreeBSD", "OSX", "Other/UNKNOWN"};
enum OSTYPE {OSLinux=0, OSSunOS, OSSunOS4, OSOSF1, OSIRIX, OSAIX, 
             OSWin9x, OSWinNT, OSHPUX, OSFreeBSD, OSOSX, OSOther};

enum LINUXARCH {LAPPC, LASPARC, LAALPHA, LAX86, LAIA64, LAOTHER};
char *wcnam[5] ={"vf", "vc", "icc", "ifort", "CRAP"};
enum WINCOMP   {WCvf, WCvc, WCic, WCif, WCgcc};

enum F2CNAME {f2c_Add_=0, f2c_Add__, f2c_NoChange, f2c_UpCase, f2c_NamErr};
enum F2CINT {FintCint=0, FintClong, FintCshort, f2c_IntErr};
enum F2CSTRING {fstrSun=0, fstrCray, fstrStructVal, fstrStructPtr, f2c_StrErr};

/* NOTE on ISA extensions, order is from most preferred to least */
#define NISA 6
#define NISAp1 7
char *ISAXNAM[NISAp1] = {"AltiVec", "SSE3", "SSE2", "SSE1", "3DNow2", "3DNow1",
                         ""};
enum ISAEXT {ISA_AV=0, ISA_SSE3, ISA_SSE2, ISA_SSE1, ISA_3DNow2, ISA_3DNow1, 
             ISA_None};
#define NASMp1 8
enum ASMDIA {gas_x86_32, gas_x86_64, gas_sparc, osx_ppc, linux_ppc, 
             linux_parisc, hpux_parisc, ASM_None};
char *ASMNAM[NASMp1] = {"GAS_x8632", "GAS_x8664", "GAS_SPARC", 
                        "AS_OSX_PPC", "GAS_LINUX_PPC", 
                        "LINUX_PARISC", "HPUX_PARISC", ""};
char *usermmnam[2] = {"", "GOTO"};
enum USERGEMM {UG_None=0, UG_GOTO};

int XCOMP=0, THREADS=0, USEWINF77=0, NLINES=0, ISWIN=0;
char TARGNAM[512];
enum MACHTYPE mach=MACHOther;

#define my_join(pre, nam) pre ## nam
#define Mstr2(m) # m
#define Mstr(m) Mstr2(m)
#define OSIsWin(OS_) ( ((OS_) == OSWin9x) || ((OS_) == OSWinNT) )
#define MachIsAlpha(mach_) \
   ( ((mach_) == Dec21264) || ((mach_) == Dec21164) || ((mach_) == Dec21064) )
#define MachIsX86(mach_)  \
   ( (mach_) >= IntP5 && (mach_) <= AmdHammer64 )
@beginskip
   ( ((mach_) == IntP5) || ((mach_) == IntP5MMX) || ((mach_) == IntPPRO) || \
     ((mach_) == IntPII) || ((mach_) == IntPIII) || ((mach_) == IntP4) || \
     ((mach_) == IntP4E) || ((mach_) == IntP4E64) || \
     ((mach_) == AmdAthlon) || ((mach_) == TMEff) || \
     ((mach_) == AmdHammer32) || ((mach_) == AmdHammer64))
@endskip
#define MachIsUS(mach_) \
   ( ((mach_) == SunUS1) || ((mach_) == SunUS2) || ((mach_) == SunUS2) || \
     ((mach_) == SunUS4) || ((mach_) == SunUS5) || ((mach_) == SunUSIII) || \
     ((mach_) == SunUSX) )

#define WCIsF77(wc_) ( (wc_) == WCvf || (wc_) == WCif )

int QUERY=0;
FILE *fpI, *fparch;

@extract -b @(incd)/query.inc

int fNumLines(char *fnam)
{
   FILE *fp;
   char ln[256];
   int i;

   fp = fopen(fnam, "r");
   assert(fp != NULL);
   for (i=0; fgets(ln, 256, fp); i++);
   return(i);
}

@ROUT config atlar findgcc
char *CmndResults(char *targ, char *cmnd)
{
   static char tnam[128];
   static int FirstTime=1;
   char ln[512];

   if (FirstTime)
   {
      FirstTime = 0;
      assert(tmpnam(tnam));
   }
   if (targ) sprintf(ln, "ssh %s \"%s\" > %s 2>&1 \n", targ, cmnd, tnam);
   else sprintf(ln, "%s > %s 2>&1\n", cmnd, tnam);
   if (!system(ln)) return(tnam);
   else return(NULL);
}

int CmndOneLine(char *targ, char *cmnd, char *ln)
/*
 * executes a system call with contents of cmnd, returns the output in ln;
 * Returns value returned by system call
 * if targ is set, we ssh to that machine
 */
{
   char ln2[512];
   int i;
   FILE *fp;
   char *tnam;

   ln[0] = '\0';
   tnam = CmndResults(targ, cmnd);
   if (tnam)
   {
      fp = fopen(tnam, "r");
      assert(fp);
      if (!fgets(ln, 512, fp)) ln[0] = '\0';
      fclose(fp);
      return(0);
   }
   else ln[0] = '\0';
   return(1);
}

#define BADINT -777938
int GetIntBeforeWord(char *word, char *ln)
/* 
 * Finds integer before word in sentence.  
 * RETURNS: integer on success, BADINT on failure
 */
{
   char *sp;
   sp = strstr(ln, word);
   if (sp == ln) return(BADINT);
   sp--;
   while(isspace(*sp) && sp != ln) sp--;
   if (sp == ln) return(BADINT);
   while (isdigit(*sp) && sp != ln) sp--;
   if (sp == ln) return(BADINT);
   return(atoi(sp));
}

@ROUT config
int GetScreenHeight()
/* 
 * Returns the number of vertical lines window has
 */
{
   int i;
   for (i=160; i; i--) fprintf(stdout, "%03d\n", i);
   i = GetIntRange(0, 0, 160, "", "number at top left of screen");
   return(i);
}

void GetEnter(FILE *fpout)
{
   char ln[128];
   fprintf(fpout, "---------- PRESS ENTER TO CONTINUE ---------- ");
   fgets(ln, 128, stdin);
}

int DisplayFile(char *fnam, FILE *fpout, int nlines)
{
   FILE *fp;
   char ln[256];
   int i, GoOn=1;

   fp = fopen(fnam, "r");
   if (fp == NULL)
   {
      fprintf(stderr, "Unable to open file '%s', continuing without display.\n",
              fnam);
      return(-1);
   }
   if (nlines)
   {
@skip      nlines--;
      do
      {
         for (i=0; i < nlines; i++)
         {
            GoOn = (int) fgets(ln, 256, fp);
            if (!GoOn) break;
            fprintf(fpout, "%s", ln);
         }
         if (GoOn) GetEnter(stdout);
         else break;
      }
      while(GoOn);
   }
   else while (fgets(ln, 256, fp)) fprintf(fpout, "%s", ln);
   i = ferror(fp);
   fclose(fp);
   return(i);
}

int DisplayFile0(char *fnam, FILE *fpout)
{
   FILE *fp;
   char ln[256];
   int i;

   fp = fopen(fnam, "r");
   if (fp == NULL)
   {
      fprintf(stderr, "Unable to open file '%s', continuing without display.\n",
              fnam);
      return(-1);
   }
   while (fgets(ln, 256, fp)) fprintf(fpout, "%s", ln);
   i = ferror(fp);
   fclose(fp);
   return(i);
}

int FoundInFile(char *fnam, char *str)
{
   FILE *fp;
   int found=0;
   char ln[256];

   fp = fopen(fnam, "r");
   assert(fp);
   while (fgets(ln, 256, fp))
   {
      if (strstr(ln, str))
      {
         found=1;
         break;
      }
   }
   fclose(fp);
   return(found);
}

int FindFiles(char *dir, char *fnam, char ***files0)
{
   int i, j;
   FILE *fp;
   char ln[256];
   static int FirstTime=1;
   static char *fpp[32], files[32][256], tnam[128], fnd[128];

   if (FirstTime)
   {
      if (ISWIN)
      {
         if (FileIsThere("/usr/bin/find.exe")) strcpy(fnd, "/usr/bin/find");
         else if (FileIsThere("/bin/find.exe")) strcpy(fnd, "/bin/find");
         else if (FileIsThere("/usr/local/bin/find.exe"))
            strcpy(fnd, "/usr/local/bin/find");
         else strcpy(fnd, "find");
      }
      else
      {
         if (FileIsThere("/usr/bin/find")) strcpy(fnd, "/usr/bin/find");
         else if (FileIsThere("/bin/find")) strcpy(fnd, "/bin/find");
         else if (FileIsThere("/usr/local/bin/find"))
            strcpy(fnd, "/usr/local/bin/find");
         else strcpy(fnd, "find");
      }
      for (i=0; i < 32; i++) fpp[i] = files[i];
      assert(tmpnam(tnam));
      FirstTime=0;
   }
   *files0 = fpp;
   sprintf(ln, "%s %s/ -name \'%s\' 2> /dev/null > %s\n", fnd, dir, fnam, tnam);
   i = system(ln);
   fp = fopen(tnam, "r");
   if (fp)
   {
      for (i=0; i < 32; i++)
      {
         if (fgets(files[i], 256, fp) == NULL) break;
         for (j=0; files[i][j]; j++) if (files[i][j] == '\n') files[i][j] = ' ';
      }
      fclose(fp);
   }
   else
   {
      fprintf(stderr, "Find not working, error code %d\n", i);
      return(0);
   }
   remove(tnam);
   if (ISWIN && i == 0) /* for windows, search for differing file extensions */
   {
      if (!strstr(fnam, "\\.")) /* add .exe to files with no extension */
      {
         sprintf(ln, "%s\\.exe", fnam);
         i = FindFiles(dir, ln, files0);
      }
      else if (strstr(fnam, "\\.a")) /* search for .lib for libraries */
      {
         for (i=0; fnam[i] != '.'; i++) ln[i] = fnam[i];
         ln[i] = '.'; ln[i+1] = 'l'; ln[i+2] = 'i'; ln[i+3] = 'b'; 
         ln[i+4] = '\0';
         i = FindFiles(dir, ln, files0);
      }
   }
   return(i);
}

#define ISSEP(ch_) ( (ch_) == ':' )
int GetAllPaths(char ***mypaths0)
{
   char sep = ':';
   int i, j=0, np=1;
   char **mpaths, *sp;

   sp = getenv("PATH");
   for (i=0; sp[i]; i++) if (ISSEP(sp[i])) np++;
   mpaths = malloc(np * sizeof(char *));
   assert(mpaths);
   for (j=0; j < np; j++)
   {
      for (i=0; ( sp[i] && !ISSEP(sp[i]) ); i++);
      mpaths[j] = malloc((i+1)*sizeof(char));
      assert(mpaths[j]);
      strncpy(mpaths[j], sp, i);
      mpaths[j][i] = '\0';
      sp += i+1;
   }
   *mypaths0 = mpaths;
   return(np);
}

char **AddToPaths(int npaths0, char **paths0, int nnew, ...)
{
   va_list argptr;
   char **paths, *pp;
   int i, j, np = npaths0 + nnew;

   assert(npaths0 >= 0 && nnew >= 0);
   va_start(argptr, nnew);
   paths = malloc(np * sizeof(char*));
   for (i=0; i != npaths0; i++) paths[i] = paths0[i];
   free(paths0);
   for (i=0; i != nnew; i++)
   {
      pp = va_arg(argptr, char *);
      j = strlen(pp)+1;
      paths[i+npaths0] = malloc(j*sizeof(char*));
      assert(paths[i+npaths0]);
      strcpy(paths[i+npaths0], pp);
   }
   va_end(argptr);
   return(paths);
}

void KillPaths(int npaths, char **paths)
{
   int i;

   for (i=0; i < npaths; i++) free(paths[i]);
   free(paths);
}

int FindFirstInPath(char *nam, char *fnd)
/*
 * finds first instance of nam in your path, returns 0 if not found, 1 else
 */
{
   char ln[256], *sp, *cp;
   FILE *fp;

   sp = getenv("PATH");
   cp = ln;
   do
   {
      while (*sp && *sp != ':') *cp++ = *sp++;
      if (*sp) sp++;
      if (cp[-1] != '/') *cp++ = '/';
      strcpy(cp, nam);
      fp = fopen(ln, "r");
      if (ISWIN) /* for Windows, look for default file extensions */
      {
         if (!strstr(ln, "."))  /* add exe to files with no extension */
         {
            strcat(ln, ".exe");
            fp = fopen(ln, "r");
         }
      }
      if (fp != NULL)
      {
         fclose(fp);
         strcpy(fnd, ln);
         return(1);
@skip         fprintf(stdout, "%s\n", ln);
      }
      cp = ln;
   }
   while(*sp);
   return(0);
}

@beginskip
int GccV278(char *GCC) /* determines if gcc is version 2.7.x or 2.8.x */
{
   char ln[256];
   char *fnam;
   int iret=0;

   sprintf(ln, "%s -v", GCC);
   fnam = CmndResults(NULL, ln);
   if (fnam)
   {
      if (FoundInFile(fnam, "version 2.8")) iret = 1;
      else if (FoundInFile(fnam, "version 2.7")) iret = 1;
   }
   return(iret);
}
@endskip

int GetIntVers(char *str, int *nskip)
{
   char ln[64];
   int i, j;

   *nskip = 0;
   for (i=0; str[i] && !isdigit(str[i]); i++);  /* skip non-digits */
   if (str[i])
   {
      for (j=0; j < 64 && str[j+i] && isdigit(str[j+i]); j++) ln[j] = str[j+i];
      ln[j] = '\0';
      if (j)
      {
         *nskip = i+j;
         return(atoi(ln));
      }
   }
   return(-1);
}

int GccIsApple(char *gcc)
{
   char ln[2048], ln2[2048];
   sprintf(ln, "%s --version", gcc);
   if (CmndOneLine(NULL, ln, ln2) == 0)
   {
      if (strstr(ln2, "Apple Computer"))
         return(1);
   }
   return(0);
}
void GetGccVers(char *gcc, int *comp, int *major, int *minor, int *patch)
/*
 * comp: 0: gcc;  1: egcs;  2: pgcc, 3: apple's gcc
 */
{
   char ln[512], ln2[512];
   int i, j;

   *comp = *major = *minor = *patch = -1;
   sprintf(ln, "%s --version", gcc);
   if (CmndOneLine(NULL, ln, ln2) == 0)
   {
      if (strstr(ln2, "Apple Computer"))
         *comp = 3;
/*
 *    Skip compiler name, which may have digits in it
 */
      for (i=0; ln2[i] && !isspace(ln2[i]); i++);
      *major = GetIntVers(ln2+i, &j); j += i;
      if (*major != -1)
      {
         *minor = GetIntVers(ln2+j, &i); j += i;
         if (*minor != -1)
         {
            *patch = GetIntVers(ln2+j, &i); j += i;
            if (strstr(ln2, "egcs")) *comp = 1;
            else if (strstr(ln2, "pgcc")) *comp = 2;
            else *comp = 0;
         }
      }
   }
}

int IsGoodGcc(enum OSTYPE OS, enum MACHTYPE mach, FILE *fpout, FILE *fplog,
              char *gcc)
{
   int iret = 0;
   int comp, major, minor, patch;

   GetGccVers(gcc, &comp, &major, &minor, &patch);
   ATL_mprintf(2, fplog, fpout, "   %s : v%d.%d.%d\n",
               gcc, major, minor, patch);
   if (major == -1)
      iret = 0;
   else if ( MachIsX86(mach) ) /* don't use gcc 2.96 - 3.0 */
   {
      if ((major == 2 && minor < 96) || (major == 3 && minor > 1))
         iret = 1;
   }
   else if (mach == IA64Itan || mach == IA64Itan2 || MachIsUS(mach) || 
            mach == Dec21164 || mach == Dec21264)
   {
      if (major == 3)
         iret = 1;
   }
/*
 * Need 3.2 or newer to make altivec work
 */
   else if ((OS == OSLinux || comp != 3) && (mach == PPCG4 || mach == PPCG5))
   {
      if (major >= 3 && minor >= 3)
         iret = 1;
   }
   else iret = 1; /* any gcc is fine, take first in path */
   return (iret);
}

int FindGoodGcc(enum OSTYPE OS, enum MACHTYPE mach, FILE *fpout, FILE *fplog,
                char *goodgcc)
/*
 * returns: 0: good gcc found;  1: bad gcc found
 */
{
   char *tmpc = "CONFIG/tst.c";
   char *tnam = "CONFIG/tmp.t";
   char **files;
   char *gccs[2] = {"gcc", "gcc-2"};
   char ln[512], ln2[512];
   char **dirs;
   int i, d, n, ND, comp, major, minor, patch, ig, ng;
   FILE *fp;

   remove(tnam);
   if (*goodgcc != '\0')
   {
      if (IsGoodGcc(OS, mach, fpout, fplog, goodgcc))
         return(0);
   }
   ND = GetAllPaths(&dirs);
   dirs = AddToPaths(ND, dirs, 2, "/usr/bin", "usr/local");
   ND += 2;
   *goodgcc = '\0';
   for (d=0; d < ND; d++)
   {
      for (ng = (OSIsWin(OS)) ? 2 : 1, ig=0; ig < ng; ig++)
      {
         n = FindFiles(dirs[d], gccs[ig], &files);
         for (i=0; i < n; i++)
         {
            if (IsGoodGcc(OS, mach, fpout, fplog, files[i]))
            {
               strcpy(goodgcc, files[i]);
               return(0);
            }
         }
      }
   }
   return(1);
}

void FindTarZip(char *tar, char *gzip, char *gunzip)
{
   char *fw[3] = {"tar", "gzip", "gunzip"};
   char *fn[3];
   char **dirs, **files;
   int i, n, d, ND;

   fn[0] = tar; fn[1] = gzip; fn[2] = gunzip;
   ND = GetAllPaths(&dirs);
   dirs = AddToPaths(ND, dirs, 3, "/bin", "/usr/bin", "usr/local");
   ND += 3;
   *tar = *gzip = *gunzip = '\0';
   for (d=0; d < ND; d++)
   {
      for (i=0; i < 3; i++)
      {
         if (fn[i][0] == '\0')
         {
            n = FindFiles(dirs[d], fw[i], &files);
            if (n) strcpy(fn[i], files[0]);
         }
      }
      if (fn[0][0] != '\0' && fn[1][0] != '\0' && fn[2][0] != '\0') break;
   }
   if (*tar == '\0') strcpy(tar, "tar");
   if (*gzip == '\0') strcpy(gzip, "gzip");
   if (*gunzip == '\0') strcpy(gunzip, "gunzip");
}

int Wstrfndsub(char *fnd, char *sub, char *in, char *out)
/*
 * copies IN to OUT, replacing the first occurrence of FND with SUB
 * 1 if FND was found, 0 otherwise
 */
{
   char *sp;
   int i, j;

   sp = strstr(in, fnd);
   if (sp)
   {
      for (i=0; &in[i] != sp; i++) out[i] = in[i];
      for (j=i; out[j] = sub[j-i]; j++);
      for (i += strlen(fnd); out[j] = in[i]; j++, i++);
   }
   else strcpy(out, in);
   return(sp != NULL);
}

#define F2C_assert(cond_) \
{ \
   if (!(cond_)) \
   { \
      fprintf(stderr, "Assertion %s failed, line %d of %s\n", \
              Mstr(cond_), __LINE__, __FILE__); \
      fprintf(stderr, "Unable to figure F2C data\n\n"); \
      return; \
   } \
}

int findSolErr(FILE *fplog, char *redir, char *TOPdir, char *CC, char *CCFLAGS,
               char *MCC, char *MMFLAGS, char *XCC, char *XCCFLAGS)
{
   char *sp, *tnam = "CONFIG/config.tmp";
   char compdef[512], ln[640];
   int i;
   FILE *fp;

   sprintf(ln, "cd CONFIG ; make IGetSunVers %s\n", redir);
   system(ln);
   fp = fopen(tnam, "r");
   fgets(ln, 256, fp);
   fclose(fp);
   remove(tnam);
   for (i=0; !isdigit(ln[i]) && ln[i]; i++);
   if (isdigit(ln[i]))
   {
      fprintf(stdout, "   cc major version number: %c\n", ln[i]);
      if (ln[i] == '4')
      {
         sp = strstr(MMFLAGS, "-xO2");
         if (sp) sp[3] = '5';
      }
   }
   else fprintf(stdout, "   unable to find version in \'%s\'\n", ln);
   DisplayFile("CONFIG/SolErr.txt", stdout, NLINES);
   return(IsYes('y', "", "Use gcc for Level 3 BLAS compilation?"));
}

void findF2C(char *redir, char *targ, char *TOPdir, char *F77, char *F77FLAGS,
             char *FLINK0, char *FLFLAGS0, char *CC, char *CCFLAGS,
             enum F2CNAME *f2cnam, enum F2CINT *f2cint, enum F2CSTRING *f2cstr)
{
   char *namdef[4] = {"Add_", "Add__", "NoChange", "UpCase"};
   char *intdef[4]={"F77_INTEGER=int", "F77_INTEGER=long", "F77_INTEGER=short"};
   char *strdef[4] = {"SunStyle", "CrayStyle", "StructVal", "StructPtr"};
   char compdef[1024], ln[1024];
   char FLINK[512], FLFLAGS[512];
   char *tnam = "CONFIG/config.tmp";
   int i;
   FILE *fp;

   *f2cnam = f2c_NamErr;
   *f2cint = f2c_IntErr;
   *f2cstr = f2c_StrErr;
   Wstrfndsub("$(F77)", F77, FLINK0, FLINK);
   Wstrfndsub("$(F77FLAGS)", F77FLAGS, FLFLAGS0, FLFLAGS);
/*
 * Find naming strategy
 */
   if (targ)
      sprintf(compdef, "F77=%s F77FLAGS=\"%s\" FLINK=%s FLFLAGS=\"%s\" CC=%s CCFLAGS=\"%s\" mydir=%s/CONFIG tnam=%s atlrun=atlas_runX targ=%s",
              F77, F77FLAGS, FLINK, FLFLAGS, CC, CCFLAGS, TOPdir, tnam, targ);
   else
      sprintf(compdef, "F77=%s F77FLAGS=\"%s\" FLINK=%s FLFLAGS=\"%s\" CC=%s CCFLAGS=\"%s\" mydir=%s/CONFIG tnam=%s",
              F77, F77FLAGS, FLINK, FLFLAGS, CC, CCFLAGS, TOPdir, tnam);
   sprintf(ln, "cd CONFIG ; make IRunName %s %s\n", compdef, redir);
   F2C_assert(system(ln) == 0);
   fp = fopen(tnam, "r");
   F2C_assert(fp);
   fgets(ln, 256, fp);
   fclose(fp);
   remove(tnam);
   if (strstr(ln, "Add__")) *f2cnam = f2c_Add__;
   else if (strstr(ln, "Add_")) *f2cnam = f2c_Add_;
   else if (strstr(ln, "NoChange")) *f2cnam = f2c_NoChange;
   else if (strstr(ln, "UpCase")) *f2cnam = f2c_UpCase;
   else return;
/*
 * Finding integer correspondence
 */
   if (targ)
      sprintf(compdef, "F77=%s F77FLAGS=\"%s\" FLINK=%s FLFLAGS=\"%s\" CC=%s CCFLAGS=\"%s -D%s\" mydir=%s/CONFIG tnam=%s atlrun=atlas_runX targ=%s",
              F77, F77FLAGS, FLINK, FLFLAGS, CC, CCFLAGS, namdef[*f2cnam],
              TOPdir, tnam, targ);
   else
      sprintf(compdef, "F77=%s F77FLAGS=\"%s\" FLINK=%s FLFLAGS=\"%s\" CC=%s CCFLAGS=\"%s -D%s\" mydir=%s/CONFIG tnam=%s",
              F77, F77FLAGS, FLINK, FLFLAGS, CC, CCFLAGS, namdef[*f2cnam], 
              TOPdir, tnam);
   sprintf(ln, "cd CONFIG ; make IRunInt %s %s\n", compdef, redir);
   F2C_assert(system(ln) == 0);
   fp = fopen(tnam, "r");
   F2C_assert(fp);
   fgets(ln, 256, fp);
   fclose(fp);
   remove(tnam);
   if (strstr(ln, "short")) *f2cint = FintCshort;
   else if (strstr(ln, "int")) *f2cint = FintCint;
   else if (strstr(ln, "long")) *f2cint = FintClong;
   else return;
/*
 * Finding string handling
 */
   if (targ)
      sprintf(compdef, "F77=%s F77FLAGS=\"%s\" FLINK=%s FLFLAGS=\"%s\" CC=%s mydir=%s/CONFIG tnam=%s atlrun=atlas_runX targ=%s",
              F77, F77FLAGS, FLINK, FLFLAGS, CC, TOPdir, tnam, targ);
   else
      sprintf(compdef, 
"F77=%s F77FLAGS=\"%s\" FLINK=%s FLFLAGS=\"%s\" CC=%s mydir=%s/CONFIG tnam=%s",
              F77, F77FLAGS, FLINK, FLFLAGS, CC, TOPdir, tnam);
   for (i=0; i < 5; i++)
   {
      sprintf(ln, 
              "cd CONFIG ; make IRunStr %s CCFLAGS=\"%s -D%s -D%s -D%s\" %s\n", 
              compdef, CCFLAGS, strdef[i], intdef[*f2cint], namdef[*f2cnam],
              redir);
      if (system(ln) == 0)
      {
         fp = fopen(tnam, "r");
         F2C_assert(fp);
         fgets(ln, 256, fp);
         fclose(fp);
         remove(tnam);
         if (strstr(ln, strdef[i]))
         {
            *f2cstr = i;
            return;
         }
      }
   }
}

#undef F2C_assert

#define ND 3
void FindBlas(FILE *fpout, FILE *fplog, char *redir, char *F77, char *F77FLAGS,
              char *BLASlib)
{
   char **files;
   char *dirs[ND] = {"/usr/lib", "/usr/local", ""};
   char ln[256];
   int i, j, n;

   ATL_mprintf(2, fplog, fpout, "Looking for BLAS (this may take a while):\n");
   if (*BLASlib)
   {
      sprintf(ln, 
      "cd CONFIG ; make IBlasLink F77=\"%s\" F77FLAGS=\"%s\" BLASlib=\"%s\" %s\n",
              F77, F77FLAGS, BLASlib, redir);
      if (system(ln) == 0)
      {
         ATL_mprintf(2, fplog, fpout, "BLASlib set to %s.\n", BLASlib);
         return;
      }
      ATL_mprintf(2, fplog, fpout, "   Link failed, %s rejected\n", BLASlib);
   }
   dirs[ND-1] = getenv("HOME");
   for (j=0; j < ND; j++)
   {
      n = FindFiles(dirs[j], "lib*blas*.a", &files);
      if (n)
      {
         for (i=0; i < n; i++)
         {
            sprintf(ln, 
      "cd CONFIG ; make IBlasLink F77=\"%s\" F77FLAGS=\"%s\" BLASlib=\"%s\" %s\n",
                    F77, F77FLAGS, files[i], redir);
            if (system(ln) == 0)
            {
               strcpy(BLASlib, files[i]);
               ATL_mprintf(2, fplog, fpout, "BLASlib set to %s.\n", BLASlib);
               return;
            }
            ATL_mprintf(2, fplog, fpout, 
                        "   Link failed, %s rejected\n", files[i]);
         }
      }
   }
   ATL_mprintf(2, fplog, fpout, 
               "Unable to find usable BLAS, BLASlib left blank.\n");
   BLASlib[0] = '\0';
}
#undef ND

char *FindUname()
{
   static int FirstTime=1;
   static char unam[64];
   if (FirstTime)
   {
      if (FileIsThere("/bin/uname")) strcpy(unam, "/bin/uname");
      else if (FileIsThere("/usr/bin/uname")) strcpy(unam, "/usr/bin/uname");
      else strcpy(unam, "uname");
      FirstTime = 0;
   }
   return(unam);
}

static int Has64Bits=0, Use64Bits = 0;
int ArchIs64(char *targ, char *TOPdir, enum OSTYPE OS)
/*
 * Uses uname/x86 probe to see if we are on a known 64-bit platform
 */
{
   char *unam = FindUname();
   char ln[2048], ln2[2048];
   int iret = 0;
   sprintf(ln2, "%s -a", unam);
   
   if (!CmndOneLine(targ, ln2, ln))
   {
      if (strstr(ln, "x86_64"))
         iret = 1;
      else if (strstr(ln, "ppc64"))
         iret = 2;
   }
   if (!iret)  /* special code for x86-64 detection (solaris fails above) */
   {
      if (targ)
         sprintf(ln2, "cd CONFIG ; make IRunx8664 mydir=%s/CONFIG atlrun=atlas_runX targ=%s OSFLAGS=\"-DATL_OS_%s\" | fgrep Pointer", TOPdir, targ, osnam[OS]);
      else
         sprintf(ln2, 
                 "cd CONFIG ; make IRunx8664 mydir=%s/CONFIG OSFLAGS=\"-DATL_OS_%s\" | fgrep Pointer",
                 TOPdir, osnam[OS]);
      if (!CmndOneLine(NULL, ln2, ln))
         iret = GetLastInt(ln) == 64 ? 1 : 0;
   }
   return(iret);
}

enum OSTYPE GetOS(FILE *fpout, FILE *fplog, char *targ)
{
   int ierr;
   char ln[512], ln2[128];
   enum OSTYPE i, OS;
   char *unam = FindUname();

   ATL_mprintf(2, fplog, fpout, 
               "Probing to make operating system determination:\n");

   sprintf(ln2, "%s -s", unam);
   ierr = CmndOneLine(targ, ln2, ln);
   if (ierr == 0)
   {
      if(strstr(ln, "Linux")) OS = OSLinux;
      else if(strstr(ln, "FreeBSD")) OS = OSFreeBSD;
      else if (strstr(ln, "Darwin")) OS = OSOSX;
      else if(strstr(ln, "SunOS")) 
      {
         sprintf(ln2, "%s -r", unam);
         CmndOneLine(targ, ln2, ln);
         if (ln[0] == '4') OS = OSSunOS4;
         else OS = OSSunOS;
      }
      else if(strstr(ln, "OSF1")) OS = OSOSF1;
      else if(strstr(ln, "IRIX")) OS = OSIRIX;
      else if(strstr(ln, "AIX")) OS = OSAIX;
      else if(strstr(ln, "WIN"))
      {
         if (strstr(ln, "95") || strstr(ln, "98") || strstr(ln, "_ME")) 
            OS = OSWin9x;
         else if (strstr(ln, "NT")) OS = OSWinNT;  /* check this */
         else ierr = 1;
      }
      else if (strstr(ln, "HP-UX")) OS = OSHPUX;
      else ierr = 1;
   }
   if (ierr)
   {
      fprintf(stdout, 
         "%s -s does not appear to work.\n", unam);
      for (i=0; i <= OSOther; i++) fprintf(stdout, " %3d. %s\n", i+1, osnam[i]);
      OS = (enum OSTYPE) GetIntRange(OSOther+1, 1, OSOther+1, "", 
                                     "the number of your operating system") - 1;
   }
   ATL_mprintf(2, fplog, stdout, 
               "Operating system configured as %s\n\n", osnam[OS]);

   return(OS);
}

char *TryComp(FILE *fpout, FILE *fplog, char *redir, char lang, int np,
              char **paths, char *comp, char *flags)
{
   static char ln2[512];
   char **matches, ln[512];
   int p, n, i;

   if (*comp != '/') /* if we don't already have explicit path */
   {
/*
 *    Try user's path first
 */
      if (FindFirstInPath(comp, ln2))
      {
         sprintf(ln, "cd CONFIG ; make %cTryComp COMP=\"%s\" FLAGS=\"%s\" %s\n",
                 lang, ln2, flags, redir);
         if (system(ln) == 0) return(ln2);
         ATL_mprintf(2, fplog, fpout, "   %s %s rejected\n", ln2, flags);
      }
/*
 *    A separate find on each directory, in order of precedence
 */
      for (p=0 ; p < np; p++)
      {
/*
 *       Try every compiler that is found, search backwards so bigger version
 *       numbers will be tried first
 */
         n = FindFiles(paths[p], comp, &matches);
         for (i=n-1; i >= 0; i--)
         {
            sprintf(ln, 
                    "cd CONFIG ; make %cTryComp COMP=\"%s\" FLAGS=\"%s\" %s\n",
                    lang, matches[i], flags, redir);
            if (system(ln) == 0) return(matches[i]);
            ATL_mprintf(2, fplog, fpout, "   %s rejected\n", matches[i]);
         }
      }
   }
/*
 * Try without explicit path if nothing else works
 */
   sprintf(ln, "cd CONFIG ; make %cTryComp COMP=\"%s\" FLAGS=\"%s\" %s\n",
           lang, comp, flags, redir);
   if (system(ln) == 0) return(comp);
   ATL_mprintf(2, fplog, fpout, "   %s %s rejected\n", comp, flags);

   return(NULL);
}


int MakeWinComp(enum WINCOMP wc, char *def)
/*
 * returns: error return from make command
 */
{
   char ln[512], ln2[1024];

   DisplayFile("CONFIG/wincomp.txt", stdout, NLINES);
   GetStrVer(def, "", "path to windows compiler", 511, ln);
   sprintf(ln2, 
"cd CONFIG; make win%s wcname=/usr/local/bin/ATLwin_%s wcexe='-DDEFDF=\"%s\"'",
           WCIsF77(wc) ? "f77" : "cc", wcnam[wc], ln);
   return(system(ln2));
}

int CheckWinComp(enum WINCOMP wc)
/*
 * Returns 0 if test pass, non-zero on failure
 */
{
   char ln[512];
   sprintf(ln, "cd CONFIG ; make %cTryComp COMP=\"ATLwin_%s\" FLAGS=\"\"",
           WCIsF77(wc) ? 'f' : 'c', wcnam[wc]);
   return(system(ln));
}

int CreateWinComp(enum WINCOMP wc)
/*
 * Returns 0 on success, 1 on failure
 */
{
   char ln[256];
   int ierr, FAIL;
   char *wcn[4] = {"DF", "CL", "IFORT", "ICL"};
   char *defp[4] = 
      {"c:/Program Files/Microsoft Visual Studio/DF98/BIN/DF.EXE",
       "c:/Program Files/Microsoft Visual Studio/VC98/BIN/CL.EXE",
       "c:/Program Files/Intel/CPP/Compiler80/IA32/BIN/ICL.EXE",
       "c:/Program Files/Intel/Fortran/Compiler80/IA32/BIN/IFORT.EXE"};

   sprintf(ln, "/usr/local/bin/ATLwin_%s.exe", wcnam[wc]);
   if (FileIsThere(ln))
   {
      fprintf(stdout, "You've already got a %s:\n", ln);
      if (!GetIntRange(0, 0, 1, "", "0 uses it, 1 to overwrite with new"))
         return(0);
   }
   assert(wc < WCgcc);
   do
   {
      FAIL = 1;
      ierr = MakeWinComp(wc, defp[wc]);
      if (!ierr)
         ierr = CheckWinComp(wc);
      if (ierr)
      {
         fprintf(stdout, "\nCompiler not working:\n");
@skip         fprintf(stdout, "   0. Continue without this compiler\n");
@skip         fprintf(stdout, "   1. Retry\n");
         ierr = GetIntRange(1, 0, 1, "", "0 skips, 1 to reenter/try again");
         sprintf(ln, "rm -f /usr/local/bin/ATLwin_%s.exe", wcnam[wc]);
         system(ln);
      }
      else FAIL = 0;
   }
   while (ierr);
   if (!FAIL)
      fprintf(stdout, "Compiler wrapper successfully created.\n\n");
   else
      fprintf(stdout, "Compiler wrapper not created.\n\n");
   return(FAIL);
}

@beginskip
void GetWinF77(enum MACHTYPE mach, char *targ, char *TOPdir, char *F77, char *F77FLAGS)
{
   FILE *fp;
   int i;

   if (!F77 || !F77FLAGS) return;

   fprintf(stdout, "Which Fortran compiler would you like to use:\n");
   fprintf(stdout, "   1. Compaq Visual Fortran with /iface:cref\n");
   fprintf(stdout, 
   "   2. Compaq Visual Fortran with /iface:cref /iface=nomixed_str_len_arg\n");
   fprintf(stdout, "   3. Gnu Fortran77 (g77)\n");
   i = GetIntRange(1, 1, 3, "", "compiler number");

   if (i == 1 || i == 2)
   {
      DisplayFile("CONFIG/winf77.txt", stdout, NLINES);
      GetStrVer("c:/Program Files/Microsoft Visual Studio/DF98/BIN/DF.EXE", "",
                "full path to compaq/digital fortran", 511, F77);
      fp = fopen("CONFIG/defdf.h", "w");
      assert(fp);
      fprintf(fp, "#define DEFDF \"%s\"\n", F77);
      fclose(fp);
@skip      strcpy(F77, "$(BINdir)/winf77.exe");
      sprintf(F77, "%s/CONFIG/winf77.exe", TOPdir);
      strcpy(F77FLAGS, "-fast -assume:accuracy_sensitive -fltconsistency");
      if (i == 2) strcat(F77FLAGS, " -iface=nomixed_str_len_arg");
      USEWINF77=1; 
      assert(system("cd CONFIG ; make ./winf77.exe") == 0);
   }
   else
   {
      if (F77) strcpy(F77, "g77");
      if (F77FLAGS) strcpy(F77FLAGS, "-funroll-all-loops -O3");
   }
}
@endskip

void GetSyslib(enum OSTYPE OS, enum MACHTYPE mach, char *targ, char *LIBS)
{
   if (THREADS) strcpy(LIBS, "-lpthread -lm");
   else strcpy(LIBS, "-lm");

   switch(OS)
   {
   case OSOSX:  /* don't know answer */
   case OSFreeBSD:  /* don't know answer */
   case OSLinux:
      break;
   case OSSunOS:
      break;
   case OSSunOS4:
      assert(!THREADS);
      break;
   case OSOSF1:
      break;
   case OSIRIX:
      /* if (THREADS) strcpy(LIBS, "-lm"); */
      /* if (THREADS) strcpy(LIBS, "-lpthread -lexc -lm"); */ /* for gcc */
      break;
   case OSAIX:
      if (THREADS) strcpy(LIBS, "-lpthreads -lm");
      break;
   case OSHPUX:
      break;
   case OSWinNT:  /* don't know answer for threads */
      if (THREADS) strcpy(LIBS, "-lpthread");
      else strcpy(LIBS, "");
      break;
   case OSWin9x:
      assert(!THREADS);
      strcpy(LIBS, "");
      break;
   }
}

char *GetFCLFLAGS(enum OSTYPE OS, enum MACHTYPE mach, char *F77)
/*
 * returns flags necessary to make f77 compiler link when main is in C
 */
{
   static char ln[256];
   ln[0] = '\0';
   switch(OS)
   {
   case OSLinux:
   case OSWinNT:
      if (strstr(F77, "ifort")) strcpy(ln, "-nofor_main");
      break;
   case OSOSF1:
      if (!strstr(F77, "g77")) strcpy(ln, "-nofor_main");
      break;
   default:;
   }
   return(ln);
}

char *NameFromPath(char *path)
/*
 * Tries to get a executable name out of the path.
 * RETURNS: ptr to string containing executable name.
 */
{
   int i;
   static char name[128];

   if (!path) return(NULL);
   if (path[0] == '\0') return(NULL);

   for (i=0; path[i]; i++);
   for (; i && path[i] != '/'; i--);
   if (path[i] == '/') i++;
   path += i;
   for (i=0; name[i] = path[i]; i++);
/*
 * Strip trailing whitespace
 */
   for (i--; i >= 0 && isspace(name[i]); i--) name[i] = '\0';
/*
 * Remove .exe for windows
 */
   if (i >= 4 && tolower(name[i]) == 'e' && tolower(name[i-1]) == 'x' &&
       tolower(name[i-2] == 'e') && name[i-3] == '.')
      name[i-3] = '\0';

   return(name);
}

void KillBegEndSpaces(char *str)
{
   int i, j;
/* 
 * Strip trailing blanks
 */
   for (i=0; str[i]; i++);
   for (i--; i >= 0 && isspace(str[i]); i--)
        str[i] = '\0';
/*
 * Strip leading blanks
 */
   if (isspace(*str))
   {
      for (j=1; isspace(str[j]); j++);
      for (i=0; str[i] = str[j]; i++,j++);
   }
}

void GetBlasTry(enum OSTYPE OS, enum MACHTYPE mach, char *blas)
{
   if (!blas) return;
   else if (*blas != '\0') return;
   switch(OS)
   {
   case OSAIX:
      if (mach == IbmTPwr2) strcpy(blas, "-esslp2");
      else strcpy(blas, "-essl");
      break;
   case OSSunOS:
      strcpy(blas, "-xlic_lib=sunperf");
      break;
   case OSOSF1:
      strcpy(blas, "-lcxml");
      break;
   case OSIRIX:
      strcpy(blas, "-lblas");
      break;
   case OSHPUX:
      strcpy(blas, "-lveclib");
      break;
   default:
      *blas = '\0';
   }
/* 
 * put a special case for MKL in here later
 */
}
char *GetLinkInfo(enum OSTYPE OS, enum MACHTYPE mach, char *F77, char *CC,
                  char *FLINK, char *FLFLAGS, char *FCLFLAGS, 
                  char *CLINK, char *CLFLAGS)
{
/*
 * Generic linker settings
 */
   if (CLINK) strcpy(CLINK, "$(CC)");
   if (CLFLAGS) strcpy(CLFLAGS, "$(CCFLAGS)");
   if (FLINK) strcpy(FLINK, "$(F77)");
   if (FLFLAGS) strcpy(FLFLAGS, "$(F77FLAGS)");
   if (FCLFLAGS) strcpy(FCLFLAGS, "$(FLINKFLAGS)");
/*
 * Exceptions
 */
   if (mach == HP9K735 && OS == OSHPUX)
   {
      if (FLFLAGS && strstr(F77, "f77")) strcpy(FLFLAGS, "-Aa");
      if (CLFLAGS && !strstr(CC, "gcc") && strstr(CC, "cc"))
         strcpy(CLFLAGS, "-Aa");
   }
   if (FLFLAGS && strstr(F77, "xlf")) strcat(FLFLAGS, " -bmaxdata:0x70000000");
   if (CLFLAGS && strstr(CC, "xlc")) strcat(CLFLAGS, " -bmaxdata:0x70000000");
/*
 * See if we need special flags for linking C main progs using FLINK
 */
   if (FCLFLAGS)
   {
      if (strstr(F77, "ifort") || (OS == OSOSF1 && strstr(F77, "f77")))
         strcat(FCLFLAGS, " -nofor_main");
   }
}

#define COMPLEN 256
enum WCOMP {CPF77, CPCC, CPMM};
char *GuessCompInfo(enum OSTYPE OS, enum MACHTYPE mach, enum WCOMP which,
                    char *targ, char *sugg)
/*
 * Suggests decent generic default compiler and flags from whatever info
 * is available.  If (sugg) is set, return info about this compiler if
 * we know about it.  Note that this function does *not* replicate info
 * in GetDefCompInfo, so only call it when GetDefCompInfo fails.
 * RETURNS: Ptr to a string, with the first COMPLEN characters holding
 *          the compiler name, and the remainder the flags.
 */
{
   static char ln[1024];
   char *comp, *flag;
   char *sp;
   int i, WANTGCC=0;

   comp = ln;
   flag = ln + COMPLEN;

   if (sugg) WANTGCC = (strstr(sugg, "gcc") || strstr(sugg, "g77"));
/*
 * Universal wild-ass guess for everybody
 */
   strcpy(flag, "-O");
   if (which == CPF77) strcpy(comp, "g77");
   else strcpy(comp, "gcc");
/*
 * See if the user wants Intel compilers
 */
   if ( sugg && (strstr(sugg, "icc") || strstr(sugg, "ifort")) )
   {
      strcpy(comp, sugg);
      if (OSIsWin(OS))
      {
         if (mach == IA64Itan)
         {
            if (which == CPF77) strcpy(flag, "-G1 -O2");
            else if (which == CPCC) strcpy(flag, "-G1 -O3");
            else strcpy(flag, "-G1 -O3 -mp1 -Oa");
         }
         else
         {
            if (which == CPF77) strcpy(flag, "-O2 -mp1");
            else if (which == CPCC) strcpy(flag, "-O3 -mp1");
            else strcpy(flag, "-O3 -mp1 -Oa");
         }
      }
      else
      {
         if (mach == IA64Itan)
         {
            if (which == CPF77) strcpy(flag, "-tpp1 -O2 -mp1 -static");
            else if (which == CPCC) strcpy(flag, "-tpp1 -O3 -mp1 -static");
            else strcpy(flag, "-tpp1 -O3 -mp1 -static -fno-alias");
         }
         else
         {
            if (which == CPF77) strcpy(flag, "-O2 -mp1 -static");
            else if (which == CPCC) strcpy(flag, "-O3 -mp1 -static");
            else strcpy(flag, "-O3 -mp1 -static -fno-alias");
         }
      }
   }
/*
 * See if we are using CVF
 */
   else if ( sugg && strstr(sugg, "ATLwin_vf") )
   {
      assert(which == CPF77);
      strcpy(comp, sugg);
      strcpy(flag, 
"-iface=nomixed_str_len_arg -fast -assume:accuracy_sensitive -fltconsistency");
   }
/*
 * See if we are using MVC
 */
   else if ( sugg && strstr(sugg, "ATLwin_vc") )
   {
      assert(which != CPF77);
      strcpy(comp, sugg);
      if (which == CPCC)
         strcpy(flag, "-O2 -Oy -Op -Za -nologo");
      else 
         strcpy(flag, "-O1 -Oy -Oa -nologo");
   }
   else
   {
      switch(OS)
      {
      case OSFreeBSD:
         if (which == CPF77)
            strcpy(comp, "f77");
      case OSLinux:
         if (which == CPCC)
            strcpy(flag, "-fomit-frame-pointer -O3 -funroll-all-loops");
         else if (which == CPMM)
            strcpy(flag, "-fomit-frame-pointer -O");
         if (THREADS && OS == OSFreeBSD)
         {
            if (which == CPF77)
               strcat(flag, " -pthread");
            else
               strcat(flag, " -pthread -D_REENTRANT -D_THREAD_SAFE");
         }
         break;
      case OSSunOS4:
         if (which == CPF77)
         {
            if (!WANTGCC)
            {
               strcpy(comp, "f77");
               strcpy(flag, "-dalign -O4 -fast");
            }
         }
         else
         {
            strcpy(comp, "gcc");
            if (which == CPCC)
               strcpy(flag, "-fomit-frame-pointer -O3 -funroll-all-loops");
            else strcpy(flag, "-fomit-frame-pointer -O");
         }
         break;
      case OSSunOS:
         if (WANTGCC)
         {
            if (mach == SunUSX)
            {
               strcpy(flag, 
                  "-mcpu=ultrasparc -mtune=ultrasparc -fomit-frame-pointer -O");
               if (which == CPCC) strcat(flag, "3");
            }
         }
         else
         {
            if (which == CPF77)
            {
               strcpy(comp, "f77");
               strcpy(flag, "-dalign -native -xO5");
            }
            else if (which == CPCC)
            {
               strcpy(comp, "cc");
               if (which == CPCC) strcpy(flag, "-dalign -fsingle -xO5 -native");
               else strcpy(flag, "-dalign -fsingle -xO2 -native");
            }
            if (THREADS) strcat(flag, " -mt");
         }
         break;
      case OSOSF1:
         if (!WANTGCC)
         {
            if (which == CPF77)
            {
               strcpy(comp, "f77");
               strcpy(flag, "-O5 -arch host -tune host");
            }
            else
            {
               strcpy(comp, "cc");
               strcpy(flag, "-arch host -tune host -std -O5");
            }
         }
         break;
      case OSIRIX:
         if (WANTGCC) break;
         sprintf(flag, "%s -m", FindUname());
         assert(CmndOneLine(targ, flag, comp) == 0);
         sp = strstr(ln, "IP");
         for (i=2; isdigit(sp[i]); i++);
         sp[i] = '\0';
         if (which == CPF77)
         {
            sprintf(flag,
         "-O3 -64 -OPT:Olimit=15000 -TARG:platform=%s -LNO:blocking=OFF", sp);
            strcpy(comp, "f77");
         }
         else
         {
            sprintf(flag, "-O3 -64 -OPT:Olimit=15000 -TARG:platform=%s -LNO:blocking=OFF -LOPT:alias=typed", sp);
            strcpy(comp, "cc");
         }
         break;
      case OSAIX :
         if (WANTGCC) break;
         if (which == CPF77) strcpy(comp, "xlf");
         else strcpy(comp, "xlc");
         if (which == CPMM) strcpy(flag, "-O -qmaxmem=-1 -qfloat=hsflt");
         else strcpy(flag, "-O3 -qmaxmem=-1 -qfloat=hsflt");
         if (THREADS) strcat(comp, "_r");
         break;
      case OSWin9x:
      case OSWinNT:
         if (which == CPF77)
            strcpy(flag, "-fomit-frame-pointer -funroll-all-loops -O3");
         else if (which == CPCC) 
            strcpy(flag, 
                   "-fomit-frame-pointer -O3 -funroll-all-loops");
         else strcpy(flag, "-fomit-frame-pointer -O");
      case OSHPUX:
         if (WANTGCC) break;
         if (which == CPF77)
         {
            strcpy(comp, "f90");
            strcpy(flag, "+O2");
         }
         else
         {
            strcpy(comp, "cc");
            if (which == CPCC)
               strcpy(flag, "-D_INCLUDE_POSIX_SOURCE -DUseTimes -Aa +O2");
            else
               strcpy(flag, 
                  "-Aa +O2 +Onoinitcheck +Odataprefetch +Optrs_strongly_typed");
         }
      default:;
      }
   }
   return(ln);
}

char *GetDefCompInfo(enum OSTYPE OS, enum MACHTYPE mach, enum WCOMP which,
                     char *sugg)
/*
 * This function returns the compiler and flags used by ATLAS to build
 * the associated architecture defaults.  If the tarfile includes multiple
 * arch defaults and (sugg) is one of these compilers, returns the info for
 * (sugg).  
 * RETURNS: NULL iff we don't have arch defaults for given which/OS/mach combo.
 *          Otherwise, ptr to a string, with the first COMPLEN characters
 *          holding the compiler name, and the remainder the flags.
 *
 * This function returns NULL if ATLAS does not presently have arch defaults
 * for the given which/OS/mach combo.
 *
 */
{
   static char comp[1024];
   char *flag;
   int i;
   int WANTGCC=0;

   flag = comp + COMPLEN;
   *flag = comp[0] = '\0';
   if (sugg)
     WANTGCC = (strstr(sugg, "gcc") || strstr(sugg, "g77"));
/*
 * See if the user wants Intel compilers
 */
   if ( sugg && (strstr(sugg, "icc") || strstr(sugg, "ifort")) )
   {
      strcpy(comp, sugg);
      if (OSIsWin(OS))
      {
         switch(mach)
         {
         case IntPIII:
            if (which == CPF77) strcpy(flag, "-QxK -O2");
            else if (which == CPCC) strcpy(flag, "-QxK -O3");
            else strcpy(flag, "-QxK -O2 -Oa");
            break;
         case IntP4E:
         case IntP4E64:
            if (which == CPF77) strcpy(flag, "-QxP -O2");
            else if (which == CPCC) strcpy(flag, "-QxP -O3");
            else strcpy(flag, "-QxP -O3 -Oa");
            break;
         case IntP4:
            if (which == CPF77) strcpy(flag, "-QxN -O2");
            else if (which == CPCC) strcpy(flag, "-QxN -O3");
            else strcpy(flag, "-QxN -O3 -Oa");
            break;
         case IA64Itan2:
            if (which == CPF77) strcpy(flag, "-G2 -O2");
            else if (which == CPCC) strcpy(flag, "-G2 -O3");
            else strcpy(flag, "-G2 -O3 -Oa");
            break;
#if 0
         case TMEff:
            break;
         case IA64Itan:
            if (which == CPF77) strcpy(flag, "-G1 -O2");
            else if (which == CPCC) strcpy(flag, "-G1 -O3");
            else strcpy(flag, "-G1 -O3 -Oa");
            break;
#endif
         default:;
         }
      }
      else
      {
         switch(mach)
         {
         case IntPIII:
            if (which == CPF77) strcpy(flag, "-xK -O2 -mp1 -static");
            else if (which == CPCC) strcpy(flag, "-xK -O3 -mp1 -static");
            else strcpy(flag, "-xK -O2 -mp1 -static -fno-alias");
            break;
         case IntP4E:
         case IntP4E64:
            if (which == CPF77) strcpy(flag, "-xP -O2 -mp1 -static");
            else if (which == CPCC) strcpy(flag, "-xP -O3 -mp1 -static");
            else strcpy(flag, "-xP -O3 -mp1 -static -fno-alias");
            break;
         case IntP4:
            if (which == CPF77) strcpy(flag, "-xN -O2 -mp1 -static");
            else if (which == CPCC) strcpy(flag, "-xN -O3 -mp1 -static");
            else strcpy(flag, "-xN -O3 -mp1 -static -fno-alias");
            break;
         case IA64Itan2:
            if (which == CPF77) strcpy(flag, "-tpp2 -O2 -mp1 -static");
            else if (which == CPCC) strcpy(flag, "-tpp2 -O3 -mp1 -static");
            else strcpy(flag, "-tpp2 -O3 -mp1 -static -fno-alias");
            break;
#if 0
         case IA64Itan:
            if (which == CPF77) strcpy(flag, "-tpp1 -O2 -mp1 -static");
            else if (which == CPCC) strcpy(flag, "-tpp1 -O3 -mp1 -static");
            else strcpy(flag, "-tpp1 -O3 -mp1 -static -fno-alias");
            break;
#endif
         default:;
         }
      }
   }
/* 
 * See if we are using CVF
 */
   else if ( which == CPF77 && sugg && strstr(sugg, "ATLwin_vf") )
   {
      strcpy(comp, sugg);
      strcpy(flag, 
"-iface=nomixed_str_len_arg -fast -assume:accuracy_sensitive -fltconsistency");
   }
/*
 * See if we are using MVC
 */
   else if ( which == CPCC && sugg && strstr(sugg, "ATLwin_vc") )
   {
      if (mach == IntP4 || mach == IntP4E || mach == IntP4E64)
      {
         strcpy(comp, sugg);
         strcpy(flag, "-O2 -Oy -Op -Za -nologo");
      }
   }
   else
   {
      switch(mach)
      {
      case Dec21164:
      case Dec21264:
         if (which == CPF77)
         {
            if (OS == OSOSF1)
            {
               strcpy(comp, "f77");
               strcpy(flag, "-O5 -arch host -tune host");
               if (THREADS) strcat(flag, " -pthread");
            }
         }
         else
         {
            strcpy(comp, "gcc");
            if (which == CPMM)
               strcpy(flag, "-O1 -fschedule-insns -fschedule-insns2");
            else strcpy(flag, "-O3 -fomit-frame-pointer");
         }
         break;
      case HPPA20:
         if (OS == OSHPUX)
         {
            if (which == CPF77)
            {
               if (sugg && !strstr(sugg, "g77"))
               {
                  strcpy(comp, "f90");
                  strcpy(flag, "+O2");
               }
               else
               {
                  strcpy(comp, "g77");
                  strcpy(flag, "-mpa-risc-2-0 -O");
               }
            }
            else
            {
               if (sugg && !strstr(sugg, "gcc"))
               {
                  if (which == CPMM)
                     strcpy(comp, 
                "-Aa +O2 +Onoinitcheck +Odataprefetch +Optrs_strongly_typed");
                  else
                     strcpy(comp, "-D_INCLUDE_POSIX_SOURCE -DUseTimes -Aa +O2");
               }
               else
               {
                  strcpy(comp, "gcc");
                  strcpy(flag, "-mpa-risc-2-0 -O3");
               }
            }
         }
         else
         {
            if (which == CPF77)
            {
               strcpy(comp, "g77");
               strcpy(flag, "-mpa-risc-2-0 -O");
            }
            else
            {
               strcpy(comp, "gcc");
               strcpy(flag, "-mpa-risc-2-0 -O3");
            }
         }
         break;
      case HP9K735:
         if (OS == OSHPUX)
         {
            if (which == CPF77)
            {
               strcpy(comp, "f77");
               strcpy(flag, "+O2");
            }
            else
            {
               strcpy(comp, "cc");
               if (which == CPMM)
                  strcpy(comp, "-Aa +O2");
               else
                  strcpy(comp, "-D_INCLUDE_POSIX_SOURCE -DUseTimes -Aa +O4");
            }
         }
         break;
      case IbmPwr:
         if (which == CPF77)
         {
            strcpy(comp, "xlf");
            strcpy(flag, "-O3 -qmaxmem=-1 -qfloat=hsflt");
         }
         else
         {
            strcpy(comp, "xlc");
            strcpy(flag, "-O3 -qarch=pwr -qtune=pwr -qmaxmem=-1 -qfloat=hsflt");
         }
         break;
      case IbmTPwr2:
         if (which == CPF77)
         {
            strcpy(comp, "xlf");
            strcpy(flag, "-O3 -qmaxmem=-1 -qfloat=hsflt");
         }
         else
         {
            strcpy(comp, "xlc");
            if (which == CPCC)
               strcpy(flag, 
                      "-O3 -qarch=pwr2 -qtune=pwr2 -qmaxmem=-1 -qfloat=hsflt");
            else
               strcpy(flag,
    "-qarch=pwr2 -qtune=pwr2 -qmaxmem=-1 -qfloat=hsflt -qansialias -qfold -O");
         }
         break;
      case IbmPwr4:  /* yes, Pwr4 does better with pwr3 flags than with pwr4! */
      case IbmPwr3:
         if (which == CPF77)
         {
            strcpy(comp, "xlf");
            strcpy(flag, 
                   "-qtune=pwr3 -qarch=pwr3 -O3 -qmaxmem=-1 -qfloat=hsflt");
         }
         else
         {
            strcpy(comp, "xlc");
            if (which == CPCC)
               strcpy(flag, 
                      "-qtune=pwr3 -qarch=pwr3 -O3 -qmaxmem=-1 -qfloat=hsflt");
            else
               strcpy(flag,
          "-qtune=pwr3 -qarch=pwr3 -O3 -qmaxmem=-1 -qfloat=hsflt -qalias=allp");
         }
         break;
      case TMEff:
      case IntP5MMX:
      case IntPPRO:
      case IntPII:
      case IntPIII:
      case IntP4:
      case IntP4E:
      case IntP4E64:
      case AmdAthlon:
      case AmdHammer32:
      case AmdHammer64:
         if (which == CPF77)
         {
            if (OS == OSFreeBSD) strcpy(comp, "f77");
            else strcpy(comp, "g77");
            strcpy(flag, "-fomit-frame-pointer -O");
         }
         else
         {
            strcpy(comp, "gcc");
            if (mach == AmdHammer64 || mach == AmdHammer32)
               strcpy(flag, "-fomit-frame-pointer -O -mfpmath=387");
            else
            {
               if (which == CPCC)
                  strcpy(flag, "-fomit-frame-pointer -O3 -funroll-all-loops");
               else strcpy(flag, "-fomit-frame-pointer -O");
            }
         }
         if (Has64Bits)
         {
            if (Use64Bits) strcat(flag, " -m64");
            else strcat(flag, " -m32");
         }
         if (mach == TMEff) 
            strcat(flag, " -msse -msse2 -mfpmath=sse");
         break;
      case IA64Itan2:
/*
 *       If the user doesn't override, use Intel compiler on Itan2
 *       only override allowable is gcc/g77
 */
         if (sugg)
            if (!strstr(sugg, "g77") && !strstr(sugg, "gcc")) 
               sugg = NULL;
         if (!sugg)
         {
            if (which == CPF77)
            {
               strcpy(comp, "ifort");
               strcpy(flag, "-tpp2 -O2 -mp1 -static");
            }
            else
            {
               strcpy(comp, "icc");
               if (which == CPCC) strcpy(flag, "-tpp2 -O3 -mp1 -static");
               else strcpy(flag, "-tpp2 -O3 -mp1 -static -fno-alias");
            }
            break;
         }
         /* If user override, fall thru for same gcc settings as Itan1 */
      case IA64Itan:
         if (which == CPF77)
         {
            strcpy(comp, "g77");
            strcpy(comp, "-O");
         }
         else
         {
            strcpy(comp, "gcc");
            strcpy(flag, "-O3 -funroll-all-loops");
         }
         break;
#if 0  /* no longer have arch defaults */
      case SgiIP22:
         if (which == CPF77) strcpy(comp, "f77");
         else strcpy(comp, "cc");
         strcpy(flag, "-O2 -mips2 -Olimit 15000");
         break;
      case SgiIP32:
         if (which == CPF77)
         {
            strcpy(comp, "f77");
            strcpy(flag, 
  "-O3 -n32 -mips4 -OPT:Olimit=15000 -TARG:platform=ip32_5k -LNO:blocking=OFF");
         }
         else
         {
            strcpy(comp, "cc");
            strcpy(flag, "-O2 -n32 -mips4 -OPT:Olimit=15000 -TARG:platform=ip32_5k -LNO:blocking=OFF -LOPT:aliased=typed");
         }
         break;
      case SgiIP27:
#endif
      case SgiIP28:
      case SgiIP30:
         if (which == CPF77) strcpy(comp, "f77");
         else strcpy(comp, "cc");
         strcpy(flag, 
                "-O3 -64 -OPT:Olimit=15000 -LNO:blocking=OFF -TARG:platform=");
         if (mach == SgiIP28) strcat(flag, "IP28");
         else if (mach == SgiIP27) strcat(flag, "IP27");
         else strcat(flag, "IP30");
         if (which == CPMM) strcat(flag, " -LOPT:alias=typed");
         break;
      case SunUS1:   /* used to be same as SunUS2 */
      case SunUS2:
      case SunUS4:
      case SunUS5:
      case SunUSIII:
         if (OS == OSSunOS && !WANTGCC)
         {
            if (which == CPF77)
            {
               strcpy(comp, "f77");
               strcpy(flag, "-dalign -native -xO5");
            }
            else
            {
               strcpy(comp, "cc");
               if (which == CPCC)
                  strcpy(flag, "-dalign -fsingle -xO5 -native");
               else
                  strcpy(flag, "-dalign -fsingle -xO2 -native");
            }
         }
         else
         {
            if (which == CPF77)
            {
               strcpy(comp, "g77");
               strcpy(flag, "-O");
            }
            else
            {
               strcpy(comp, "gcc");
               if (which == CPCC)
                  strcpy(flag, 
                  "-mcpu=ultrasparc -mtune=ultrasparc -fomit-frame-pointer -O");
               else
                  strcpy(flag, 
                 "-mcpu=ultrasparc -mtune=ultrasparc -fomit-frame-pointer -O3");
            }
         }
         break;
      case PPC604e:
      case PPC604:
         if (OS == OSAIX && !WANTGCC)
         {
            if (which == CPF77)
               strcpy(comp, "xlf");
            else
               strcpy(comp, "xlc");
            if (which == CPMM)
               strcpy(flag, "-O -qarch=ppc -qtune=604 -qmaxmem=-1 -qfloat=hsflt -qproto -qansialias -qfold");
            else
               strcpy(flag, 
                      "-O3 -qarch=ppc -qtune=604 -qmaxmem=-1 -qfloat=hsflt");
         }
         else
         {
            if (which == CPF77)
            {
               strcpy(comp, "g77");
               strcpy(flag, "-O");
            }
            else
            {
               strcpy(comp, "gcc");
               if (which == CPCC)
                  strcpy(flag, "-fomit-frame-pointer -O3");
               else
                  strcpy(flag, "-fomit-frame-pointer -O");
            }
         }
         break;
      case PPCG4:
         if (which == CPF77)
         {
            strcpy(comp, "g77");
            strcpy(flag, "-O");
         }
         else
         {
            strcpy(comp, "gcc");
            if (which == CPCC)
               strcpy(flag, "-fomit-frame-pointer -O3");
            else
               strcpy(flag,
              "-fomit-frame-pointer -O2 -fschedule-insns -fno-schedule-insns2");
            if (OS == OSOSX && !WANTGCC)
            {
               strcpy(comp, "cc");
/*               strcat(flag, " -traditional-cpp -faltivec"); */
            }
         }
         break;
      case PPCG5:
         if (which == CPF77)
         {
            strcpy(comp, "g77");
            strcpy(flag, "-O -mcpu=970 -mtune=970");
         }
         else
         {
            strcpy(comp, "gcc");
            strcpy(flag, "-mcpu=970 -mtune=970 -O3");
         }
         if (Has64Bits)
         {
            if (Use64Bits) strcat(flag, " -m64");
            else strcat(flag, " -m32");
         }
         break;
      default:;
      }
/* 
 *    Don't actually give a crap about fortran, so allow user to suggest
 *    g77 without nullifying defaults
 */
      if (which == CPF77 && sugg)
      {
         strcpy(comp, sugg);
         strcpy(flag, "-O");
      }
   }
   if (THREADS)
   {
      if (strstr(comp, "xlc") || strstr(comp, "xlf")) strcat(comp, "_r");
      if (strstr(comp, "ifort"))
      {
         if (OSIsWin(OS))
            strcat(flag, " -reentrancy");
         else
            strcat(flag, " -reentrancy threaded");
      }
      if (OS == OSFreeBSD)
      {
         if (strstr(comp, "cc"))
            strcat(flag, " -pthread -D_REENTRANT -D_THREAD_SAFE");
         else strcat(flag, " -pthread");
      }
   }
@skip fprintf(stderr, "ArchDef which=%d, sugg=%s, comp=%s, flag='%s'\n",
@skip         which, sugg?sugg:"NULL", comp, comp+COMPLEN);
   return(*comp ? comp : NULL);
}

void GimmeWinComp(enum WCOMP which, char *comp)
{
   enum WINCOMP wc;
   if (!comp) return;
   wc = WCgcc;
   if (!strcmp(comp, "cvf")) wc = WCvf;
   else if (!strcmp(comp, "mvc")) wc = WCvc;
   else if (!strcmp(comp, "icl") || !strcmp(comp, "icc")) wc = WCic;
   else if (!strcmp(comp, "ifort")) wc = WCif;
   if (wc != WCgcc)
      assert(!CreateWinComp(wc));
   sprintf(comp, "ATLwin_%s", wcnam[wc]);
}

void GimmeCompInfo(enum OSTYPE OS, enum MACHTYPE mach, enum WCOMP which,
                   char *targ, char *comp, char *flag)
{
   char *sp;
   if (!comp) return;
   sp = GetDefCompInfo(OS, mach, which, *comp ? comp : NULL);
   if (!sp)
      sp = GetDefCompInfo(OS, mach, which, which == CPF77 ? "g77" : "gcc");
   if (!sp)
      sp = GuessCompInfo(OS, mach, which, targ, *comp ? comp : NULL);
   if (*comp == '\0')
      strcpy(comp, sp);
   if (flag && *flag == '\0') strcpy(flag, sp+COMPLEN);
}

int GetCompInfo(FILE *fpout, FILE *fplog, enum OSTYPE OS, enum MACHTYPE mach,
                enum ISAEXT isaX, char *targ, char *redir, char *TOPdir,
                char *F77, char *F77FLAGS, char *FLINK, char *FLFLAGS,
                char *FCLFLAGS, char *goodgcc,
                char *CC, char *CCFLAGS, char *CLINK, char *CLFLAGS, 
                char *MCC, char *MMFLAGS, char *BLASlib)
/*
 * Sets up good compiler flags for various OSs, and searches for the correct
 * compilers.  The compiler search should be improved so that it always takes
 * the newest release;  right now it simply takes the first compiler that
 * works with the desired flags.
 * CC & CCFLAGS are required;  other options may be set ptr to NULL, and
 * thus not probed.
 * RETURNS: 0 if no good gcc was found, 1 otherwise
 */
{
   int i, np;
   char *paths[16];
   char *CCG=NULL, *MCCG=NULL, *F77G=NULL;
   char gcc[256];
   int iret=1;

   np = 3;
   paths[0] = "/usr/bin/";
   paths[1] = "/usr/local/";
   paths[2] = "/opt/";

/*
 * Create windows compiler wrappers if required by user selection
 */
   if (OSIsWin(OS))
   {
      if (*CC)
         GimmeWinComp(CPCC, CC);
      if (MCC && *MCC)
         GimmeWinComp(CPMM, MCC);
      if (F77 && *F77)
         GimmeWinComp(CPF77, F77);
   }

   if (BLASlib && BLASlib[0] == '0')
   {
      *BLASlib = '\0';
      BLASlib = NULL;
   }
   if (goodgcc && goodgcc[0] != '\0') strcpy(gcc, goodgcc);
   else gcc[0] = '\0';
   GimmeCompInfo(OS, mach, CPCC, targ, CC, CCFLAGS);
   if (F77) GimmeCompInfo(OS, mach, CPF77, targ, F77, F77FLAGS);
   if (MCC) GimmeCompInfo(OS, mach, CPMM, targ, MCC, MMFLAGS);
   ATL_mprintf(2, fpout, fplog, 
               "Looking for compilers (this may take a while):\n");
   if ( FindGoodGcc(OS, mach, fpout, fplog, gcc) )
   {
      gcc[0] = '\0';
      iret = 0;
   }
   if (goodgcc) strcpy(goodgcc, gcc);
   if (gcc[0])
   {
      if ( strstr(CC, "gcc") ) strcpy(CC, gcc);
      if (MCC) { if ( strstr(MCC, "gcc") ) strcpy(MCC, gcc); }
   }
   if (CCG == NULL)
      CCG = TryComp(fpout, fplog, redir, 'c', np, paths, CC, CCFLAGS);
   if (CCG) strcpy(CC, CCG);
/*
 * If we've failed to find a working CC compiler, but we've found gcc, use
 * gcc instead
 */
   else if (*gcc)
   {
      strcpy(CC, "gcc");
      *CCFLAGS = '\0';
      GimmeCompInfo(OS, mach, CPCC, targ, CC, CCFLAGS);
      strcpy(CC, gcc);
   }

   if (MCC && MMFLAGS && MCCG == NULL)
   {
      MCCG = TryComp(fpout, fplog, redir, 'c', np, paths, MCC, MMFLAGS);
      if (MCCG) strcpy(MCC, MCCG);
      else if (*gcc)
      {
         *MMFLAGS = '\0';
         strcpy(MCC, "gcc");
         GimmeCompInfo(OS, mach, CPMM, targ, MCC, MMFLAGS);
         strcpy(MCC, gcc);
      }
   }
   if (F77G == NULL && F77)
   {
      F77G = TryComp(fpout, fplog, redir, 'f', np, paths, F77, F77FLAGS);
      if (F77G) strcpy(F77, F77G);
      else if (*gcc)
      {
         F77FLAGS = '\0';
         strcpy(F77, "g77");
         GimmeCompInfo(OS, mach, CPF77, targ, F77, F77FLAGS);
      }
   }
/*
 * Tack on altivec flags iff altivec has been detected
 */
   if (isaX == ISA_AV)
   {
      if (GccIsApple(CC))
         strcat(CCFLAGS, " -faltivec -no-cpp-precomp");
      else if (strstr(CC, "gcc"))
         strcat(CCFLAGS, " -maltivec -mabi=altivec");
      if (MCC && MMFLAGS)
      {
         if (GccIsApple(MCC))
            strcat(MMFLAGS, " -faltivec -no-cpp-precomp");
         else if (strstr(MCC, "gcc"))
               strcat(MMFLAGS, " -maltivec -mabi=altivec");
      }
   }
/*
 * Now that we have compilers, let's find out linker info
 */
   GetLinkInfo(OS, mach, F77, CC, FLINK, FLFLAGS, FCLFLAGS, CLINK, CLFLAGS);
/*
 * If requested, see if we can locate a comparison BLAS
 */
   if (F77 && BLASlib)
   {
      GetBlasTry(OS, mach, BLASlib);
      FindBlas(fpout, fplog, redir, F77, F77FLAGS, BLASlib);
   }
/*
 * If using a non-g77 Fortran under Windows, throw the -mno-cygwin for all gcc
 */
   if (OSIsWin(OS) && F77 && !strstr(F77, "g77"))
   {
      if (strstr(CC, "gcc"))
         strcat(CCFLAGS, " -mno-cygwin");
      if (MCC && strstr(MCC, "gcc"))
         strcat(MMFLAGS, " -mno-cygwin");
   }
/*
 * Strip stray whitespace from strings
 */
   KillBegEndSpaces(CC);
   KillBegEndSpaces(CCFLAGS);
   if (F77)
   {
      KillBegEndSpaces(F77);
      if (F77FLAGS) KillBegEndSpaces(F77FLAGS);
   }
   if (MCC)
   {
      KillBegEndSpaces(MCC);
      if (MMFLAGS) KillBegEndSpaces(MMFLAGS);
   }
   if (BLASlib) KillBegEndSpaces(BLASlib);

   if (F77) ATL_mprintf(2, fplog, fpout, "F77 = %s %s\n", F77, F77FLAGS);
   ATL_mprintf(2, fplog, fpout, "CC = %s %s\n", CC, CCFLAGS);
   if (MCC) ATL_mprintf(2, fplog, fpout, "MCC = %s %s\n\n", MCC, MMFLAGS);

   return(iret);
}

void GetArchDef(enum OSTYPE OS, enum MACHTYPE mach, char *arch, 
                char *CC, char *CCFLAGS, char *MCC, char *MMFLAGS,
                char *mmdef, char *def)
{
   char *mmc=NULL, *syc=NULL;
   char *sp=NULL, *mp=NULL;
   char *tack;
   int i;

/*
 * Make sure we have arch defaults for this compiler
 */
   mmdef[0] = def[0] = '\0';
   syc = NameFromPath(CC);
   if (!strcmp(syc, "xlc_r")) syc[3] = '\0';
   else if (strstr(syc, "ATLwin_"))
   {
      if (strstr(syc, "_icc")) strcpy(syc, "icc");
      else if (strstr(syc, "_vc")) strcpy(syc, "vc");
   }
   sprintf(  def, "$(TOPdir)/CONFIG/ARCHS/%s/%s/misc", arch, syc);
   if (!FileIsThere(def+10)) def[0] = '\0';

   mmc = NameFromPath(MCC);
   if (!strcmp(mmc, "xlc_r")) mmc[3] = '\0';
   else if (strstr(mmc, "ATLwin_"))
   {
      if (strstr(mmc, "_icc")) strcpy(mmc, "icc");
      else if (strstr(mmc, "_vc")) strcpy(mmc, "vc");
   }
   sprintf(mmdef, "$(TOPdir)/CONFIG/ARCHS/%s/%s/gemm", arch, mmc);
   if (!FileIsThere(mmdef+10)) mmdef[0] = '\0';
/*
 * If the user has changed flags on us, get reassurance arch defaults are
 * still valid
 */
   if (*def)
   {
      sp = GetDefCompInfo(OS, mach, CPCC, CC);
/*
 *    Remove tacked on info before comparison
 */
      tack = strstr(CCFLAGS, " -faltivec");
      if (!tack) tack = strstr(CCFLAGS, " -maltivec");
      if (tack) *tack = '\0';
      assert(sp);
      sp += COMPLEN;
      if (strcmp(CCFLAGS, sp))
      {
         fprintf(stdout, "\nYour CCFLAGS      : %s\n", CCFLAGS);
         fprintf(stdout,   "Config recommends : %s\n", sp);
         DisplayFile("CONFIG/UseCCFlagsDef.txt", stdout, 200);
         fprintf(stdout, "1. Quit install\n");
         fprintf(stdout, "2. Continue install without arch defaults\n");
         fprintf(stdout, "3. Use arch defaults anyway\n");
         i = GetIntRange(3, 1, 3, "", "your choice");
         if (i == 1) exit(-1);
         else if (i == 2) *def = '\0';
      }
      if (tack) *tack = ' ';
   }
   if (*mmdef)
   {
      sp = GetDefCompInfo(OS, mach, CPMM, MCC);
      assert(sp);
      tack = strstr(MMFLAGS, " -faltivec");
      if (!tack) tack = strstr(MMFLAGS, " -maltivec");
      if (tack) *tack = '\0';
      sp += COMPLEN;
      if (strcmp(MMFLAGS, sp))
      {
         fprintf(stdout, "\nYour MMFLAGS      : %s\n", MMFLAGS);
         fprintf(stdout,   "Config recommends : %s\n", sp);
         DisplayFile("CONFIG/UseCCFlagsDef.txt", stdout, 200);
         fprintf(stdout, "1. Quit install\n");
         fprintf(stdout, "2. Continue install without arch defaults\n");
         fprintf(stdout, "3. Use arch defaults anyway\n");
         i = GetIntRange(3, 1, 3, "", "your choice");
         if (i == 1) exit(-1);
         else if (i == 2) *mmdef = '\0';
      }
      if (tack) *tack = ' ';
/*
 *    atlas_install expects a default directory if we give it a MM dir,
 *    so put in bogus if we only have MM
 */
      if (!(*def))
         strcpy(def, mmdef);
   }
}

int RunASMProbe(char *asmnam, char *TOPdir, enum OSTYPE OS, char *targ)
{
   char ln[512], ln2[512];
   if (targ)
      sprintf(ln2, "cd CONFIG ; make IRun_%s mydir=%s/CONFIG atlrun=atlas_runX OSFLAGS=\"-DATL_OS_%s\" targ=%s 2> /dev/null | fgrep SUCCESS",
              asmnam, TOPdir, osnam[OS], targ);
   else
      sprintf(ln2, 
      "cd CONFIG ; make IRun_%s mydir=%s/CONFIG OSFLAGS=\"-DATL_OS_%s\" 2> /dev/null | fgrep SUCCESS",
              asmnam, TOPdir, osnam[OS]);
   if(!CmndOneLine(NULL, ln2, ln))
   {
      if (strstr(ln, "SUCCESS"))
      {
         fprintf(stdout, "   %s: DETECTED!\n", asmnam);
         return(1);
      }
   }
   fprintf(stdout, "   %s: NO.\n", asmnam);
   return(0);
}

int RunISAProbe(char *isaxnam, char *TOPdir, char *targ, char *opt)
{
   char ln[512], ln2[512];
   if (targ)
      sprintf(ln2, "cd CONFIG ; make IRun_%s mydir=%s/CONFIG atlrun=atlas_runX targ=%s %s 2> /dev/null | fgrep SUCCESS",
              isaxnam, TOPdir, targ, opt);
   else
      sprintf(ln2, 
              "cd CONFIG ; make IRun_%s mydir=%s/CONFIG %s 2> /dev/null | fgrep SUCCESS",
              isaxnam, TOPdir, opt);
   if(!CmndOneLine(NULL, ln2, ln))
   {
      if (strstr(ln, "SUCCESS"))
      {
         fprintf(stdout, "   %s: DETECTED!\n", isaxnam);
         return(1);
      }
   }
   fprintf(stdout, "   %s: NO.\n", isaxnam);
   return(0);
}

enum ISAEXT GetISAExt(char *targ, char *TOPdir)
{
   int i;

   fprintf(stdout, "\nProbing for supported ISA extensions:\n");

   if (RunISAProbe(ISAXNAM[0], TOPdir, targ, "CC=\"cc -faltivec\""))
      return(0);
   else if (RunISAProbe(ISAXNAM[0], TOPdir, targ, "CC=\"gcc -maltivec -mabi=altivec -DATL_AVgcc\""))
      return(0);
   else
   {
      for (i=1; i < ISA_None; i++)
      {
         if (RunISAProbe(ISAXNAM[i], TOPdir, targ, "")) return(i);
      }
   }
   return(ISA_None);
}

enum ISAEXT Has3DNow(char *targ, char *TOPdir)
/*
 * RETURNS if 
 */
{
   enum ISAEXT iret = ISA_None;
   if (RunISAProbe(ISAXNAM[ISA_3DNow2], TOPdir, targ, ""))
      iret = ISA_3DNow2;
   else if (RunISAProbe(ISAXNAM[ISA_3DNow1], TOPdir, targ, ""))
      iret = ISA_3DNow1;
   return(iret);
}

enum ASMDIA ProbeAsm(char *targ, char *TOPdir, 
                     enum OSTYPE OS, enum MACHTYPE mach)
{
   enum ASMDIA iret=ASM_None;
   int i;
   
   if (MachIsX86(mach)) iret = Use64Bits ? gas_x86_64 : gas_x86_32;
   else if (MachIsUS(mach)) iret = gas_sparc;
   else
   {
      for (i=0; i < ASM_None; i++)
         if (RunASMProbe(ASMNAM[i], TOPdir, OS, targ))
           iret = i;
   }
   return(iret);
}

int FlushMul(enum OSTYPE OS, enum MACHTYPE mach, char *targ, char *TOPdir)
/*
 * returns the multiplication factor of true cache size necessary to do
 * complete flush; this is essentially the associativity of the cache
 * if not known, returns 0
 */
{
   int imul=0;
   char ln[256], ln2[256];

   switch(OS)
   {
   case OSAIX :
      if (targ)
         sprintf(ln2, "cd CONFIG ; make IRunAixInfo mydir=%s/CONFIG atlrun=atlas_runX targ=%s | fgrep L2",
                 TOPdir, targ);
      else
         sprintf(ln2, "cd CONFIG ; make IRunAixInfo mydir=%s/CONFIG | fgrep L2",
                 TOPdir);
      if(!CmndOneLine(NULL, ln2, ln))
         imul = GetLastInt(ln);
      break;
   }
   if (imul == 0)
   {
      switch(mach)
      {
      case Dec21164:
      case AmdAthlon:
      case AmdHammer32:
      case AmdHammer64:
      case SunUS1:
      case SunUS2:
      case SunUSIII:
      case SunUS4:
      case SunUS5:
      case SunUSX:
      case IntP4:
      case IntP4E:
      case IntP4E64:
      case PPCG4:
      case IntPIII:
         imul = 2;
         break;
      case PPCG5:
         imul = 8;
         break;
      case IntP5:
      case IntP5MMX:
      case IntPPRO:
      case IntPII:
         imul = 1;
         break;
      default:
         imul = 2;
      }
   }
   return(imul);
}

int ProbeCacheSize(enum OSTYPE OS, enum MACHTYPE mach, char *targ, char *TOPdir)
/*
 * Returns size (in KB) of largest cache, returns 0 if OS cannot provide
 */
{
   int i, size=0;
   char ln[256], ln2[256], *sp, s2;

   switch(OS)
   {
   case OSLinux:
      if (mach == IntPII || mach == IntPIII || mach == IntPPRO || 
          mach == AmdAthlon || mach == AmdHammer32 || mach == AmdHammer64)
      {
         if( !CmndOneLine(targ, "fgrep 'cache size' /proc/cpuinfo", ln) )
         {
            size = GetLastInt(ln);
            for (i=0; ln[i]; i++);
            i--;
            while (i > 0 && isspace(ln[i])) i--;
            while (i > 0 && !isspace(ln[i])) i--;
            if (i > 0)
            {
               if (ln[i+1] == 'M') size *= 1024;
               else if (ln[i+1] != 'K') size = 0;
            }
            else size = 0;
         }
      }
      else if (mach == PPCG4 || mach == PPCG5)
      {
         if( !CmndOneLine(targ, "fgrep 'L2 cache' /proc/cpuinfo", ln) )
         {
            size = GetLastInt(ln);
         }
         else size = 0;
      }
      break;
   case OSOSF1:
      break;
   case OSIRIX:
      if(!CmndOneLine(targ, "hinv | fgrep Secondary | fgrep 'cache size'", ln))
      {
         if (sp = strstr(ln, " Mbyte"))
         {
            s2 = 1;
            sp--;
            while(isdigit(*sp)) sp--;
            sp++;
            sscanf(sp, "%d", &size);
            size *= 1024;
         }
         else if (sp = strstr(ln, " Kbyte"))
         {
            s2 = 1;
            sp--;
            while(isdigit(*sp)) sp--;
            sp++;
            sscanf(sp, "%d", &size);
         }
      }
      break;
   case OSAIX :
      if (targ)
         sprintf(ln2, "cd CONFIG; make IRunAixInfo mydir=%s/CONFIG atlrun=atlas_runX targ=%s | fgrep L2",
                 TOPdir, targ);
      else
         sprintf(ln2, "cd CONFIG; make IRunAixInfo mydir=%s/CONFIG | fgrep L2",
                 TOPdir);
      if(!CmndOneLine(NULL, ln2, ln)) size = GetFirstInt(ln+5) / 1024;
      break;
   case OSHPUX :
   case OSSunOS:
   case OSSunOS4:
   case OSWin9x:
   case OSWinNT:
   case OSFreeBSD:
   case OSOSX:
   default:
      size = 0;
   }
   return(size);
}

int GetCacheSize(enum OSTYPE OS,  enum MACHTYPE mach, char *targ, char *TOPdir,
                 int lvl, int *AmSure)
{
/*
 * Returns size of requested level of cache.  If *AmSure is 0, this is a max,
 * otherwise that machine only comes with that size of cache.  If lvl is < 0,
 * give me a safe size to flush (handling associativity and so forth)
 */
   int l1, l2, s1, s2;
   int lf1, lf2;
   char ln[512], *sp;

   if (lvl == -2)
   {
      l2 = ProbeCacheSize(OS, mach, targ, TOPdir);
      if (l2 > 0)
      {
         *AmSure = 1;
         l1 = FlushMul(OS, mach, targ, TOPdir);
         if (!l1) l1 = 2;
         return(l2*l1);
      }
   }
   switch(mach)
   {
   case MACHOther:
      l1 = l2 = s1 = s2 = 0;
      lf2 = 4096;
      break;
   case SunUSIII:
   case SunUS2:
   case SunUS4:
   case SunUS5:
      lf1 = l1 = 16;
      lf2 = l2 = 4096;
      s1 = 1;
      s2 = 0;
      break;
   case SunUS1:
      lf1 = l1 = 16;
      lf2 = l2 = 1024;
      s1 = 1;
      s2 = 0;
      break;
   case SunSS:
      lf1 = l1 = 32;
      lf2 = l2 = 1024;
      s1 = 1;
      s2 = 0;
      break;
   case SunMS:
      lf1 = l1 = 8;
      lf2 = l2 = l1;
      s1 = 1;
      s2 = 1;
      break;
   case SgiIP22:    /* R4600 */
      if (l2 == -1) lf2 = l2 = 128;
      lf1 = l1 = 16;
      s1 = 1;
      break;
   case SgiIP32:   /* R5K */
      if (l2 == -1) lf2 = l2 = 1024;
      l1 = 32;
      lf1 = 2*l1;
      s1 = 1;
      break;
   case SgiIP27:
   case SgiIP28:
   case SgiIP30:
      if (l2 == -1) lf2 = l2 = 4096;
      l1 = 32;
      lf1 = 2*l1;
      s1 = 1;
      break;
   case AmdAthlon:
   case AmdHammer32:
   case AmdHammer64:
      lf1 = l1 = 64;
      lf2 = l2 = 4096;
      s1 = 1;
      s2 = 0;
      break;
   case IA64Itan2:
      lf1 = l1 = 256;
      lf2 = l2 = 4096;
      s1 = 1;
      s2 = 0;
      break;
   case IA64Itan:
      lf1 = l1 = 96;  /* ignore actual L1, 'cause fpu doesn't use it */
      lf2 = l2 = 4096;
      break;
   case TMEff:
      lf1 = l1 = 64;
      lf2 = l2 = 1024;
      s1 = 1;
      s2 = 0;
      break;
   case IntPII:
   case IntPIII:
      lf1 = l1 = 16;
      lf2 = l2 = 512;
      s1 = 1;
      s2 = 0;
      break;
   case IntP4E:
   case IntP4E64:
      lf1 = l1 = 16;
      lf2 = l2 = 1024;
      s1 = 1;
      s2 = 0;
      break;
   case IntP4:
      lf1 = l1 = 64;
      lf2 = l2 = 512;
      s1 = 0;
      s2 = 0;
      break;
   case IntPPRO:
      lf1 = l1 = 8;
      lf2 = l2 = 1024;
      s1 = 1;
      s2 = 0;
      break;
   case IntP5MMX:
      lf1 = l1 = 16;
      lf2 = l2 = 1024;
      s1 = 1;
      s2 = 0;
      break;
   case IntP5:
      lf1 = l1 = 8;
      lf2 = l2 = 1024;
      s1 = 1;
      s2 = 0;
      break;
   case PPCG5:
      lf1 = l1 = 32;
      lf2 = l2 = 512;
@skip      lf1 *= 2;
@skip      lf2 *= 8;
      s1 = s2 = 1;
      break;
   case PPCG4:
   case PPC604e:
      l1 = 32;
      lf1 = 4*l1;
      lf2 = l2 = 4096;
      s1 = 1;
      s2 = 0;
      break;
   case PPC604:
      l1 = 16;
      lf1 = 4*l1;
      lf2 = l2 = 4096;
      s1 = 1;
      s2 = 0;
      break;
   case IbmPwr:
      l1 = 64;
      l2 = 64;
      lf2 = lf1 = 4*l1;
      s1 = 0;
      s2 = 0;
      break;
   case IbmWPwr2:
      l1 = 256;
      l2 = 256;
      lf2 = lf1 = 4*l1;
      s1 = 1;
      s2 = 1;
      break;
   case IbmTPwr2:
      l1 = 128;
      l2 = 128;
      lf2 = lf1 = 4*l1;
      s1 = 1;
      s2 = 1;
      break;
   case IbmPwr4:
      l1 = 32;
      lf2 = l2 = 8096;
      s1 = 1;
      s2 = 0;
      break;
   case IbmPwr3:
      l1 = 64;
      lf2 = l2 = 4096;
      s1 = 1;
      s2 = 0;
      break;
   case HP9K735:
      lf1 = l1 = 256;
      l2 = 256;
      lf2 = 4*l2;
      s1 = 1;
      s2 = 1;
      break;
   case HPPA20:
      lf1 = l1 = 4096;
      lf2 = l2 = 4096;
      s1 = 0;
      s2 = 0;
      break;
   case Dec21064:
      lf1 = l1 = 16;
      lf2 = l2 = 4096;
      s1 = 1;
      s2 = 0;
      break;
   case Dec21164:
      lf1 = l1 = 8;
      lf2 = l2 = 4096;
      s1 = 1;
      s2 = 0;
      break;
   default:
      l1 = l2 = s1 = s2 = 0;
      lf2 = 4096;
   }
   if (lvl == 1) 
   {
      if (AmSure) *AmSure = s1;
      return(l1);
   }
   else if (lvl == -1)
   {
      if (AmSure) *AmSure = s1;
      return(lf1);
   }
   else if (lvl == -2)
   {
      if (AmSure) *AmSure = s2;
      return(lf2);
   }
   else
   {
      if (AmSure) *AmSure = s2;
      return(l2);
   }
}

int ProbeNCPU(enum OSTYPE OS,  enum MACHTYPE mach, char *targ, char *TOPdir)
/*
 * Probes the OS for the number of CPUs.  Returns 0 if it can't
 * figure it out
 */
{
   char ln[256], ln2[256], *fnam;
   char unam;
   int ncpu=0;

   switch(OS)
   {
   case OSSunOS4: /* SunOS4 single proc, need SunOS5 for SMP, I think */
      ncpu = 1;
      break;
   case OSSunOS:
      sprintf(ln2, "%s -X | fgrep NumCPU", FindUname());
      if (!CmndOneLine(targ, ln2, ln))
         ncpu = GetFirstInt(ln);
      break;
   case OSFreeBSD:
   case OSOSX:
         if ( !CmndOneLine(targ, "sysctl hw.ncpu", ln) ) ncpu = GetLastInt(ln);
         break;
   case OSLinux:
      if (mach == Dec21264 || mach == Dec21164 || mach == Dec21064)
      {
         if ( !CmndOneLine(targ, "fgrep 'cpus detected' /proc/cpuinfo", ln) )
            ncpu = GetLastInt(ln);
      }
      else
      {
@skip         fnam = CmndResults(targ, "fgrep processor /proc/cpuinfo");
         fnam = CmndResults(targ, "grep '^processor' /proc/cpuinfo");
         if (fnam) ncpu = fNumLines(fnam);
      }
      break;
   case OSOSF1:
      if (!CmndOneLine(targ, "/usr/sbin/psrinfo -n", ln))
         ncpu = GetFirstInt(ln);
      break;
   case OSIRIX:
      if (!CmndOneLine(targ, "hinv | fgrep Processor | fgrep MHZ", ln))
         ncpu = GetFirstInt(ln);
      break;
   case OSAIX :
      if (targ) sprintf(ln2, "cd CONFIG ; make IRunAixInfo mydir=%s/CONFIG atlrun=atlas_runX targ=%s | fgrep ncpus", TOPdir, targ);
      else sprintf(ln2, "cd CONFIG ; make IRunAixInfo mydir=%s/CONFIG | fgrep ncpus", TOPdir);
      if ( !CmndOneLine(NULL, ln2, ln) ) ncpu = GetLastInt(ln);
      break;
   case OSHPUX:
      if (targ) sprintf(ln2,"cd CONFIG ; make IRunHpuxInfo mydir=%s/CONFIG atlrun=atlas_runX targ=%s | fgrep ncpus", TOPdir, targ);
      else sprintf(ln2,"cd CONFIG ; make IRunHpuxInfo mydir=%s/CONFIG | fgrep ncpus", TOPdir);
      if ( !CmndOneLine(NULL, ln2 ,ln) ) ncpu = GetLastInt(ln);
      break;
   case OSWin9x:
      ncpu = 1;
      break;
   case OSWinNT:
   default: 
      ncpu = 0;
   }
   return(ncpu);
}

int GetNCPU(enum OSTYPE OS, enum MACHTYPE mach, char *targ, char *TOPdir)
{
   int ncpu;

   ncpu = ProbeNCPU(OS, mach, targ, TOPdir);
   if (!ncpu)
   {
      DisplayFile("CONFIG/ncpu.txt", stdout, NLINES);
      ncpu = GetIntRange(0, 0, 64, "", "the number processors in system");
   }
   return(ncpu);
}

enum LINUXARCH ProbeLinuxArch(char *targ)
{
   enum LINUXARCH la=LAOTHER;
   char ln[256], ln2[256];
   char *unam;

   unam = FindUname();

   sprintf(ln2, "%s -m", unam);
   if ( !CmndOneLine(targ, ln2, ln) )
   {
      if (strstr(ln, "ppc") || strstr(ln, "Power Macintosh") ||
          strstr(ln, "powerpc")) la = LAPPC;
      else if (strstr(ln, "sparc")) la = LASPARC;
      else if (strstr(ln, "alpha")) la = LAALPHA;
      else if (strstr(ln, "ia64")) la = LAIA64;
      else if ( strstr(ln, "i686") || strstr(ln, "i586") ||
                strstr(ln, "i486") || strstr(ln, "i386") ||
                strstr(ln, "x86_64") ) la = LAX86;
   }
   return(la);
}

enum MACHTYPE ProbeArch(enum OSTYPE OS, int Has64Bits, char *targ, char *TOPdir)
/*
 * Probes OS for machine type, returns MACHOther on failure
 */
{
   enum MACHTYPE mach=MACHOther;
   enum LINUXARCH la;
   char *unam;
   int ierr, i;
   char ln[2048], ln2[2048];

/*
 * For 64-bit systems, see what lib the user wants to build
 */
@skip   if (mach == AmdHammer64)
/*
 * Probably most common case, so try x86 probe
 */
   if (Has64Bits)
      sprintf(ln, "-m64 -DATL_GAS_x8664 -DATL_OS_%s", osnam[OS]);
   else
      sprintf(ln, "-m32 -DATL_OS_%s", osnam[OS]);
   if (targ)
      sprintf(ln2, 
      "cd CONFIG ; make IRunx86Info mydir=%s/CONFIG atlrun=atlas_runX targ=%s OSFLAGS=\"%s\" | fgrep cpu",
              TOPdir, targ, ln);
   else
      sprintf(ln2, 
         "cd CONFIG ; make IRunx86Info mydir=%s/CONFIG OSFLAGS=\"%s\" | fgrep cpu", 
              TOPdir, ln);
   if ( !CmndOneLine(NULL, ln2, ln) )
   {
      mach = GetLastInt(ln);
      if (!Use64Bit)
      {
         if (mach == IntP4E64)
            mach = IntP4E;
         else if (mach = AmdHammer64)
            mach = AmdHammer32;
      }
      if (mach != MACHOther)
         return(mach);
   }

   unam = FindUname();
   sprintf(ln2, "%s -m", unam);
   switch(OS)
   {
   case OSFreeBSD:
   case OSOSX:
      la = ProbeLinuxArch(targ);
      switch(la)
      {
      case LAPPC: /* don't know */
         if (!CmndOneLine(targ, "sysctl hw.model", ln))
         {
            if (strstr(ln, "PowerMac"))
            {
               if (strstr(ln, "4")) mach = PPCG4;
               else if (strstr(ln, "3,3")) mach = PPCG4;
               else if (strstr(ln, "7,2")) mach = PPCG5;
            }
         }
         break;
      case LASPARC: /* don't know */
         break;
      case LAALPHA:
         if (!CmndOneLine(targ, "sysctl hw.model", ln))
         {
            if (strstr(ln, "433au")) mach = Dec21164;
            else if (strstr(ln, "XP1000")) mach = Dec21264;
         }
         break;
      case LAIA64: /* don't know */
         break;
      case LAX86:
         if (!CmndOneLine(targ, "sysctl hw.model", ln))
         {
            if (strstr(ln, "Pentium Pro")) mach = IntPPRO;
            else if (strstr(ln, "Pentium III")) mach = IntPIII;
            else if (strstr(ln, "Pentium II ")) mach = IntPII;
            else if (strstr(ln, "Athlon")) mach = AmdAthlon;
            else if (strstr(ln, "AMD-K7")) mach = AmdAthlon;
            else if (strstr(ln, "32 bit Hammer")) mach = AmdHammer32;
            else if (strstr(ln, "64 bit Hammer")) mach = AmdHammer64;
            else if (strstr(ln, "Pentium/P55C")) mach = IntP5MMX; /* sent by */
            else if (strstr(ln, "Pentium")) mach=IntP5;       /* Nakata Maho */
         }
         break;
      default:;
      }
      break;
   case OSLinux:
      la = ProbeLinuxArch(targ);
      switch(la)
      {
      case LAPPC:
         if ( !CmndOneLine(targ, "cat /proc/cpuinfo | fgrep cpu", ln2) )
         {
            if (strstr(ln2, "604e")) mach = PPC604e;
            else if (strstr(ln2, "604")) mach = PPC604;
            else if (strstr(ln2, "G4")) mach = PPCG4;
            else if (strstr(ln2, "7400")) mach = PPCG4;
            else if (strstr(ln2, "7410")) mach = PPCG4;
            else if (strstr(ln2, "7455")) mach = PPCG4;
            else if (strstr(ln2, "PPC970FX")) mach = PPCG5;
         }
         break;
      case LASPARC:  /* don't know here anymore */
         #if 0
         if ( !CmndOneLine(targ, "fgrep cpu /proc/cpuinfo", ln) )
         {
            if (strstr(ln, "UltraSparc II")) mach = SunUS2;
            else if (strstr(ln, "UltraSparc I")) mach = SunUS1;
            else if (strstr(ln, "UltraSparc")) mach = SunUSX;
         }
         #endif
         break;
      case LAALPHA:
         ln[0] = '\0';
         ierr = CmndOneLine(targ, "fgrep 'model name' /proc/cpuinfo", ln);
         if (ierr || ln[0] == '\0')
            ierr = CmndOneLine(targ, "fgrep model /proc/cpuinfo", ln);
         if (!ierr && ln[0] != '\0')
         {
            if (strstr(ln, "EV5")) mach = Dec21164;
            else if (strstr(ln, "EV4")) mach = Dec21064;
            else if (strstr(ln, "EV6")) mach = Dec21264;
         }
         break;
      case LAIA64:
         ln[0] = '\0';
         ierr = CmndOneLine(targ, "fgrep 'Itanium' /proc/cpuinfo", ln);
         if (ierr || ln[0] == '\0')
            ierr = CmndOneLine(targ, "fgrep model /proc/cpuinfo", ln);
         if (!ierr && ln[0] != '\0')
         {
            if (strstr(ln, "Itanium 2")) mach = IA64Itan2;
            else if (strstr(ln, "Itanium")) mach = IA64Itan;
         }
         break;
      case LAX86:
         ln[0] = '\0';
         ierr = CmndOneLine(targ, "fgrep 'model name' /proc/cpuinfo", ln);
         if (ierr || ln[0] == '\0')
            ierr = CmndOneLine(targ, "fgrep model /proc/cpuinfo", ln);
         if (!ierr && ln[0] != '\0')
         {
            if (strstr(ln, "Pentium"))
            { /* Pentium of some flavor */
               if (strstr(ln, " III ")) mach = IntPIII;
               else if (strstr(ln, " II ")) mach = IntPII;
               else if (strstr(ln, "Pro")) mach = IntPPRO;
               else if (strstr(ln, "MMX")) mach = IntP5MMX;
               else if (strstr(ln, " 4 "))
               {
                  ierr = CmndOneLine(targ,
                         "fgrep 'model' /proc/cpuinfo | fgrep -v 'name'", ln);
                  if (!ierr)
                  {
                     i = GetLastInt(ln);
                     if (i < 3) mach = IntP4;
                     else if (i == 3) mach = Use64Bits ? IntP4E64 : IntP4E;
                  }
               }
            }
            else if (strstr(ln, "Efficeon")) mach = TMEff;
            else if (strstr(ln, "Athlon HX")) mach = AmdHammer64;
            else if (strstr(ln, "Opteron") || strstr(ln, "Hammer") ||
                     strstr(ln, "Athlon(tm) 64"))
               mach = Use64Bits ? AmdHammer64 : AmdHammer32;
            else if (strstr(ln, "Athlon")) mach = AmdAthlon;
            else if (strstr(ln, "AMD-K7")) mach = AmdAthlon;
         }
         break;
      default:
         if (!CmndOneLine(targ, "fgrep 'cpu family' /proc/cpuinfo", ln))
            if (strstr(ln, "PA-RISC 2.0")) mach = HPPA20;
      }
      break;
   case OSSunOS:
      if (!CmndOneLine(targ, "/usr/sbin/psrinfo -v | fgrep sparcv9", ln))
      {
         if (!CmndOneLine(targ, "/usr/sbin/psrinfo -v | fgrep MHz", ln))
         {
            i = GetIntBeforeWord("MHz", ln);
            if (i != BADINT && i > 800) mach = SunUSIII;
         }
         else if (!CmndOneLine(targ, "/usr/sbin/psrinfo -v | fgrep GHz", ln))
         {
            if (strstr(ln, "GHz")) mach = SunUSIII;
         }
      }
      if (mach == MACHOther)
      {
         sprintf(ln2, "%s -i", unam);
         if( !CmndOneLine(targ, ln2, ln) )
         {
            if (strstr(ln, "SPARCstation-5")) mach = SunMS;
            else if (strstr(ln, "Ultra-1")) mach = SunUS1;
            else if (strstr(ln, "Ultra-2")) mach = SunUS2;
            else if (strstr(ln, "Ultra-4")) mach = SunUS4;
            else if (strstr(ln, "Ultra-5_")) mach = SunUS5;
            else if (strstr(ln, "Ultra-5\n")) mach = SunUS5;
            else if (strstr(ln, "Ultra")) mach = SunUSX;
         }
      }
      break;
   case OSSunOS4:
      if ( !CmndOneLine(targ, "sysinfo | fgrep CPU | fgrep MHz", ln) )
      {
         if (strstr(ln, "microSPARC")) mach = SunMS;
         else if (strstr(ln, "UltraSPARC"))
         {
            if( !CmndOneLine(targ, "sysinfo | fgrep Ultra", ln) )
            {
               if (strstr(ln, "Ultra-2")) mach = SunUS2;
               else if (strstr(ln, "Ultra-1")) mach = SunUS1;
               else if (strstr(ln, "Ultra")) mach = SunUSX;
            }
         }
         else if (strstr(ln, "Ultra-2")) mach = SunUS2;
         else if (strstr(ln, "Ultra-1")) mach = SunUS1;
         else if (strstr(ln, "Ultra")) mach = SunUSX;
      }
      break;
   case OSOSF1:
      if ( !CmndOneLine(targ, ln2, ln) ) 
      {
         if (strstr(ln, "alpha"))
         {
            ierr = CmndOneLine(targ, "/usr/sbin/pinfo -v | fgrep EV", ln);
            if (ierr)
            {
               ierr = CmndOneLine(targ, "/usr/sbin/psrinfo -v | fgrep EV", ln);
               if (ierr) ierr = CmndOneLine(targ, "psrinfo -v | fgrep EV", ln);
            }
            if (!ierr)
            {
               if (strstr(ln, "EV6")) mach = Dec21264;
               else if (strstr(ln, "EV5")) mach = Dec21164;
               else if (strstr(ln, "EV4")) mach = Dec21064;
            }
         }
      }
      break;
   case OSIRIX:
      if ( !CmndOneLine(targ, ln2, ln) ) 
      {
         if (strstr(ln, "IP28")) mach = SgiIP28;
         else if (strstr(ln, "IP27")) mach = SgiIP27;
         else if (strstr(ln, "IP22")) mach = SgiIP22;
         else if (strstr(ln, "IP32")) mach = SgiIP32;
         else if (strstr(ln, "IP30")) mach = SgiIP30;
      }
      break;
   case OSAIX :
      if (targ)
         sprintf(ln2, "cd CONFIG ; make IRunAixInfo mydir=%s/CONFIG atlrun=atlas_runX targ=%s | fgrep 'CPU type'", TOPdir, targ);
      else
         sprintf(ln2, 
            "cd CONFIG ; make IRunAixInfo mydir=%s/CONFIG | fgrep 'CPU type'", 
                 TOPdir);
      if ( !CmndOneLine(NULL, ln2, ln) )
      {
         if (strstr(ln, "PowerPC"))
         {
            if (strstr(ln, "604e")) mach = PPC604e;
            else if (strstr(ln, "604") && !strstr(ln, "UNKNOWN")) mach = PPC604;
            else if (strstr(ln, "PowerPC 630")) mach = IbmPwr3;
         }
         else if (strstr(ln, "Power"))
         {
            if (strstr(ln, "Power2")) mach= IbmTPwr2;
            else if (strstr(ln, "Power1")) mach = IbmPwr;
            else if (strstr(ln, "Power4")) mach = IbmPwr4;
         }
      }
      break;
   case OSHPUX:
      if(!CmndOneLine(targ, ln2, ln))
      {
         if (strstr(ln, "9000/735")) mach=HP9K735;
      }
/*
 *    I can't distinguish between Itan1 & Itan2 with these methods, so
 *    only look for PA-RISC machines
 */
      if (mach == MACHOther  && !CmndOneLine(targ, "file /stand/vmunix", ln))
      {
         if (strstr(ln, "PA-RISC 2.0")) mach = HPPA20;
      }

@beginskip
      if (mach == MACHOther !CmndOneLine(targ, "model", ln))
      {
         if (strstr(ln, "A400-36")) mach = HPPA20;
         else if (strstr(ln, "/A400-44")) mach = HPPA20;
         else if (strstr(ln, "/A400-5X")) mach = HPPA20;
         else if (strstr(ln, "/A400-7X")) mach = HPPA20;
         else if (strstr(ln, "/A400-8X")) mach = HPPA20;
         else if (strstr(ln, "/A500-36")) mach = HPPA20;
         else if (strstr(ln, "/A500-55")) mach = HPPA20;
         else if (strstr(ln, "/A500-5X")) mach = HPPA20;
         else if (strstr(ln, "/A500-7X")) mach = HPPA20;
         else if (strstr(ln, "/A500-8X")) mach = HPPA20;
         else if (strstr(ln, "/B1000")) mach = HPPA20;
         else if (strstr(ln, "/B2000")) mach = HPPA20;
         else if (strstr(ln, "/B2600")) mach = HPPA20;
         else if (strstr(ln, "/C180")) mach = HPPA20;
         else if (strstr(ln, "/C200+")) mach = HPPA20;
         else if (strstr(ln, "/C240+")) mach = HPPA20;
         else if (strstr(ln, "/C360")) mach = HPPA20;
         else if (strstr(ln, "/C3000")) mach = HPPA20;
         else if (strstr(ln, "/C3600")) mach = HPPA20;
         else if (strstr(ln, "/C3700")) mach = HPPA20;
         else if (strstr(ln, "/C3750")) mach = HPPA20;
         else if (strstr(ln, "/D270")) mach = HPPA20;
         else if (strstr(ln, "/D280")) mach = HPPA20;
         else if (strstr(ln, "/D370")) mach = HPPA20;
         else if (strstr(ln, "/D380")) mach = HPPA20;
         else if (strstr(ln, "/D390")) mach = HPPA20;
         else if (strstr(ln, "/D650")) mach = HPPA20;
         else if (strstr(ln, "/J220")) mach = HPPA20;
         else if (strstr(ln, "/J2240")) mach = HPPA20;
         else if (strstr(ln, "/J280")) mach = HPPA20;
         else if (strstr(ln, "/J400")) mach = HPPA20;
         else if (strstr(ln, "/J410")) mach = HPPA20;
         else if (strstr(ln, "/J5000")) mach = HPPA20;
         else if (strstr(ln, "/J5600")) mach = HPPA20;
         else if (strstr(ln, "/J6000")) mach = HPPA20;
         else if (strstr(ln, "/J6700")) mach = HPPA20;
         else if (strstr(ln, "/J6750")) mach = HPPA20;
         else if (strstr(ln, "/J7000")) mach = HPPA20;
         else if (strstr(ln, "/J7600")) mach = HPPA20;
      }
@endskip
      break;
   case OSWin9x:
   case OSWinNT:
   default:;
   }
   if (mach == SunUSX) mach =SunUS2;
   return(mach);
}

enum MACHTYPE Getx86Arch(char *targ, char *unam)
{
   char ln[256], ln2[256];
   int i, j;
   enum MACHTYPE mach=MACHOther;

   j = 0;
   sprintf(ln2, "%s -m", unam);
   ln[0] = '\0';
   i = CmndOneLine(targ, ln2, ln);
   if (i || ln[0] == '\0' || strstr(ln, "i586") || strstr(ln, "i486") || 
            strstr(ln, "i386"))
   {
      fprintf(stdout, "Enter your machine type:\n");
      fprintf(stdout, "   1. Other/UNKNOWN\n\n");
      fprintf(stdout, "   2. AMD Athlon\n");
      fprintf(stdout, "   3. 32 bit AMD Hammer\n");
      fprintf(stdout, "   4. 64 bit AMD Hammer\n");
      fprintf(stdout, "   5. Pentium PRO\n");
      fprintf(stdout, "   6. Pentium II\n");
      fprintf(stdout, "   7. Pentium III\n");
      fprintf(stdout, "   8. Pentium 4\n");
      fprintf(stdout, "   9. Pentium 4E (prescott)\n");
      fprintf(stdout, "  10. Pentium 4E EM64T\n");
      fprintf(stdout, "  11. Transmeta Efficeon\n");
      fprintf(stdout, "  12. Pentium \n");
      fprintf(stdout, "  13. Pentium MMX\n");
      fprintf(stdout, "  14. IA-64 Itanium 1\n");
      fprintf(stdout, "  15. IA-64 Itanium 2\n");
      j = 15;
   }
   else if (strstr(ln, "ia64"))
   {
      fprintf(stdout, "Enter your machine type:\n");
      fprintf(stdout, "   1. Other/UNKNOWN\n");
      fprintf(stdout, "   2. IA-64 Itanium 1\n");
      fprintf(stdout, "   3. IA-64 Itanium 2\n");
      i = GetIntRange(1, 1, 3, "", "machine number");
      if (i == 2) mach = IA64Itan;
      else if (i == 3) mach = IA64Itan2;
      else mach = MACHOther;
   }
   else if (strstr(ln, "x86_64"))
   {
      fprintf(stdout, "Enter your machine type:\n");
      fprintf(stdout, "   1. Other/UNKNOWN\n");
      fprintf(stdout, "   2. 32 bit AMD Hammer\n");
      fprintf(stdout, "   3. 64 bit AMD Hammer\n");
      fprintf(stdout, "   4. 32 bit Intel P4E\n");
      fprintf(stdout, "   5. 64 bit Intel P4E\n");
      i = GetIntRange(1, 1, 5, "", "machine number");
      if (i == 2) mach = AmdHammer32;
      else if (i == 3) mach = AmdHammer64;
      else if (i == 4) mach = IntP4E;
      else if (i == 5) mach = IntP4E64;
      else mach = MACHOther;
   }
   else if (strstr(ln, "i686"))
   {
      fprintf(stdout, "Enter your machine type:\n");
      fprintf(stdout, "   1. Other/UNKNOWN\n");
      fprintf(stdout, "   2. AMD Athlon\n");
      fprintf(stdout, "   3. 32 bit AMD Hammer\n");
      fprintf(stdout, "   4. 64 bit AMD Hammer\n");
      fprintf(stdout, "   5. Pentium PRO\n");
      fprintf(stdout, "   6. Pentium II\n");
      fprintf(stdout, "   7. Pentium III\n");
      fprintf(stdout, "   8. Pentium 4\n");
      fprintf(stdout, "   9. Pentium 4E (prescott)\n");
      fprintf(stdout, "  10. Transmeta Efficeon\n");
      j = 10;
   }
   if (j > 0)
   {
      i = GetIntRange(1, 1, j, "", "machine number");
      if (i == 1) mach = MACHOther;
      else if (i == 2) mach = AmdAthlon;
      else if (i == 3) mach = AmdHammer32;
      else if (i == 4) mach = AmdHammer64;
      else if (i == 5) mach = IntPPRO;
      else if (i == 6) mach = IntPII;
      else if (i == 7) mach = IntPIII;
      else if (i == 8) mach = IntP4;
      else if (i == 9) mach = IntP4E;
      else if (i == 10) mach = Use64Bits ? IntP4E64 : IntP4E;
      else if (i == 11) mach = TMEff;
      else if (i == 12) mach = IntP5;
      else if (i == 13) mach = IntP5MMX;
      else if (i == 14) mach = IA64Itan;
      else if (i == 15) mach = IA64Itan2;
      else mach = MACHOther;
   }
   return(mach);
}

enum MACHTYPE GetArch(FILE *fpout, FILE *fplog, enum OSTYPE OS, 
                      int Has64Bits, char *targ, char *TOPdir)
{
   char ln[512], ln2[512];
   int i, j, ierr;
   enum MACHTYPE mach=MACHOther;
   enum LINUXARCH la;
   char *unam=FindUname();

   ATL_mprintf(2, fplog, fpout, "Probing for architecture:\n");
   mach = ProbeArch(OS, Has64Bits, targ, TOPdir);
   if (mach != MACHOther)
   {
      ATL_mprintf(2, fplog, fpout, "Architecture is set to %s\n\n", 
                  machnam[mach]);
      return(mach);
   }

   switch(OS)
   {
   case OSFreeBSD:
   case OSLinux:
   case OSOSX:
      la = ProbeLinuxArch(targ);
      switch(la)
      {
      case LAIA64:
         fprintf(stdout, "Enter your machine type:\n");
         fprintf(stdout, "   1. IA-64 Itanium 1\n");
         fprintf(stdout, "   2. IA-64 Itanium 2\n");
         fprintf(stdout, "   3. Other/UNKNOWN\n");
         i = GetIntRange(3, 1, 2, "", "machine number");
         if (i == 1) mach = IA64Itan;
         else if (i == 2) mach = IA64Itan2;
         break;
      case LAPPC:
         fprintf(stdout, "Enter your machine type:\n");
         fprintf(stdout, "   1. PowerPC 604e\n");
         fprintf(stdout, "   2. PowerPC 604\n");
         fprintf(stdout, "   3. PowerPC G4 (7400)\n");
         fprintf(stdout, "   4. PowerPC G5 (970FX)\n");
         fprintf(stdout, "   5. Other/UNKNOWN\n");
         i = GetIntRange(5, 1, 5, "", "machine number");
         if (i == 1) mach = PPC604e;
         else if (i == 2) mach = PPC604;
         else if (i == 3) mach = PPCG4;
         else if (i == 4) mach = PPCG5;
         break;
      case LASPARC:
         fprintf(stdout, "Enter your machine type:\n");
         fprintf(stdout, "   1. Ultra-1\n");
         fprintf(stdout, "   2. Ultra-2\n");
         fprintf(stdout, "   3. Ultra-4\n");
         fprintf(stdout, "   4. Ultra-5/10\n");
         fprintf(stdout, "   5. UltraSparc III\n");
         fprintf(stdout, "   6. Other UltraSparc\n");
         fprintf(stdout, "   7. Other/UNKNOWN\n");
         i = GetIntRange(6, 1, 6, "", "machine number");
         if (i == 1) mach = SunUS1;
         else if (i == 2) mach = SunUS2;
         else if (i == 3) mach = SunUS4;
         else if (i == 4) mach = SunUS5;
         else if (i == 5) mach = SunUSIII;
         else if (i == 6) mach = SunUSX;
         break;
      case LAALPHA:
         fprintf(stdout, "Enter your machine type:\n");
         fprintf(stdout, "   1. DEC ALPHA 21064\n");
         fprintf(stdout, "   2. DEC ALPHA 21164 (ev5/ev56)\n");
         fprintf(stdout, "   3. DEC ALPHA 21264 (ev6)\n");
         fprintf(stdout, "   4. Other/UNKNOWN\n");
         i = GetIntRange(4, 1, 4, "", "machine number");
         if (i == 1) mach = Dec21064;
         else if (i == 2) mach = Dec21164;
         else if (i == 3) mach = Dec21264;
         break;
      case LAX86:
         mach = Getx86Arch(targ, unam);
      }
      break;
   case OSHPUX:
      if (!CmndOneLine(targ, "uname -m", ln))
      {
         if (strstr(ln, "ia64"))
         {
            fprintf(stdout, "Enter your machine type:\n");
            fprintf(stdout, "   1. Itanium 1\n");
            fprintf(stdout, "   2. Itanium 2\n");
            fprintf(stdout, "   3. Other/UNKNOWN\n");
            i = GetIntRange(3, 1, 3, "", "machine number");
            if (i == 1) mach = IA64Itan;
            else if (i == 2) mach = IA64Itan2;
         }
         else
         {
            fprintf(stdout, "Enter your machine type:\n");
            fprintf(stdout, "   1. HP9000/735\n");
            fprintf(stdout, "   2. HP PA-RISC 2.0\n");
            fprintf(stdout, "   3. Other/UNKNOWN\n");
            i = GetIntRange(3, 1, 3, "", "machine number");
            if (i == 1) mach = HP9K735;
            else if (i == 2) mach = HPPA20;
         }
      }
      if (mach == MACHOther)
      {
         fprintf(stdout, "Enter your machine type:\n");
         fprintf(stdout, "   1. HP9000/735\n");
         fprintf(stdout, "   2. HP PA-RISC 2.0\n");
         fprintf(stdout, "   3. Itanium 1\n");
         fprintf(stdout, "   4. Itanium 2\n");
         fprintf(stdout, "   5. Other/UNKNOWN\n");
         i = GetIntRange(5, 1, 5, "", "machine number");
         if (i == 1) mach = HP9K735;
         else if (i == 2) mach = HPPA20;
         if (i == 3) mach = IA64Itan;
         else if (i == 4) mach = IA64Itan2;
      }
      break;
   case OSSunOS4:
      fprintf(stdout, "Running trusty old SunOS 4 (hey, is that a Nehru jacket you're wearing), I see.\n");
      fprintf(stdout, 
         "Since SunOS 4 is silent on the subject, what chip do you have:\n");
      fprintf(stdout, 
"   1. UltraSparc\n   2. SuperSparc 1/2\n   3. MicroSparc\n  4. Other/UNKNOWN\n");
      i = GetIntRange(4, 1, 4, "", "chip number");
      if (i == 1) mach = SunUS2;
      else if (i == 2) mach = SunSS;
      else if (i == 3) mach = SunMS;
      break;
   case OSSunOS:
/*      assert(0); */
      break;
   case OSOSF1:
      mach = MACHOther;
         fprintf(stdout, "Looks like you are compiling OSF1/Tru64.\n");
         fprintf(stdout, "Choose model:\n");
         fprintf(stdout, "   1. Alpha 21064\n");
         fprintf(stdout, "   2. Alpha 21164 (ev5/ev56)\n");
         fprintf(stdout, "   3. Alpha 21264 (ev6)\n");
         fprintf(stdout, "   4. Other/UNKNOWN\n\n");
         i = GetIntRange(4, 1, 4, "", "machine number");
         if (i == 1) mach = Dec21064;
         else if (i == 2) mach = Dec21164;
         else if (i == 3) mach = Dec21264;
      break;
   case OSIRIX:
/*      assert(0); */
      break;
   case OSAIX:  /* don't even think about translating IBM's wild-ass uname */
      fprintf(stdout, "Here are the preconfigured ATLAS choices for AIX:\n");
      fprintf(stdout, "   1. IBM Power\n");
      fprintf(stdout, "   2. IBM Thin-node, Power2\n");
      fprintf(stdout, "   3. IBM PowerPC 604\n");
      fprintf(stdout, "   4. IBM PowerPC 604e (silver node)\n");
      fprintf(stdout, "   5. IBM Power3\n");
      fprintf(stdout, "   6. IBM Power4\n");
      fprintf(stdout, "   7. Other/UNKNOWN\n\n");
      i = GetIntRange(6, 1, 6, "", "machine number");
      if (i == 1) mach = IbmPwr;
      else if (i == 2) mach = IbmTPwr2;
      else if (i == 3) mach = PPC604;
      else if (i == 4) mach = PPC604e;
      else if (i == 5) mach = IbmPwr3;
      else if (i == 6) mach = IbmPwr4;
      else mach = MACHOther;
      break;
   case OSWin9x:
   case OSWinNT:
      mach = Getx86Arch(targ, unam);
      break;
   case OSOther:
      break;
   }
   ATL_mprintf(2, fplog, fpout, "Architecture is set to %s\n\n", machnam[mach]);
   return(mach);
}

void GetPmake(enum OSTYPE OS, int ncpu, char *pmake)
{
   if (ncpu == 0) ncpu = 1;
   if (!OSIsWin(OS)&&CmndResults(NULL, "make DoNothing --version | fgrep GNU"))
   { /* using gnu make */
      if (ncpu == 1) sprintf(pmake, "$(MAKE) -j 2");
      else sprintf(pmake, "$(MAKE) -j %d", ncpu);
   }
   else
   {  /* AIX, HP-UX, SunOS make do not have parallel option */
      switch(OS)
      {
      case OSIRIX:
         strcpy(pmake, "$(MAKE) -P");
         break;
      case OSFreeBSD:
         if (ncpu == 1) sprintf(pmake, "$(MAKE) -j 2");
         else sprintf(pmake, "$(MAKE) -j %d", ncpu);
         break;
      default:
         strcpy(pmake, "$(MAKE)");
      }
   }
}

char *GetXCompTarg(FILE *fpout0, FILE *fplog, char *targnam)
{
   char *targ=NULL;
   char ln[512];
   int ierr;
   FILE *fpout;

   fprintf(stdout, "\n\nI need to know if you are using a cross-compiler (i.e., you are compiling on\n");
   fprintf(stdout, 
      "a different architecture than you want the library built for).\n\n");
   targnam[0] = '\0';
   if (IsYes('n', "", "Are you using a cross-compiler?"))
   {
      DisplayFile("CONFIG/xcomp.txt", stdout, NLINES);
      do
      {
         GetStrVer(targnam, "", "name of target machine", 511, targnam);
         fprintf(stdout, "\n\nTRYING TO ssh %s\n", targnam);
         sprintf(ln, "ssh %s \"ls\"", targnam);
         ierr = system(ln);
         if (ierr) DisplayFile("CONFIG/xcomp-err.txt", stdout, NLINES);
         else fprintf(stdout, "\n\nssh successful!\n\n");
         ATL_mprintf(2, stdout, fplog, 
                     "Using cross compiler, spawning runs to %s.\n\n", targnam);
      }
      while (ierr);
      targ = targnam;
      fpout = fopen("CONFIG/Make.inc", "w");
      assert(fpout);
      fprintf(fpout, 
         "atlas_run:\n\tssh %s \"cd $(atldir) ; ./$(exe) $(args) > $(redir)\"\n",
              targnam);
   }
   else
   {
      fpout = fopen("CONFIG/Make.inc", "w");
      assert(fpout);
      fprintf(fpout, "atlas_run:\n\tcd $(atldir) ; ./$(exe) $(args) > $(redir)\n");
   }
   fclose(fpout);
   return(targ);
}

enum USERGEMM GetUserMM(enum OSTYPE OS, enum MACHTYPE mach,
                        char *UMMdir0, char *UMMdef0)
{
   enum USERGEMM iret=UG_None;

   strcpy(UMMdir0, "$(GMMdir)");
   UMMdef0[0] = '\0';

   switch(mach)
   {
   case Dec21164 :
   case Dec21264 :
/*
 *    This is a cheap workaround to Linux_21164GOTO error, forcing use
 *    of the non-goto defaults on such a platform
 */
      if (mach != Dec21164 || OS != OSLinux)
      {
      DisplayFile("CONFIG/gotogemm.txt", stdout, NLINES);
      if (IsYes('y', "", "Use Goto GEMM for Compaq/DEC alpha speedup?"))
      {
         strcpy(UMMdir0, "$(TOPdir)/src/blas/gemm/GOTO/$(ARCH)");
         if (mach == Dec21164) strcpy(UMMdef0, "-DEV5");
         else if (mach == Dec21264) strcpy(UMMdef0, "-DEV6");
         iret = UG_GOTO;
      }
      }
      break;
   default:;
   }
   return(iret);
}

#define CF_ARCHDEF      0x1
#define CF_CREATEDIRS   0x2
#define CF_CREATEATLRUN 0x4
#define CF_CREATEWINF77 0x8
#define CF_STOREL1      0xA
#define CF_MOVELOG      0x10

void GoToTown(int flag, enum MACHTYPE mach, int ncpu, char *TOPdir, char *ARCH,
              char *BLASlib, char *F77, char *F77FLAGS, char *CC, char *CCFLAGS,
              char *MCC, char *MMFLAGS, char *GOODGCC, 
              char *XCC, char *XCCFLAGS, char *UCDEF)
{
   char ARCH0[128], LIBdir[256], ATLASlib[256];
   char UMMdir[256], UMMdef[256];
   char CBLASlib[256], PTCBLASlib[256];
   char F77BLASlib[256], PTF77BLASlib[256];
   int L1SIZE=(-1), L2SIZE, BADMCC=0;
   char F2CDEFS[256];
   char FLINKER[128], CLINKER[128], ARCHIVER[128], RANLIB[128];
   char CLINKFLAGS[512], FLINKFLAGS[512], ARFLAGS[256], FCLINKFLAGS[512];
   char LIBS[256];
   char TAR[256], GZIP[256], GUNZIP[256], PMAKE[128];

   char comp[64], cflg[512], ln[512], tnam[256], archdef[256], mmdef[256];
   char BC[256], BCFLAGS[256];
   int GOGO=0, L2IsKnown=0, Use3DNow=0, TuneL1=1; 
   int USEDEFL1=0;
   int ierr, i, j, SOLERR=0, np=2, delay=0;
   char *paths[2] = {"/usr/bin/", "/usr/local/"};
   char *sp, *targ;
   enum OSTYPE OS=OSOther, XOS=OSOther;
   enum MACHTYPE Xmach;
   enum F2CNAME f2cnam;
   enum F2CINT f2cint;
   enum F2CSTRING f2cstr;
   enum ISAEXT ISAX;
   enum ASMDIA ASMD;
   enum USERGEMM USERMM=UG_None;
   FILE *fpout, *fplog, *fps[2];
   const char *lognam="ConfSummary.log", *dmpnam="ConfDump.log";
   char redir[128];
   sprintf(redir, ">> %s 2>&1", dmpnam);

   F2CDEFS[0] = '\0';
   remove(dmpnam);
   fplog = fopen(lognam, "w");
   fps[0] = stdout;
   fps[1] = fplog;
   assert(fplog);
   assert(tmpnam(tnam));
   ATL_mprintf(2, fplog, stdout, "ATLAS@(ver) configure started.\n\n");
   NLINES = GetScreenHeight();

   DisplayFile("CONFIG/errata.txt", stdout, NLINES);
   if (!IsYes('y', "", "Have you scoped the errata file?")) exit(-1);
   DisplayFile("CONFIG/init.txt", stdout, NLINES);
   if (!IsYes('y', "", "Are you ready to continue?")) exit(-1);

/*
 * It doesn't seem to quite work right anymore, rsh is no longer available,
 * and ssh-based is sloooooowww, so just disable cross-compilation for now
 * Need to replace with version that doesn't require shared filesystem anyway
 */
#if 0
   targ = GetXCompTarg(stdout, fplog, TARGNAM);
#else
   targ = NULL;
#endif
   if (targ) XCOMP = 1;
/* 
 * Set up some good defaults
 */
   if (TOPdir[0] == '\0')
   {
      i = CmndOneLine(targ, "pwd", ln);
      if (i || ln[0] == '\0')
      {
         sp = getenv("PWD");
         if (sp) strcpy(TOPdir, sp);
         else strcpy(TOPdir, "$(HOME)/ATLAS");
      }
      else
      {
         for (i=0; TOPdir[i] = ln[i]; i++);
         i--;
         while(Mciswspace(TOPdir[i])) i--;
         TOPdir[i+1] = '\0';
      }
   }
   strcpy(LIBdir, "$(TOPdir)/lib/$(ARCH)");
   strcpy(ATLASlib, "libatlas.a");
   strcpy(F77BLASlib, "libf77blas.a");
   strcpy(CBLASlib, "libcblas.a");
   strcpy(PTCBLASlib, "libptcblas.a");
   strcpy(PTF77BLASlib, "libptf77blas.a");
   strcpy(ARCHIVER, "ar");
   strcpy(ARFLAGS, "r");
   strcpy(RANLIB, "echo");
   L2SIZE = MAXL2SIZE;

   OS = GetOS(stdout, fplog, targ);
   Has64Bits = ArchIs64(targ, TOPdir, OS);
   if (Has64Bits)
   {
      fprintf(stdout, "Select pointer width and ABI for 64 bit system:\n");
      fprintf(stdout, "   1. 32 bit libraries\n");
      fprintf(stdout, "   2. 64 bit libraries\n");
      i = GetIntRange(2, 1, 2, "", "bit number");
      if (i == 2) Use64Bits = 1;
      else Use64Bits = 0;
   }
   ISWIN = OSIsWin(OS);
   if (mach == MACHOther)
      mach = GetArch(stdout, fplog, OS, Has64Bits, targ, TOPdir);
   ASMD = ProbeAsm(targ, TOPdir, OS, mach);
   ISAX = GetISAExt(targ, TOPdir);
   USERMM = GetUserMM(OS, mach, UMMdir, UMMdef);
   if (ISAX == ISA_3DNow1 || ISAX == ISA_3DNow2)
   {
      DisplayFile("CONFIG/3DNow.txt", stdout, NLINES);
      Use3DNow = IsYes('n', "   ", "Use 3DNow! for computation?");
@skip      if (!Use3DNow) ISAX = ISA_None;
   }
   i = ncpu;
   if (!ncpu) ncpu = ProbeNCPU(OS, mach, targ, TOPdir);
   if (ncpu != 1) /* user may want to thread */
   {
      DisplayFile("CONFIG/pthread.txt", stdout, NLINES);
      if ( IsYes(ncpu > 1 ? 'y' : 'n', "   ", "enable Posix threads support?") )
      {
         THREADS=1;
         if (!i) ncpu = GetNCPU(OS, mach, targ, TOPdir);
      }
      else ncpu = 1;
   }
   if (ncpu) ATL_mprintf(2, fplog, stdout, "Number of CPUs: %d\n\n", ncpu);
   else ATL_mprintf(2, fplog, stdout,
                    " Unable to determine number of CPUs.\n\n");

   strcpy(ARCH0, machnam[mach]);
   if (ISAX != ISA_None)
   {
      if (ISAX == ISA_3DNow1 || ISAX == ISA_3DNow2)
      {
         if (Use3DNow) strcat(ARCH0, ISAXNAM[ISAX]);
      }
      else strcat(ARCH0, ISAXNAM[ISAX]);
   }
   if (USERMM) strcat(ARCH0, usermmnam[USERMM]);
   L1SIZE = GetCacheSize(OS,  mach, targ, TOPdir, 1, &i);
   if (!i) L1SIZE = -1;

/*
 * Linux paging may screw up L1 cache on 604e, so force detection
 */
   if (OS == OSLinux && mach == PPC604e) L1SIZE = -1;

   L2SIZE = GetCacheSize(OS,  mach, targ, TOPdir, -2, &L2IsKnown) * 1024;
   if (L2IsKnown)
      ATL_mprintf(2, fplog, stdout, 
                  "Required cache flush detected as : %d bytes\n", L2SIZE);
   i = GetCompInfo(stdout, fplog, OS, mach, ISAX, targ, redir, TOPdir,
                   F77, F77FLAGS, FLINKER, FLINKFLAGS, FCLINKFLAGS,
                   GOODGCC, CC, CCFLAGS, CLINKER, CLINKFLAGS, 
                   MCC, MMFLAGS, BLASlib);
   if (!i) /* no good gcc is found, issue warning */
   {
      if (MachIsX86(mach)) /* bad gcc warnings */
      {
         BADMCC = 1;
         DisplayFile("CONFIG/gcc3x86.txt", stdout, NLINES);
         if (IsYes('y', "   ", "Stop ATLAS install?")) exit(-1);
      }
      else if (MachIsUS(mach)) 
      {
         BADMCC = 1;
         DisplayFile("CONFIG/gcc3US.txt", stdout, NLINES);
         if (IsYes('n', "   ", "Stop ATLAS install?")) exit(-1);
      }
      else if (mach == Dec21164 || mach == Dec21264)
      {
         BADMCC = 1;
         DisplayFile("CONFIG/gcc3evX.txt", stdout, NLINES);
         if (IsYes('y', "   ", "Stop ATLAS install?")) exit(-1);
      }
      else if (mach == IA64Itan || mach == IA64Itan2)
      {
         BADMCC = 1;
         DisplayFile("CONFIG/gcc3ia64.txt", stdout, NLINES);
         if (IsYes('y', "   ", "Stop ATLAS install?")) exit(-1);
      }
      else if ((mach == PPCG4 || mach == PPCG5) && OS == OSLinux)
      {
         BADMCC = 1;
         DisplayFile("CONFIG/gcc33ppc.txt", stdout, NLINES);
         if (IsYes('y', "   ", "Stop ATLAS install?")) exit(-1);
      }
   }

   GetSyslib(OS, mach, targ, LIBS);
   if (XCOMP)
   {
      delay = 60;
      ATL_mprintf(2, fplog, stdout, "\n\n*******************************************************************************\n");
      ATL_mprintf(2, fplog, stdout, "****************  FINDING INFO ABOUT CROSS-COMPILING MACHINE  *****************\n");
      ATL_mprintf(2, fplog, stdout, "*******************************************************************************\n");
      XOS = GetOS(stdout, fplog, NULL);
      Xmach = GetArch(stdout, fplog, XOS, NULL, TOPdir);
      GetCompInfo(stdout, fplog, XOS, Xmach, ISA_None, NULL, redir, TOPdir,
                  NULL, NULL, NULL, NULL, NULL, XCC, XCCFLAGS, NULL, NULL,
                  NULL, NULL, NULL, NULL);
      ATL_mprintf(2, fplog, stdout, "\n\n*******************************************************************************\n");
      ATL_mprintf(2, fplog, stdout, "****************  DONE FINDING INFO ABOUT CROSS-COMPILING MACHINE  ************\n");
      ATL_mprintf(2, fplog, stdout, "*******************************************************************************\n");
   }
   else if (strstr(CC, "ATLwin_") || strstr(CCFLAGS, "-mno-cygwin"))
   {
      strcpy(XCC, GOODGCC);
      strcpy(XCCFLAGS, "-O");
   }
   else
   {
      strcpy(XCC, CC);
      strcpy(XCCFLAGS, CCFLAGS);
   }
   if (OS == OSSunOS4 || OS == OSOSX) strcpy(RANLIB, "ranlib");

   ATL_mprintf(2, fplog, stdout, "FINDING tar, gzip, AND gunzip\n");
   FindTarZip(TAR, GZIP, GUNZIP);
   ATL_mprintf(2, fplog, stdout, "   tar    : %s\n", TAR);
   ATL_mprintf(2, fplog, stdout, "   gzip   : %s\n", GZIP);
   ATL_mprintf(2, fplog, stdout, "   gunzip : %s\n", GUNZIP);
   GetPmake(OS, ncpu, PMAKE);

   if (OS != OSOther)
   {
      if (mach != MACHOther)
         fprintf(stdout, 
         "\n\nATLAS has default parameters for OS=\'%s\' and system=\'%s\'.\n",
                 osnam[OS], machnam[mach]);
      else
         fprintf(stdout, 
"\n\nAlthough your machine is not known, ATLAS has default parameters for OS=\'%s\'.\n",
                 osnam[OS]);
      fprintf(stdout,
"If you want to just trust these default values, you can use express setup,\n");
      fprintf(stdout,
"drastically reducing the amount of questions you are required to answer\n\n");
      GOGO = IsYes('y', "   ", "use express setup?");
      fprintf(stdout, "\n\n");
   }

   ierr = 0;
   DisplayFile("CONFIG/arch.txt", stdout, NLINES);
   if (*ARCH == '\0')
   {
      if (OS == OSOther) strcpy(ARCH, "UNKNOWN");
      else strcpy(ARCH, osnam[OS]);
      if (OS == OSLinux && mach == PPCG5 && Use64Bits) strcat(ARCH, "_64");
      else strcat(ARCH, "_");
      strcat(ARCH, ARCH0);
      ierr = 1;
   }
   if (THREADS) /* add ncpu to ARCH */
   {
      for (i=0; ARCH[i]; i++);
      sprintf(ARCH+i, "_%d", ncpu);
   }
   do
   {
      if (ierr)
      {
         GetString(stdin, ARCH, "   ", "Architecture name (ARCH)", 127, ARCH);
         sprintf(ln, "Make.%s", ARCH);
      }
      ierr = FileIsThere(ln);
      if (ierr)
      {
         fprintf(stderr, "File Make.%s already exists!\n", ARCH);
         ierr = !IsYes('n', "", "overwrite it?");
      }
   }
   while (ierr);
   ATL_mprintf(2, stdout, fplog, "<arch> set to \'%s\'\n\n", ARCH);

   if (!L2IsKnown)
   {
      DisplayFile("CONFIG/l2size.txt", stdout, NLINES);
      L2SIZE = GetIntRange(L2SIZE/1024, 64, 16*1024, "   ", 
                           "Maximum cache size (KB)");
      L2SIZE *= 1024;
   }
   else if (L2SIZE > MAXL2SIZE)
   {
      DisplayFile("CONFIG/l2sizemax.txt", stdout, NLINES);
      L2SIZE = GetIntRange(L2SIZE/1024, 64, 16*1024, "   ", 
                           "Maximum cache size (KB)");
      L2SIZE *= 1024;
   }
   DisplayFile("CONFIG/nfsdelay.txt", stdout, NLINES);
   delay = GetIntRange(delay, 0, 600, "   ", "File creation delay in seconds");
   if (!GOGO)
   {
      GetString(stdin, TOPdir, "   ", "Top level ATLAS directory", 255, TOPdir);
      GetString(stdin, LIBdir, "   ", 
                "Directory to build libraries in", 255, LIBdir);

      GetString(stdin, ATLASlib, "   ", 
                "Library name for ATLAS primitives", 255, ATLASlib);
      GetString(stdin, CBLASlib, "   ", 
                "Library name for the C interface to BLAS", 255, CBLASlib);
      GetString(stdin, F77BLASlib, "   ", 
                "Library name for the Fortran77 interface to BLAS", 
                255, F77BLASlib);
      if (THREADS)
      {
         GetString(stdin, PTCBLASlib, "   ", 
                   "Library name for the C interface to BLAS", 255, PTCBLASlib);
         GetString(stdin, PTF77BLASlib, "   ", 
                   "Library name for the Fortran77 interface to BLAS", 
                   255, PTF77BLASlib);
      }
   }

   DisplayFile("CONFIG/f77exp.txt", stdout, NLINES);
@beginskip
   if (OSIsWin(OS) && USEWINF77)
   {
      strcpy(F77, TOPdir);
      strcat(F77, "/CONFIG/winf77.exe");
   }
@endskip
   ierr = 0;
   do
   {
      if (ierr != 0)
      {
         if (GOGO) DisplayFile("CONFIG/f77exp.txt", stdout, NLINES);
         GetString(stdin, F77, "   ", "f77 compiler", 127, F77);
         GetString(stdin, F77FLAGS, "   ", "F77 Flags", 511, F77FLAGS);
      }
      sprintf(ln, "%s -c CONFIG/tst.f %s\n", F77, redir);
      ierr = system(ln);
      if (ierr)
      {
         if (GOGO) DisplayFile("CONFIG/f77exp.txt", stdout, NLINES);
         fprintf(stderr, "F77 = \'%s %s\' doesn't seem to work for me.\n", 
                 F77, F77FLAGS);
         ierr = GetIntRange(1, 0, 1, "   ", 
                   "1 to enter a different F77, 0 to continue with none");
      }
   }
   while (ierr);
   if (!GOGO)
   {
      GetString(stdin, FLINKER, "   ", "F77 Linker ", 127, FLINKER);
      GetString(stdin, FLINKFLAGS, "   ", "F77 Link Flags ", 511, FLINKFLAGS);
      fprintf(stdout, "\n\n");
   }
   ATL_mprintf(2, fplog, stdout, "F77 & FLAGS: %s %s\n", F77, F77FLAGS);
   ATL_mprintf(2, fplog, stdout, "FLINKER & FLAGS: %s %s\n\n", 
               FLINKER, FLINKFLAGS);

   ierr = !GOGO;
   if (!GOGO) DisplayFile("CONFIG/ccomp.txt", stdout, NLINES);
   do
   {
      if (ierr != 0)
      {
         if (GOGO) DisplayFile("CONFIG/ccomp.txt", stdout, NLINES);
         GetString(stdin, CC, "   ", "ANSI C compiler(CC)", 127, CC);
         GetString(stdin, CCFLAGS, "   ", "C Flags (CCFLAGS)", 511, CCFLAGS);
      }
      sprintf(ln, "%s %s -c CONFIG/tst.c %s\n", CC, CCFLAGS, redir);
      ierr = system(ln);
      if (ierr)
      {
         fprintf(stderr, 
                 "Compiling with = \'%s %s\' doesn't seem to work for me.\n",
                 CC, CCFLAGS);
         ierr = GetIntRange(1, 0, 1, "   ", 
                           "1 to try different CC/flags, 0 to continue anyway");
      }
   }
   while(ierr);
   ATL_mprintf(2, fplog, stdout, "CC & FLAGS: %s %s\n", CC, CCFLAGS);

@beginskip
   if (MachIsAlpha(mach))
   {
      if (GOGO)
      {
         ierr = 1;
         if (!strstr(MCC, "gcc"))
            DisplayFile("CONFIG/ccomp-alpha_nogcc.txt", stdout, NLINES);
         else if (!GccV278(MCC))
            DisplayFile("CONFIG/ccomp-alpha_newgcc.txt", stdout, NLINES);
         else ierr = 0;
         if (ierr) if ( !IsYes('y', "", "Continue install anyway?") ) exit(1);
      }
   }
@endskip
   if (MachIsAlpha(mach)&& !GOGO)
      DisplayFile("CONFIG/ccomp-alpha.txt", stdout, NLINES);
   ierr = !GOGO;
   do
   {
      if (ierr != 0)
      {
         if (GOGO) DisplayFile("CONFIG/ccomp-alpha.txt", stdout, NLINES);
         GetString(stdin, MCC, "   ", "C compiler for generated code (MCC)", 
                   127, MCC);
         GetString(stdin, MMFLAGS, "   ", "C FLAGS (MMFLAGS)", 511, MMFLAGS);
      }
      Wstrfndsub("$(CC)", CC, MCC, comp);
      Wstrfndsub("$(CCFLAGS)", CCFLAGS, MMFLAGS, ln);
      Wstrfndsub("$(CDEFS)", "", ln, cflg);
      sprintf(ln, "%s %s -c CONFIG/tst.c %s\n", comp, cflg, redir);
      ierr = system(ln);
      if (ierr)
      {
         fprintf(stderr, 
                 "Compiling with \'%s %s\' doesn't seem to work for me.\n", 
                 MCC, MMFLAGS);
         ierr = GetIntRange(1, 0, 1, "   ", 
                            "1 to re-enter, 0 to continue anyway");
      }
   }
   while(ierr);
   if (!GOGO)
   {
      GetString(stdin, CLINKER, "   ", "C Linker ", 127, CLINKER);
      GetString(stdin, CLINKFLAGS, "   ", "C Link Flags ", 511, CLINKFLAGS);
   }
   ATL_mprintf(2, fplog, stdout, "MCC & FLAGS: %s %s\n", MCC, MMFLAGS);
   ATL_mprintf(2, fplog, stdout, "CLINKER & FLAGS: %s %s\n\n", 
               CLINKER, CLINKFLAGS);
   if (XCOMP)
   {
      ierr = !GOGO;
      do
      {
         if (ierr != 0)
         {
            GetString(stdin, XCC, "   ", 
                      "ANSI C compiler for cross-compiling machine (XCC)", 
                      127, XCC);
            GetString(stdin, XCCFLAGS, "   ", 
                      "C Flags for cross-compiling machine (XCCFLAGS)", 
                      511, XCCFLAGS);
         }
         Wstrfndsub("$(CC)", CC, XCC, comp);
         Wstrfndsub("$(CCFLAGS)", CCFLAGS, XCCFLAGS, ln);
         Wstrfndsub("$(CDEFS)", "", ln, cflg);
         sprintf(ln, "%s %s -c CONFIG/tst.c %s\n", comp, cflg, redir);
         ierr = system(ln);
         if (ierr)
         {
            fprintf(stderr, 
                    "Compiling with \'%s %s\' doesn't seem to work for me.\n", 
                    XCC, XCCFLAGS);
            ierr = GetIntRange(1, 0, 1, "   ", 
                               "1 to re-enter, 0 to continue anyway");
         }
      }
      while(ierr);
      ATL_mprintf(2, fplog, stdout, "XCC & FLAGS: %s %s\n\n", XCC, XCCFLAGS);
   }

   if (!GOGO)
   {
      GetString(stdin, ARCHIVER, "   ", "Archiver ", 127, ARCHIVER);
      GetString(stdin, ARFLAGS, "   ", "Archiver flags ", 255, ARFLAGS);
      GetString(stdin, RANLIB, "   ", "Ranlib ", 127, RANLIB);
      GetString(stdin, BLASlib, "   ", "BLAS library", 255, BLASlib);
      GetString(stdin, LIBS, "   ", "General and system libs", 255, LIBS);
   }

   fprintf(stdout, 
           "\nFinding F77 to C calling conventions (this may take a while):\n");
   findF2C(redir, targ, TOPdir, F77, F77FLAGS, FLINKER, FLINKFLAGS, CC, CCFLAGS,
           &f2cnam, &f2cint, &f2cstr);
   fprintf(stdout, "\nCalculated F77/C interoperation conventions:\n");
   sp = F2CDEFS;
   if (f2cnam == f2c_Add_)
   {
      ATL_mprintf(2, fplog, stdout, "   Suffix F77 names with _\n");
      strcpy(sp, "-DAdd_ ");
      sp += 7;
   }
   else if (f2cnam == f2c_NoChange) 
   {
      ATL_mprintf(2, fplog, stdout, "   C & F77 share the same namespace\n");
      strcpy(sp, "-DNoChange ");
      sp += 11;
   }
   else if (f2cnam == f2c_UpCase)
   {
      strcpy(sp, "-DUpCase ");
      sp += 9;
      ATL_mprintf(2, fplog, stdout, "   Make F77 names upper case\n");
   }
   else if (f2cnam == f2c_Add__)
   {
      strcpy(sp, "-DAdd__ ");
      sp += 8;
      ATL_mprintf(2, fplog, stdout, 
                  "   Suffix F77 names with underscores with __\n");
   }
   else ATL_mprintf(2, fplog, stdout, 
                    "   Unable to determine naming conventions\n");

   if (f2cint == FintCint)
      ATL_mprintf(2, fplog, stdout, "   F77 INTEGER -> C int\n");
   else if (f2cint == FintClong)
   {
      ATL_mprintf(2, fplog, stdout, "   F77 INTEGER -> C long\n");
      strcpy(sp, "-DF77_INTEGER=long ");
      sp += 19;
   }
   else if (f2cint == FintCshort)
   {
      ATL_mprintf(2, fplog, stdout,"   F77 INTEGER -> C short\n");
      strcpy(sp, "-DF77_INTEGER=short ");
      sp += 20;
   }
   else ATL_mprintf(2, fplog, stdout,
                    "   Unable to determine F77/C integer correspondence\n");

   if (f2cstr == fstrSun)
   {
      strcpy(sp, "-DStringSunStyle");  
      ATL_mprintf(2, fplog, stdout, 
                  "   F77 strings handled via standard sun style\n");
   }
   else if (f2cstr == fstrCray)
   {
      strcpy(sp, "-DCRAY");  
      ATL_mprintf(2, fplog, stdout, "   F77 strings handled using CRAY fcd\n");
   }
   else if (f2cstr == fstrStructVal)
   {
      strcpy(sp, "-DStringStructVal");  
      ATL_mprintf(2, fplog, stdout, 
                  "   F77 strings handled by passing a struct\n");
   }
   else if (f2cstr == fstrStructPtr)
   {
      strcpy(sp, "-DStringStructPtr");  
      ATL_mprintf(2, fplog, stdout,
                  "   F77 strings handled by passing a pointer to struct\n");
   }
   else ATL_mprintf(2, fplog, stdout,
                    "   Unable to determine F77/C string interoperation\n");

   mmdef[0] = archdef[0] = '\0';
   j = 1;
   if (mach != MACHOther && !BADMCC && (flag & CF_ARCHDEF))
   {
      if (mach == SunUS4) sp = "SunUS2";
      else sp = ARCH0;
      sprintf(ln, "CONFIG/ARCHS/%s.tgz", sp);
      if (FileIsThere(ln))
      {
         DisplayFile("CONFIG/NoSearch.txt", stdout, NLINES);
         if ( IsYes('y', "", "Use supplied default values for install?") )
         {
            ATL_mprintf(2, fplog, stdout, 
                        "\n\nUnpacking Architectural defaults . . . ");
            sprintf(ln, "cd CONFIG/ARCHS ; %s -c %s.tgz | %s xf - %s\n", 
                    GUNZIP, sp, TAR, redir);
            system(ln);
            ATL_mprintf(2, fplog, stdout, "done.\n");
            GetArchDef(OS, mach, sp, CC, CCFLAGS, MCC, MMFLAGS, mmdef, archdef);
            sprintf(ln, "%s%s/dAXPBY_SUMM", TOPdir, archdef+9);
            j = !FileIsThere(ln);
        }
      }
   }
   if (j && (flag & CF_ARCHDEF))
   {
      DisplayFile("CONFIG/l1def.txt", stdout, NLINES);
      USEDEFL1 = !IsYes('y', "", "Tune the Level 1 BLAS?");
   }
@skip   if (USEWINF77) strcpy(F77, "$(BINdir)/winf77.exe");

   ATL_mprintf(2, fplog, stdout,"\nCreating make include file Make.%s\n", ARCH);
   sprintf(ln, "Make.%s", ARCH);
   fpout = fopen(ln, "w");
   assert(fpout);
   fprintf(fpout, "#  -----------------------------\n");
   fprintf(fpout, "#  Make.ARCH for ATLAS@(ver)\n");
   fprintf(fpout, "#  -----------------------------\n\n");

   fprintf(fpout, "#  ----------------------------------\n");
   fprintf(fpout, "#  Make sure we get the correct shell\n");
   fprintf(fpout, "#  ----------------------------------\n");
   fprintf(fpout, "   SHELL = /bin/sh\n\n");

   fprintf(fpout, "#  -------------------------------------------------\n");
   fprintf(fpout, "#  Name indicating the platform to configure BLAS to\n");
   fprintf(fpout, "#  -------------------------------------------------\n");
   fprintf(fpout, "   ARCH = %s\n\n", ARCH);

   fprintf(fpout, "#  -------------------\n");
   fprintf(fpout, "#  Various directories\n");
   fprintf(fpout, "#  -------------------\n");
   fprintf(fpout, "   TOPdir = %s\n", TOPdir);
   fprintf(fpout, "   INCdir = $(TOPdir)/include/$(ARCH)\n");
   fprintf(fpout, "   SYSdir = $(TOPdir)/tune/sysinfo/$(ARCH)\n");
   fprintf(fpout, "   GMMdir = $(TOPdir)/src/blas/gemm/$(ARCH)\n");
   fprintf(fpout, "   UMMdir = %s\n", UMMdir);
   fprintf(fpout, "   GMVdir = $(TOPdir)/src/blas/gemv/$(ARCH)\n");
   fprintf(fpout, "   GR1dir = $(TOPdir)/src/blas/ger/$(ARCH)\n");
   fprintf(fpout, "   L1Bdir = $(TOPdir)/src/blas/level1/$(ARCH)\n");
   fprintf(fpout, "   L2Bdir = $(TOPdir)/src/blas/level2/$(ARCH)\n");
   fprintf(fpout, "   L3Bdir = $(TOPdir)/src/blas/level3/$(ARCH)\n");
   fprintf(fpout, "   TSTdir = $(TOPdir)/src/testing/$(ARCH)\n");
   fprintf(fpout, "   AUXdir = $(TOPdir)/src/auxil/$(ARCH)\n");
   fprintf(fpout, "   CBLdir = $(TOPdir)/interfaces/blas/C/src/$(ARCH)\n");
   fprintf(fpout, "   FBLdir = $(TOPdir)/interfaces/blas/F77/src/$(ARCH)\n");
   fprintf(fpout, "   BINdir = $(TOPdir)/bin/$(ARCH)\n");
   fprintf(fpout, "   LIBdir = %s\n", LIBdir);
   fprintf(fpout, "   PTSdir = $(TOPdir)/src/pthreads\n");
   fprintf(fpout, "   MMTdir = $(TOPdir)/tune/blas/gemm/$(ARCH)\n");
   fprintf(fpout, "   MVTdir = $(TOPdir)/tune/blas/gemv/$(ARCH)\n");
   fprintf(fpout, "   R1Tdir = $(TOPdir)/tune/blas/ger/$(ARCH)\n");
   fprintf(fpout, "   L1Tdir = $(TOPdir)/tune/blas/level1/$(ARCH)\n");
   fprintf(fpout, "   L3Tdir = $(TOPdir)/tune/blas/level3/$(ARCH)\n\n");

   fprintf(fpout,
"#  ---------------------------------------------------------------------\n");
   fprintf(fpout,
"#  Name and location of scripts for running executables during tuning\n");
   fprintf(fpout,
"#  ---------------------------------------------------------------------\n");
   fprintf(fpout, "   ATLRUN = $(BINdir)/ATLrun.sh\n");
   fprintf(fpout, "   ATLFWAIT = $(BINdir)/xatlas_waitfile\n\n");

   fprintf(fpout, "#  ---------------------\n");
   fprintf(fpout, "#  Libraries to be built\n");
   fprintf(fpout, "#  ---------------------\n");
   fprintf(fpout, "   ATLASlib = $(LIBdir)/%s\n", ATLASlib);
   fprintf(fpout, "   CBLASlib = $(LIBdir)/%s\n", CBLASlib);
   fprintf(fpout, "   F77BLASlib = $(LIBdir)/%s\n", F77BLASlib);
   if (THREADS)
   {
      fprintf(fpout, "   PTCBLASlib = $(LIBdir)/%s\n", PTCBLASlib);
      fprintf(fpout, "   PTF77BLASlib = $(LIBdir)/%s\n", PTF77BLASlib);
   }
   fprintf(fpout, "   LAPACKlib = $(LIBdir)/liblapack.a\n\n");
   fprintf(fpout, "   TESTlib = $(LIBdir)/libtstatlas.a\n");

   fprintf(fpout, "#  -------------------------------------------\n");
   fprintf(fpout, "#  Upper bound on largest cache size, in bytes\n");
   fprintf(fpout, "#  -------------------------------------------\n");
   fprintf(fpout, "   L2SIZE = -DL2SIZE=%d\n\n", L2SIZE);

   fprintf(fpout, "#  ---------------------------------------\n");
   fprintf(fpout, "#  Command setting up correct include path\n");
   fprintf(fpout, "#  ---------------------------------------\n");
   fprintf(fpout, 
      "   INCLUDES = -I$(TOPdir)/include -I$(TOPdir)/include/$(ARCH) \\\n");
   fprintf(fpout, 
      "              -I$(TOPdir)/include/contrib \n\n");

   fprintf(fpout, "#  -------------------------------------------\n");
   fprintf(fpout, "#  Defines for setting up F77/C interoperation\n");
   fprintf(fpout, "#  -------------------------------------------\n");
   fprintf(fpout, "   F2CDEFS = %s\n\n", F2CDEFS);

   fprintf(fpout, "#  --------------------------------------\n");
   fprintf(fpout, "#  Special defines for user-supplied GEMM\n");
   fprintf(fpout, "#  --------------------------------------\n");
   fprintf(fpout, "   UMMDEFS = %s\n\n", UMMdef);

   fprintf(fpout, "#  ------------------------------\n");
   fprintf(fpout, "#  Architecture identifying flags\n");
   fprintf(fpout, "#  ------------------------------\n");
   fprintf(fpout, "   ARCHDEFS =");
   if (OS != OSOther) fprintf(fpout, " -DATL_OS_%s", osnam[OS]);
   if (mach != MACHOther) fprintf(fpout, " -DATL_ARCH_%s", machnam[mach]);
   if (USERMM) fprintf(fpout, " -DUSERGEMM");
   if (OSIsWin(OS))
      fprintf(fpout, " -DGCCWIN -DUseClock");
   if (ISAX == ISA_AV && strstr(CC, "gcc") && strstr(MCC, "gcc") &&
       !GccIsApple(CC))
      fprintf(fpout, " -DATL_%s -DATL_AVgcc", ISAXNAM[ISAX]);
      
   else if (ISAX != ISA_None) fprintf(fpout, " -DATL_%s", ISAXNAM[ISAX]);
   if (ISAX == ISA_SSE3) fprintf(fpout, " -DATL_SSE2 -DATL_SSE1");
   else if (ISAX == ISA_SSE2) fprintf(fpout, " -DATL_SSE1");
   if (Use3DNow) fprintf(fpout, " -DATL_3DNowFLOPS");
   if (ISAX < ISA_3DNow2)
   {
      if (Has3DNow(targ, TOPdir) != ISA_None)
         fprintf(fpout, " -DATL_Has3DNow");
   }
   if (Use64Bits) fprintf(fpout, " -DATL_USE64BITS");
   if (mach == IA64Itan || mach == IA64Itan2 )
      fprintf(fpout, " -DATL_MAXNREG=128");
   if (ASMD != ASM_None) fprintf(fpout, " -DATL_%s", ASMNAM[ASMD]);
   if (Has64Bits)
   {
      if (Use64Bits) fprintf(fpout, " -m64");
      else fprintf(fpout, " -m32");
   }
   if (mach == IA64Itan2 && strstr(CC, "icc"))
      fprintf(fpout, " -DATL_IntelIccBugs");
   fprintf(fpout, "\n\n");

   fprintf(fpout, 
   "#  -------------------------------------------------------------------\n");
   fprintf(fpout, 
   "#  NM is the flag required to name a compiled object/executable\n");
   fprintf(fpout, 
   "#  OJ is the flag required to compile to object rather than executable\n");
   fprintf(fpout, "#  These flags are used by all compilers.\n");
   fprintf(fpout, 
   "#  -------------------------------------------------------------------\n");
   fprintf(fpout, "   NM = -o\n");
   fprintf(fpout, "   OJ = -c\n\n");

   DisplayFile("CONFIG/f77make.txt", fpout, 0);
   fprintf(fpout, "   F77 = %s\n", F77);
   fprintf(fpout, "   F77FLAGS = %s\n", F77FLAGS);
   fprintf(fpout, "   FLINKER = %s\n", FLINKER);
   fprintf(fpout, "   FLINKFLAGS = %s\n", FLINKFLAGS);
   fprintf(fpout, "   FCLINKFLAGS = %s\n\n", FCLINKFLAGS);

   DisplayFile("CONFIG/CCmake.txt", fpout, 0);
   fprintf(fpout, "   CDEFS = $(L2SIZE) $(INCLUDES) $(F2CDEFS) $(ARCHDEFS)");
   if (UCDEF[0])
      fprintf(fpout, " %s", UCDEF);
   if (THREADS)
   {
      fprintf(fpout, " -DATL_NCPU=%d", ncpu);
@skip      if (OS == OSLinux || OS == OSIRIX || OS == OSOSF1 || OS == OSAIX || 
@skip          OS == SunOS) fprintf(fpout, " -DDUseSystemScope");
      if (OS == OSFreeBSD) fprintf(fpout, " -D_THREAD_SAFE -D_REENTRANT");
      if (OS == OSAIX) fprintf(fpout, " -DIBM_PT_ERROR");
      if (OS == OSIRIX) fprintf(fpout, " -D_POSIX_C_SOURCE=199506L");
   }
   if (delay) fprintf(fpout, " -DATL_FOPENDELAY");
   fprintf(fpout, "\n\n");

   j = 0;
   if (*GOODGCC)
   {
      i = strlen(GOODGCC);
      for (i--; i >= 0 && isspace(GOODGCC[i]); i--) GOODGCC[i] = '\0';
      if (i > 3 && GOODGCC[i] == 'c' && GOODGCC[i-1] == 'c' && 
          GOODGCC[i-2] == 'g' && GOODGCC[i-3] == '/')
      {
         GOODGCC[i-3] = '\0';
         fprintf(fpout, "   GCCdir = %s\n", GOODGCC);
         GOODGCC[i-3] = '/';
         j = 1;
      }
      fprintf(fpout, "   GOODGCC = %s\n", GOODGCC);
   }
   else fprintf(fpout, "   GOODGCC = gcc\n");
   fprintf(fpout, "   CC = %s\n", j && strstr(CC, "gcc") ? "$(GOODGCC)" : CC);
   fprintf(fpout, "   CCFLAG0 = %s\n", CCFLAGS);
   fprintf(fpout, "   CCFLAGS = $(CDEFS) $(CCFLAG0)\n");
   fprintf(fpout, "   MCC = %s\n", j && strstr(MCC, "gcc") ? "$(GOODGCC)":MCC);
   fprintf(fpout, "   MMFLAGS = %s\n", MMFLAGS);
   if (strstr(CC, "gcc") /* || strstr(CC, "GOODGCC) */)
   {
      GetGccVers(CC, &i, &j, &j, &j);
      if (i > 3)
         fprintf(fpout, "   MAFLAGS = $(CCFLAGS) -fno-tree-loop-optimize\n");
      else
         fprintf(fpout, "   MAFLAGS = $(CCFLAGS)\n");
   }
   else
      fprintf(fpout, "   MAFLAGS = $(CCFLAGS)\n");
@skip   if (strstr(MMFLAGS, "CCFLAGS"))
@skip      fprintf(fpout, "   MMFLAGS = %s\n", MMFLAGS);
@skip   else
@skip      fprintf(fpout, "   MMFLAGS = $(CDEFS) %s\n", MMFLAGS);
   fprintf(fpout, "   XCC = %s\n", j && strstr(XCC, "gcc") ? "$(GOODGCC)":XCC);
   if (strstr(XCCFLAGS, "CCFLAGS"))
      fprintf(fpout, "   XCCFLAGS = %s\n", XCCFLAGS);
   else fprintf(fpout, "   XCCFLAGS = $(CDEFS) %s\n", XCCFLAGS);
   fprintf(fpout, "   CLINKER = %s\n", CLINKER);
   fprintf(fpout, "   CLINKFLAGS = %s\n", CLINKFLAGS);
   if (SOLERR)
   {
      fprintf(fpout, "   BC = %s\n", BC);
      fprintf(fpout, "   BCFLAGS = $(CDEFS) %s\n", BCFLAGS);
   }
   else if (strstr(CC, "ATLwin_") || strstr(CCFLAGS, "-mno-cygwin"))
   {
      fprintf(fpout, "   BC = $(XCC)\n", CC);
      fprintf(fpout, "   BCFLAGS = $(XCCFLAGS)\n");
   }
   else
   {
      fprintf(fpout, "   BC = $(CC)\n");
      fprintf(fpout, "   BCFLAGS = $(CCFLAGS)\n");
   }
   fprintf(fpout, "   ARCHIVER = %s\n", ARCHIVER);
   fprintf(fpout, "   ARFLAGS  = %s\n", ARFLAGS);
   fprintf(fpout, "   RANLIB   = %s\n\n", RANLIB);

   fprintf(fpout, "#  -------------------------------------\n");
   fprintf(fpout, "#  tar, gzip, gunzip, and parallel make\n");
   fprintf(fpout, "#  -------------------------------------\n");
   fprintf(fpout, "   TAR    = %s\n", TAR);
   fprintf(fpout, "   GZIP   = %s\n", GZIP);
   fprintf(fpout, "   GUNZIP = %s\n", GUNZIP);
   fprintf(fpout, "   PMAKE  = %s\n\n", PMAKE);

   fprintf(fpout, "#  ------------------------------------\n");
   fprintf(fpout, "#  Reference and system libraries\n");
   fprintf(fpout, "#  ------------------------------------\n");
   fprintf(fpout, "   BLASlib = %s\n", BLASlib);
   fprintf(fpout, "   FBLASlib = \n");
   fprintf(fpout, "   FLAPACKlib = \n");
   fprintf(fpout, "   LIBS = %s\n\n", LIBS);

   fprintf(fpout, 
      "#  ----------------------------------------------------------\n");
   fprintf(fpout, 
      "#  ATLAS install resources (include arch default directories)\n");
   fprintf(fpout, 
      "#  ----------------------------------------------------------\n");
   fprintf(fpout, "   ARCHDEF = %s\n", archdef);
   fprintf(fpout, "   MMDEF = %s\n", mmdef);
   if (USEDEFL1) fprintf(fpout, "   INSTFLAGS = -1 1\n\n");
   else fprintf(fpout, "   INSTFLAGS = \n\n");
   fprintf(fpout, "#  ---------------------------------------\n");
   fprintf(fpout, "#  Generic targets needed by all makefiles\n");
   fprintf(fpout, "#  ---------------------------------------\n");
   if (delay)
   {
      fprintf(fpout, "   waitfile = wfdefault\n");
      fprintf(fpout, "waitfile:\n\tcd $(BINdir) ; make xatlas_waitfile\n");
      fprintf(fpout, "\t$(ATLFWAIT) -s %d -f $(waitfile)\n", delay);
   }
   else fprintf(fpout, "waitfile:\n");
   fclose(fpout);
   ATL_mprintf(2, fplog, stdout, "Make.%s successfully created.\n\n", ARCH);

   if (flag & CF_CREATEATLRUN)
   {
      ATL_mprintf(2, fplog, stdout, "\n\nCreating ATLrun.sh\n\n", ARCH);
      sprintf(ln, "CONFIG/ATLrun.%s", ARCH);
      fpout = fopen(ln, "w");
      assert(fpout);
      fprintf(fpout, "#!/bin/sh\n");
      fprintf(fpout, "atldir=$1\nshift\n");
      if (XCOMP)
         fprintf(fpout, "exe=$1\nshift\nssh %s \"cd $atldir ; ./$exe $*\"", 
                 TARGNAM);
      else fprintf(fpout, "$atldir/$*\n");
      fclose(fpout);
      sprintf(ln, "chmod a+rx CONFIG/ATLrun.%s\n", ARCH);
      assert(system(ln) == 0);
   }

   if (flag & CF_CREATEDIRS)
   {
      fprintf(stdout, "Creating subdirectories:\n");
      fprintf(stdout, "   Checking for already existing subdirectories  .....");
      fflush(stdout);
      sprintf(ln, "cd bin/%s %s", ARCH, redir);
      i = 1;
      if (system(ln) == 0)
      {
         fprintf(stdout, "...... found!\n");
         i = IsYes('y', "", "kill old subdirectories?");
      }
      else fprintf(stdout, "... no\n");
      if (i)
      {
         sprintf(ln, "make killall arch=%s %s\n", ARCH, redir);
         system(ln);
         sprintf(ln, "make startup arch=%s %s\n", ARCH, redir);
         if (system(ln))
         {
            fps[0] = stderr;
            fps[1] = fplog;
            for (i=0; i < 2; i++)
            {
               fprintf(fps[i], "UNABLE TO CREATE NECESSARY SUBDIRECTORIES:\n");
               fprintf(fps[i], 
       "  review Make.%s for accurracy, paying special attention to TOPdir.\n",
                       ARCH);
               fprintf(fps[i], "Examine %s and %s for specifics.\n", 
                       lognam, dmpnam);
               fprintf(fps[i], 
                  "   for further help, see ATLAS/doc/TroubleShoot.txt.\n");
               fprintf(fps[i],
                       "   when you have corrected the problem, finish the\n");
               fprintf(fps[i], "   configuration by typing :\n");
               fprintf(fps[i], "      make startup arch=%s\n", ARCH);
            }
            sprintf(ln, "make killall arch=%s %s\n", ARCH, redir);
            system(ln);
            fclose(fplog);
            exit(-1);
         }
      }
      ATL_mprintf(2, fplog, stdout, "Subdirectories successfully created.\n\n");
   }
@beginskip
   if (USEWINF77 && (flag & CF_CREATEWINF77))
   {
      ATL_mprintf(2, fplog, stdout, "\n\nCreating winf77.exe\n\n", ARCH);
      sprintf(ln, "cd CONFIG ; make winf77bob ARCH=%s", ARCH);
      if ( system(ln) )
      {
         ATL_mprintf(2, fplog, stderr, "Unable to create winf77, aborting.\n");
         fclose(fplog);
         exit(-1);
      }
   }
@endskip
   if (L1SIZE != -1 && (flag & CF_STOREL1))
   {
      ATL_mprintf(2, fplog, stdout, "\nStoring L1 cache size of %dKB.\n\n", 
                  L1SIZE);
      sprintf(ln, "make -f Make.top ISetL1 arch=%s L1Size=%d %s\n", 
              ARCH, L1SIZE, redir);
      if (system(ln))
      {
         ATL_mprintf(2, fplog, stderr, 
                     "Unable to store L1CacheSize, aborting.\n");
         fclose(fplog);
         exit(-1);
      }
   }
   fprintf(fplog, "\n\nConfiguration completed successfully.\n\n");
   fclose(fplog);
   if (flag & CF_MOVELOG)
   {
      fprintf(stdout, 
              "\nMoving config logfiles %s and %s to bin/%s/INSTALL_LOG/\n",
              lognam, dmpnam, ARCH);
      sprintf(ln, "mv -f %s bin/%s/INSTALL_LOG/.\n", lognam, ARCH);
      system(ln);
      sprintf(ln, "mv -f %s bin/%s/INSTALL_LOG/.\n", dmpnam, ARCH);
      system(ln);
   }
   fprintf(stdout, "\n\nConfiguration completed successfully.  You may want to examine the make include \n");
   fprintf(stdout, 
"file (Make.%s) for accuracy before starting the install with the command:\n",
           ARCH);
   fprintf(stdout, "   make install arch=%s\n\n", ARCH);
}

void PrintUsage(char *name)
{
   fprintf(stderr, "USAGE: %s [flags]\n", name);
   DisplayFile("CONFIG/config_flags.txt", stderr, 0);
   exit(-1);
}

int GetFlags(int nargs, char **args, enum MACHTYPE *mach, int *ncpu,
             char *ucdef, char *TOPdir, char *ARCH, char *blaslib,
             char *cc, char *ccflags, char *f77, char *f77flags,
             char *mcc, char *mmflags, char *gcc, char *xcc, char *xccflags)
{
    int i;
    int flag;

    *ncpu = 0;
    *mach = MACHOther;
    flag = CF_ARCHDEF | CF_CREATEDIRS | CF_CREATEATLRUN | CF_CREATEWINF77 |
           CF_STOREL1 | CF_MOVELOG;
   *ARCH = *TOPdir = *cc = *ccflags = *f77 = *f77flags = 
           *mcc = *mmflags = *gcc = *xcc = *xccflags = *ucdef = '\0';
   *blaslib = '0'; blaslib[1] = '\0';

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') 
         PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'C':
         strcpy(ucdef, args[++i]);
         break;
      case 'A':
         *mach = atoi(args[++i]);
         break;
      case 'N':
         *ncpu = atoi(args[++i]);
         break;
      case 'D':
         flag = atoi(args[++i]);
         break;
      case 'a': /* user sets ARCH from command line */
         strcpy(ARCH, args[++i]);
         break;
      case 't':
         strcpy(TOPdir, args[++i]);
         break;
      case 'c':
         strcpy(cc, args[++i]);
         break;
      case 'f':
         strcpy(f77, args[++i]);
         break;
      case 'm':
         strcpy(mcc, args[++i]);
         break;
      case 'g':
         strcpy(gcc, args[++i]);
         break;
      case 'x':
         strcpy(xcc, args[++i]);
         break;
      case 'F':
         i++;
         if (args[i][0] == 'c')
            strcpy(ccflags, args[++i]);
         else if (args[i][0] == 'm')
            strcpy(mmflags, args[++i]);
         else if (args[i][0] == 'f')
            strcpy(f77flags, args[++i]);
         else if (args[i][0] == 'x')
            strcpy(xccflags, args[++i]);
         else
            PrintUsage(args[0]);
         break;
      case 'b':
         i++;
         if (args[i][0] == '1' && args[i][1] == '\0')
            *blaslib = '\0';
         else
            strcpy(blaslib, args[i]);
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   return(flag);
}

main(int nargs, char *args[])
{
   char TOPdir[512], blaslib[512], ARCH[512];
   char F77[512], CC[512], MCC[512], XCC[512], GOODGCC[512];
   char F77FLAGS[512], CCFLAGS[512], MMFLAGS[512], XCCFLAGS[512];
   int flag, ncpu;
   char UCDEF[256];
   enum MACHTYPE mach;

   flag = GetFlags(nargs, args, &mach, &ncpu, UCDEF, TOPdir, ARCH, blaslib,
                   CC, CCFLAGS, F77, F77FLAGS, MCC, MMFLAGS, GOODGCC,
                   XCC, XCCFLAGS);
   GoToTown(flag, mach, ncpu, TOPdir, ARCH, blaslib, F77, F77FLAGS, CC, CCFLAGS,
            MCC, MMFLAGS, GOODGCC, XCC, XCCFLAGS, UCDEF);
   exit(0);
}
@ROUT archinfo_x86.c
@extract -b @(topd)/gen.inc what=cw -def cdate 2006 -def contrib "Dean Gaudet" -def author "R. Clint Whaley"
/*
 * This code written for ATLAS use by R. Clint Whaley based on code and info
 * submitted by Dean Gaudet, with the later help of the following websites:
 *   http://www.sandpile.org/ia32/cpuid.htm
 *   http://en.wikipedia.org/wiki/CPUID
 */

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define uint unsigned int
@extract -b @(basd)/config.base rout=machenum

/*
 * This routine returns the contents of registers set by the cpuid instruction
 * in the array res:
 *   res[0] : eax
 *   res[1] : ebx
 *   res[2] : ecx
 *   res[3] : edx
 */
void do_cpuid(uint *res, uint level);
/* result defines */
#define EAX 0
#define EBX 1
#define ECX 2
#define EDX 3


/* My driver, based on Dean's */
int ProbeArch(char *vendor, unsigned *family, unsigned *model, int *x86_64)
/*
 * Returns 0 on success, non-zero on error
 */
{
   uint r[4];
   uint max_level;
   uint *vp = (uint*) vendor;

   *x86_64 = 0;
/*
 * In this call, we ask for max supported cpuid support, and return if
 * we can't get any usuable info.  Also sets ebx,edx and ecx (16 chars of data)
 * to vendor ID string
 */
   do_cpuid(r, 0);
   max_level = r[EAX];
   if (!max_level)
      return(1);
/*
 * Copy vendor string as 3 ints rather than 16 char, then null-term at 12
 */
   *vp = r[EBX];
   vp[1] = r[EDX];
   vp[2] = r[ECX];
   vendor[12] = '\0';

/*
 * Find processor family and model, ouput EAX
 */
   do_cpuid(r, 1);
   *family = (r[EAX] >> 8) & 0xf;      /* base family in bits 11-8 */
   if (*family == 0xf || *family == 0) /* extended family is added in */
       *family += ((r[EAX] >> 20) & 0xff);

   *model = (r[0] >> 4) & 0xf;         /* model in bits 7-4 */
   if (*model == 0xf)                  /* extended model is concatenated */
      *model |= ((r[0] >> 12) & 0xf0);

/* 
 * Find out if we have extended cpuid level, and if so, see if we've got
 * x86-64 capability or not
 */
   do_cpuid(r, 0x80000000);
   if (r[0] >= 0x80000001)
   {
      do_cpuid(r, 0x80000001);
      *x86_64 = (r[EDX] & (1<<29)) != 0;   /* x86-64 in bit 29 */
   }
   return(0);
}

/*
 * constants used to check family + extended family
 */
#define EF_486       4        /* also AMD 5x86 and Cyrix 5x86 */
#define EF_P5        5        /* P5, K5 and K6 */
#define EF_P6        6        /* P6, Core and K7 (athlon) */
#define EF_ITAN0     7        /* Itanium */
#define EF_K8_P4_EFF 0x00F    /* P4, Hammer, Efficien */
#define EF_K8_ITAN   0x01F    /* Hammer, Itanium */
#define EF_K8        0x02F    /* Hammer */
#define EF_ITAN      0x020    /* Itanium */

enum FAM {ERR,         /* cannot decipher */
          i486,        /* 486 & AMD 5x86 and Cyrix 5x86 */
          P5,          /* Original Pentium and AMD K5 & K6 */
          P6,          /* Intel PIII, Core and AMD K7 (orig athlon) */
          P7,          /* Intel P4, AMD hammer, Efficeon */
          ITAN};       /* Intel Itanium */

enum FAM GetFamily(int efam)  /* efam = (family+ext fam) from cpuid */
/*
 * Translates CPUID (family+extended family) to FAM enum type
 */
{
   enum FAM iret;
   switch (efam)
   {
   case EF_486:               /* also AMD 5x86 and Cyrix 5x86 */
      iret = i486;
      break;
   case EF_P5:                /* P5, K5 and K6 */
      iret = P5;
      break;
   case EF_P6:                /* P6, Core and K7 (athlon) */
      iret = P6;
      break;
   case EF_K8_P4_EFF:         /* P4, Hammer, Efficien */
      iret = P7;
      break;
   case EF_K8_ITAN:           /* Hammer, Itanium */
   case EF_K8:                /* Hammer */
      iret = P7;
      break;
   case EF_ITAN:              /* Itanium */
   case EF_ITAN0:             /* Itanium */
      iret = ITAN;
      break;
   default:
      iret = ERR;
   }
   return (iret);
}

enum VEND {VERR, Intel, AMD, TM};
enum VEND str2vend(char *vendor)
/*
 * Translates vendor string to enum type
 */
{
   enum VEND iret;
   if (strstr(vendor, "GenuineIntel") != NULL)
      iret = Intel;
   else if (strstr(vendor, "AuthenticAMD") != NULL)
      iret = AMD;
   else if (strstr(vendor, "GenuineTMx86") != NULL)
      iret = TM;
   else
      iret = VERR;
   return(iret);
}

/*
 * Specific chip (family, but disambiguated using vendor string 
 */
enum CHIP {CERR, Pentium, IntP6, Pentium4, Itanium, K7, Hammer, 
           Crusoe, Efficeon};

enum CHIP Family2Chip(char *vendor, enum FAM family)
/*
 * Disambiguates family based on vendor string
 */
{
   enum CHIP iret=CERR;
   enum VEND ivend;
   
/*
 * Figure out the vendor
 */
   ivend = str2vend(vendor);
   if (ivend == VERR)
      return(CERR);

   switch(family)
   {
   case   i486:        /* 486 & AMD 5x86 and Cyrix 5x86; unsupported */
      break;
   case   P5:          /* Original Pentium and AMD K5 & K6 */
      if (ivend == Intel)
         iret = Pentium;
      break;
   case   P6:          /* Intel PIII, Core and AMD K7 (orig athlon) */
      if (ivend == Intel)
         iret = IntP6;
      else if (ivend == AMD)
         iret = K7;
      else if (ivend == TM)
         iret = Crusoe;
      break;
   case   P7:          /* Intel P4, AMD hammer, Efficeon */
      if (ivend == Intel)
         iret = Pentium4;
      else if (ivend == AMD)
         iret = Hammer;
      else if (ivend == TM)
         iret = Efficeon;
      break;
   case   ITAN:        /* Intel Itanium */
      iret = Itanium;
      break;
   default:
      iret = CERR;
   }
   return(iret);
}

enum MACHTYPE Chip2Mach(enum CHIP chip, int model, int x8664)
/*
 * translates chip and cpuid's model to config's machine enum
 */
{
   enum MACHTYPE iret=MACHOther;

   switch(chip)
   {
   case Pentium:
      switch(model)
      {
      case 1:
         iret = IntP5;
         break;
      case 4:
      case 8:
         iret = IntP5MMX;
         break;
      default:
         iret = MACHOther;
      }
      break;
   case IntP6:  /* includes PPRO, PII, PIII, Core and Pentium-M */
      switch(model)
      {
      case 0:
      case 1:
         iret = IntPPRO;
         break;
      case 3:
      case 5:
      case 6:
         iret = IntPII;
         break;
      case 7:
      case 8:
      case 10:
      case 11:
         iret = IntPIII;
         break;
      case  9:
      case 13:
         iret = IntPM;
      case 14:
         iret = IntCoreDuo;
         break;
      default:
         iret = MACHOther;
      }
      break;
   case Pentium4:
      switch(model)
      {
      case 0:
      case 1:
      case 2:
         iret = IntP4;
         break;
      case 3:
      case 4:
         if (x8664)
            iret = IntP4E64;
         else
            iret = IntP4E;
         break;
      default:
         iret = MACHOther;
      }
      break;
   case Itanium:
      switch(model)
      {
      case 7:
         iret = IA64Itan;
         break;
      case 0x1F:
         iret = IA64Itan2;
         break;
      default:
         iret = MACHOther;
      }
      break;
   case K7:
      switch(model)
      {
      case 4:
      case 6:
      case 8:
      case 10:
         iret = AmdAthlon;
         break;
      default:
         iret = MACHOther;
      }
      break;
   case Hammer:
      iret = AmdHammer64;
      break;
   case Efficeon:
      iret = TMEff;
      break;
   case Crusoe:  /* unsupported */
   default:
      iret = MACHOther;
   }
   return(iret);
}

void PrintUsage(char *name)
{
   fprintf(stderr, "USAGE: %s -c (cpu) -b (@ bits) -A (arch #)\n", name);
   exit(1);
}

enum WHATPROBE{Pcpu=1, P64=2, Parchnum=4};
int GetFlags(int nargs, char **args)
{
   int i, flag = 0;
   for (i=1; i < nargs; i++)
   {
      if (args[i][0] != '-') PrintUsage(args[0]);
      switch(args[i][1])
      {
      case 'c':
         flag |= Pcpu;
         break;
      case 'b':
         flag |= P64;
         break;
      case 'A':
         flag |= Parchnum;
         break;
      default:
         PrintUsage(args[0]);
      }
   }
   if (!flag)
     flag = Pcpu | P64;
   return(flag);
}

main(int nargs, char **args)
{
   int ierr, x86_64, flags;
   unsigned family, model;
   char *cpu="UNKNOWN", vendor[13];
   enum FAM fam;
   enum CHIP chip;
   enum MACHTYPE mach;

   flags = GetFlags(nargs, args);
   cpu = NULL;
   vendor[0] = '\0';
   ierr = ProbeArch(vendor, &family, &model, &x86_64);
/*
 * If ProbeArch worked, translate vendor+family+model to ATLAS config-name
 */
   if (!ierr)
   {
       fam = GetFamily(family);
       if (fam)
       {
          chip = Family2Chip(vendor, fam);
          if (chip)
          {
             mach = Chip2Mach(chip, model, x86_64);
             if (!mach) ierr = 300;
          }
          else ierr = 200;
       }
       else ierr = 100;
   }
   if (ierr)
   {
      fprintf(stderr, "ERROR: enum fam=%d, chip=%d, mach=%d\n", 
              fam, chip, mach);
      printf("ERROR %d: vendor='%s', family=%d, model=%d, x86_64=%d\n",
             ierr, vendor, family, model, x86_64);
   }
   else
   {
      if (flags == Pcpu)
         printf("cpu: %s\n", machnam[mach]);
      else if (flags == P64)
         printf("Pointer width: %d\n", x86_64 ? 64 : 32);
      else if (flags == Parchnum)
         printf("%d\n", mach);
      else
         printf("family=%d, model=%d, cpu='%s', Ptr bits=%d, arch#=%d\n",
                family, model, machnam[mach], x86_64?64:32, mach);
   }
   exit(ierr);
}
@ROUT archinfo_hpux.c
#include <stdio.h>
@skip #include <sys/mp.h>
@skip #include <sys/syscall.h>
@ROUT archinfo_aix.c
#include <stdio.h>
#include <sys/systemcfg.h>

/* 
 * ifdef guards for older systemcfg.h's:
 */
#ifndef POWER_620
   #define POWER_620 0x0040
#endif
#ifndef POWER_630
   #define POWER_630 0x0080
#endif
#ifndef POWER_A35
   #define POWER_A35 0x0100
#endif
#ifndef POWER_RS64II
   #define POWER_RS64II 0x0200
#endif
#ifndef POWER_RS64III
   #define POWER_RS64III 0x0400
#endif
#ifndef IA64
   #define IA64 0x0003
#endif
#ifndef IA64_M1
   #define IA64_M1 0x0001
#endif
#ifndef IA64_M2
   #define IA64_M2 0x0002
#endif

@ROUT archinfo_hpux.c archinfo_aix.c
enum WHATPROBE {Pcpu, Pnproc, Pl1, Pl2, Ptlb, Pall};

PrintUsage(char *nam)
{
   fprintf(stderr, "USAGE: %s -c (cpu) -n (#procs) -1 (L1 cache) -2 (L2 cache) -t (# of tlb)\n\n", nam);
   exit(1);
}

enum WHATPROBE GetFlags(int nargs, char **args)
{
   int i;
   enum WHATPROBE ret=Pall;

   if (nargs > 2) PrintUsage(args[0]);
   if (nargs > 1)
   {
      if (args[1][0] != '-') PrintUsage(args[0]);
      switch(args[1][1])
      {
      case 'c':
         ret = Pcpu;
         break;
      case 'n':
         ret = Pnproc;
         break;
      case '1':
         ret = Pl1;
         break;
      case '2':
         ret = Pl2;
         break;
      case 't':
         ret = Ptlb;
         break;
      default:
         ret = Pall;
      }
   }
   return(ret);
}

@ROUT archinfo_hpux.c
main(int nargs, char **args)
{
   enum WHATPROBE what;
   int ncpu;

   what = GetFlags(nargs, args);
   switch(what)
   {
   case Pnproc:
      ncpu = syscall(315, 1);
@skip      ncpu = syscall(SYSMPCTL, MCP_GETNUMSPUS);  /* syscall(315, 1); */
      printf("ncpus = %d\n", ncpu);
      break;
   default:
      fprintf(stderr, "Not implemented\n");
      exit(-1);
   }
   exit(0);
}
@ROUT archinfo_aix.c
main(int nargs, char **args)
{
   enum WHATPROBE what;
   char *cpu;
   int l1;

   what = GetFlags(nargs, args);
   l1 = _system_configuration.dcache_size;

   switch(what)
   {
   default:
      what = Pall;
   case Pall:
   case Pcpu:
      switch(_system_configuration.architecture)
      {
      case POWER_RS:
      case POWER_PC:
         switch(_system_configuration.implementation)
         { /* need to differintiate betweein Thin & Wide Pwr2 */
         case POWER_RS1:
            cpu = "Power1";
            break;
         case POWER_RSC:
            cpu = "POWER_RSC";
            break;
         case POWER_RS2:
            cpu = "Power2";
            break;
         case POWER_601:
            cpu = "PowerPC 601";
            break;
         case POWER_603:
            cpu = "PowerPC 603";
            break;
         case POWER_604:
            if (l1 == 32*1024) cpu = "PowerPC 604e";
            else if (l1 == 16*1024) cpu = "PowerPC 604";
            else cpu = "PowerPC 604 UNKNOWN";
            break;
         case POWER_620:
            cpu = "PowerPC 620";
            break;
         case POWER_630:
            cpu = "PowerPC 630";
            break;
         case POWER_A35:
            cpu = "PowerPC A35";
            break;
         case POWER_RS64II:
            cpu = "Power RS64II";
            break;
         case POWER_RS64III:
            cpu = "Power RS64III";
            break;
#ifdef POWER_4
         case POWER_4:
            cpu = "Power4";
            break;
#endif
         default:
            if (__power_rs())  /* power1, 2 or 3 */
               cpu = "UNKNOWN Power architecture";
            else if (__power_pc())  /* PPC of some type */
               cpu = "UNKNOWN PowerPC architecture";
            else cpu = "UNKNOWN";
         }
         break;
      case IA64:
         switch(_system_configuration.implementation)
         {
         case IA64_M1:
            cpu = "IA64 M1";
            break;
         case IA64_M2:
            cpu = "IA64 M2";
            break;
         default:
            cpu = "UNKNOWN IA64";
         }
         break;
      }
      printf("CPU type = %s\n", cpu);
      if (what != Pall) break;
   case Pnproc:
      if (what != Pall) break;
      printf("ncpus = %d\n", _system_configuration.ncpus);
   case Pl1:
      if (what != Pall) break;
      printf("L1 cache: size=%d, associativity=%d\n", 
             _system_configuration.dcache_size, 
             _system_configuration.dcache_asc);
   case Pl2:
      printf("L2 cache: size=%d, associativity=%d\n", 
             _system_configuration.L2_cache_size, 
             _system_configuration.L2_cache_asc);
      if (what != Pall) break;
   case Ptlb:
      printf("Number of TLB entries = %d\n", _system_configuration.dtlb_size);
   }
   exit(0);
}
@ROUT atlar
void PrintWords(WORDS *wp0)
{
   WORDS *wp;
   for (wp=wp0; wp; wp = wp->next) fprintf(stdout, "%s\n", wp->word);
}

static int strcode(char *str)
{
   int i, j=0;
   for (i=0; str[i] && i < unilen; i++) j += str[i];
   return(j);
}

static WORDS *GetWord(const char *str)
{
   WORDS *wp;

   wp = malloc(sizeof(WORDS));
   assert(wp);
   wp->word = (char *) str;
   wp->next = NULL;
   return(wp);
}

WORDS *FindAmbigWord(WORDS *wp0, char *str)
/*
 * returns first word with ambiguous match of unilen chars
 */
{
   WORDS *wp;
   int i, itst = unilen>>1;
   char ch = str[itst];

   for (wp=wp0; wp; wp = wp->next)
   {
      if (wp->word[itst] == ch)
      {
         i = strncmp(wp->word, str, unilen);
         if (i >= 0)
         {
            if (i) wp = NULL;
            break;
         }
      }
   }
   return(wp);
}

int AmbigCount(WORDS *wp0)
/*
 * returns number of entries with same unilen beginning, starting at wp0
 */
{
   WORDS *wp;
   int n, itst = (unilen>>1);

   if (wp0)
   {
      for (n=1, wp=wp0->next; wp; wp = wp->next, n++)
         if (strncmp(wp->word, wp0->word, unilen) != 0) break;
   }
   else n = 0;
   return(n);
}

WORDS *FindWord(WORDS *wp0, const int itst, const char *str)
{
   WORDS *wp;
   char ch = str[itst];
   int i;

   for (wp=wp0; wp; wp = wp->next)
   {
      if (wp->word[itst] == ch)
      {
         i = strcmp(wp->word, str);
         if (i >= 0)
         {
            if (i) wp = NULL;
            break;
         }
      }
   }
   return(wp);
}

WORDS *AddWordSorted(WORDS *wp0, const char *str)
/*
 * Adds str to list of sorted words, returning base of list
 */
{
   WORDS *wp, *wpp, *wp1;

   if (wp0 == NULL || strcmp(str, wp0->word) < 0) 
   {
      wp = GetWord(str);
      wp->next = wp0;
      wp0 = wp;
   }
   else
   {
      for(wpp=wp0, wp=wp0->next; wp; wp = wp->next)
      {
         if (strcmp(str, wp0->word) < 0) break;
         wpp = wp;
      }
      wp1 = GetWord(str);
      wp1->next = wp;
      wpp->next = wp1;
   }
   return(wp0);
}

ADDTREE *FindAT0(ADDTREE *atp, int sum)
/* 
 * Returns addtree node on match, parent node if not in tree
 */
{
   ADDTREE *ap;
   if (atp)
   {
      if (sum != atp->sum)
      {
         if (sum < atp->sum) ap = FindAT0(atp->lt, sum);
         else if (sum > atp->sum) ap = FindAT0(atp->gt, sum);
         if (ap == NULL) ap = atp;
      }
      else ap = atp;
   }
   else ap = NULL;
   return(ap);
}

ADDTREE *FindAT(ADDTREE *atp, int sum)
{
   ADDTREE *ap;
   if (atp)
   {
      if (sum < atp->sum) ap = FindAT(atp->lt, sum);
      else if (sum > atp->sum) ap = FindAT(atp->gt, sum);
      else ap = atp;
   }
   else ap = NULL;
   return(ap);
}

static ADDTREE *GetAT(int sum)
{
   ADDTREE *ap;

   ap = malloc(sizeof(ADDTREE));
   ap->lt = ap->gt = NULL;
   ap->eq = NULL;
   ap->sum = sum;
   return(ap);
}

ADDTREE *AddAT(ADDTREE *atp, int sum)
/*
 * Finds, and if necessary, creates an addtree node with value sum
 */
{
   ADDTREE *ap, *ap1;

   ap = FindAT0(atp, sum);
   if (ap)
   {
      if (ap->sum == sum) ap1 = ap;
      else
      {
         ap1 = GetAT(sum);
         if (sum > ap->sum) ap->gt = ap1;
         else ap->lt = ap1;
      }
   }
   else ap1 = GetAT(sum);
   return(ap1);
}

void AddStr(char *str)
{
   int code, len;
   ADDTREE *ap, *atp;

   len = strlen(str);
   code = strcode(str);
   if (len > unilen)
   {
      ap = AddAT(ambig, code);
      if (!ambig) ambig = ap;
      nambig++;
   }
   else
   {
      ap = AddAT(unamb, code);
      if (!unamb) unamb = ap;
      nunamb++;
   }
   ap->eq = AddWordSorted(ap->eq, str);
}

WORDS *FindStr(char *str)
{
   WORDS *wp=NULL;
   ADDTREE *ap;
   int len, sum, itst;

   len = strlen(str);
   sum = strcode(str);
   if (len <= unilen)
   {
      itst = 0;
      ap = FindAT(unamb, sum);
   }
   else
   {
      itst = unilen>>1;
      ap = FindAT(ambig, sum);
   }
   if (ap) wp = FindWord(ap->eq, itst, str);
   return(wp);
}

WORDS *FindAmbig(char *str)
/*
 * Returns first word that is ambiguous with <str>
 */
{
   ADDTREE *ap;
   WORDS *wp=NULL;
   int code;

   code = strcode(str);
   ap = FindAT(ambig, code);
   if (ap) wp = FindAmbigWord(ap->eq, str);
   return(wp);
}

void execmnd(int line, char *form, ...)
{
   static char ln[256];
   va_list argptr;
   int i;

   va_start(argptr, form);
   vsprintf(ln, form, argptr);
   va_end(argptr);
   if (i = system(ln))
   {
      fprintf(stderr, "system failed, line %d: %s", line, ln);
      exit(i);
   }
}

/*
 * raw file begins with 3 ints, <N> <maxlen> <syslen>, and then N
 * totlen length strings, the first maxlen+1 of which are the atlar
 * name with NULL terminator, and the next syslen+1 of which are the
 * system, truncated, name
 */
int FileIsThere(char *nam)
{
   FILE *fp;

   fp = fopen(nam, "r");
   if (fp == NULL) return(0);
   fclose(fp);
   return(1);
}

char *GetIndex(char *arnam)
{
   static char ln[128];
   if (FileIsThere(arnam))
      execmnd(__LINE__, "cd %s ; ar x %s %s\n", tmpdir, arnam, indxfile);
   sprintf(ln, "%s/%s", tmpdir, indxfile);
   return(ln);
}

char *ReadFiles(char *arnam, int nnew)
{
   FILE *fpin;
   int i, n=0;
   char *buff=NULL, *fnam;

   fnam = GetIndex(arnam);
   fpin = fopen(fnam, "rb");
   if (fpin)
   {
      fread(&maxlen, sizeof(int), 1, fpin);
      fread(&syslen, sizeof(int), 1, fpin);
      fread(&nambig, sizeof(int), 1, fpin);
      fread(&nunamb, sizeof(int), 1, fpin);
      n = nambig + nunamb + nnew;
      unilen = syslen - 3;
      totlen = syslen + maxlen + 2;
   }
   if (n > 0)
   {
      buff = malloc(sizeof(char)*( (nambig+nnew)*totlen + nunamb*(syslen+1) ));
      assert(buff);
      if (fpin)
         fread(buff, sizeof(char), nambig*totlen+nunamb*(syslen+1), fpin);
      if (fpin) fclose(fpin);
   }
   for (i=nambig+nunamb; i < n; i++) buff[i] = '\0';
   return(buff);
}

void WriteTree(FILE *fp, ADDTREE *ap, const int len)
{
   WORDS *wp;

   if (ap)
   {
      for (wp=ap->eq; wp; wp = wp->next)
         fwrite(wp->word, sizeof(char), len, fp);
      WriteTree(fp, ap->lt, len);
      WriteTree(fp, ap->gt, len);
   }
}

void WriteFiles(char *fnam)
{
   FILE *fp;

   fp = fopen(fnam, "wb");
   assert(fp);
   fwrite(&maxlen, sizeof(int), 1, fp);
   fwrite(&syslen, sizeof(int), 1, fp);
   fwrite(&nambig, sizeof(int), 1, fp);
   fwrite(&nunamb, sizeof(int), 1, fp);
   WriteTree(fp, unamb, syslen+1);
   WriteTree(fp, ambig, totlen);
   fclose(fp);
}

void CreateTree(char *buff)
/*
 * Creates lookup tree using buff read in by ReadFiles
 */
{
   int i, n;
   n = nunamb;
   for (nunamb=i=0; i < n; i++, buff += syslen+1) AddStr(buff);
   assert(nunamb == n);
   n = nambig;
   for (nambig=i=0; i < n; i++, buff += totlen) AddStr(buff);
   assert(nambig == n);
}

void KillWords(WORDS *wp0)
/*
 * Frees all word structures in linked list
 */
{
   WORDS *wp;

   while(wp0)
   {
      wp = wp0->next;
      free(wp0);
      wp0 = wp;
   }
}

void KillTree(ADDTREE *ap0)
/*
 * Kills entire tree structure
 */
{
   if (ap0)
   {
      KillWords(ap0->eq);
      KillTree(ap0->lt);
      KillTree(ap0->gt);
      free(ap0);
   }
}

@beginskip
WORDS *JoinLists(WORDS *wp0, *wp1);
/*
 * Joins to sorted list into one sorted list, returns ptr to start of 
 * combined list
 */
{
   WORDS *wp, *wpJ, *wpI, *wpJ0, wpJ1, wpI1;

   if (!wp1) return(wp0);
   else if (!wp0) return(wp1);

   i = strcmp(wp0->word, wp1->word);
   if (i <= 0)
   {
      wpJ = wp0;
      wp0 = wp0->next;
   }
   else
   {
      wpJ = wp1;
      wp1 = wp1->next;
   }
   wpJ0 = wpJ;
   wpJ->next = NULL;

   while (wp0 && wp1)
   {
      if (strcmp(wp0->word, wp1->word) <= 0)
      {
         wpJ->next = wp0;
         wpJ = wp0;
         wpI = wp1;
      }
      else
      {
         wpJ->next = wp1;
         wpJ = wp1;
         wpI = wp0;
      }
      for (wp=wpJ; wp; wp = wp->next)
         if (strcmp(wp->word, wpI->word) > 0) break;
      wpJ1 = wp; /* node in wpJ that wpI goes before */
/*
 *    wpI1 is last node in wpI chain that goes before wpJ1
 */
      for (wp=wpI->next; wp; wp = wp->next)
         if (strcmp(wp->word, wpJ1->word) > 0) break;
      for (wpI1=wpI; wpI1->next != wp; wpI1 = wpI1->next);

      wpJ->next = wpI;
      if (wpI == wp1)
      {
         for (wp1=wpI; wp1 != wpI1; wp1 = wp1->next);
         wp0 = wp0->next;
      }
      else
      {
         for (wp0=wpI; wp0 != wpI1; wp0 = wp0->next);
         wp1 = wp1->next;
      }
      if (wp0) wp0 = wp0->next;
      if (wp1) wp1 = wp1->next;
      wpI1->next = wpJ1;
      wpJ = wpJ1;
   }
   if (wp0) wpJ->next = wp0;
   else wpJ->next = wp1;

   return(wpJ0);
}

@endskip
WORDS *Args2Words(int nargs, char **args)
/*
 * Translates args array into WORDS
 */
{
   WORDS *wp0, *wp, *wpp=NULL;
   int i;

   if (nargs > 0)
   {
      wp0 = wp = malloc(sizeof(WORDS));
      assert(wp);
      wp->next = NULL;
      for (i=0; i < nargs; i++)
      {
         wpp = wp;
         wp->word = args[i];
         wp->next = malloc(sizeof(WORDS));
         wp = wp->next;
         assert(wp);
      }
      if (wpp) wpp->next = NULL;
      free(wp);
   }
   else wp0 = NULL;
   return(wp0);
}

static int IsPathChar(char *str)
{
   int iret = 0;
   if (*str == '/') iret = 1;
   else if (*str == '.') /* possible path */
   {
      if (str[1] == '/') iret = 1;
      else if (str[1] == '.' && str[2] == '/') iret = 1;
   }
   return(iret);
}

char *RemovePath(char *str)
/*
 * Returns a pointer to file, with path info stripped off
 */
{
   int i;
   if ( !IsPathChar(str) ) return(str);
   for (i=0; str[i]; i++);
   for (i--; str[i] != '/'; i--);
   return(str+i+1);
}

void ExternalRename(char *arnam)
/*
 * Renames files on aliasedp to appropriate name in tmpdir; must be
 * called _before_ InternalRename
 */
{
   WORDS *wp;
   for (wp=aliasedp; wp; wp = wp->next) /* rename files */
      execmnd(__LINE__, "cp %s %s/%s", wp->word, tmpdir, wp->word+maxlen+1);
}

void InternalRename(char *arnam)
/* 
 * extracts orig name to TMPDIR, moves files to new name, adds files
 * to aliased queue
 */
{
   WORDS *wp;
   char *sp;
   int j;

   if (renamep)
   {
/*
 *    Extract files into tmpdir, then delete them from the archive
 */
      j = sprintf(lnln, "cd %s ; ar x %s", tmpdir, arnam);
      for (wp=renamep; wp; wp = wp->next) j += sprintf(lnln+j, " %s", wp->word);
      execmnd(__LINE__, lnln);
      sp = strstr(lnln, "; ar x");
      sp[5] = 'd';
      execmnd(__LINE__, lnln);
/*
 *    Rename files
 */
      for (wp=renamep; wp; wp = wp->next) /* rename files */
         execmnd(__LINE__, "mv %s/%s %s/%s", tmpdir, wp->word, tmpdir, 
                 wp->word+maxlen+1);
/*
 *    Move files to aliasedp
 */
      for (wp=renamep; wp->next; wp = wp->next);
      wp->next = aliasedp;
      aliasedp = renamep;
      renamep = NULL;
   }
}

int GetUnusedInt(WORDS *wp0, int n)
{
   WORDS *wp=wp0;
   int *iused;
   int i, j, iun=(-1);

   assert(n < 999 && n > 0);
   if (n == 1)
   {
         if (wp->word[maxlen+1])
         {
            i = atoi(wp->word+totlen-4);
            if (i == 0) iun = 1;
            else iun = 0;
         }
         else iun = 1;
   }
   else
   {
      iused = malloc(n*sizeof(int));
      assert(iused);
      for (i=0; i < n; i++)
      {
         if (wp->word[maxlen+1]) iused[i] = atoi(wp->word+totlen-4);
         else iused[i] = -1;
         wp = wp->next;
      }
      for (j=n; j >= 0; j--)
      {
         for (i=0; i < n && iused[i] != j; i++);
         if (iused[i] != j)
         {
            iun = j;
            break;
         }
      }
      free(iused);
   }
   assert(iun != -1);
   return(iun);
}

void SupplyUniqueName0(char *str, WORDS *wp, int n)
/*
 * <str> must have length of <totlen>; writes into the last <syslen>+1
 * characters a name that is unique to <syslen> length, based on the
 * string name stored in the first <maxlen> characters
 */
{
   int i;

   wp = FindAmbig(str);
   if (wp) /* it is ambiguous */
   {
      n = AmbigCount(wp);
      i = GetUnusedInt(wp, n);
      strncpy(str+maxlen+1, str, unilen);
      sprintf(str+totlen-4, "%03d", i);
   }
   else str[maxlen+1] = '\0';
}

void SupplyUniqueName(char *str)
{
   WORDS *wp, *wp0, *wp1;
   int i, n=0;

   wp = FindAmbig(str);
   if (wp)
   {
      wp0 = wp;
      n = AmbigCount(wp);
      SupplyUniqueName0(str, wp, n);
      for (wp0=wp, i=0; i < n; i++, wp = wp->next) /* check for renaming */
      {
         if (wp->word[maxlen+1] == '\0') /* need to rename */
         {
            SupplyUniqueName0(wp->word, wp0, n);
            wp1 = GetWord(wp->word);
            wp1->next = renamep;
            renamep = wp1;
         }
      }
   }
   else str[maxlen+1] = '\0';
}

void KillIndexStr(ADDTREE *ap)
{
   WORDS *wp;

   if (ap)
   {
      KillIndexStr(ap->lt);
      KillIndexStr(ap->gt);
      for (wp=ap->eq; wp; wp = wp->next) free(wp->word);
   }
}
void BuildIndex(char *arnam)
/*
 * Builds a atlar index from an existing archive.
 * NOTE: if there are already truncated files in there, they will stay
 *       truncated
 */
{
   char *fnam, *str;
   FILE *fp;
   int n=0, len, i;

   sprintf(lnln, "ar t %s", arnam);
   fnam = CmndResults(NULL, lnln);
   assert(fnam);
   fp = fopen(fnam, "r");
   assert(fp);
   while(fgets(lnln, maxlen, fp))
   {
      len = strlen(lnln);
      for (i=len-1; i > 0 && isspace(lnln[i]); i--) lnln[i] = '\0';
      len = i+1;
      if (len <= unilen)
      {
         str = calloc(syslen+1, sizeof(char));
         assert(str);
         strcpy(str, lnln);
      }
      else
      {
         str = calloc(totlen, sizeof(char));
         assert(str);
         strcpy(str, lnln);
         SupplyUniqueName(str);
      }
      AddStr(str);
      n++;
   }
   fclose(fp);
   WriteFiles(indxfp);

   KillIndexStr(ambig);
   KillIndexStr(unamb);
   KillTree(ambig);
   KillTree(unamb);

   execmnd(__LINE__, "ar r %s %s\n", arnam, indxfp);
}

void PrintTable(char *arnam, int VERB)
{
   int i, N;
   char *buff, *bf;

   buff = bf = ReadFiles(arnam, 0);
   fprintf(stdout, "nambig=%d, nunamb=%d\n\n", nambig, nunamb);
   if (VERB)
   {
      for (i=0; i < nunamb; i++, bf += syslen+1) 
         fprintf(stdout, "%s\n", bf);
      for (i=0; i < nambig; i++, bf += totlen) 
      {
         if (bf[maxlen+1]) fprintf(stdout, "%s --> %s\n", bf, bf+maxlen+1);
         else fprintf(stdout, "%s\n", bf);
      }
   }
   else
   {
      for (i=0; i < nunamb; i++, bf += syslen+1) fprintf(stdout, "%s\n", bf);
      for (i=0; i < nambig; i++, bf += totlen) fprintf(stdout, "%s\n", bf);
   }
   free(buff);
}

void ReplaceFiles(char *arnam, WORDS *wp0, char *bf0)
/*
 * handles calls of form "ar r"
 */
{
   WORDS *wp, *wp1, *wp2;
   char *sp, *sp1, *bf=bf0;
   int i, j;

   for (wp=wp0; wp; wp = wp1)
   {
      sp = RemovePath(wp->word);
      wp2 = FindStr(sp);
      if (!wp2) /* not already in archive, must add */
      {
         sp1 = bf;
         bf += totlen;
         strcpy(sp1, sp);
         SupplyUniqueName(sp1);
         AddStr(sp1);
         wp2 = FindStr(sp);
      }
      wp1 = wp->next;
      i = strlen(sp);
      if (i > unilen && wp2->word[maxlen+1] != '\0')
      {
         execmnd(__LINE__, "cp %s %s/%s", wp->word, tmpdir, 
                 wp2->word[maxlen+1]);
         wp2 = GetWord(wp2->word);  /* aliased need new word pointers */
         wp2->next = aliasedp;
         aliasedp = wp2;
      }
      else /* not aliased */
      {
         wp->next = unaliasp;
         unaliasp = wp;
      }
   }
   InternalRename(arnam);  /* rename old files if necessary */
   WriteFiles(indxfp);

   j = sprintf(lnln, "ar r %s %s", arnam, tmpdir, indxfp);
   for (wp=aliasedp; wp; wp = wp->next)
      j += sprintf(lnln+j, " %s/%s", tmpdir, wp->word+maxlen+1);
   for (wp=unaliasp; wp; wp = wp->next) j += sprintf(lnln+j, " %s", wp->word);
   assert(system(lnln) == 0);
   KillWords(aliasedp);
   aliasedp = unaliasp = NULL;
}

void PrintUsage(char *fnam)
{
   fprintf(stderr, "USAGE: %s {sdrtx}[covVf] <archive> <files>\n", fnam);
   exit(-1);
}

enum ARACTION GetDefaults(int nargs, char **args, char **arch0, WORDS **wp0,
                          char **buff0)
{
   char *flags, *arch, *sp, *arnam, *buff;
   enum ARACTION act=Replace;

   indxfile = "atlar.idx";
   *wp0 = NULL;
   if (nargs < 3) PrintUsage(args[0]);
   flags = args[1];
   arch = args[2];

   if (strchr(flags, 's')) act = Ranlib;
   else if (strchr(flags, 'd')) act = Delete;
   else if (strchr(flags, 'r')) act = Replace;
   else if (strchr(flags, 't')) act = Print;
   else if (strchr(flags, 'x')) act = Extract;
   else PrintUsage(args[0]);

   if (arch[0] != '/') /* need to prefix arnam with pwd */
   {
      sp = getenv("PWD");
      if (!sp)
      {
         assert(CmndOneLine(NULL, "pwd", lnln) == 0);
         sp = lnln;
      }
      arnam = malloc( (strlen(sp)+strlen(arch)+2)*sizeof(char) );
      strcpy(arnam, sp);
      strcat(arnam, "/");
      strcat(arnam, arch);
   }
   else
   {
      arnam = malloc( (strlen(arch)+1)*sizeof(char) );
      strcpy(arnam, arch);
   }
   *arch0 = arnam;
   unilen = syslen - 3;  /* unique length */
   totlen = syslen + maxlen + 2;
   tmpdir = Mstr(TMPDIR);
   indxfile = "atlar.idx";
   sprintf(indxfp, "%s/%s", tmpdir, indxfile);

   if (act == Delete || act == Replace || act == Extract)
   {
      buff = ReadFiles(arnam, nargs-3);
      CreateTree(buff);
@skip      *wp0 = Args2Words(nargs-3, args+3, buff+nambig*totlen+nunamb*(syslen+1));
      *wp0 = Args2Words(nargs-3, args+3);
   }

   *buff0 = buff;

   return(act);
}
/*
 m : move -- not supported
 p : not supported
 q : quick append -- not supported

 d : delete files
 r : insert files with replacement
 t : display table listing of contents
 x : extract members

 modifiers:
 a,b,i,l : not supported
 c : create lib -- ignore
 f : ignore
 o,v,V : passed to ar
 s : build symbol table, not supported
 S : insert with symbol, not supported
 u : not supported
 */
main(int nargs, char **args)
{
   enum ARACTION act;
   WORDS *wp;
   char *arnam=NULL, *buff, *bf;

   act = GetDefaults(nargs, args, &arnam, &wp, &buff);
   bf = buff + nambig*totlen + nunamb*(syslen+1);
   switch(act)
   {
   case Replace:
      ReplaceFiles(arnam, wp, bf);
      break;
   case Delete:
      break;
   case Print:
      PrintTable(arnam, 1);
      break;
   case Extract:
      break;
   case Ranlib:
      assert(wp == NULL);
      BuildIndex(arnam);
   }
   if (wp) KillWords(wp);
   if (arnam) free(arnam);
   if (buff) free(buff);
   exit(0);
}
@ROUT probe_asm.c
#include <stdio.h>
main(int nargs, char **args)
{
   int asm_probe(int i);
   int i;
   i = asm_probe(7);
   if (i != 21)
   {
      fprintf(stdout, "FAILURE, i=%d!!\n", i);
      fprintf(stderr, "FAILURE, i=%d!!\n", i);
      exit(-1);
   }
   fprintf(stdout, "SUCCESS\n");
   exit(0);
}
@ROUT probe_linux_parisc.s probe_hpux_parisc.s
        .LEVEL 2.0
@ROUT probe_hpux_parisc.s
        .SPACE $TEXT$
        .SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY
@ROUT probe_linux_parisc.s
        .text
@ROUT probe_linux_parisc.s probe_hpux_parisc.s
; PA-RISC assembler for:
; int asm_probe(int i)
; RETURNS: i*3
        .align 4
@ROUT probe_hpux_parisc.s
        .SUBSPA $CODE$
        .EXPORT asm_probe,ENTRY,PRIV_LEV=3
asm_probe
@ROUT probe_linux_parisc.s
        .globl asm_probe
asm_probe:
@ROUT probe_linux_parisc.s probe_hpux_parisc.s
        .PROC
        .CALLINFO FRAME=0,NO_CALLS
        .ENTRY
        depw,z  %r26, 29,30, %r28  ; r28 = 4 * i
        sub     %r28, %r26, %r28
        bve     (%r2)
        nop
        .EXIT
        .PROCEND
@ROUT probe_gas_linux_ppc.s
# Linux PPC assembler for:
# int asm_probe(int i)
# RETURNS: i*3
.globl asm_probe
asm_probe:
	add	4, 3, 3
	add	3, 3, 4
	blr
@ROUT probe_as_osx_ppc.s
; Linux PPC assembler for:
; int asm_probe(int i)
; RETURNS: i*3
.globl _asm_probe
_asm_probe:
	add	r4, r3, r3
	add	r3, r3, r4
	blr
@ROUT probe_gas_x8632.S
# x86-32 assembler for:
# int asm_probe(int i)
# RETURNS: i*3
#
.text
#if defined(ATL_OS_WinNT) || defined(ATL_OS_Win9x) || defined(ATL_OS_OSX)
.globl _asm_probe
_asm_probe:
#else
.globl asm_probe
asm_probe:
#endif
        movl    4(%esp), %eax
        movl    %eax, %ecx
        shl     $1, %eax
        addl    %ecx, %eax
        ret
@ROUT probe_gas_x8664.S
# x86-64 assembler for:
# int asm_probe(int i)
# RETURNS: i*3
#
.text
#if defined(ATL_OS_WinNT) || defined(ATL_OS_Win9x) || defined(ATL_OS_OSX)
.global asm_probe
asm_probe:
#else
.global asm_probe
asm_probe:
#endif
        movl    %edi, %eax
        shl     $1, %eax
        addl    %edi, %eax
        ret
@ROUT probe_gas_sparc.s
!
! sparc assembler for:
! int asm_probe(int i)
! RETURNS: i*3
!
.section        ".text"
        .align 4
        .global asm_probe
        .type   asm_probe,#function
asm_probe:
        sll     %o0, 1, %o1
        add     %o1, %o0, %o0
        retl
        nop
@ROUT probe_altivec.c
@extract -b @(topd)/gen.inc what=cw @(cw01)
#include <stdio.h>
#include <stdlib.h>
#ifdef ATL_AVgcc
   #include <altivec.h>
#endif
main(int nargs, char **args)
{
   char ln[128];
   float *tp;
#ifdef ATL_AVgcc
   vector float v0, v1 = (vector float) {2.0f, 3.0f, 4.0f, 5.0f};
#else
   vector float v0, v1 = (vector float) (2.0f, 3.0f, 4.0f, 5.0f);
#endif

   tp = (void*) (16+ ((((size_t)ln)>>4)<<4));
   tp[0] = 0.0; tp[1] = 1.0; tp[2] = 2.0; tp[3] = 3.0;
   v0 = vec_ld(0, tp);
   v0 = vec_add(v0, v1);
   vec_st(v0, 0, tp);
   vec_st(v1, 0, tp+4);
   if (tp[0] != 2.0f || tp[1] != 4.0f || tp[2] != 6.0f || tp[3] != 8.0f)
   {
      printf("FAILURE\n");
      exit(1);
   }
   else if (tp[4] != 2.0f || tp[5] != 3.0f || tp[6] != 4.0f || tp[7] != 5.0f)
   {
      printf("FAILURE\n");
      exit(2);
   }
   printf("SUCCESS\n");
   exit(0);
}
@ROUT probe_SSE3.c
@extract -b @(topd)/gen.inc what=cw -def cdate 2004 -def author "Peter Soendergaard" -def contrib "R. Clint Whaley"

/*
 * Hacked by RCW to probe for SSE3 on 03/19/04.
 */
#include <stdio.h>

#define gen_vec_rr(op,reg1,reg2) \
        __asm__ __volatile__ (#op " %%" #reg1 ", %%" #reg2 \
                              :  /* nothing */ \
                              : /* nothing */)


#define gen_vec_mr(op,mem,reg) \
        __asm__ __volatile__ (#op " %0, %%" #reg \
                              :  /* nothing */ \
                              : "m" (((mem)[0])), "m" (((mem)[1])))


#define gen_vec_rm(op,reg,mem) \
        __asm__ __volatile__ (#op " %%" #reg ", %0" \
                              : "=m" (((mem)[0])), "=m" (((mem)[1])) \
                              :  /* nothing */ )

#define vec_mov_mr(mem,reg)     gen_vec_mr(lddqu,mem,reg)
#define vec_mov_rm(reg,mem)     gen_vec_rm(movupd,reg,mem)
#define vec_add_rr(reg1,reg2)   gen_vec_rr(haddpd,reg1,reg2)

#define reg0 xmm0
#define reg1 xmm1

main()
{

  int i;
  double testv1[2],testv2[2],testv3[2];

  testv1[0] = 1.0; testv1[1] = 2.0;
  testv2[0] = 3.0; testv2[1] = 4.0;

  vec_mov_mr(testv1,reg0);
  vec_mov_mr(testv2,reg1);
  vec_add_rr(reg1,reg0);
  vec_mov_rm(reg0,testv3);

  if (testv3[0] != 3.0 || testv3[1] != 7.0)
  {
     printf("FAILURE\n");
     exit(1);
   }

  printf("SUCCESS\n");
  exit(0);
}
@ROUT probe_3dnow1.c probe_3dnow2.c probe_SSE1.c probe_SSE2.c
@extract -b @(topd)/gen.inc what=cw -def cdate 2000 -def author "Peter Soendergaard"
#include <stdio.h>
@ROUT probe_3dnow1.c

#define VECLEN 2

#define gen_vec_rr(op,reg1,reg2) \
        __asm__ __volatile__ (#op " %%" #reg1 ", %%" #reg2 \
                              :  /* nothing */ \
                              : /* nothing */)


#define gen_vec_mr(op,mem,reg) \
        __asm__ __volatile__ (#op " %0, %%" #reg \
                              :  /* nothing */ \
                              : "m" (((mem)[0])), "m" (((mem)[1])))

#define gen_vec_rm(op,reg,mem) \
        __asm__ __volatile__ (#op " %%" #reg ", %0" \
                              : "=m" (((mem)[0])), "=m" (((mem)[1])) \
			      :  /* nothing */ )                            


#define vec_mov_mr(mem,reg)     gen_vec_mr(movq,mem,reg)
#define vec_mov_rm(reg,mem)     gen_vec_rm(movq,reg,mem)
#define vec_add_rr(reg1,reg2)   gen_vec_rr(pfadd,reg1,reg2)

#define reg0 mm0
#define reg1 mm1

main()
{

  int i;
  float testv1[VECLEN],testv2[VECLEN],testv3[VECLEN];
  
  for (i=0;i<VECLEN;i++)
    {
      testv1[i]=i;
      testv2[i]=i+2;
      testv3[i]=0;
    }
  
  __asm__ __volatile__ ("femms");
  
  vec_mov_mr(testv1,reg0);
  vec_mov_mr(testv2,reg1);
  vec_add_rr(reg1,reg0);
  vec_mov_rm(reg0,testv3);
  
  __asm__ __volatile__ ("femms");

  for (i=0;i<VECLEN;i++)
    {
      if (testv3[i]!=(2*i+2))
	{
	  printf("FAILURE\n");
	  exit(1);
	}
    }

  printf("SUCCESS\n");
  exit(0);

}
@ROUT probe_3dNow2.c
#define VECLEN 2

#define gen_vec_rr(op,reg1,reg2) \
        __asm__ __volatile__ (#op " %%" #reg1 ", %%" #reg2 \
                              :  /* nothing */ \
                              : /* nothing */)


#define gen_vec_mr(op,mem,reg) \
        __asm__ __volatile__ (#op " %0, %%" #reg \
                              :  /* nothing */ \
                              : "m" (((mem)[0])), "m" (((mem)[1])))

#define gen_vec_rm(op,reg,mem) \
        __asm__ __volatile__ (#op " %%" #reg ", %0" \
                              : "=m" (((mem)[0])), "=m" (((mem)[1])) \
			      :  /* nothing */ )                            


#define vec_mov_mr(mem,reg)     gen_vec_mr(movq,mem,reg)
#define vec_mov_rm(reg,mem)     gen_vec_rm(movq,reg,mem)
#define vec_add_rr(reg1,reg2)   gen_vec_rr(pfadd,reg1,reg2)

#define reg0 mm0
#define reg1 mm1

main()
{

  int i;
  float testv1[VECLEN],testv2[VECLEN],testv3[VECLEN];
  
  for (i=0;i<VECLEN;i++)
    {
      testv1[i]=i;
      testv2[i]=i+2;
      testv3[i]=0;
    }
  
  __asm__ __volatile__ ("femms");

  __asm__ __volatile__ ("sfence");
  
  vec_mov_mr(testv1,reg0);
  vec_mov_mr(testv2,reg1);
  vec_add_rr(reg1,reg0);
  vec_mov_rm(reg0,testv3);
  
  __asm__ __volatile__ ("femms");

  for (i=0;i<VECLEN;i++)
    {
      if (testv3[i]!=(2*i+2))
	{
	  printf("FAILURE\n");
	  exit(1);
	}
    }

  printf("SUCCESS\n");
  exit(0);

}
@ROUT probe_sse2.c
#define VECLEN 2

#define gen_vec_rr(op,reg1,reg2) \
        __asm__ __volatile__ (#op " %%" #reg1 ", %%" #reg2 \
                              :  /* nothing */ \
                              : /* nothing */)


#define gen_vec_mr(op,mem,reg) \
        __asm__ __volatile__ (#op " %0, %%" #reg \
                              :  /* nothing */ \
                              : "m" (((mem)[0])), "m" (((mem)[1])))


#define gen_vec_rm(op,reg,mem) \
        __asm__ __volatile__ (#op " %%" #reg ", %0" \
                              : "=m" (((mem)[0])), "=m" (((mem)[1])) \
                              :  /* nothing */ )                          

#define vec_mov_mr(mem,reg)     gen_vec_mr(movupd,mem,reg)
#define vec_mov_rm(reg,mem)     gen_vec_rm(movupd,reg,mem)
#define vec_add_rr(reg1,reg2)   gen_vec_rr(addpd,reg1,reg2)

#define reg0 xmm0
#define reg1 xmm1

main()
{

  int i;
  double testv1[VECLEN],testv2[VECLEN],testv3[VECLEN];
  
  for (i=0;i<VECLEN;i++)
    {
      testv1[i]=i;
      testv2[i]=i+2;
      testv3[i]=0;
    }
  
  vec_mov_mr(testv1,reg0);
  vec_mov_mr(testv2,reg1);
  vec_add_rr(reg1,reg0);
  vec_mov_rm(reg0,testv3);

  for (i=0;i<VECLEN;i++)
    {
      if (testv3[i]!=(2*i+2))
	{
	  printf("FAILURE\n");
	  exit(1);
	}
    }

  printf("SUCCESS\n");
  exit(0);
}
@ROUT probe_sse1.c
#define VECLEN 4

#define gen_vec_rr(op,reg1,reg2) \
        __asm__ __volatile__ (#op " %%" #reg1 ", %%" #reg2 \
                              :  /* nothing */ \
                              : /* nothing */)


#define gen_vec_mr(op,mem,reg) \
        __asm__ __volatile__ (#op " %0, %%" #reg \
                              :  /* nothing */ \
                              : "m" (((mem)[0])), "m" (((mem)[1])), "m" (((mem)[2])), "m" (((mem)[3])))


#define gen_vec_rm(op,reg,mem) \
        __asm__ __volatile__ (#op " %%" #reg ", %0" \
                              : "=m" (((mem)[0])), "=m" (((mem)[1])), "=m" (((mem)[2])), "=m" (((mem)[3])) \
                              :  /* nothing */ )                          

#define vec_mov_mr(mem,reg)     gen_vec_mr(movups,mem,reg)
#define vec_mov_rm(reg,mem)     gen_vec_rm(movups,reg,mem)
#define vec_add_rr(reg1,reg2)   gen_vec_rr(addps,reg1,reg2)

#define reg0 xmm0
#define reg1 xmm1

main()
{

  int i;
  float testv1[VECLEN],testv2[VECLEN],testv3[VECLEN];
  
  for (i=0;i<VECLEN;i++)
    {
      testv1[i]=i;
      testv2[i]=i+2;
      testv3[i]=0;
    }
  
  vec_mov_mr(testv1,reg0);
  vec_mov_mr(testv2,reg1);
  vec_add_rr(reg1,reg0);
  vec_mov_rm(reg0,testv3);

  for (i=0;i<VECLEN;i++)
    {
      if (testv3[i]!=(2*i+2))
	{
	  printf("FAILURE\n");
	  exit(1);
	}
    }

  printf("SUCCESS\n");
  exit(0);

}

@ROUT SolErr.c
#include <stdio.h>

void ATL_dlascal(const int M, const int N, const double *x, double *A, 
                 const int lda)
{

fprintf(stderr, "line %d of %s \n", __LINE__, __FILE__);
fprintf(stderr, "line %d of %s, x=%f\n", __LINE__, __FILE__, *x);
   if (*x != 0.0);
fprintf(stderr, "line %d of %s \n", __LINE__, __FILE__);
}

void bob(int M, int N, const double *A, int LDA, const double *B, int LDB,
         const double bet0, double *C, int LDC )
{
   ATL_dlascal(M, N, &bet0, C, LDC); 
}

main()
{
   double A[110], B[110], C[110];
   double bet=22.8;
   ATL_dlascal(1,1,&bet,C,11); 
   bob(10, 10, A, 11, B, 11, 3.3, C, 11);
   exit(0);
}
@ROUT cf2c_char.c
#if defined(Add_) || defined(F77IsF2C)
   #define crout crout_
#elif defined(UPCASE)
   #define crout CROUT
#endif
#ifdef SunStyle

void crout(char *str1, int *n1, char *str2, int *n2, int three, int five)
{
   if ( (*n1 != -1) || (*n2 != -2) || (three != 3) || (five != 5) ) exit(-1);
   if (str1[0] != '1' || str1[1] != '2' || str1[2] != '3') exit(-1);
   if (str2[0] != '1' || str2[1] != '2' || str2[2] != '3' ||
       str2[3] != '4' || str2[4] != '5') exit(-1);
   printf("-DSunStyle\n");
}

#elif defined(CrayStyle)

#include <fortran.h>
void crout(_fcd str1, int *n1, _fcd str2, int *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) ) exit(-1);
   if (*(_fcdtocp(str1)) != '1' || *(_fcdtocp(str2)) != '1' ) exit(-1);
   printf("-DCRAY\n");
}

#elif defined(StructVal)

typedef struct {char *cp; F77_INTEGER len;} F77_CHAR;
void crout(F77_CHAR str1, int *n1, F77_CHAR str2, int *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1.len != 3) || (str2.len != 5) )
      exit(-1);
   if (str1.cp[0] != '1' || str1.cp[1] != '2' || str1.cp[2] != '3') exit(-1);
   if (str2.cp[0] != '1' || str2.cp[1] != '2' || str2.cp[2] != '3' ||
       str2.cp[3] != '4' || str2.cp[4] != '5') exit(-1);
   printf("-DStringStructVal\n");
}
#elif defined(StructPtr)
typedef struct {char *cp; F77_INTEGER len;} *F77_CHAR;
void crout(F77_CHAR str1, int *n1, F77_CHAR str2, int *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1->len != 3) || (str2->len != 5) )
      exit(-1);
   if (str1->cp[0] != '1' || str1->cp[1] != '2' || str1->cp[2] != '3') exit(-1);
   if (str2->cp[0] != '1' || str2->cp[1] != '2' || str2->cp[2] != '3' ||
       str2->cp[3] != '4' || str2->cp[4] != '5') exit(-1);
   printf("-DStringStructPtr\n");
}
#endif

@ROUT cname.c
#include <stdio.h>
void c_routine_(void)  { printf("-DAdd_\n"); }
void c_routine(void)   { printf("-DNoChange\n"); }
void C_ROUTINE(void)  { printf("-DUpCase\n"); }
void c_routine__(void) { printf("-DAdd__\n"); }
@ROUT winf77.c_repeat
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "defdf.h"
#ifndef DEFDF
   #define DEFDF "c:/Program Files/DevStudio/DF/BIN/DF.EXE"
#endif

int slashdrivesub(char *ln)
/*
 * replaces \\c\ with c:\, returns change in string length
 * this version required for older cygwins
 */
{
   char *sp, *lp=ln, ctmp;
   int nrep=0;
   do
   {
      sp = strstr(lp, "\\\\");
      if (sp && strlen(sp) > 3)
      {
         if (sp[2] == 'a' || sp[2] == 'b' || sp[2] == 'c' || sp[2] == 'd' ||
             sp[2] == 'e' || sp[2] == 'f' || sp[2] == 'g' || sp[2] == 'h')
         {
            if (sp[3] == '\\')
            {
               ctmp = sp[2];
               sp[0] = sp[2];
               sp[1] = ':';
               sp[2] = '\\';
               for (lp=sp+3; *lp = lp[1]; lp++);
               lp = sp + 3;
               nrep++;
            }
            else lp = sp + 2;
         }
         else lp = sp + 2;
      }
      else lp = sp + 2;
   }
   while (sp);
   return(-nrep);
}

int cygdrivesub(char *ln)
/*
 * replaces \cygdrive\c\ with c:\, returns change in string length
 * this version works cygnus version 1.1.0
 */
{
   char *sp;
   int i=0;

   while(sp = strstr(ln, "\\cygdrive\\"))
   {
      i++;
      sp[0] = sp[10];
      sp[1] = ':';
      sp[2] = '\\';
      sp += 3;
      while (*sp = sp[9]) sp++;
   }
   return( slashdrivesub(ln) - (i*9) );
}

void slashsub(char *ln)
/* 
 * changes forward slash of unix to backslash of windoze
 */
{
   int i;
   for (i=0; ln[i]; i++) if (ln[i] == '/') ln[i] = '\\';
}

void doto2dotobj(char *ln)
/*
 * changes all occurences of unix's .o extension to windoze-friendly obj
 */
{
   char ln2[1024];
   int i, j=0;
   for (i=0; ln[i]; i++)
   {
      ln2[j++] = ln[i];
      if (ln[i] == '.' && ln[i+1] == 'o' && isspace(ln[i+2]))
      {
         ln2[j] = 'o';
         ln2[j+1] = 'b';
         ln2[j+2] = 'j';
         ln2[j+3] = ln[i+2];
         j += 4;
         i += 2;
      }
   }
   ln2[j] = '\0';
   sprintf(ln, "%s", ln2);
}

#ifdef DEBUG

#define system SYSTEM
int system(char *ln)
{
   fprintf(stdout, "%s\n", ln);
   return(0);
}

#endif

typedef struct wOrDs WORDS;
struct wOrDs
{
   char *word;
   WORDS *next;
};

void KillWords(WORDS *wp)
{
   WORDS *wpn;

   while (wp)
   {
      free(wp->word);
      wpn = wp->next;
      free(wp);
      wp = wpn;
   }
}

WORDS *AddWord(WORDS *wbas, char *wrd, int wlen)
{
   WORDS *wp;
   int i;

   wp = malloc(sizeof(WORDS));
   assert(wp);
   wp->word = malloc( (wlen+1) * sizeof(char) );
   for (i=0; i != wlen; i++) wp->word[i] = wrd[i];
   wp->word[i] = '\0';
   wp->next = wbas;
   return(wp);
}

WORDS *AddFile(WORDS *wbase, char *fnam)
{
   int i, len;
   len = strlen(fnam);
   assert(len > 2);
   if (fnam[len-1] = 'f' && fnam[len-2] == '.');
   {
      for (i=len-3; i > 0; i--)
      {
         if (fnam[i] == ' ' || fnam[i] == '/' || fnam[i] == '\\')
         {
            i++;
            break;
         }
      }
      wbase = AddWord(wbase, fnam+i, len-i-2);
   }
   return(wbase);
}

int RenameFiles(WORDS *wbase)
{
   WORDS *wp;
   char ln[1024];

   for (wp=wbase; wp; wp = wp->next)
   {
      sprintf(ln, "MOVE %s.obj %s.o\n", wp->word, wp->word);
      fprintf(stdout, "%s", ln);
      if (system(ln)) return(1);
   }
   return(0);
}

main(int nargs, char **args)
{
   char ln[2048], *cptr=NULL;
   int i, j, k, ierr, ic;
   int COMP=0, RENAME=0;
   WORDS *wbase=NULL;

   ic = sprintf(ln, "\"%s\" ", DEFDF);
   slashsub(ln);
   ic += sprintf(ln+ic, "/iface:cref ");

   for (i=1; i < nargs; i++)
   {
      if (args[i][0] == '-')  /* compiler flag */
      {
         if (args[i][1] == 'o') /* handle renaming, guess exe not .obj */
         {
            RENAME = 1;
            k = strlen(args[++i]);
            j = sprintf(ln+ic, "/Fe%s.exe ", args[i]);
            cptr = ln+ic;
            slashsub(ln+ic+3);
         }
         else if (args[i][1] == 'l') /* library to link against */
         {
            j = sprintf(ln+ic, "/link:DEFAULTLIB:%s", &args[i][2]);
            slashsub(ln+ic+17);
         }
         else
         {
            if (args[i][1] == 'c') COMP=1;
            j = sprintf(ln+ic, "/%s ", &args[i][1]);
            slashsub(ln+ic+1);
         }
      }
      else  /* must be files, not flags */
      {
         j = sprintf(ln+ic, "%s ", args[i]);
         if (j > 3 && ln[ic+j-2] == 'f' && ln[ic+j-3] == '.')
         { /* add this file to list of files to be moved to .o */
            wbase = AddFile(wbase, args[i]);
         }
         slashsub(ln+ic);
      }
      ic += j;
   }
   sprintf(ln+ic, "\n");
   cygdrivesub(ln);
   if (RENAME && COMP) /* gotta use different rename command if not exe */
   {
      if (cptr) cptr[2] = 'o';
      cptr = strstr(cptr, ".exe");
      cptr[0] = cptr[1] = cptr[2] = cptr[3] = ' ';
   }
   fprintf(stdout, "%s", ln);
   ierr = system(ln);
   if (!ierr && COMP && !RENAME) /* rename the .obj to .o */
      ierr = RenameFiles(wbase);
   KillWords(wbase);
   exit(ierr);
}
@ROUT cf2cint.c
#if defined(Add_) || defined(Add__)
   #define c2fint c2fint_
#elif defined(UpCase)
   #define c2fint C2FINT
#endif
void c2fint(void *vp)
{
   int *ip=vp;
   long *lp=vp;
   short *sp=vp;

   if ( (sizeof(long) != sizeof(int)) && (*lp == 1) )
      printf("F77 INTEGER -> C long\n");
   else if (*ip == 1) printf("F77 INTEGER -> C int\n");
   else if (*sp == 1) printf("F77 INTEGER -> C short\n");
}
@ROUT cf2cstr.c
#if defined(Add_) || defined(Add__)
   #define crout crout_
#elif defined(UpCase)
   #define crout CROUT
#endif
#ifdef SunStyle

void crout(char *str1, F77_INTEGER *n1, char *str2, F77_INTEGER *n2, 
           F77_INTEGER three, F77_INTEGER five)
{
   if ( (*n1 != -1) || (*n2 != -2) || (three != 3) || (five != 5) ) exit(-1);
   if (str1[0] != '1' || str1[1] != '2' || str1[2] != '3') exit(-1);
   if (str2[0] != '1' || str2[1] != '2' || str2[2] != '3' ||
       str2[3] != '4' || str2[4] != '5') exit(-1);
   printf("-DSunStyle\n");
}

#elif defined(CrayStyle)

#include <fortran.h>
void crout(_fcd str1, F77_INTEGER *n1, _fcd str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) ) exit(-1);
   if (*(_fcdtocp(str1)) != '1' || *(_fcdtocp(str2)) != '1' ) exit(-1);
   printf("-DCrayStyle\n");
}

#elif defined(StructVal)

typedef struct {char *cp; F77_INTEGER len;} F77_CHAR;
void crout(F77_CHAR str1, F77_INTEGER *n1, F77_CHAR str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1.len != 3) || (str2.len != 5) )
      exit(-1);
   if (str1.cp[0] != '1' || str1.cp[1] != '2' || str1.cp[2] != '3') exit(-1);
   if (str2.cp[0] != '1' || str2.cp[1] != '2' || str2.cp[2] != '3' ||
       str2.cp[3] != '4' || str2.cp[4] != '5') exit(-1);
   printf("-DStringStructVal\n");
}
#elif defined(StructPtr)
typedef struct {char *cp; F77_INTEGER len;} *F77_CHAR;
void crout(F77_CHAR str1, F77_INTEGER *n1, F77_CHAR str2, F77_INTEGER *n2)
{
   if ( (*n1 != -1) || (*n2 != -2) || (str1->len != 3) || (str2->len != 5) )
      exit(-1);
   if (str1->cp[0] != '1' || str1->cp[1] != '2' || str1->cp[2] != '3') exit(-1);
   if (str2->cp[0] != '1' || str2->cp[1] != '2' || str2->cp[2] != '3' ||
       str2->cp[3] != '4' || str2->cp[4] != '5') exit(-1);
   printf("-DStringStructPtr\n");
}
#endif
@ROUT tst.c
#include <stdio.h>
#include <stdlib.h>

void hello(void *p, int i)
{
   if (p) fprintf(stdout, "hello, i=%d\n", i);
   else fprintf(stdout, "helloNULL, i=%d\n", i);
}

main(int nargs, char *args)
{
   hello(NULL, 2);
}
@ROUT blaslink.f
       program blink
       double precision a(2,2), B(2,2), C(2,2)
       external dgemm
       call dgemm('n', 'n', 2, 2, 2, 1.0D0, a, 2, b, 2, 1.0D0, c, ldc)
       stop
       end
@ROUT ff2c_char.f
      program chartst
      external crout

      call crout('123', -1, '12345', -2)
      print*,'Coolness'

      stop
      end
@ROUT ff2cint.f
       program ff2cint
       integer iarr(8)
       iarr(1) = 1
       iarr(2) = -1
       iarr(3) = -1
       iarr(4) = -1
       iarr(5) = -1
       iarr(6) = -1
       iarr(7) = -1
       iarr(8) = -1
       call c2fint(iarr)
       stop
       end
@ROUT ff2cstr.f
      program chartst
      external crout

      call crout('123', -1, '12345', -2)

      stop
      end
@ROUT fname.f
      program namtst
      external c_routine

      call c_routine()

      stop
      end
@ROUT tst.f
      program tst
      print*,'hello'
      stop
      end
@ROUT Makefile
SHELL = /bin/sh
# include Make.inc
mydir = ${PWD}
# mydir = 'pwd'
atlrun = atlas_run
waitfile=config.tmp
ARCH=archdefault
OSFLAGS=
CC = gcc
atlas_run :
	cd $(atldir) ; ./$(exe) $(args) > $(redir)
atlas_runX :
	ssh $(targ) 'cd $(atldir) ; ./$(exe) $(args) > $(redir)'

$(waitfile) :
	- @sleep 2 

IRunx8664: xx86archinfo_64
	- rm -f config.tmp
	$(MAKE) $(atlrun) atldir=$(mydir) exe="xx86archinfo_64 -b" \
                redir=config.tmp
	- cat config.tmp
IRunx86Info: xx86archinfo
	- rm -f config.tmp
	$(MAKE) $(atlrun) atldir=$(mydir) exe="xx86archinfo -A" redir=config.tmp
	- cat config.tmp
IRunAixInfo: xaixarchinfo
	- rm -f config.tmp
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xaixarchinfo redir=config.tmp
	$(MAKE) config.tmp
	- cat config.tmp
IRunHpuxInfo: xhpuxarchinfo
	- rm -f config.tmp
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xhpuxarchinfo args="-n" \
                redir=config.tmp
	$(MAKE) config.tmp
	- cat config.tmp

@skip @multidef comp gcc   gcc    gcc  gcc  cc@^-traditional-cpp@^-faltivec
@whiledef isa 3DNow1 3DNow2 SSE1 SSE2 SSE3 AltiVec
xprobe_@(isa) : probe_@(isa).c
	$(CC) -o $@ probe_@(isa).c
IRun_@(isa): xprobe_@(isa)
	- rm -f config.tmp
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_@(isa) redir=config.tmp
	$(MAKE) config.tmp
	- cat config.tmp
@skip    @undef comp
@endwhile

@whiledef asm GAS_x8632 GAS_x8664
IRun_@(asm) :
	gcc -o xprobe_@low@(asm) $(OSFLAGS) probe_asm.c probe_@low@(asm).S
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_@low@(asm) redir=config.tmp
	- cat config.tmp
@endwhile
@whiledef asm GAS_SPARC GAS_LINUX_PPC AS_OSX_PPC HPUX_PARISC LINUX_PARISC
IRun_@(asm) :
	gcc -o xprobe_@low@(asm) probe_asm.c probe_@low@(asm).s
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xprobe_@low@(asm) redir=config.tmp
	- cat config.tmp
@endwhile

IRunName:
	- rm -f fname.o cname.o xfcnam config.tmp
	$(MAKE) fname.o cname.o F77=$(F77) CC=$(CC) \
                F77FLAGS="$(F77FLAGS)" CCFLAGS="$(CCFLAGS)"
	$(FLINK) $(FLFLAGS) -o ./xfcnam fname.o cname.o
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xfcnam redir=config.tmp
	$(MAKE) config.tmp
	- cat config.tmp
	- rm -f fname.o cname.o xfcnam

IRunInt:
	- rm -f ff2cint.o cf2cint.o xfcint
	$(MAKE) ff2cint.o cf2cint.o F77=$(F77) CC=$(CC) \
                F77FLAGS="$(F77FLAGS)" CCFLAGS="$(CCFLAGS)"
	$(FLINK) $(FLFLAGS) -o ./xfcint ff2cint.o cf2cint.o
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xfcint redir=config.tmp
	$(MAKE) config.tmp
	cat config.tmp
	- rm -f ff2cint.o cf2cint.o xfcint
	
IRunStr:
	- rm -f ff2cstr.o cf2cstr.o xfcstr
	$(MAKE) ff2cstr.o cf2cstr.o F77=$(F77) CC=$(CC) \
                F77FLAGS="$(F77FLAGS)" CCFLAGS="$(CCFLAGS)"
	$(FLINK) $(FLFLAGS) -o ./xfcstr ff2cstr.o cf2cstr.o
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xfcstr redir=config.tmp
	$(MAKE) config.tmp
	cat config.tmp
	- rm -f ff2cstr.o cf2cstr.o xfcstr

IRunSol:
	rm -f SolErr.o xsoltst
	$(CC) $(CCFLAGS) -o xsoltst SolErr.c
	$(MAKE) $(atlrun) atldir=$(mydir) exe=xsoltst redir=config.tmp
	$(MAKE) config.tmp
	- rm -f SolErr.o xsoltst
IGetSunVers:
	rm -f config.tmp
	- cc -V > config.tmp 2>&1
	$(MAKE) config.tmp

IBlasLink :
	$(F77) $(F77FLAGS) -o xtst ./blaslink.f $(BLASlib)
	- rm -f xtst blaslink.o

cTryComp :
	$(COMP) $(FLAGS) -c ./tst.c
	- rm -f tst.o
fTryComp :
	$(COMP) $(FLAGS) -c ./tst.f
	- rm -f tst.o
	
wincc :
	gcc -mno-cygwin -o $(wcname) '$(wcexe)' wincc.c
winf77 :
	gcc -mno-cygwin -o $(wcname) '$(wcexe)' winf77.c

winf77.exe : winf77.c defdf.h
	gcc -mno-cygwin -I./ -o winf77.exe winf77.c

winf77bob : ../bin/$(ARCH)/winf77.exe

../bin/$(ARCH)/winf77.exe : winf77.c defdf.h
	gcc -mno-cygwin -I./ -o ../bin/$(ARCH)/winf77.exe winf77.c

xhpuxarchinfo : archinfo_hpux.c
	cc -Ae -o $@ archinfo_hpux.c
xaixarchinfo : archinfo_aix.c
	xlc -o $@ archinfo_aix.c
xx86archinfo : archinfo_x86.c cpuid.S
	gcc -o $@ $(OSFLAGS) archinfo_x86.c cpuid.S
xx86archinfo_64 : archinfo_x86.c cpuid.S
	gcc -m64 -o $@ $(OSFLAGS) -DATL_GAS_x8664 archinfo_x86.c cpuid.S

.c.o :
	$(CC) -c $(CCFLAGS) $<
.f.o :
	$(F77) -c $(F77FLAGS) $<

@ROUT config_flags.txt
   -A #           : Set config mach to #
   -C 'string'    : Add string to CDEFS
   -D #           : Set various levels of what config will do (additive):
      0           : Create Make.ARCH and config logfiles only
      1           : Unpack & set arch defauls
      2           : Create ARCH subdirectories
      4           : Create the ATLrun shell script
      8           : If needed, create winf77.exe
     16           : Store the known L1 value
     32           : Move the config logfiles to ARCH subdir
   -N #           : Set ncpu to #
   -t <TOPdir>    : Set TOPdir as indicated
   -a <arch>      : Set ARCH to <arch>
   -b <1/blaslib> : Use this BLAS for BLASlib (1: search for blas)
   -f <f77>       : Use <f77> for F77
   -c <CC>        : Use <CC> for CC
   -m <MM>        : Use <MM> for MCC
   -g <gcc>       : Use <gcc> for gcc
   -x <XCC>       : Use <XCC> for XCC
   -F [c,f,m,x] '<flags>': set the indicated compiler flags
NOTE: If a compiler is specified without flags, ATLAS will try to fill in
      appropriate flags.  This is the recommended way to get config to select
      a non-default supported compiler.
@ROUT gcc3US.txt

Configure has determined that you are using UltraSparc, but do not have
gcc 3.0.  If you have gcc 3.0 installed, but ATLAS is not finding it,
quit here, put gcc 3.0 in your path, and restart the install.  You can
improve your performance by a significant amount by installing gcc 3.0.

@ROUT gcc33ppc.txt

ATLAS has detected that you are installing on a Linux/PPCG4/5 platform,
but do not have gcc 3.3 or newer where ATLAS can find it. If you have gcc 3.3
installed, but ATLAS is not finding it, quit this install, put gcc 3.3 in
your path, and restart the install.  Installing without gcc 3.3 may result
in all of the AltiVec code producing incorrect answers, as well as an
extremely extended install time.  It is highly recommended that you first
install gcc 3.3 before installing ATLAS.

@ROUT gcc3ia64.txt

ATLAS has detected that you are installing on an IA64 based machine,
but do not have gcc 3.0 where ATLAS can find it.  If you have gcc 3.0
installed, but ATLAS is not finding it, quit this install, put gcc 3.0 in
your path, and restart the install.  Installing without gcc 3.0 may result
in a large performance loss, and an extremely extended install time.
It is highly recommended that you first install gcc 3.0 before installing ATLAS.

@ROUT gcc3evX.txt

ATLAS has detected that you are installing on an ev5x or ev6x based machine,
but do not have gcc 3.0 where ATLAS can find it.  If you have gcc 3.0
installed, but ATLAS is not finding it, quit this install, put gcc 3.0 in
your path, and restart the install.  Installing without gcc 3.0 may result
in up to 20% performance loss, and an extremely extended install time.
It is highly recommended that you first install gcc 3.0 before installing ATLAS.

@ROUT gcc3x86.txt

ATLAS has detected that you are running on an x86 architecture 
(eg., Athlon, P4, PIII, etc), but do not have a pre-2.96 gcc installed.
Using gcc 3/2.96 will result in a performance loss of 10-20% IN THE BEST CASE
over a gcc previous to 2.96.  If your install goes slightly wrong, performance
drops of 50% are more normal with these compilers.  Full details of this
problem can be found at:
   http://www.cs.utk.edu/~rwhaley/ATLAS/gcc30.html
In the meantime, we suggest you abondon this ATLAS install, and install a gcc 
that delivers decent x86 performance, and restart the install then.  You
do not need to be root to install, and full instructions, along with all
needed files, are given in the ATLAS errata file at:
   http://math-atlas.sourceforge.net/errata.html#UnixGccInst

@ROUT 3DNow.txt
ATLAS has detected that your machine has 3DNow! capability, and ATLAS
can use these instructions to dramatically speed up single precision
operations.  However, 3DNow! does not use IEEE compliant arithmetic;
in particular, it does not handle NaNs or Infinities at all (operations 
on them are essentially undefined), and it does not handle overflow or
underflow correctly.  There may be other discrepencies as well.  Therefore,
only enable 3DNow! if you are very sure that these shortcomings in 
accuracy do not concern you.  In general, getting the answer very fast
is no substitute for getting the *correct* answer, so just say no if
you are at all unsure.
@ROUT blas.txt

Next I need a pointer to your BLAS library.  If you don't have one, you can
simply leave this entry blank.  However, without another BLAS implementation,
you will not be able to test your ATLAS BLAS without downloading the BLAS
tester off of netlib (the ATLAS testers assume a trusted BLAS).

@ROUT errata.txt
===============================================================================
                                  IMPORTANT
===============================================================================
Before going any further, check 
   http://math-atlas.sourceforge.net/errata.html
This is the ATLAS errata file, which keeps a running count of all known
ATLAS bugs and system problems, with associated workarounds or fixes.
IF YOU DO NOT CHECK THIS FILE, YOU MAY BE COMPILING A LIBRARY WITH KNOWN BUGS.

@ROUT gotogemm.txt

Kazushige Goto (goto@statabo.rim.or.jp) has developed an assembly language
GEMM which is considerably faster than ATLAS's generated code for the
Compaq/DEC alpha ev5x and ev6 architectures.  Mr. Goto has contributed his
implementation to the ATLAS project under the LGPL license (ATLAS in
general uses a BSD-style license).  This LGPL sublibrary is included via
the LGPL's clause 7.  In accordance with this clause, this screen
informs you that if you select yes below, ATLAS will use Mr. Goto's LGPL
GEMM, and thus the resulting library will also have an LGPL license.  The
modified library is stored in ATLAS/src/blas/gemm/GOTO, and the unmodified
tarfile is in ATLAS/src/blas/gemm/GOTO/libgemm-20000228.tar.bz2.
The homepage for Mr. Goto's excellent work is:
   http://members.jcom.home.ne.jp/kgoto/

None of this lawyer-weenie junk means anything to real techies, anyway, and
laywers probably don't have a great deal of use for ATLAS, so say "yes" below,
unless a 5-10% speedup sounds like a bad idea to you.

If you use this routine on a Linux system, you can get some additional 
speedup by the settings:
   setenv MALLOC_TRIM_THRESHOLD_ -1
   setenv MALLOC_MMAP_MAX_ 0

@ROUT nfsdelay.txt
The ATLAS install process is heavily file-based, and this can cause major
reliability problems when interacting with an overloaded or malfunctioning
remotely mounted filesystem.  ATLAS therefore has a mechanism in place to
allow for a delay before a file is declared to not be there, so that
slow NFS (i.e., waiting for amd timout) problems can be overcome, or for
handling slightly differing clocks between server/client.  This problem is
magnified if doing cross-compilation.  In the question below, we ask how
much of a delay, in seconds, ATLAS should tolerate between file creation
and appearance.  If you are installing on a local filesystem (eg. /tmp) or
a smooth-running NFS system, answer 0; for a moderately loaded NFS server, you
may want a value in the 10 second range, and for cross-compiling systems or
NFS servers experiencing errors, you may want to go as high as a couple
of minutes (120).
@ROUT CCmake.txt
#  ---------------------------------------------------------------------------
#  Various C compilers, and the linker to be used when we are not linking in
#  non-ATLAS BLAS (which usually necessitate using the Fortran linker).
#  The C compilers recognized by ATLAS are:
#     CC :  Compiler to use to compile regular, non-generated code
#    MCC :  Compiler to use to compile generated, highly-optimized code
#    XCC :  Compiler to be used on the compile engine of a cross-compiler
#  These will typically all be the same.  An example of where this is not
#  the case would be DEC ALPHA 21164, where you want to use gcc for MCC,
#  because DEC's cc does not allow the programmer access to all 32 floating
#  point registers.  However, on normal C code, DEC's cc produces much faster
#  code than gcc, so you CC set to cc.  Of course, any system where you are
#  cross-compiling, you will need to set XCC differently than CC & MCC.
#  ---------------------------------------------------------------------------
@ROUT ccomp-alpha.txt

I see you are using a DEC ALPHA.  Gcc 3.0 is the best compiler for ATLAS
for these platforms.  It appears that DEC's cc reserves several registers
(probably for use in software pipelining), that prevents ATLAS from achieving
maximal performance.  I therefore recommend that you use gcc 3.0 as for all C
compilation, rather than cc.

If you don't have gcc 3.0 installed, I recommend you do so.  Older gccs and
OSF1's cc will not yield as good performance.
@ROUT error.txt

First, make sure this error is not covered in the ATLAS errata file,
   http://math-atlas.sourceforge.net/errata.html
All known errors, and most common mistakes/system problems are documented
in this file, so it will save everyone hassle in the long run if you take
the time to scope it out before sending e-mail to the help list.

If this does not have the solution to your problem, and you can't figure out
what went wrong, submit a support request to the ATLAS support tracker, as
discussed here:
   http://math-atlas.sourceforge.net/faq.html#help

In the above examples, <ARCH> should be replaced with your architecture
string, such as "Linux_PIII" or "FreeBSD_21264".

@ROUT init.txt
Configure will ask a series of questions, in one of two forms.  The first form
of question is a menu of choices.  One option in almost all menus is
'Other/UNKNOWN'.  If you are unsure of the answer, always choose this option. 
The second form of question is a single line, with a default answer shown in
square braces.  If you hit return without typing anything, this default answer
will be used.  Again, if you are unsure of the answer, simply accept the
default.

ATLAS can detect almost everything it needs to know, so choosing the default
or 'Other/UNKNOWN' will at worst simply extend the install time (if you tell
config the answer to something ATLAS can skip some tests).

Configure makes no changes to the state of things until all questions have
been asked and answered.  Therefore, if you get confused and want to start
over, feel free to break out of this program (CTRL-C, CTRL-BREAK, etc)
and start again.  Alternatively, if you make a mistake you can finish the
configure process, and then edit the created make include file by hand to fix
the mistake manually (the name and location of this file will be printed
out at the end of configure).

If you have problems during configure or installation, consult the file
'ATLAS/doc/TroubleShoot.txt'.

@ROUT pthread.txt
ATLAS can provide SMP support for the Level 3 BLAS via Posix threads.
If you choose to build a threaded library, ATLAS will compile all
aspects of the library (including the serial components) with the 
threaded compiler/link flags.  Most machines can use the serial
library even when it is compiled with threaded options, but this
is not guaranteed to work, so if you want a true serial library,
answer no to threading below.
@ROUT NoSearch.txt

The ATLAS team has provided a default install for your architecture.  If you
want, these default values can be used, and ATLAS can skip most of the search
for your machine.  This will greatly decrease the amount of time required for
the install, allow you to take advantage of any special features found by the
ATLAS team, and provide protection against install miscues caused by unreliable
timing results, assuming you really have the machine ATLAS thinks you have.  If
your machine is non-standard in some way, or you just want to see the ATLAS
search for yourself, you should answer no to the following question.  Otherwise,
it is highly recommended to accept the default of yes.

@ROUT ccomp-alpha_newgcc.txt

You appear to be on a Dec ALPHA with only gcc newer than 2.8 installed.
Gcc does a better job optimizing generated code than DEC's cc.  It appears
that DEC's cc reserves several registers (probably for use in software
pipelining), and that prevents ATLAS from achieving maximal performance.  

The second rather surprising result on ALPHAs is that EGCS and new versions
of gcc produces much less optimal code than gcc 2.8 or earlier.  You will
lose roughly 10% of performance by using newer gcc.  The errata file
   www.cs.utk.edu/~rwhaley/ATLAS/errata.html
contains pointers to instructions on downloading and compiling an old version
of gcc.

If you continue the ATLAS install without first installing gcc 2.8 or earlier,
your performance will be about 10% below what you could achieve.

@ROUT f77exp.txt

I'm going to ask you for information about your Fortran 77 compiler.  ATLAS
does not need Fortran77 to build, so if you don't have a Fortran compiler,
the install can still be completed successfully.  However, ATLAS built without
a Fortran compiler will not be callable from Fortran (i.e., the user should
use the C interface), and we will not be able to do full testing, since some of
the tester code is written in Fortran77.

@ROUT l2size.txt

This next value is the size, in kilobytes, that ATLAS must read/write in order
to completely flush your largest cache.  ATLAS will flush this much memory
between timing calls, in order to ensure timings are not inflated by
cache preloading.  A safe maximum is usually twice the size of your actual
largest cache size.  If you do not know the size of your largest cache,
a maximum value is fine.  The only drawback to making this value large
is that it requires more memory to do timings, and may slow down
the install process (if you have only a small amount of memory, it can also
invalidate the timings by causing the timers to swap).  The default given
below is ATLAS's idea of either the maximum cache your system could have, or
the maximum ATLAS believes it is safe to flush.  If you are certain that
your largest cache is smaller than the default given below, expedite the
install by changing it.  If you are certain you have enough memory to
support the necessary memory demands without swapping, and the value
is not twice the size of your largest cache, increase it.  Otherwise, just
hit enter to continue.

@ROUT wincomp.txt

Welcome to the ugly kludge atop the festering pile of makeshift code!

ATLAS is about to create a wrapper routine in your /usr/local/bin directory
around your windows compiler that makes it behave like a unix compiler.  To
do this, it needs the full path to your windows compiler.  Notice that the
default path below uses unix-style / rather than windows style path slashes:
please use the unix-style slashes if you must change the default path.  If
you mess up the path, you will get another shot at it until you give up.

You will probably also need to set the LIB environment variable if it's
not already set appropriately to allow command-line linking using these
compilers.  You want to build up your LIB variable with the union of
all the compilers you are using.  For MVC that is something like:
   export LIB="C:/Program Files/Microsoft Developer Studio/VC98/LIB;"
Now if CVF would require the MSV lib, plus it's own:
   export LIB="C:/Program Files/Microsoft Developer Studio/DF98/LIB;"$LIB
If you are using the Intel compiler, you'd need all of these, plus
something like:
   export LIB="C:/Program Files/Intel/CPP/COMPILER80/Ia32/Lib;"$LIB
If this is causing all wrapper build to fail, you will have to quit config
and set it (maybe put it in your ~/.profile), and then run config again.
See the errata for more help if this doesn't do it for you.
   
@ROUT winf77.txt

ATLAS needs the full path to your Compaq/Dec Visual Fortran compiler.  Notice
that the default as shown below uses unix-style / rather than windows style
path slashes: please use the unix-style slashes if you must change the
default.  If you incorrectly enter the path here, you will need to edit
ATLAS/CONFIG/dfdef.h, and issue "make winf77 ARCH=<arch>" in ATLAS/CONFIG.

On some systems, you will need to also set the LIB environment
variable so that the linker can find the system libraries.  For example,
for newer versions of cygnus, you would issue the following commands
(modifying the path as appropriate):
default install, this would be accomplished by:
@skip   export LIB="/cygdrive/c/Program Files/DevStudio/DF/LIB;/cygdrive/c/Program Files/DevStudio/VC/LIB"
   export LIB="C:/Program Files/DevStudio/DF/LIB;C:/Program Files/DevStudio/VC/LIB;"
@skip For older cygwin installs, you'd use:
@skip    export LIB="//c/Program Files/DevStudio/DF/LIB;//c/Program Files/DevStudio/VC/LIB"

@ROUT SolErr.txt

There is a compiler error in Sun WorkShop cc 5.0 (and the 4.X versions as well),
which causes ATLAS's Level 3 BLAS routines to bus error.
   http://math-atlas.sourceforge.net/errata.html
Should have any new information on this bug.  In the meantime, the error
goes away if you compile these routines with gcc.  If you have gcc on your
machine, use it for this compilation.  Otherwise, be aware that the some
of the BLAS may fail.

@ROUT ccomp-alpha_nogcc.txt

You appear to be on a Dec ALPHA without gcc installed.  Gcc does a better job
optimizing generated code than DEC's cc.  It appears that DEC's cc reserves
several registers (probably for use in software pipelining), and that prevents
ATLAS from achieving maximal performance.  

The second rather surprising result on ALPHAs is that EGCS and new versions
of gcc produces much less optimal code than gcc 2.8 or earlier.  You will
lose roughly 10% of performance by using newer gcc.  The errata file
   www.cs.utk.edu/~rwhaley/ATLAS/errata.html
contains pointers to instructions on downloading and compiling an old version
of gcc.

If you continue the ATLAS install without first installing gcc 2.8 or earlier,
your performance will be subpar, and ATLAS will have to search for the best
parameters.

@ROUT f77make.txt
#  ---------------------------------------------------------------------------
#  Fortran 77 compiler and the flags to use.  Presently, ATLAS does not itself
#  use any Fortran 77, but vendor BLAS are typically written for Fortran, so
#  any links that include non-ATLAS BLAS will use FLINKER instead of CLINKER
#  ---------------------------------------------------------------------------
@ROUT l2sizemax.txt

ATLAS probed the system and determined that the following amount of memory
(in kilobytes) would be required to completely flush the cache of your
system.  However, this amount of memory may cause swapping if you don't
have enough physical memory available.  Some timers may use 3 times this
much memory purely for cache flushing (not including operands being timed).
So, if this value looks too large, decrease it (meaning ATLAS may not tune
itself perfectly since some operands will be cache resident), otherwise
hit enter to install with default.  If this causes the ATLAS timers to
swap, you can always reinstall and supply a smaller value for this entry.

@ROUT xcomp-err.txt
I can't seem to ssh your machine.  Make sure the target system name you gave
is correct.  Also, you probably need to put the name of your cross-compiling
machine in the file ~/.rhosts on the target machine.  If your login name
is different on the two machines, suffix the machine name with your 
cross-compiler login name.  For instance, if I were compiling on the machine
xcomp.cs.utk.edu, and my login name there was whaley, and I was compiling for
the machine targ.bob.net, where my login name was rwhaley, I would log into
targ.bob.net, vi ~/.rhosts, and add the following line:
   xcomp.cs.utk.edu whaley


@ROUT arch.txt

You need to choose a name which represents this architecture (eg. UltraSparc,
Dec21164, etc).  Do not use a generic name (eg. solaris, linux), which might
apply to different  hardware.  This architecture name will be appended to the
name of the created make include file, and appear in all subdirectories, so
don't make it longer than you like to type.  The name should follow the rules
for file names (so don't use punctuation and spaces, for instance).

@ROUT ccomp.txt

I am now going to ask for two C compilers, and their associated flags.
The first such set (CC & CCFLAGS) are used in compiling the non-generated
ATLAS code.  This code is written in normal C, and responds well to high
levels of optimization.  Typically, this is set to your default compiler,
and your highest levels of optimization.

The second set of C compilers (MCC & MMFLAGS) is used to compile the generated
ATLAS code.  Generated codes are written at a very low-level (think of C used
as a kind of portable assembler).  On many platforms, high levels of
optimization are detrimental, as the compiler tries to pipeline a perfectly
pipelined code, and succeeds in reducing performance substantially (this
occurs on DEC ALPHAs & Sun UltraSparcs, for instance).  If the default does
not work for you, try a midrange optimization such as -O.  The generated code
does not alias any output arguments, so aliasing optimizations should be OK.

@ROUT goodbye.txt
Configuration complete.  You should examine the created make include file
and make sure it is accurate.  If it is, you are ready to install the libraries.
@ROUT ncpu.txt
Config was unable to determine the number of processors your system
possesses.  This information is needed as part of the architecture
name, and can be helpful when optimizing the threaded code.  If
you know how many processors your system possesses, enter it below.
Otherwise, accept the default of 0, and ATLAS will empirically
detect the number of processors to use later on in the install
process.
@ROUT xcomp.txt
The requirements for ATLAS to operate using cross-compilation are as follows:

  (1) Both the cross-compiler and target system must share the filesystem
      where the ATLAS files are stored
  (2) The target system must be accessible from the cross-compiling system
      via ssh

You will need to tell ATLAS the target system's name to ssh to, eg. 
cupid.cs.utk.edu.
@ROUT UseCCFlagsDef.txt
ATLAS has architectural defaults for this platform.  They were
built with the compiler flags you see above, instead of the ones you have
chosen.  At this stage, you have several options.  You can quit this install,
and run again letting ATLAS choose the default flags.  Another option is
to proceed with the install, but not use the architectural defaults.  Finally,
if you are convinced that your flags won't change the arch defaults,
you can continue the install using your flags and the arch defaults.  Unless
you really know what you are doing, quit and use the default flags.  If you
choose another course of action, we recommend you build the default library
later, and make sure the performance of both installs is roughly the same.
A quick and dirty comparison may be made by examining each install's:
   ATLAS/bin/<arch>/INSTALL_LOG/SUMMARY.LOG

@ROUT UseCCDef.txt
You have chosen a different C compiler than the default one ATLAS has been
built with.  For most machines, this will usually result in a substantial
performance penalty.  If you choose to do this, we strongly recommend that
you build ATLAS with the default settings as well, and make sure your
non-default compiler library gets roughly the same performance.  An easy
comparison can be made by examining each install's:
   ATLAS/bin/<arch>/INSTALL_LOG/SUMMARY.LOG
If you are not absolutely certain you want to do this, we recommend you
quit this install and try again, letting ATLAS use its default compiler
for this platform.

@ROUT l1def.txt

Your architectural defaults do not include defaults for the
Level 1 BLAS.  ATLAS now has the ability to tune the Level 1 BLAS to
your machine.  However, this will add time to the install.  If your
algorithm utilizes the Level 2 or Level 3 BLAS to any degree, the
the Level 1 BLAS will usually be a low order term, and thus only matter
for small problems.  Therefore, if you don't think you need good performance
from the Level 1 BLAS, you can answer "no" to the question below, and ATLAS
will skip the Level 1 tuning.  ATLAS will still provide Level 1 BLAS, but
their performance may be much worse than if tuning were allowed.

@ROUT !
